<!DOCTYPE html><html lang="zh-Hans" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RececlerView 源码分析 | Afree</title><meta name="description" content="本文基于 V7-25.3.1  图文总结RecyclerView优点 更好的灵活配置能力，在LayoutManager（布局）、Adapter（数据适配）和动画的兼容上都更优雅 缓存能力增强，离屏缓存相对较优，另增加了一层缓存池缓存 支持局部刷新，对于一些交互处理多的情况下，会带来更好的性能  RecyclerView类图 RecyclerView绘制流程图 RecyclerView滑动流程图"><meta name="keywords" content="RececlerView"><meta name="author" content="Afree"><meta name="copyright" content="Afree"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/blog/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="RececlerView 源码分析"><meta name="twitter:description" content="本文基于 V7-25.3.1  图文总结RecyclerView优点 更好的灵活配置能力，在LayoutManager（布局）、Adapter（数据适配）和动画的兼容上都更优雅 缓存能力增强，离屏缓存相对较优，另增加了一层缓存池缓存 支持局部刷新，对于一些交互处理多的情况下，会带来更好的性能  RecyclerView类图 RecyclerView绘制流程图 RecyclerView滑动流程图"><meta name="twitter:image" content="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141843.png"><meta property="og:type" content="article"><meta property="og:title" content="RececlerView 源码分析"><meta property="og:url" content="https://afree8909.github.io/blog/2020/04/27/RececlerView%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="Afree"><meta property="og:description" content="本文基于 V7-25.3.1  图文总结RecyclerView优点 更好的灵活配置能力，在LayoutManager（布局）、Adapter（数据适配）和动画的兼容上都更优雅 缓存能力增强，离屏缓存相对较优，另增加了一层缓存池缓存 支持局部刷新，对于一些交互处理多的情况下，会带来更好的性能  RecyclerView类图 RecyclerView绘制流程图 RecyclerView滑动流程图"><meta property="og:image" content="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141843.png"><meta property="article:published_time" content="2020-04-26T16:00:00.000Z"><meta property="article:modified_time" content="2020-04-28T06:29:46.402Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://afree8909.github.io/blog/2020/04/27/RececlerView%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="next" title="Git主流分支模型" href="https://afree8909.github.io/blog/2020/04/27/Git%E4%B8%BB%E6%B5%81%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/blog/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/blog/archives/"><div class="headline">Articles</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/blog/tags/"><div class="headline">Tags</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/blog/categories/"><div class="headline">Categories</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#图文总结"><span class="toc-number">1.</span> <span class="toc-text">图文总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView优点"><span class="toc-number">1.1.</span> <span class="toc-text">RecyclerView优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView类图"><span class="toc-number">1.2.</span> <span class="toc-text">RecyclerView类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView绘制流程图"><span class="toc-number">1.3.</span> <span class="toc-text">RecyclerView绘制流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView滑动流程图"><span class="toc-number">1.4.</span> <span class="toc-text">RecyclerView滑动流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView缓存介绍图"><span class="toc-number">1.5.</span> <span class="toc-text">RecyclerView缓存介绍图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码阅读"><span class="toc-number">2.</span> <span class="toc-text">源码阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView使用方法分分析"><span class="toc-number">2.1.</span> <span class="toc-text">RecyclerView使用方法分分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView-构造方法"><span class="toc-number">2.1.1.</span> <span class="toc-text">RecyclerView 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setLayoutManager"><span class="toc-number">2.1.2.</span> <span class="toc-text">setLayoutManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setAdapter"><span class="toc-number">2.1.3.</span> <span class="toc-text">setAdapter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView绘制方法分析"><span class="toc-number">2.2.</span> <span class="toc-text">RecyclerView绘制方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#onMeasure"><span class="toc-number">2.2.1.</span> <span class="toc-text">onMeasure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView-onLayout"><span class="toc-number">2.2.2.</span> <span class="toc-text">RecyclerView.onLayout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchLayoutStep1"><span class="toc-number">2.2.3.</span> <span class="toc-text">dispatchLayoutStep1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchLayoutStep2"><span class="toc-number">2.2.4.</span> <span class="toc-text">dispatchLayoutStep2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchLayoutStep3"><span class="toc-number">2.2.5.</span> <span class="toc-text">dispatchLayoutStep3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#draw"><span class="toc-number">2.2.6.</span> <span class="toc-text">draw</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinearLayoutManager-填充子View过程"><span class="toc-number">2.3.</span> <span class="toc-text">LinearLayoutManager 填充子View过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinearLayoutManager-onLayoutChildren"><span class="toc-number">2.3.1.</span> <span class="toc-text">LinearLayoutManager.onLayoutChildren</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinearLayoutManager-fill"><span class="toc-number">2.3.2.</span> <span class="toc-text">LinearLayoutManager.fill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinearLayoutManager-layoutChunk"><span class="toc-number">2.3.3.</span> <span class="toc-text">LinearLayoutManager.layoutChunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinearLayoutManager-next"><span class="toc-number">2.3.4.</span> <span class="toc-text">LinearLayoutManager.next</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recycler获取VH的缓存和创建过程"><span class="toc-number">2.4.</span> <span class="toc-text">Recycler获取VH的缓存和创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Recycler-getViewForPosition"><span class="toc-number">2.4.1.</span> <span class="toc-text">Recycler.getViewForPosition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Recycler-tryGetViewHolderForPositionByDeadline"><span class="toc-number">2.4.2.</span> <span class="toc-text">Recycler.tryGetViewHolderForPositionByDeadline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#00-从ChangeScrap获取"><span class="toc-number">2.4.3.</span> <span class="toc-text">00 从ChangeScrap获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一次尝试获取VH（AttachScrap、Hidden、CacheView）"><span class="toc-number">2.4.4.</span> <span class="toc-text">第一次尝试获取VH（AttachScrap、Hidden、CacheView）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二次尝试获取VH（Adapter有稳定id情况）"><span class="toc-number">2.4.5.</span> <span class="toc-text">第二次尝试获取VH（Adapter有稳定id情况）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView滑动机制分析"><span class="toc-number">2.5.</span> <span class="toc-text">RecyclerView滑动机制分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scrollByInternal"><span class="toc-number">2.5.1.</span> <span class="toc-text">scrollByInternal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinearLayoutManager执行滑动处理"><span class="toc-number">2.5.2.</span> <span class="toc-text">LinearLayoutManager执行滑动处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinearLayoutManager回收流程"><span class="toc-number">2.5.3.</span> <span class="toc-text">LinearLayoutManager回收流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView-removeAndRecycleViewAt"><span class="toc-number">2.5.4.</span> <span class="toc-text">RecyclerView.removeAndRecycleViewAt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerView-recycleViewHolderInternal"><span class="toc-number">2.5.5.</span> <span class="toc-text">RecyclerView.recycleViewHolderInternal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部刷新"><span class="toc-number">2.6.</span> <span class="toc-text">局部刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Adapter数据操作对外API"><span class="toc-number">2.6.1.</span> <span class="toc-text">Adapter数据操作对外API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerViewDataObserver"><span class="toc-number">2.6.2.</span> <span class="toc-text">RecyclerViewDataObserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AdapterHelper-onItemRangeChanged"><span class="toc-number">2.6.3.</span> <span class="toc-text">AdapterHelper.onItemRangeChanged</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RecyclerViewDataObserver-triggerUpdateProcessor"><span class="toc-number">2.6.4.</span> <span class="toc-text">RecyclerViewDataObserver.triggerUpdateProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#triggerUpdateProcessor下requestLayout"><span class="toc-number">2.6.5.</span> <span class="toc-text">triggerUpdateProcessor下requestLayout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#triggerUpdateProcessor下mUpdateChildViewsRunnable"><span class="toc-number">2.6.6.</span> <span class="toc-text">triggerUpdateProcessor下mUpdateChildViewsRunnable</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141843.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/blog/">Afree</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">RececlerView 源码分析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-04-27 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-04-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-04-28 14:29:46"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-04-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/Android/">Android</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>Word count:</span><span class="word-count">6.6k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>Reading time: 31 min</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><blockquote>
<p>本文基于 V7-25.3.1</p>
</blockquote>
<h2 id="图文总结"><a href="#图文总结" class="headerlink" title="图文总结"></a>图文总结</h2><h3 id="RecyclerView优点"><a href="#RecyclerView优点" class="headerlink" title="RecyclerView优点"></a>RecyclerView优点</h3><ul>
<li>更好的灵活配置能力，在LayoutManager（布局）、Adapter（数据适配）和动画的兼容上都更优雅</li>
<li>缓存能力增强，离屏缓存相对较优，另增加了一层缓存池缓存</li>
<li>支持局部刷新，对于一些交互处理多的情况下，会带来更好的性能</li>
</ul>
<h3 id="RecyclerView类图"><a href="#RecyclerView类图" class="headerlink" title="RecyclerView类图"></a>RecyclerView类图</h3><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141843.png"  alt=""></p>
<h3 id="RecyclerView绘制流程图"><a href="#RecyclerView绘制流程图" class="headerlink" title="RecyclerView绘制流程图"></a>RecyclerView绘制流程图</h3><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141858.png"  alt=""></p>
<h3 id="RecyclerView滑动流程图"><a href="#RecyclerView滑动流程图" class="headerlink" title="RecyclerView滑动流程图"></a>RecyclerView滑动流程图</h3><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141904.png"  alt=""></p>
<h3 id="RecyclerView缓存介绍图"><a href="#RecyclerView缓存介绍图" class="headerlink" title="RecyclerView缓存介绍图"></a>RecyclerView缓存介绍图</h3><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141917.png"  alt=""></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="RecyclerView使用方法分分析"><a href="#RecyclerView使用方法分分析" class="headerlink" title="RecyclerView使用方法分分析"></a>RecyclerView使用方法分分析</h3><h4 id="RecyclerView-构造方法"><a href="#RecyclerView-构造方法" class="headerlink" title="RecyclerView 构造方法"></a>RecyclerView 构造方法</h4><ul>
<li>进行View相关配置属性设置，触摸范围、滑动速度等</li>
<li>设置Item动画监听器</li>
<li>初始化AdapterManager，创建AdapterHelper（负责Adapter里的数据集发生变化时的预处理操作）</li>
<li>初始化ChildHelper（负责管理和访问 RecyclerView 的子视图）</li>
<li>如果配置了LayoutManager 则通过反射方法创建它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">       super(context, attrs, defStyle);</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; View配置相关属性设置</span><br><span class="line">       final ViewConfiguration vc &#x3D; ViewConfiguration.get(context);</span><br><span class="line">       mTouchSlop &#x3D; vc.getScaledTouchSlop();</span><br><span class="line">       mMinFlingVelocity &#x3D; vc.getScaledMinimumFlingVelocity();</span><br><span class="line">       mMaxFlingVelocity &#x3D; vc.getScaledMaximumFlingVelocity();</span><br><span class="line">       setWillNotDraw(getOverScrollMode() &#x3D;&#x3D; View.OVER_SCROLL_NEVER);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 设置Item动画监听器</span><br><span class="line">       mItemAnimator.setListener(mItemAnimatorListener);</span><br><span class="line">       &#x2F;&#x2F; 设置 AdapterManager</span><br><span class="line">       initAdapterManager();</span><br><span class="line">       &#x2F;&#x2F; 设置 ChildrenHelper </span><br><span class="line">       initChildrenHelper();</span><br><span class="line">       &#x2F;&#x2F; 硬件加速相关属性设置</span><br><span class="line">       if (ViewCompat.getImportantForAccessibility(this)</span><br><span class="line">               &#x3D;&#x3D; ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">           ViewCompat.setImportantForAccessibility(this,</span><br><span class="line">                   ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">       &#125;</span><br><span class="line">       mAccessibilityManager &#x3D; (AccessibilityManager) getContext()</span><br><span class="line">               .getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class="line">       setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 如果attrs指定了LayoutManager，则创建LayoutManager</span><br><span class="line">       boolean nestedScrollingEnabled &#x3D; true;</span><br><span class="line">       </span><br><span class="line">       if (attrs !&#x3D; null) &#123;</span><br><span class="line">           int defStyleRes &#x3D; 0;</span><br><span class="line">           TypedArray a &#x3D; context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,</span><br><span class="line">                   defStyle, defStyleRes);</span><br><span class="line">           String layoutManagerName &#x3D; a.getString(R.styleable.RecyclerView_layoutManager);</span><br><span class="line">           int descendantFocusability &#x3D; a.getInt(</span><br><span class="line">                   R.styleable.RecyclerView_android_descendantFocusability, -1);</span><br><span class="line">           if (descendantFocusability &#x3D;&#x3D; -1) &#123;</span><br><span class="line">               setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">           &#125;</span><br><span class="line">           a.recycle();</span><br><span class="line">           &#x2F;&#x2F; 反射方法创建 LayoutManager</span><br><span class="line">           createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);</span><br><span class="line"></span><br><span class="line">           if (Build.VERSION.SDK_INT &gt;&#x3D; 21) &#123;</span><br><span class="line">               &#x2F;&#x2F; SDK &gt;&#x3D;21下 ，nestedScrollingEnabled状态支持变更</span><br><span class="line">               a &#x3D; context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,</span><br><span class="line">                       defStyle, defStyleRes);</span><br><span class="line">               nestedScrollingEnabled &#x3D; a.getBoolean(0, true);</span><br><span class="line">               a.recycle();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 重置nestedScrollingEnabled状态 SDK 21以下默认true</span><br><span class="line">       setNestedScrollingEnabled(nestedScrollingEnabled);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="setLayoutManager"><a href="#setLayoutManager" class="headerlink" title="setLayoutManager"></a>setLayoutManager</h4><ul>
<li>处理重新设置一个新的LayoutManager的一些逻辑</li>
<li>设置this给到LayoutManager，并如果attach了则执行LayoutManger的attach分发实践</li>
<li>跟新缓存大小，并请求重新布局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void setLayoutManager(LayoutManager layout) &#123;</span><br><span class="line">        if (layout &#x3D;&#x3D; mLayout) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        stopScroll();</span><br><span class="line">        &#x2F;&#x2F; 设置新的layout情况下的一些处理逻辑</span><br><span class="line">        ... </span><br><span class="line">        </span><br><span class="line">        mChildHelper.removeAllViewsUnfiltered();</span><br><span class="line">        mLayout &#x3D; layout;</span><br><span class="line">        if (layout !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; layout只能绑定一个mRecyclerView </span><br><span class="line">            if (layout.mRecyclerView !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +</span><br><span class="line">                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置this引用给LayoutManager</span><br><span class="line">            mLayout.setRecyclerView(this);</span><br><span class="line">            if (mIsAttached) &#123;</span><br><span class="line">                &#x2F;&#x2F; 分发attach事件</span><br><span class="line">                mLayout.dispatchAttachedToWindow(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 重新更新缓存大小 及请求重新布局</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="setAdapter"><a href="#setAdapter" class="headerlink" title="setAdapter"></a>setAdapter</h4><ul>
<li>接触frozen状态</li>
<li>设置新的Adapter，并触发一系列监听事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void setAdapter(Adapter adapter) &#123;</span><br><span class="line">   &#x2F;&#x2F; 解除frozen状态</span><br><span class="line">   setLayoutFrozen(false);</span><br><span class="line">   &#x2F;&#x2F; 替换到当前Adapter，并触发监听</span><br><span class="line">   setAdapterInternal(adapter, false, true);</span><br><span class="line">   requestLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,</span><br><span class="line">            boolean removeAndRecycleViews) &#123;</span><br><span class="line">        &#x2F;&#x2F; 旧Adapter进行解绑数据监听 和 RecyclerView的引用</span><br><span class="line">        if (mAdapter !&#x3D; null) &#123;</span><br><span class="line">            mAdapter.unregisterAdapterDataObserver(mObserver);</span><br><span class="line">            mAdapter.onDetachedFromRecyclerView(this);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!compatibleWithPrevious || removeAndRecycleViews) &#123;</span><br><span class="line">            removeAndRecycleViews(); &#x2F;&#x2F; 移除缓存的View</span><br><span class="line">        &#125;</span><br><span class="line">        mAdapterHelper.reset();</span><br><span class="line">        final Adapter oldAdapter &#x3D; mAdapter;</span><br><span class="line">        mAdapter &#x3D; adapter;</span><br><span class="line">        if (adapter !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理新设置的Adapter的关联监听和RecyclerView</span><br><span class="line">            adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">            adapter.onAttachedToRecyclerView(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通知LayoutManager Adapter变更</span><br><span class="line">        if (mLayout !&#x3D; null) &#123;</span><br><span class="line">            mLayout.onAdapterChanged(oldAdapter, mAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 触发Recycler Adapter变更事件</span><br><span class="line">        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</span><br><span class="line">        &#x2F;&#x2F; 状态置为 mStructureChanged </span><br><span class="line">        mState.mStructureChanged &#x3D; true;</span><br><span class="line">        markKnownViewsInvalid();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecyclerView绘制方法分析"><a href="#RecyclerView绘制方法分析" class="headerlink" title="RecyclerView绘制方法分析"></a>RecyclerView绘制方法分析</h3><h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><ul>
<li>未赋值layoutManager情况下，走默认measure，结果是无展示</li>
<li>系统提供的LayoutManager默认AutoMeasure。执行LayoutManger的onMeasure方法</li>
<li>如果未指定确定宽高的尺寸规格，则会进行布局，继而获得子View的大小。此过程可能执行两次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">   if (mLayout &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 无LayoutManger</span><br><span class="line">       defaultOnMeasure(widthSpec, heightSpec); </span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; Android提供的三个LayoutManger，都是AutoMeasure</span><br><span class="line">   if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取测量规格</span><br><span class="line">       final int widthMode &#x3D; MeasureSpec.getMode(widthSpec);</span><br><span class="line">       final int heightMode &#x3D; MeasureSpec.getMode(heightSpec);</span><br><span class="line">       final boolean skipMeasure &#x3D; widthMode &#x3D;&#x3D; MeasureSpec.EXACTLY</span><br><span class="line">               &amp;&amp; heightMode &#x3D;&#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">       &#x2F;&#x2F; 执行LayoutManager的onMeasure方法</span><br><span class="line">       mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">       </span><br><span class="line">       if (skipMeasure || mAdapter &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 如果测量规格不确定 且设置了Adapter，则先执行一次layout</span><br><span class="line">       if (mState.mLayoutStep &#x3D;&#x3D; State.STEP_START) &#123;</span><br><span class="line">           dispatchLayoutStep1();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 设置测量规格</span><br><span class="line">       mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">       mState.mIsMeasuring &#x3D; true;</span><br><span class="line">       dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 设置 获取到子View的宽高</span><br><span class="line">       mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;二次测量，宽高不确定情况下</span><br><span class="line">       if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">           mLayout.setMeasureSpecs(</span><br><span class="line">                   MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                   MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">           mState.mIsMeasuring &#x3D; true;</span><br><span class="line">           dispatchLayoutStep2();</span><br><span class="line">           &#x2F;&#x2F; now we can get the width and height from the children.</span><br><span class="line">           mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RecyclerView-onLayout"><a href="#RecyclerView-onLayout" class="headerlink" title="RecyclerView.onLayout"></a>RecyclerView.onLayout</h4><ul>
<li>执行DispatchLayout方法</li>
<li>根据不同State状态，分别执行Step1、Step2、Step3方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">   TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">   dispatchLayout();</span><br><span class="line">   TraceCompat.endSection();</span><br><span class="line">   mFirstLayoutComplete &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">    void dispatchLayout() &#123;</span><br><span class="line">        mState.mIsMeasuring &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 如果State状态是 State.STEP_START 则执行 Step1 和Step2</span><br><span class="line">        if (mState.mLayoutStep &#x3D;&#x3D; State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() !&#x3D; getWidth() </span><br><span class="line">            &#x2F;&#x2F; 直接执行 step2</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 执行Step3 ，主要保存一些View信息和动画执行</span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4><ul>
<li>第一步layout方法</li>
<li>处理adapter变更</li>
<li>确定需要执行的动画</li>
<li>针对当前的Views进行信息缓存</li>
<li>如有必要，则进行预布局并缓存信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep1() &#123;</span><br><span class="line">   &#x2F;&#x2F;  State状态断言 </span><br><span class="line">   mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">   mState.mIsMeasuring &#x3D; false;</span><br><span class="line">   &#x2F;&#x2F; 是否过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1</span><br><span class="line">   eatRequestLayout();</span><br><span class="line">   &#x2F;&#x2F; 清楚 ViewInfo 所有状态和其存在的数据</span><br><span class="line">   mViewInfoStore.clear();</span><br><span class="line">   &#x2F;&#x2F; 执行进入 layout或者scroll行为标志</span><br><span class="line">   onEnterLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 执行Adapter变更及计算那些需要执行的动画</span><br><span class="line">   processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">   &#x2F;&#x2F; 存储焦点信息</span><br><span class="line">   saveFocusInfo();</span><br><span class="line">   &#x2F;&#x2F; state状态信息设置</span><br><span class="line">   mState.mTrackOldChangeHolders &#x3D; mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">   mItemsAddedOrRemoved &#x3D; mItemsChanged &#x3D; false;</span><br><span class="line">   mState.mInPreLayout &#x3D; mState.mRunPredictiveAnimations;</span><br><span class="line">   mState.mItemCount &#x3D; mAdapter.getItemCount();</span><br><span class="line">   &#x2F;&#x2F; 寻找 layout过程中position的最大和最小值</span><br><span class="line">   findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line">   </span><br><span class="line">   if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">       ...  </span><br><span class="line">       int count &#x3D; mChildHelper.getChildCount();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; count; ++i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历VieHolder</span><br><span class="line">           final ViewHolder holder &#x3D; getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">           if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 创建 ItemHolderInfo</span><br><span class="line">           final ItemHolderInfo animationInfo &#x3D; mItemAnimator</span><br><span class="line">                   .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                           ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                           holder.getUnmodifiedPayloads());</span><br><span class="line">           &#x2F;&#x2F; mViewInfoStore存储 holder及其对应animation信息</span><br><span class="line">           mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">           if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">               &#x2F;&#x2F; 如果holder确定要更新，就把它添加到 oldChangeHolders 集合中</span><br><span class="line">               mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">   if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">      ... &#x2F;&#x2F; 运行预布局</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 执行退出 layout或者scroll行为标志</span><br><span class="line">   onExitLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 对应 mEatRequestLayout -1</span><br><span class="line">   resumeRequestLayout(false);</span><br><span class="line">   &#x2F;&#x2F; 状态进入 State.STEP_LAYOUT</span><br><span class="line">   mState.mLayoutStep &#x3D; State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void processAdapterUpdatesAndSetAnimationFlags() &#123;</span><br><span class="line">   if (predictiveItemAnimationsEnabled()) &#123;</span><br><span class="line">       mAdapterHelper.preProcess(); &#x2F;&#x2F; 预处理</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">   &#125;</span><br><span class="line">   boolean animationTypeSupported &#x3D; mItemsAddedOrRemoved || mItemsChanged;</span><br><span class="line">   &#x2F;&#x2F; 计算 mRunSimpleAnimations 和 mRunPredictiveAnimations</span><br><span class="line">   &#x2F;&#x2F; mDataSetHasChangedAfterLayout 数据是否变化</span><br><span class="line">   mState.mRunSimpleAnimations &#x3D; mFirstLayoutComplete</span><br><span class="line">           &amp;&amp; mItemAnimator !&#x3D; null</span><br><span class="line">           &amp;&amp; (mDataSetHasChangedAfterLayout</span><br><span class="line">           || animationTypeSupported</span><br><span class="line">           || mLayout.mRequestedSimpleAnimations)</span><br><span class="line">           &amp;&amp; (!mDataSetHasChangedAfterLayout</span><br><span class="line">           || mAdapter.hasStableIds());</span><br><span class="line">   mState.mRunPredictiveAnimations &#x3D; mState.mRunSimpleAnimations</span><br><span class="line">           &amp;&amp; animationTypeSupported</span><br><span class="line">           &amp;&amp; !mDataSetHasChangedAfterLayout</span><br><span class="line">           &amp;&amp; predictiveItemAnimationsEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4><ul>
<li>执行最终的View布局操作，该过程由LayoutManager完成</li>
<li>该方法可能会被多次执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep2() &#123;</span><br><span class="line">   &#x2F;&#x2F; 过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1。对应resumeRequestLayout方法进行消费</span><br><span class="line">   eatRequestLayout();</span><br><span class="line">   &#x2F;&#x2F; 对应 onExitLayoutOrScroll</span><br><span class="line">   onEnterLayoutOrScroll();</span><br><span class="line">   mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">   &#x2F;&#x2F; 跳过预处理过程，一次性执行完所有的update</span><br><span class="line">   mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">   mState.mItemCount &#x3D; mAdapter.getItemCount(); &#x2F;&#x2F; 赋值 itemCOunt</span><br><span class="line">   mState.mDeletedInvisibleItemCountSincePreviousLayout &#x3D; 0; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   mState.mInPreLayout &#x3D; false;</span><br><span class="line">   &#x2F;&#x2F; 执行 layout （执行 LayoutManager 布局）</span><br><span class="line">   mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">   mState.mStructureChanged &#x3D; false;</span><br><span class="line">   mPendingSavedState &#x3D; null;</span><br><span class="line">   mState.mRunSimpleAnimations &#x3D; mState.mRunSimpleAnimations &amp;&amp; mItemAnimator !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; State状态进入 State.STEP_ANIMATIONS</span><br><span class="line">   mState.mLayoutStep &#x3D; State.STEP_ANIMATIONS;</span><br><span class="line">   &#x2F;&#x2F; 对应 onExitLayoutOrScroll</span><br><span class="line">   onExitLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 对应eatRequestLayout方法</span><br><span class="line">   resumeRequestLayout(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><p>layout过程最后一步，执行相关动画和一些清理事项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep3() &#123;</span><br><span class="line">   ...</span><br><span class="line">   if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">       &#x2F;&#x2F; 执行相关动画</span><br><span class="line">       ... </span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 一些清理动作   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h4><p>主要涉及Item装饰的绘制和动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas c) &#123;</span><br><span class="line">   super.draw(c);</span><br><span class="line"></span><br><span class="line">   final int count &#x3D; mItemDecorations.size();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">       mItemDecorations.get(i).onDrawOver(c, this, mState);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   boolean needsInvalidate &#x3D; false;</span><br><span class="line">   ...</span><br><span class="line">   if (!needsInvalidate &amp;&amp; mItemAnimator !&#x3D; null &amp;&amp; mItemDecorations.size() &gt; 0 &amp;&amp;</span><br><span class="line">           mItemAnimator.isRunning()) &#123;</span><br><span class="line">       needsInvalidate &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (needsInvalidate) &#123;</span><br><span class="line">       ViewCompat.postInvalidateOnAnimation(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void onDraw(Canvas c) &#123;</span><br><span class="line">   super.onDraw(c);</span><br><span class="line"></span><br><span class="line">   final int count &#x3D; mItemDecorations.size();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">       mItemDecorations.get(i).onDraw(c, this, mState);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinearLayoutManager-填充子View过程"><a href="#LinearLayoutManager-填充子View过程" class="headerlink" title="LinearLayoutManager 填充子View过程"></a>LinearLayoutManager 填充子View过程</h3><h4 id="LinearLayoutManager-onLayoutChildren"><a href="#LinearLayoutManager-onLayoutChildren" class="headerlink" title="LinearLayoutManager.onLayoutChildren"></a>LinearLayoutManager.onLayoutChildren</h4><ul>
<li>Child布局执行核心方法</li>
<li>布局方式，通过确定锚点，首先以锚点为基准上到下布局，在以锚点为基准从下往上布局。如果还有空间，继续从上到下布局。最后确认整个间隙是正确的。（反向布局及横向反之则可）</li>
<li>该方法为LayoutManager布局核心执行方法，Child的测量和添加工作在fill这个重要方法执行，接下来会阐述 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">    </span><br><span class="line">       &#x2F;&#x2F; 确定是否需要反向布局</span><br><span class="line">       &#x2F;&#x2F; 确定锚点及偏移量 (1. 优先焦点child 2. 如果是反向布局，则找recycler里面最最接近尾部的child 3. 如果是正向，则找最接近头部的child)</span><br><span class="line">       &#x2F;&#x2F; 计算额外的偏移量（RecyclerView padding） </span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 锚点准备ready        </span><br><span class="line">       onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">       &#x2F;&#x2F; 临时 detach和回收当前的view 第一次 measure 的时候不会产生效果，因为此时 RecyclerView 还没有子 View。 而在第二第三次 layout 时，它会把子 View 从 RecyclerView 中 remove 或 detach ，并缓存子 View，以便之后重新 add 回来或 attach 回来，避免重复加载相同的子 View</span><br><span class="line">       detachAndScrapAttachedViews(recycler); </span><br><span class="line">       mLayoutState.mInfinite &#x3D; resolveIsInfinite(); </span><br><span class="line">       mLayoutState.mIsPreLayout &#x3D; state.isPreLayout();</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 开始填充view</span><br><span class="line">       if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">          ... &#x2F;&#x2F; 反向填充</span><br><span class="line">       &#125; else &#123; &#x2F;&#x2F; 正向填充</span><br><span class="line">           &#x2F;&#x2F; （基于锚点位置先 由上到下||由左到右）更新锚点信息</span><br><span class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">           mLayoutState.mExtra &#x3D; extraForEnd; &#x2F;&#x2F; 额外的尾部偏移量</span><br><span class="line">           &#x2F;&#x2F; 开始填充 View布局主要方法</span><br><span class="line">           fill(recycler, mLayoutState, state, false);</span><br><span class="line">           &#x2F;&#x2F; 尾部位移</span><br><span class="line">           endOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           final int lastElement &#x3D; mLayoutState.mCurrentPosition;</span><br><span class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">               extraForStart +&#x3D; mLayoutState.mAvailable;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; （基于锚点位置 由下到上||由右到左）更新锚点信息</span><br><span class="line">           updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">           mLayoutState.mExtra &#x3D; extraForStart;</span><br><span class="line">           mLayoutState.mCurrentPosition +&#x3D; mLayoutState.mItemDirection;</span><br><span class="line">           &#x2F;&#x2F; 二次填充</span><br><span class="line">           fill(recycler, mLayoutState, state, false);</span><br><span class="line">           startOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           &#x2F;&#x2F; 仍有可用空间</span><br><span class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">               extraForEnd &#x3D; mLayoutState.mAvailable;</span><br><span class="line">               &#x2F;&#x2F; 继续 （基于锚点位置先 由上到下||由左到右）更新信息并填充View</span><br><span class="line">               updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">               mLayoutState.mExtra &#x3D; extraForEnd;</span><br><span class="line">               fill(recycler, mLayoutState, state, false);</span><br><span class="line">               endOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       &#x2F;&#x2F; 有滑动位置导致的gap间隙修复处理</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 预布局动画处理</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-fill"><a href="#LinearLayoutManager-fill" class="headerlink" title="LinearLayoutManager.fill"></a>LinearLayoutManager.fill</h4><ul>
<li>如果是滑动流程，则根据情况进行回收流程</li>
<li>LayoutState中部分成员变量含义，mOffset：填充起始坐标，mCurrentPosition：填充起始数据的position，mAvailable：本次滑动可填充的距离，mScrollingOffset：滑动过的总量循环依次加载子View</li>
<li>确定可布局大小，直至布局大小消费完成</li>
<li>加载子View在 layoutChunk 中执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</span><br><span class="line">            </span><br><span class="line">   &#x2F;&#x2F; 可布局的位移</span><br><span class="line">   final int start &#x3D; layoutState.mAvailable;</span><br><span class="line">   &#x2F;&#x2F; 滑动偏移的情况下</span><br><span class="line">   if (layoutState.mScrollingOffset !&#x3D; LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">       if (layoutState.mAvailable &lt; 0) &#123;</span><br><span class="line">           layoutState.mScrollingOffset +&#x3D; layoutState.mAvailable;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 执行回收流程</span><br><span class="line">       recycleByLayoutState(recycler, layoutState);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 余量大小</span><br><span class="line">   int remainingSpace &#x3D; layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">   &#x2F;&#x2F; 每次布局结果中间记录 方便运算  </span><br><span class="line">   LayoutChunkResult layoutChunkResult &#x3D; mLayoutChunkResult;</span><br><span class="line">   while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">       layoutChunkResult.resetInternal();</span><br><span class="line">       &#x2F;&#x2F; 加载子View</span><br><span class="line">       layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line"></span><br><span class="line">       if (layoutChunkResult.mFinished) &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       layoutState.mOffset +&#x3D; layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">       &#x2F;&#x2F; 计算布局使用过的大小值</span><br><span class="line">       if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList !&#x3D; null</span><br><span class="line">               || !state.isPreLayout()) &#123;</span><br><span class="line">           layoutState.mAvailable -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">           remainingSpace -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">       &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果当前正在滚动屏幕</span><br><span class="line">       if (layoutState.mScrollingOffset !&#x3D; LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">           layoutState.mScrollingOffset +&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">           if (layoutState.mAvailable &lt; 0) &#123;</span><br><span class="line">               layoutState.mScrollingOffset +&#x3D; layoutState.mAvailable;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 把移出屏幕的 View 缓存到 mCachedViews 里面</span><br><span class="line">           recycleByLayoutState(recycler, layoutState);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-layoutChunk"><a href="#LinearLayoutManager-layoutChunk" class="headerlink" title="LinearLayoutManager.layoutChunk"></a>LinearLayoutManager.layoutChunk</h4><ul>
<li>通过layoutState.next(recycler)获取目标布局View</li>
<li>获取目标View完毕后，进行含装饰的Margin计算，并执行布局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,</span><br><span class="line">            LayoutState layoutState, LayoutChunkResult result) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取下一个布局View （核心方法）</span><br><span class="line">        View view &#x3D; layoutState.next(recycler);</span><br><span class="line">        </span><br><span class="line">        LayoutParams params &#x3D; (LayoutParams) view.getLayoutParams();</span><br><span class="line">        if (layoutState.mScrapList &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 除非特殊指定，否则mScrapList为null</span><br><span class="line">            &#x2F;&#x2F; 执行 addView </span><br><span class="line">            if (mShouldReverseLayout &#x3D;&#x3D; (layoutState.mLayoutDirection</span><br><span class="line">                    &#x3D;&#x3D; LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 添加到末尾</span><br><span class="line">                addView(view); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addView(view, 0); &#x2F;&#x2F; 添加到第一个位置</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...      </span><br><span class="line">        &#125;</span><br><span class="line">        measureChildWithMargins(view, 0, 0); &#x2F;&#x2F; 测量子View的Margins</span><br><span class="line">        &#x2F;&#x2F; 计算 含装饰的Margin值的大小</span><br><span class="line">        result.mConsumed &#x3D; mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">        int left, top, right, bottom;</span><br><span class="line">        &#x2F;&#x2F; 计算 r、l、t、b的值</span><br><span class="line">        if (mOrientation &#x3D;&#x3D; VERTICAL) &#123;</span><br><span class="line">            if (isLayoutRTL()) &#123;</span><br><span class="line">                right &#x3D; getWidth() - getPaddingRight();</span><br><span class="line">                left &#x3D; right - mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left &#x3D; getPaddingLeft();</span><br><span class="line">                right &#x3D; left + mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">            &#125;</span><br><span class="line">            if (layoutState.mLayoutDirection &#x3D;&#x3D; LayoutState.LAYOUT_START) &#123;</span><br><span class="line">                bottom &#x3D; layoutState.mOffset;</span><br><span class="line">                top &#x3D; layoutState.mOffset - result.mConsumed;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                top &#x3D; layoutState.mOffset;</span><br><span class="line">                bottom &#x3D; layoutState.mOffset + result.mConsumed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 对View进行布局</span><br><span class="line">        layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">        &#x2F;&#x2F; 部分状态改变 </span><br><span class="line">        if (params.isItemRemoved() || params.isItemChanged()) &#123;</span><br><span class="line">            result.mIgnoreConsumed &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        result.mFocusable &#x3D; view.hasFocusable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-next"><a href="#LinearLayoutManager-next" class="headerlink" title="LinearLayoutManager.next"></a>LinearLayoutManager.next</h4><p>通过RecyclerView.Recycler获取对应Pos的View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">View next(RecyclerView.Recycler recycler) &#123;</span><br><span class="line">  if (mScrapList !&#x3D; null) &#123; &#x2F;&#x2F; 除非定制View，不然为null</span><br><span class="line">      return nextViewFromScrapList();</span><br><span class="line">  &#125;</span><br><span class="line">  通过RecyclerView.Recycler 获取目标position对应的View </span><br><span class="line">  final View view &#x3D; recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">  mCurrentPosition +&#x3D; mItemDirection; &#x2F;&#x2F; 当前pos 增加</span><br><span class="line">  return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Recycler获取VH的缓存和创建过程"><a href="#Recycler获取VH的缓存和创建过程" class="headerlink" title="Recycler获取VH的缓存和创建过程"></a>Recycler获取VH的缓存和创建过程</h3><h4 id="Recycler-getViewForPosition"><a href="#Recycler-getViewForPosition" class="headerlink" title="Recycler.getViewForPosition"></a>Recycler.getViewForPosition</h4><p>根据Pos获取View方法，最终执行tryGetViewHolderForPositionByDeadline获取View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public View getViewForPosition(int position) &#123;</span><br><span class="line">  return getViewForPosition(position, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">  return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Recycler-tryGetViewHolderForPositionByDeadline"><a href="#Recycler-tryGetViewHolderForPositionByDeadline" class="headerlink" title="Recycler.tryGetViewHolderForPositionByDeadline"></a>Recycler.tryGetViewHolderForPositionByDeadline</h4><ul>
<li>获取ViewHolder方法</li>
<li>如果是预布局，线通过ChangeScrap中获取</li>
<li>第一次尝试获取VH，依次从Scrap、Hidden、Cache中获取VH</li>
<li>第二次尝试获取VH，针对具有StableId的Adapter，根据id依次从Scrap和Cache获取</li>
<li>第三次尝试从自定义缓存中获取VH</li>
<li>第四次尝试从Recycler获取VH</li>
<li>最后直接创建VH</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">  </span><br><span class="line">  boolean fromScrapOrHiddenOrCache &#x3D; false;</span><br><span class="line">  ViewHolder holder &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 0) 如果是预布局， 从mChangedScrap中获取 </span><br><span class="line">  if (mState.isPreLayout()) &#123;</span><br><span class="line">      holder &#x3D; getChangedScrapViewForPosition(position);</span><br><span class="line">      fromScrapOrHiddenOrCache &#x3D; holder !&#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 1) 第一次尝试获取，依次从Scrap、Hidden、Cache中获取VH</span><br><span class="line">  if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 依次从Scrap、Hidden、Cache中获取VH</span><br><span class="line">      holder &#x3D; getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">      ... </span><br><span class="line">  &#125;</span><br><span class="line">  if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">      final int type &#x3D; mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">      &#x2F;&#x2F; 2) 第二次尝试获取，当Adapter具备StableIds情况</span><br><span class="line">      if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">          holder &#x3D; getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                  type, dryRun);</span><br><span class="line">          if (holder !&#x3D; null) &#123;</span><br><span class="line">              &#x2F;&#x2F; update position</span><br><span class="line">              holder.mPosition &#x3D; offsetPosition;</span><br><span class="line">              fromScrapOrHiddenOrCache &#x3D; true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 3) 第三次尝试从 自定义缓存获取</span><br><span class="line">      if (holder &#x3D;&#x3D; null &amp;&amp; mViewCacheExtension !&#x3D; null) &#123;</span><br><span class="line">                   final View view &#x3D; mViewCacheExtension</span><br><span class="line">                  .getViewForPositionAndType(this, position, type);</span><br><span class="line">          if (view !&#x3D; null) &#123;</span><br><span class="line">              holder &#x3D; getChildViewHolder(view);</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 4) 第四次尝试 从 RecyclerPool中获取</span><br><span class="line">      if (holder &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; fallback to pool</span><br><span class="line">          holder &#x3D; getRecycledViewPool().getRecycledView(type);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 5) 开始创建</span><br><span class="line">      if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">          long start &#x3D; getNanoTime();</span><br><span class="line">          &#x2F;&#x2F; 创建VH</span><br><span class="line">          holder &#x3D; mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">          ... </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">       boolean bound &#x3D; false;</span><br><span class="line">       if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">           holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">       &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 为bind过，执行bind方法</span><br><span class="line">           final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">           bound &#x3D; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        private boolean tryBindViewHolderByDeadline(ViewHolder holder, int offsetPosition,</span><br><span class="line">                int position, long deadlineNs) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 执行Adapter bindViewHolder方法</span><br><span class="line">            mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">            ...</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="00-从ChangeScrap获取"><a href="#00-从ChangeScrap获取" class="headerlink" title="00 从ChangeScrap获取"></a>00 从ChangeScrap获取</h4><p>针对的是预布局状态，从mChangedScrap中获取目标ViewHolder<br>ScrapView：View仍然attach在其父RecyclerView上且可以被重复绑定数据及重复使用。将View标记为Scrap过程中分为两大类mAttachedScrap 和 mChangedScrap。<br>mAttachedScrap：VH有ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID这两个Flag，或者VH是没有被更新过的，或者是可以被重新更新的VH。<br>其它则是mChangedScrap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder getChangedScrapViewForPosition(int position) &#123;</span><br><span class="line">  &#x2F;&#x2F; 必须是预布局状态，取mChangedScrap中的ViewHolder</span><br><span class="line">  final int changedScrapSize;</span><br><span class="line">  if (mChangedScrap &#x3D;&#x3D; null || (changedScrapSize &#x3D; mChangedScrap.size()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 通过position获取</span><br><span class="line">  for (int i &#x3D; 0; i &lt; changedScrapSize; i++) &#123;</span><br><span class="line">      final ViewHolder holder &#x3D; mChangedScrap.get(i);</span><br><span class="line">      if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position) &#123;</span><br><span class="line">          holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">          return holder;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果Adapter是固定id，尝试从Adapter获取</span><br><span class="line">  if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">      final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">      if (offsetPosition &gt; 0 &amp;&amp; offsetPosition &lt; mAdapter.getItemCount()) &#123;</span><br><span class="line">          final long id &#x3D; mAdapter.getItemId(offsetPosition);</span><br><span class="line">          for (int i &#x3D; 0; i &lt; changedScrapSize; i++) &#123;</span><br><span class="line">              final ViewHolder holder &#x3D; mChangedScrap.get(i);</span><br><span class="line">              if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getItemId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">                  holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">                  return holder;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mark an attached view as scrap.</span><br><span class="line">void scrapView(View view) &#123;</span><br><span class="line">       final ViewHolder holder &#x3D; getChildViewHolderInt(view);</span><br><span class="line">       if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">               || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">           holder.setScrapContainer(this, false);</span><br><span class="line">           mAttachedScrap.add(holder);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (mChangedScrap &#x3D;&#x3D; null) &#123;</span><br><span class="line">               mChangedScrap &#x3D; new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">           &#125;</span><br><span class="line">           holder.setScrapContainer(this, true);</span><br><span class="line">           mChangedScrap.add(holder);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="第一次尝试获取VH（AttachScrap、Hidden、CacheView）"><a href="#第一次尝试获取VH（AttachScrap、Hidden、CacheView）" class="headerlink" title="第一次尝试获取VH（AttachScrap、Hidden、CacheView）"></a>第一次尝试获取VH（AttachScrap、Hidden、CacheView）</h4><ul>
<li>先从 mAttachedScrap中获取VH</li>
<li>从隐藏且未移出的View中获取 View</li>
<li>从一级缓存CacheView中获取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">       final int scrapCount &#x3D; mAttachedScrap.size();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 先从 mAttachedScrap中获取VH</span><br><span class="line">       for (int i &#x3D; 0; i &lt; scrapCount; i++) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mAttachedScrap.get(i);</span><br><span class="line">           &#x2F;&#x2F; 验证VH是否可用，若可用，则直接返回该VH</span><br><span class="line">           if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position</span><br><span class="line">                   &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;</span><br><span class="line">               holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">               return holder;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; dryRun 传递是false（代表VH在scrap、cache中可以被Removed）</span><br><span class="line">       if (!dryRun) &#123;</span><br><span class="line">           &#x2F;&#x2F; 从隐藏且未移出的View中获取 View</span><br><span class="line">           View view &#x3D; mChildHelper.findHiddenNonRemovedView(position);</span><br><span class="line">           if (view !&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; View可用，则进行可视、detach、scrap缓存</span><br><span class="line">               final ViewHolder vh &#x3D; getChildViewHolderInt(view);</span><br><span class="line">               mChildHelper.unhide(view);</span><br><span class="line">               int layoutIndex &#x3D; mChildHelper.indexOfChild(view);</span><br><span class="line">               mChildHelper.detachViewFromParent(layoutIndex);</span><br><span class="line">               scrapView(view);</span><br><span class="line">               vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP</span><br><span class="line">                       | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">               return vh;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 从第一级缓存View中获取</span><br><span class="line">       final int cacheSize &#x3D; mCachedViews.size();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; cacheSize; i++) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mCachedViews.get(i);</span><br><span class="line">           &#x2F;&#x2F; VH是有效的</span><br><span class="line">           if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position) &#123;</span><br><span class="line">               if (!dryRun) &#123;</span><br><span class="line">                   mCachedViews.remove(i); &#x2F;&#x2F; 移出获取的cache</span><br><span class="line">               &#125;</span><br><span class="line">               return holder; &#x2F;&#x2F; 返回VH</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二次尝试获取VH（Adapter有稳定id情况）"><a href="#第二次尝试获取VH（Adapter有稳定id情况）" class="headerlink" title="第二次尝试获取VH（Adapter有稳定id情况）"></a>第二次尝试获取VH（Adapter有稳定id情况）</h4><ul>
<li>Adapter配置的id是稳定的，稳定指数据集变化的时候，对于同一数据对应的id是唯一的</li>
<li>先尝试从Scrap获取VH，非dryRun下，将未命中的从Scrap中移出，并加入到Cache或Pool缓存</li>
<li>在尝试从Cache获取VH，将未命中的从Cache中移出，并加入到Pool缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) &#123;</span><br><span class="line">       &#x2F;&#x2F; 从AttachedScrap中 尝试获取VH</span><br><span class="line">       final int count &#x3D; mAttachedScrap.size();</span><br><span class="line">       for (int i &#x3D; count - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mAttachedScrap.get(i);</span><br><span class="line">           &#x2F;&#x2F; id 相等 且 holder 非Scrap返回</span><br><span class="line">           if (holder.getItemId() &#x3D;&#x3D; id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">               if (type &#x3D;&#x3D; holder.getItemViewType()) &#123;</span><br><span class="line">                   holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">                   if (holder.isRemoved()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 从事</span><br><span class="line">                       if (!mState.isPreLayout()) &#123;</span><br><span class="line">                           holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE</span><br><span class="line">                                   | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return holder;</span><br><span class="line">               &#125; else if (!dryRun) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 从AttachedScrap移除</span><br><span class="line">                   mAttachedScrap.remove(i);</span><br><span class="line">                   removeDetachedView(holder.itemView, false);</span><br><span class="line">                   &#x2F;&#x2F; 回收加入至 cache 或者 pool</span><br><span class="line">                   quickRecycleScrapView(holder.itemView);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 从CacheView中尝试获取</span><br><span class="line">       final int cacheSize &#x3D; mCachedViews.size();</span><br><span class="line">       for (int i &#x3D; cacheSize - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mCachedViews.get(i);</span><br><span class="line">           if (holder.getItemId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">               if (type &#x3D;&#x3D; holder.getItemViewType()) &#123;</span><br><span class="line">                   if (!dryRun) &#123;</span><br><span class="line">                       mCachedViews.remove(i); &#x2F;&#x2F; 从Cache中移出</span><br><span class="line">                   &#125;</span><br><span class="line">                   return holder;</span><br><span class="line">               &#125; else if (!dryRun) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 从Cache中移出，放到pool中</span><br><span class="line">                   recycleCachedViewAt(i);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecyclerView滑动机制分析"><a href="#RecyclerView滑动机制分析" class="headerlink" title="RecyclerView滑动机制分析"></a>RecyclerView滑动机制分析</h3><p>根据View事件机制可以直接来看onTouchEvent方法。<br>重点查看move事件。move事件执行了scrollByInternal方法。该方法最后会执行LayoutManager的Scroll方法，以LinearLayoutManager为例，它的ScrollBy方法最终执行到fill方法。也就是上文提到的ItemView填充方法，滑动过程中会不断执行获取对应位置的ViewHolder，然后进行View的展示。从而实现RecyclerView的滑动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent e) &#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   switch (action) &#123;</span><br><span class="line">       case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">          ...</span><br><span class="line">       case MotionEventCompat.ACTION_POINTER_DOWN: </span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_MOVE: &#123; &#x2F;&#x2F; 触摸时间-move</span><br><span class="line">           ...</span><br><span class="line">           if (mScrollState &#x3D;&#x3D; SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">               mLastTouchX &#x3D; x - mScrollOffset[0];</span><br><span class="line">               mLastTouchY &#x3D; y - mScrollOffset[1];</span><br><span class="line">                &#x2F;&#x2F; 执行内部滑动方法</span><br><span class="line">               if (scrollByInternal(</span><br><span class="line">                       canScrollHorizontally ? dx : 0,</span><br><span class="line">                       canScrollVertically ? dy : 0,</span><br><span class="line">                       vtev)) &#123;</span><br><span class="line">                   getParent().requestDisallowInterceptTouchEvent(true);</span><br><span class="line">               &#125;</span><br><span class="line">               ...           &#125;</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEventCompat.ACTION_POINTER_UP: &#123;</span><br><span class="line">           onPointerUp(e);</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_UP: &#123; &#x2F;&#x2F; 触摸事件-up</span><br><span class="line">           &#x2F;&#x2F; 执行 fling方法 ，主要做一些item和scroller动画等操作</span><br><span class="line">           if (!((xvel !&#x3D; 0 || yvel !&#x3D; 0) &amp;&amp; fling((int) xvel, (int) yvel))) &#123;</span><br><span class="line">               setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">           &#125;</span><br><span class="line">           resetTouch();</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">           cancelTouch();</span><br><span class="line">       &#125; break;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scrollByInternal"><a href="#scrollByInternal" class="headerlink" title="scrollByInternal"></a>scrollByInternal</h4><ul>
<li>内部Scroll执行方法，此处会执行LayoutManager的Scroll方法</li>
<li>其它处罚Nested、OnScroll等事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean scrollByInternal(int x, int y, MotionEvent ev) &#123;</span><br><span class="line">   int unconsumedX &#x3D; 0, unconsumedY &#x3D; 0;</span><br><span class="line">   int consumedX &#x3D; 0, consumedY &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   consumePendingUpdateOperations();</span><br><span class="line">   if (mAdapter !&#x3D; null) &#123;</span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">       if (x !&#x3D; 0) &#123;</span><br><span class="line">           consumedX &#x3D; mLayout.scrollHorizontallyBy(x, mRecycler, mState);</span><br><span class="line">           unconsumedX &#x3D; x - consumedX;</span><br><span class="line">       &#125;</span><br><span class="line">       if (y !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; LinearLayout 竖向布局为例，走LayoutManager滑动放啊放</span><br><span class="line">           consumedY &#x3D; mLayout.scrollVerticallyBy(y, mRecycler, mState);</span><br><span class="line">           unconsumedY &#x3D; y - consumedY;</span><br><span class="line">       &#125;</span><br><span class="line">       TraceCompat.endSection();</span><br><span class="line">       repositionShadowingViews();</span><br><span class="line">       onExitLayoutOrScroll();</span><br><span class="line">       resumeRequestLayout(false);</span><br><span class="line">   &#125;</span><br><span class="line">   if (!mItemDecorations.isEmpty()) &#123;</span><br><span class="line">       invalidate();</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 分发 NestedScroll事件</span><br><span class="line">   if (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">   if (consumedX !&#x3D; 0 || consumedY !&#x3D; 0) &#123;</span><br><span class="line">       dispatchOnScrolled(consumedX, consumedY); &#x2F;&#x2F; 分发onScrolled事件</span><br><span class="line">   &#125;</span><br><span class="line">   if (!awakenScrollBars()) &#123;</span><br><span class="line">       invalidate();</span><br><span class="line">   &#125;</span><br><span class="line">   return consumedX !&#x3D; 0 || consumedY !&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager执行滑动处理"><a href="#LinearLayoutManager执行滑动处理" class="headerlink" title="LinearLayoutManager执行滑动处理"></a>LinearLayoutManager执行滑动处理</h4><ul>
<li>执行scrollBy方法</li>
<li>scrollBy方法最终走到 fill方法（上面提到的填充子View方法）</li>
<li>该方法则会进行 ItemView的填充。从而完成Recycler滑动时，View的重新创建或者重新绑定一系列过程</li>
<li>平移整个View的child，实现滑动效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,</span><br><span class="line">       RecyclerView.State state) &#123;</span><br><span class="line">   if (mOrientation &#x3D;&#x3D; HORIZONTAL) &#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   return scrollBy(dy, recycler, state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">   ...</span><br><span class="line">   mLayoutState.mRecycle &#x3D; true;</span><br><span class="line">   ensureLayoutState();</span><br><span class="line">   final int layoutDirection &#x3D; dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">   final int absDy &#x3D; Math.abs(dy);</span><br><span class="line">   &#x2F;&#x2F; 更新LayoutState，布局方向和偏移值。目的是让LayoutManager知道从开始还是末尾进行回收和填充</span><br><span class="line">   updateLayoutState(layoutDirection, absDy, true, state);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 执行 LinearLayout的fill 方法</span><br><span class="line">   final int consumed &#x3D; mLayoutState.mScrollingOffset</span><br><span class="line">           + fill(recycler, mLayoutState, state, false);</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 平移整个view的child</span><br><span class="line">   mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">   </span><br><span class="line">   return scrolled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 执行回收流程</span><br><span class="line">    recycleByLayoutState(recycler, layoutState);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 执行填充流程（参考上面layoutChunk方法）</span><br><span class="line">    layoutChunk(recycler, state, layoutState,layoutChunkResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager回收流程"><a href="#LinearLayoutManager回收流程" class="headerlink" title="LinearLayoutManager回收流程"></a>LinearLayoutManager回收流程</h4><ul>
<li>根据不同的布局方向进行不同方向的回收。以Start为例介绍</li>
<li>计算位移limit值，根据limit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123;</span><br><span class="line">   &#x2F;&#x2F; 假设是 初始方向布局，则开始末尾View回收。反之亦然</span><br><span class="line">   if (layoutState.mLayoutDirection &#x3D;&#x3D; LayoutState.LAYOUT_START) &#123;</span><br><span class="line">       recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) &#123;</span><br><span class="line">   final int limit &#x3D; dt;</span><br><span class="line">   final int childCount &#x3D; getChildCount();</span><br><span class="line">   if (mShouldReverseLayout) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; childCount; i++) &#123;</span><br><span class="line">           View child &#x3D; getChildAt(i);</span><br><span class="line">           &#x2F;&#x2F; 遍历child，当超过限制大小时候，开始回收</span><br><span class="line">           if (mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">                   || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">               recycleChildren(recycler, 0, i); &#x2F;&#x2F; 执行Children回收流程</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) &#123;</span><br><span class="line">   if (endIndex &gt; startIndex) &#123;</span><br><span class="line">       for (int i &#x3D; endIndex - 1; i &gt;&#x3D; startIndex; i--) &#123;</span><br><span class="line">           removeAndRecycleViewAt(i, recycler); &#x2F;&#x2F; 执行RecyclerView的移出和回收方法</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (int i &#x3D; startIndex; i &gt; endIndex; i--) &#123;</span><br><span class="line">           removeAndRecycleViewAt(i, recycler);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RecyclerView-removeAndRecycleViewAt"><a href="#RecyclerView-removeAndRecycleViewAt" class="headerlink" title="RecyclerView.removeAndRecycleViewAt"></a>RecyclerView.removeAndRecycleViewAt</h4><ul>
<li>移出和回收View方法</li>
<li>执行ChildHelper的移出View方法。内部Bucket移出和回掉CallBack进行View移出</li>
<li>执行Recycler回收方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void removeAndRecycleViewAt(int index, Recycler recycler) &#123;</span><br><span class="line">  final View view &#x3D; getChildAt(index); &#x2F;&#x2F; 获取目标View</span><br><span class="line">  removeViewAt(index); &#x2F;&#x2F; 执行ChildHelper移出</span><br><span class="line">  recycler.recycleView(view); &#x2F;&#x2F; 回收View</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeViewAt(int index) &#123;</span><br><span class="line">  final View child &#x3D; getChildAt(index); </span><br><span class="line">  if (child !&#x3D; null) &#123;</span><br><span class="line">      mChildHelper.removeViewAt(index); &#x2F;&#x2F; 执行ChildHelper移出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void recycleView(View view) &#123;</span><br><span class="line">  ViewHolder holder &#x3D; getChildViewHolderInt(view); &#x2F;&#x2F; 获取VH</span><br><span class="line">  &#x2F;&#x2F; ViewHolder 回收前，需要完全detach、且不是Scrap</span><br><span class="line">  if (holder.isTmpDetached()) &#123;</span><br><span class="line">      removeDetachedView(view, false); </span><br><span class="line">  &#125;</span><br><span class="line">  if (holder.isScrap()) &#123;</span><br><span class="line">      holder.unScrap();</span><br><span class="line">  &#125; else if (holder.wasReturnedFromScrap())&#123;</span><br><span class="line">      holder.clearReturnedFromScrapFlag();</span><br><span class="line">  &#125;</span><br><span class="line">  recycleViewHolderInternal(holder); &#x2F;&#x2F; 执行回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="RecyclerView-recycleViewHolderInternal"><a href="#RecyclerView-recycleViewHolderInternal" class="headerlink" title="RecyclerView.recycleViewHolderInternal"></a>RecyclerView.recycleViewHolderInternal</h4><ul>
<li>内部缓存VH方法</li>
<li>如果CacheView满了，则移出一个Cache到Pool中</li>
<li>将目标VH缓存到Cache末尾</li>
<li>如果没有Cache成功，则直接缓存到Pool中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> void recycleViewHolderInternal(ViewHolder holder) &#123;  </span><br><span class="line">      if (mViewCacheMax &gt; 0</span><br><span class="line">              &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">              | ViewHolder.FLAG_REMOVED</span><br><span class="line">              | ViewHolder.FLAG_UPDATE</span><br><span class="line">              | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</span><br><span class="line">          &#x2F;&#x2F; Cache缓存个数超了，则直接回收CacheView到RecyclerPool</span><br><span class="line">          int cachedViewSize &#x3D; mCachedViews.size();</span><br><span class="line">          if (cachedViewSize &gt;&#x3D; mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</span><br><span class="line">              recycleCachedViewAt(0);</span><br><span class="line">              cachedViewSize--;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          int targetCacheIndex &#x3D; cachedViewSize;</span><br><span class="line">          &#x2F;&#x2F; 将VH缓存到CacheView中</span><br><span class="line">          mCachedViews.add(targetCacheIndex, holder);</span><br><span class="line">          cached &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果未CacheView缓存，则直接缓存RecyclerViewPool中</span><br><span class="line">      if (!cached) &#123;</span><br><span class="line">          addViewHolderToRecycledViewPool(holder, true);</span><br><span class="line">          recycled &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="局部刷新"><a href="#局部刷新" class="headerlink" title="局部刷新"></a>局部刷新</h3><h4 id="Adapter数据操作对外API"><a href="#Adapter数据操作对外API" class="headerlink" title="Adapter数据操作对外API"></a>Adapter数据操作对外API</h4><p>RecyclerView.Adapter提供局部数据变化通知方法，然后执行到RecyclerViewDataObserver对应的各种数据操作方法上。</p>
<h4 id="RecyclerViewDataObserver"><a href="#RecyclerViewDataObserver" class="headerlink" title="RecyclerViewDataObserver"></a>RecyclerViewDataObserver</h4><ul>
<li>通过mAdapterHelper进行数据变化处理操作</li>
<li>然后触发更新处理</li>
<li>下面介绍下 ItemChanged操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void onItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onItemRangeInserted(int positionStart, int itemCount) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onItemRangeRemoved(int positionStart, int itemCount) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AdapterHelper-onItemRangeChanged"><a href="#AdapterHelper-onItemRangeChanged" class="headerlink" title="AdapterHelper.onItemRangeChanged"></a>AdapterHelper.onItemRangeChanged</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean onItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加一个更新操作 ，标志为update、记录pos、item相关信息</span><br><span class="line">   mPendingUpdates.add(obtainUpdateOp(UpdateOp.UPDATE, positionStart, itemCount, payload));</span><br><span class="line">   mExistingUpdateTypes |&#x3D; UpdateOp.UPDATE;</span><br><span class="line">   &#x2F;&#x2F; 如果只有一个待处理操作则为true，true则执行后续更新处理。如果是多个，则会忽略，因为在第一次出发后，就会集中处理</span><br><span class="line">   return mPendingUpdates.size() &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RecyclerViewDataObserver-triggerUpdateProcessor"><a href="#RecyclerViewDataObserver-triggerUpdateProcessor" class="headerlink" title="RecyclerViewDataObserver.triggerUpdateProcessor"></a>RecyclerViewDataObserver.triggerUpdateProcessor</h4><ol>
<li>当RecyclerView有固定大小，且已经Attached了。则走Runnable更新</li>
<li>否则直接走requestLayout方式更新，即重新走绘制流程 onMeasure、onLayout等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void triggerUpdateProcessor() &#123;</span><br><span class="line">  if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">      &#x2F;&#x2F; RecyclerView有固定大小的时候 会执行mUpdateChildViewsRunnable 来处理更新</span><br><span class="line">      ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 直接走 requestLayout方式来处理</span><br><span class="line">      mAdapterUpdateDuringMeasure &#x3D; true;</span><br><span class="line">      requestLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="triggerUpdateProcessor下requestLayout"><a href="#triggerUpdateProcessor下requestLayout" class="headerlink" title="triggerUpdateProcessor下requestLayout"></a>triggerUpdateProcessor下requestLayout</h4><p>requestLayout下 onMeasure -&gt; dispatchLayout -&gt; dispatchLayoutStep2 -&gt; layoutChildren -&gt; fill -&gt; layoutChunk -&gt; next -&gt; tryGetViewHolderForPositionByDeadline<br>最终对Item进行重新绑定 实现局部刷新逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">                </span><br><span class="line">           if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">                holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">            &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行数据变化的Holder的重新bind，从而实现局部刷新              </span><br><span class="line">                final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                bound &#x3D; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="triggerUpdateProcessor下mUpdateChildViewsRunnable"><a href="#triggerUpdateProcessor下mUpdateChildViewsRunnable" class="headerlink" title="triggerUpdateProcessor下mUpdateChildViewsRunnable"></a>triggerUpdateProcessor下mUpdateChildViewsRunnable</h4><p>当RecyclerView有固定大小时，则不需要Measure，直接走dispatchLayout方法进行刷新操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final Runnable mUpdateChildViewsRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 消费 等待执行的操作 </span><br><span class="line">        consumePendingUpdateOperations();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumePendingUpdateOperations() &#123;</span><br><span class="line">        </span><br><span class="line">      if (mAdapterHelper.hasAnyUpdateTypes(AdapterHelper.UpdateOp.UPDATE) &amp;&amp; !mAdapterHelper</span><br><span class="line">           .hasAnyUpdateTypes(AdapterHelper.UpdateOp.ADD | AdapterHelper.UpdateOp.REMOVE</span><br><span class="line">                   | AdapterHelper.UpdateOp.MOVE)) &#123;</span><br><span class="line">        &#x2F;&#x2F; update 情况下 逻辑</span><br><span class="line">       </span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       &#x2F;&#x2F; 数据预处理 </span><br><span class="line">       mAdapterHelper.preProcess();</span><br><span class="line">       if (!mLayoutRequestEaten) &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行 dispatchLayout 进行局部刷新处理</span><br><span class="line">           if (hasUpdatedView()) &#123;</span><br><span class="line">               dispatchLayout();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; no need to layout, clean state</span><br><span class="line">               mAdapterHelper.consumePostponedUpdates();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125; else if (mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">       &#x2F;&#x2F; add、remove等操作，直接执行dispatchLayout</span><br><span class="line">       dispatchLayout();</span><br><span class="line">       TraceCompat.endSection();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Afree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://afree8909.github.io/blog/2020/04/27/RececlerView%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://afree8909.github.io/blog/2020/04/27/RececlerView%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/RececlerView/">RececlerView</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/afree8909/pictures/master/blogbranch_comparison.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/blog/2020/04/27/Git%E4%B8%BB%E6%B5%81%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blogbranch_comparison.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Git主流分支模型</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'cb1555f9c0cbd64760a2',
  clientSecret: '1b7216ee7c340092507f7fa63a1435dcb5ad8bed',
  repo: 'blog-comment',
  owner: 'afree8909',
  admin: ['afree8909'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428141843.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Afree</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode far fa-sun" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/blog/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>