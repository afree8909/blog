<!DOCTYPE html><html lang="zh-Hans" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OkHttp 4源码（3）—缓存机制分析 | Afree</title><meta name="description" content="本文基于OkHttp 4.3.1源码分析OkHttp - 官方地址OkHttp - GitHub代码地址  预备知识HTTP缓存原理  概述OkHttp整体流程（本文覆盖红色部分）  缓存处理流程 缓存文件夹 缓存日志格式 源码分析测试代码如果需要缓存机制，那么在构造OkHttpClient的时候需要传入一个Cache实例。下面是OkHttp提供的一个CacheResponse的用例，除了传入一"><meta name="keywords" content="OkHttp"><meta name="author" content="Afree"><meta name="copyright" content="Afree"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/blog/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="OkHttp 4源码（3）—缓存机制分析"><meta name="twitter:description" content="本文基于OkHttp 4.3.1源码分析OkHttp - 官方地址OkHttp - GitHub代码地址  预备知识HTTP缓存原理  概述OkHttp整体流程（本文覆盖红色部分）  缓存处理流程 缓存文件夹 缓存日志格式 源码分析测试代码如果需要缓存机制，那么在构造OkHttpClient的时候需要传入一个Cache实例。下面是OkHttp提供的一个CacheResponse的用例，除了传入一"><meta name="twitter:image" content="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144613.png"><meta property="og:type" content="article"><meta property="og:title" content="OkHttp 4源码（3）—缓存机制分析"><meta property="og:url" content="https://afree8909.github.io/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89%E2%80%94%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="Afree"><meta property="og:description" content="本文基于OkHttp 4.3.1源码分析OkHttp - 官方地址OkHttp - GitHub代码地址  预备知识HTTP缓存原理  概述OkHttp整体流程（本文覆盖红色部分）  缓存处理流程 缓存文件夹 缓存日志格式 源码分析测试代码如果需要缓存机制，那么在构造OkHttpClient的时候需要传入一个Cache实例。下面是OkHttp提供的一个CacheResponse的用例，除了传入一"><meta property="og:image" content="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144613.png"><meta property="article:published_time" content="2020-01-13T02:32:35.166Z"><meta property="article:modified_time" content="2020-04-28T06:47:04.913Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://afree8909.github.io/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89%E2%80%94%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"><link rel="prev" title="OkHttp 4源码（4）—连接机制分析" href="https://afree8909.github.io/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%884%EF%BC%89%E2%80%94%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"><link rel="next" title="OkHttp 4源码（2）— 拦截器机制分析" href="https://afree8909.github.io/blog/2020/01/12/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%882%EF%BC%89%E2%80%94%20%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/blog/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/blog/archives/"><div class="headline">Articles</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/blog/tags/"><div class="headline">Tags</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/blog/categories/"><div class="headline">Categories</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#预备知识"><span class="toc-number">1.</span> <span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">3.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试代码"><span class="toc-number">3.1.</span> <span class="toc-text">测试代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存拦截器逻辑"><span class="toc-number">3.2.</span> <span class="toc-text">缓存拦截器逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CacheInterceptor-intercept"><span class="toc-number">3.2.1.</span> <span class="toc-text">CacheInterceptor.intercept</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存获取逻辑"><span class="toc-number">3.3.</span> <span class="toc-text">缓存获取逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-get"><span class="toc-number">3.3.1.</span> <span class="toc-text">Cache.get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Entry-构造"><span class="toc-number">3.3.2.</span> <span class="toc-text">Cache.Entry 构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiskLruCache-get"><span class="toc-number">3.3.3.</span> <span class="toc-text">DiskLruCache.get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiskLruCache-initialize"><span class="toc-number">3.3.4.</span> <span class="toc-text">DiskLruCache.initialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiskLruCache-readJournal"><span class="toc-number">3.3.5.</span> <span class="toc-text">DiskLruCache.readJournal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiskLruCache-readJournalLine"><span class="toc-number">3.3.6.</span> <span class="toc-text">DiskLruCache.readJournalLine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiskLruCache-processJournal"><span class="toc-number">3.3.7.</span> <span class="toc-text">DiskLruCache.processJournal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存使用策略逻辑"><span class="toc-number">3.4.</span> <span class="toc-text">缓存使用策略逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CacheStrategy-init"><span class="toc-number">3.4.1.</span> <span class="toc-text">CacheStrategy.init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CacheStrategy-compute"><span class="toc-number">3.4.2.</span> <span class="toc-text">CacheStrategy.compute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CacheStrategy-computeCandidate"><span class="toc-number">3.4.3.</span> <span class="toc-text">CacheStrategy.computeCandidate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存存储逻辑"><span class="toc-number">3.5.</span> <span class="toc-text">缓存存储逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-put"><span class="toc-number">3.5.1.</span> <span class="toc-text">Cache.put</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiskLruCache-edit"><span class="toc-number">3.5.2.</span> <span class="toc-text">DiskLruCache.edit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-writeTo"><span class="toc-number">3.5.3.</span> <span class="toc-text">Cache.writeTo</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144613.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/blog/">Afree</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">OkHttp 4源码（3）—缓存机制分析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-01-13 10:32:35"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-01-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-04-28 14:47:04"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-04-28</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/Android/">Android</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>Word count:</span><span class="word-count">4.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>Reading time: 19 min</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a href="https://www.jianshu.com/p/6ec0d13d85bb" target="_blank" rel="noopener">HTTP缓存原理</a></p>
<p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428143220.png"  alt="HTTP缓存流程图"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）</p>
<p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144516.png"  alt=""></p>
<p>缓存处理流程<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144613.png"  alt=""></p>
<p>缓存文件夹<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144602.png"  alt=""></p>
<p>缓存日志格式<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144613.png"  alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>如果需要缓存机制，那么在构造OkHttpClient的时候需要传入一个Cache实例。<br>下面是OkHttp提供的一个CacheResponse的用例，除了传入一个Cache构造OkHttpClient，其它完全一样。<br>OkHttp实现缓存的切入点依旧是拦截器，之前的文章我们知道拦截器处理对象可以接受命令对象并根据自身情况选择处理还是不处理，所以接下来就是直接从CacheInterceptor开始分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final class CacheResponse &#123;</span><br><span class="line">  private final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public CacheResponse(File cacheDirectory) throws Exception &#123;</span><br><span class="line">    int cacheSize &#x3D; 10 * 1024 * 1024; &#x2F;&#x2F; 10 MiB 大小</span><br><span class="line">    Cache cache &#x3D; new Cache(cacheDirectory, cacheSize); &#x2F;&#x2F; 路径</span><br><span class="line">    &#x2F;&#x2F; 要使用缓存功能，需要在构造OkHttpClient的时候传入 cache （缓存大小，缓存路径地址）</span><br><span class="line">    client &#x3D; new OkHttpClient.Builder()</span><br><span class="line">        .cache(cache)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run() throws Exception &#123;</span><br><span class="line">    Request request &#x3D; new Request.Builder()</span><br><span class="line">        .url(&quot;http:&#x2F;&#x2F;publicobject.com&#x2F;helloworld.txt&quot;)</span><br><span class="line">        .build();</span><br><span class="line">    </span><br><span class="line">    String response1Body;</span><br><span class="line">    try (Response response1 &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String response2Body;</span><br><span class="line">    try (Response response2 &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两次请求结果一致</span><br><span class="line">    System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) throws Exception &#123;</span><br><span class="line">    new CacheResponse(new File(&quot;CacheResponse.tmp&quot;)).run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存拦截器逻辑"><a href="#缓存拦截器逻辑" class="headerlink" title="缓存拦截器逻辑"></a>缓存拦截器逻辑</h3><h4 id="CacheInterceptor-intercept"><a href="#CacheInterceptor-intercept" class="headerlink" title="CacheInterceptor.intercept"></a>CacheInterceptor.intercept</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; </span><br><span class="line">   val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">   val now &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">   val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">   val networkRequest &#x3D; strategy.networkRequest</span><br><span class="line">   val cacheResponse &#x3D; strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 缓存追踪，网络请求数、命中缓存数，两者比值可以查看缓存命中率</span><br><span class="line">   cache?.trackResponse(strategy)</span><br><span class="line"></span><br><span class="line">   if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">     cacheCandidate.body?.closeQuietly()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 异常情况</span><br><span class="line">   if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return Response.Builder()</span><br><span class="line">         .request(chain.request())</span><br><span class="line">         .protocol(Protocol.HTTP_1_1)</span><br><span class="line">         .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">         .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">         .body(EMPTY_RESPONSE)</span><br><span class="line">         .sentRequestAtMillis(-1L)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果networkRequest为null，则直接使用缓存数据，拦截器处理至此终结，开始响应阶段</span><br><span class="line">   if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return cacheResponse!!.newBuilder()</span><br><span class="line">         .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   var networkResponse: Response? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 继续执行 拦截器链处理方法，最终发送网络请求，到读取网络数据</span><br><span class="line">     networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">       cacheCandidate.body?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">     if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123; &#x2F;&#x2F; 304</span><br><span class="line">     &#x2F;&#x2F; 如果网络数据标志性没有改变，开始返回数据</span><br><span class="line">       val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">           .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">           .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">           .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">           .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">           .networkResponse(stripBody(networkResponse))</span><br><span class="line">           .build()</span><br><span class="line"></span><br><span class="line">       networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">       &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">       cache!!.trackConditionalCacheHit()</span><br><span class="line">       cache.update(cacheResponse, response)</span><br><span class="line">       return response</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       cacheResponse.body?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">       .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">       .networkResponse(stripBody(networkResponse))</span><br><span class="line">       .build()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   if (cache !&#x3D; null) &#123;</span><br><span class="line">     if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">       &#x2F;&#x2F; 对响应数据进行缓存</span><br><span class="line">       val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">       &#x2F;&#x2F; 返回一个带有new Source的body读取流 的 Response</span><br><span class="line">       return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">     &#125;</span><br><span class="line">       </span><br><span class="line">     if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         cache.remove(networkRequest)</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return response</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存获取逻辑"><a href="#缓存获取逻辑" class="headerlink" title="缓存获取逻辑"></a>缓存获取逻辑</h3><h4 id="Cache-get"><a href="#Cache-get" class="headerlink" title="Cache.get"></a>Cache.get</h4><ul>
<li>生成请求对应的唯一标志key</li>
<li>通过DiskLruCache获取对应key的缓存快照数据</li>
<li>如果有快照，则将快照对应的缓存资源数据通过Okio中流读写转换成内存数据</li>
<li>最后返回构造好的Response</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">internal fun get(request: Request): Response? &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据请求url字符串进行md5作为缓存对应的key标识</span><br><span class="line">  val key &#x3D; key(request.url)</span><br><span class="line">  &#x2F;&#x2F; Cache成员变量DiskLruCache，缓存逻辑实现类</span><br><span class="line">  &#x2F;&#x2F; snapshot</span><br><span class="line">  val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">    &#x2F;&#x2F; 从DiskLruCache中取缓存</span><br><span class="line">    cache[key] ?: return null</span><br><span class="line">  &#125; catch (_: IOException) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 读取快照中的缓存资源流 ，构造数据Entry</span><br><span class="line">  val entry: Entry &#x3D; try &#123;</span><br><span class="line">    Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">  &#125; catch (_: IOException) &#123;</span><br><span class="line">    snapshot.closeQuietly()</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 取 response</span><br><span class="line">  val response &#x3D; entry.response(snapshot)</span><br><span class="line">  if (!entry.matches(request, response)) &#123; </span><br><span class="line">    response.body?.closeQuietly() &#x2F;&#x2F; 响应和请求 不匹配则关闭</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response &#x2F;&#x2F; 返回响应数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cache-Entry-构造"><a href="#Cache-Entry-构造" class="headerlink" title="Cache.Entry 构造"></a>Cache.Entry 构造</h4><p>缓存数据实例，DiskLruCache中lruEntries存储了请求key对应的快照，快照里有key对应的本地文件读取流，根据读取流读取本地数据，转换输出构造Entry实例，最终应用构造出一个缓存的Response</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">internal constructor(rawSource: Source) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        val source &#x3D; rawSource.buffer()</span><br><span class="line">        &#x2F;&#x2F; 从缓存文件流中 读取数据 ，写入到Entry中</span><br><span class="line">        ... &#x2F;&#x2F; 一堆 读取流 写入内存操作</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">        rawSource.close()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="DiskLruCache-get"><a href="#DiskLruCache-get" class="headerlink" title="DiskLruCache.get"></a>DiskLruCache.get</h4><ul>
<li>初始化或者确认初始化（主要目的是将key和对应缓存本地文件标识存储到内存Map中，便于查询）</li>
<li>如果找到了就返回一个快照对象，没有则为null</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">operator fun get(key: String): Snapshot? &#123;</span><br><span class="line">  initialize() &#x2F;&#x2F; 初始化 || 确认已经初始化</span><br><span class="line"></span><br><span class="line">  checkNotClosed() &#x2F;&#x2F; check cache是否关闭</span><br><span class="line">  validateKey(key) &#x2F;&#x2F; 确认key 符合 写入的规则</span><br><span class="line">  &#x2F;&#x2F; 找key对应的缓存entry</span><br><span class="line">  val entry &#x3D; lruEntries[key] ?: return null </span><br><span class="line">  if (!entry.readable) return null</span><br><span class="line">  &#x2F;&#x2F; 有缓存entry 取对应的快照</span><br><span class="line">  val snapshot &#x3D; entry.snapshot() ?: return null</span><br><span class="line">  &#x2F;&#x2F; 标识一次操作</span><br><span class="line">  redundantOpCount++ </span><br><span class="line">  &#x2F;&#x2F; 写入 标记READ 和对应 key 一行</span><br><span class="line">  journalWriter!!.writeUtf8(READ)</span><br><span class="line">      .writeByte(&#39; &#39;.toInt())</span><br><span class="line">      .writeUtf8(key)</span><br><span class="line">      .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">  &#x2F;&#x2F; 如果操作&gt;2000次了，则需要重新清理 日志 </span><br><span class="line">  if (journalRebuildRequired()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行清理任务</span><br><span class="line">    cleanupQueue.schedule(cleanupTask)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回快照</span><br><span class="line">  return snapshot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-initialize"><a href="#DiskLruCache-initialize" class="headerlink" title="DiskLruCache.initialize"></a>DiskLruCache.initialize</h4><ul>
<li>整理日志文件，删除backup或者重命名bakcup日志文件</li>
<li>读取日志文件，生成lruEntries内存缓存</li>
<li>处理日志文件</li>
<li>按需是否重新构建日志文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化方法</span><br><span class="line">fun initialize() &#123;</span><br><span class="line">   this.assertThreadHoldsLock()</span><br><span class="line">   &#x2F;&#x2F; 是否已经初始化 ，内存缓存</span><br><span class="line">   if (initialized) &#123;</span><br><span class="line">     return &#x2F;&#x2F; Already initialized.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 开始初始化工作</span><br><span class="line">   &#x2F;&#x2F; 如果存在backup的日志文件，</span><br><span class="line">   &#x2F;&#x2F; 则看是否存在日志文件，如果存在日志文件则删除backup的，</span><br><span class="line">   &#x2F;&#x2F; 如果没有则将backup文件转化为日志文件</span><br><span class="line">   if (fileSystem.exists(journalFileBackup)) &#123;</span><br><span class="line">     if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">       fileSystem.delete(journalFileBackup)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       fileSystem.rename(journalFileBackup, journalFile)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; journal文件存在 开始读取工作</span><br><span class="line">   if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       readJournal()</span><br><span class="line">       processJournal()</span><br><span class="line">       initialized &#x3D; true</span><br><span class="line">       return</span><br><span class="line">     &#125; catch (journalIsCorrupt: IOException) &#123;</span><br><span class="line">       Platform.get().log(</span><br><span class="line">           &quot;DiskLruCache $directory is corrupt: $&#123;journalIsCorrupt.message&#125;, removing&quot;,</span><br><span class="line">           WARN,</span><br><span class="line">           journalIsCorrupt)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span><br><span class="line">     &#x2F;&#x2F; we&#39;ll let that propagate out as it likely means there is a severe filesystem problem.</span><br><span class="line">     try &#123;</span><br><span class="line">       delete()</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       closed &#x3D; false</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   rebuildJournal()</span><br><span class="line"></span><br><span class="line">   initialized &#x3D; true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-readJournal"><a href="#DiskLruCache-readJournal" class="headerlink" title="DiskLruCache.readJournal"></a>DiskLruCache.readJournal</h4><ul>
<li>读取日志，判断日志是否可用</li>
<li>日志可用，则读取每行日志，构建Key、Entry的map到内存缓存</li>
<li>如果读取过程中有问题，则根据tmp日志重新构建日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取日志文件，构造[key,entry]内存缓存集合</span><br><span class="line">private fun readJournal() &#123;</span><br><span class="line">  fileSystem.source(journalFile).buffer().use &#123; source -&gt;</span><br><span class="line">    &#x2F;&#x2F; 基于Okio读写本地数据</span><br><span class="line">    &#x2F;&#x2F; libcore.io.DiskLruCache</span><br><span class="line">    val magic &#x3D; source.readUtf8LineStrict() </span><br><span class="line">    val version &#x3D; source.readUtf8LineStrict() &#x2F;&#x2F; 版本 1</span><br><span class="line">    val appVersionString &#x3D; source.readUtf8LineStrict() &#x2F;&#x2F; app version</span><br><span class="line">    val valueCountString &#x3D; source.readUtf8LineStrict()&#x2F;&#x2F; </span><br><span class="line">    val blank &#x3D; source.readUtf8LineStrict()</span><br><span class="line"></span><br><span class="line">    if (MAGIC !&#x3D; magic ||</span><br><span class="line">        VERSION_1 !&#x3D; version ||</span><br><span class="line">        appVersion.toString() !&#x3D; appVersionString ||</span><br><span class="line">        valueCount.toString() !&#x3D; valueCountString ||</span><br><span class="line">        blank.isNotEmpty()) &#123;</span><br><span class="line">      throw IOException(</span><br><span class="line">          &quot;unexpected journal header: [$magic, $version, $valueCountString, $blank]&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var lineCount &#x3D; 0</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 见readJournalLine方法分析（读取key，构造entry）</span><br><span class="line">        readJournalLine(source.readUtf8LineStrict())</span><br><span class="line">        lineCount++</span><br><span class="line">      &#125; catch (_: EOFException) &#123;</span><br><span class="line">        break &#x2F;&#x2F; End of journal.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 无用的line数目</span><br><span class="line">    redundantOpCount &#x3D; lineCount - lruEntries.size</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果读取有无，则重构建日志</span><br><span class="line">    if (!source.exhausted()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 通过Okio读取tmp日志文件重新写Journal文件</span><br><span class="line">      rebuildJournal() </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      journalWriter &#x3D; newJournalWriter() &#x2F;&#x2F; 创建日志writer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-readJournalLine"><a href="#DiskLruCache-readJournalLine" class="headerlink" title="DiskLruCache.readJournalLine"></a>DiskLruCache.readJournalLine</h4><ul>
<li>读取每一行日志</li>
<li>根据行日志属性，CLEAN、DIRTY、REMOVE、READ进行对应的处理</li>
<li>缓存到内存缓存LruEntries的Map中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取每一行日志，存储到LruEntries Map中</span><br><span class="line">private fun readJournalLine(line: String) &#123;</span><br><span class="line">  &#x2F;&#x2F; 找 第一个空格的 指引</span><br><span class="line">  val firstSpace &#x3D; line.indexOf(&#39; &#39;)</span><br><span class="line">  if (firstSpace &#x3D;&#x3D; -1) throw IOException(&quot;unexpected journal line: $line&quot;)</span><br><span class="line">  &#x2F;&#x2F; 从第一个空格指引+1位置开始找第二个空格指引</span><br><span class="line">  val keyBegin &#x3D; firstSpace + 1</span><br><span class="line">  val secondSpace &#x3D; line.indexOf(&#39; &#39;, keyBegin)</span><br><span class="line">  val key: String</span><br><span class="line">  &#x2F;&#x2F; 如果第二个空格指引没有找到</span><br><span class="line">  if (secondSpace &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 截取第一个空格指引到字符串最后的字段，截取的字段赋值key</span><br><span class="line">    key &#x3D; line.substring(keyBegin)</span><br><span class="line">    &#x2F;&#x2F; 如果第一个空格指引大小为Remove长度或者line是以remove开头</span><br><span class="line">    if (firstSpace &#x3D;&#x3D; REMOVE.length &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">      &#x2F;&#x2F; lruEntries 移除key</span><br><span class="line">      lruEntries.remove(key)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果第二个空格存在，则key赋值为第一个空格和第二个空格之间的字符串值</span><br><span class="line">    key &#x3D; line.substring(keyBegin, secondSpace)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 取key对应的Entry</span><br><span class="line">  var entry: Entry? &#x3D; lruEntries[key]</span><br><span class="line">  if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 不存砸，则创建Entry并赋值</span><br><span class="line">    entry &#x3D; Entry(key)</span><br><span class="line">    lruEntries[key] &#x3D; entry</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  when &#123;</span><br><span class="line">    secondSpace !&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; CLEAN.length &amp;&amp; line.startsWith(CLEAN) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 示例数据 CLEAN 4b217e04ba52215f3a6b64d28f6729c6 333 194</span><br><span class="line">      &#x2F;&#x2F; 读line间隔有多少个 方便存储对应大小数据</span><br><span class="line">      val parts &#x3D; line.substring(secondSpace + 1)</span><br><span class="line">          .split(&#39; &#39;)</span><br><span class="line">      entry.readable &#x3D; true &#x2F;&#x2F; 设置可读</span><br><span class="line">      entry.currentEditor &#x3D; null &#x2F;&#x2F; 重置null</span><br><span class="line">      entry.setLengths(parts) &#x2F;&#x2F; 根据文件个数，设置每个文件大小</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 示例数据：DIRTY 4b217e04ba52215f3a6b64d28f6729c6</span><br><span class="line">    secondSpace &#x3D;&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; DIRTY.length &amp;&amp; line.startsWith(DIRTY) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 赋值currentEditor为对应Entry的Editor</span><br><span class="line">      entry.currentEditor &#x3D; Editor(entry)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; READ，不做处理</span><br><span class="line">    secondSpace &#x3D;&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; READ.length &amp;&amp; line.startsWith(READ) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; This work was already done by calling lruEntries.get().</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else -&gt; throw IOException(&quot;unexpected journal line: $line&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-processJournal"><a href="#DiskLruCache-processJournal" class="headerlink" title="DiskLruCache.processJournal"></a>DiskLruCache.processJournal</h4><ul>
<li>计算有效文件的总大小值</li>
<li>删除无效本地缓存文件和内存缓存key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private fun processJournal() &#123;</span><br><span class="line">  &#x2F;&#x2F; 删除journal.tmp临时文件</span><br><span class="line">  fileSystem.delete(journalFileTmp)</span><br><span class="line">  val i &#x3D; lruEntries.values.iterator()</span><br><span class="line">  &#x2F;&#x2F; 遍历lruEntries ，计算currentEditor为null对应的文件总大小</span><br><span class="line">  while (i.hasNext()) &#123; </span><br><span class="line">    val entry &#x3D; i.next()</span><br><span class="line">    if (entry.currentEditor &#x3D;&#x3D; null) &#123;</span><br><span class="line">      for (t in 0 until valueCount) &#123;</span><br><span class="line">        size +&#x3D; entry.lengths[t]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      entry.currentEditor &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; 删除currentEditor文件（对应Dirty文件）</span><br><span class="line">      for (t in 0 until valueCount) &#123;</span><br><span class="line">        fileSystem.delete(entry.cleanFiles[t])</span><br><span class="line">        fileSystem.delete(entry.dirtyFiles[t])</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存使用策略逻辑"><a href="#缓存使用策略逻辑" class="headerlink" title="缓存使用策略逻辑"></a>缓存使用策略逻辑</h3><p>缓存使用策略：给定请求和缓存响应，决策出用网络响应还是缓存响应，或者两者都有</p>
<h4 id="CacheStrategy-init"><a href="#CacheStrategy-init" class="headerlink" title="CacheStrategy.init"></a>CacheStrategy.init</h4><ul>
<li>读取请求时间戳、响应时间戳</li>
<li>读取缓存策略决策的关键Header，Date、Expires、Last-Modified、ETag</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">      if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">        this.sentRequestMillis &#x3D; cacheResponse.sentRequestAtMillis</span><br><span class="line">        this.receivedResponseMillis &#x3D; cacheResponse.receivedResponseAtMillis</span><br><span class="line">        val headers &#x3D; cacheResponse.headers</span><br><span class="line">        for (i in 0 until headers.size) &#123;</span><br><span class="line">          val fieldName &#x3D; headers.name(i)</span><br><span class="line">          val value &#x3D; headers.value(i)</span><br><span class="line">          when &#123;</span><br><span class="line">            &#x2F;&#x2F; 读取缓存策略决策的关键Header</span><br><span class="line">            &#x2F;&#x2F; Date、Expires、Last-Modified、ETag</span><br><span class="line">            fieldName.equals(&quot;Date&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              servedDate &#x3D; value.toHttpDateOrNull()</span><br><span class="line">              servedDateString &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Expires&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              expires &#x3D; value.toHttpDateOrNull()</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Last-Modified&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              lastModified &#x3D; value.toHttpDateOrNull()</span><br><span class="line">              lastModifiedString &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;ETag&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              etag &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Age&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              ageSeconds &#x3D; value.toNonNegativeInt(-1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheStrategy-compute"><a href="#CacheStrategy-compute" class="headerlink" title="CacheStrategy.compute"></a>CacheStrategy.compute</h4><p>执行CacheStrategy.computeCandidate策略，最后返回四种策略结果</p>
<ol>
<li>CacheStrategy(request, null)； 无缓存，需要取网络数据</li>
<li>CacheStrategy(null, cacheResponse)；直接使用缓存</li>
<li>CacheStrategy(conditionalRequestHeaders,cacheResponse)；构建新的网络请求（加Header）需要新的网络请求返回后判断是否使用哪一个</li>
<li>CacheStrategy(null, null)； 错误场景</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun compute(): CacheStrategy &#123;</span><br><span class="line">  val candidate &#x3D; computeCandidate()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 禁止构建新的请求 且 缓存数据有没有，则返回null，这一般是个错误场景</span><br><span class="line">  if (candidate.networkRequest !&#x3D; null &amp;&amp; request.cacheControl.onlyIfCached) &#123;</span><br><span class="line">    return CacheStrategy(null, null)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return candidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheStrategy-computeCandidate"><a href="#CacheStrategy-computeCandidate" class="headerlink" title="CacheStrategy.computeCandidate"></a>CacheStrategy.computeCandidate</h4><p>缓存策略一系列判断，最后有三种策略返回结果</p>
<ol>
<li>CacheStrategy(request, null)； 无缓存，需要取网络数据</li>
<li>CacheStrategy(null, cacheResponse)；直接使用缓存</li>
<li>CacheStrategy(conditionalRequestHeaders,cacheResponse)；构建新的网络请求（加Header）需要新的网络请求返回后判断是否使用哪一个</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">private fun computeCandidate(): CacheStrategy &#123;</span><br><span class="line">    &#x2F;&#x2F; 无缓存</span><br><span class="line">    if (cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; https请求 且无handshake数据</span><br><span class="line">    if (request.isHttps &amp;&amp; cacheResponse.handshake &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 不支持缓存</span><br><span class="line">    if (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 配置了cacheControl字段 说明不需要cache</span><br><span class="line">    val requestCaching &#x3D; request.cacheControl</span><br><span class="line">    if (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算!noCache情况Header下，是否过期，是否可以直接使用Cache数据</span><br><span class="line">    val responseCaching &#x3D; cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">    val ageMillis &#x3D; cacheResponseAge()</span><br><span class="line">    var freshMillis &#x3D; computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">    if (requestCaching.maxAgeSeconds !&#x3D; -1) &#123;</span><br><span class="line">      freshMillis &#x3D; minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var minFreshMillis: Long &#x3D; 0</span><br><span class="line">    if (requestCaching.minFreshSeconds !&#x3D; -1) &#123;</span><br><span class="line">      minFreshMillis &#x3D; SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var maxStaleMillis: Long &#x3D; 0</span><br><span class="line">    if (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds !&#x3D; -1) &#123;</span><br><span class="line">      maxStaleMillis &#x3D; SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; !noCache Header标志，且缓存数据未过期，则直接使用</span><br><span class="line">    if (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">      val builder &#x3D; cacheResponse.newBuilder()</span><br><span class="line">      if (ageMillis + minFreshMillis &gt;&#x3D; freshMillis) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      val oneDayMillis &#x3D; 24 * 60 * 60 * 1000L</span><br><span class="line">      if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return CacheStrategy(null, builder.build())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将header数据取出，带入新的请求header中</span><br><span class="line">    val conditionName: String</span><br><span class="line">    val conditionValue: String?</span><br><span class="line">    when &#123;</span><br><span class="line">      etag !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-None-Match&quot;</span><br><span class="line">        conditionValue &#x3D; etag</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastModified !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; lastModifiedString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      servedDate !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; servedDateString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      else -&gt; return CacheStrategy(request, null) &#x2F;&#x2F; No condition! Make a regular request.</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 构建新的网络请求，返回带有新的网络请求+cacheReponse数据</span><br><span class="line">    val conditionalRequestHeaders &#x3D; request.headers.newBuilder()</span><br><span class="line">    conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">    val conditionalRequest &#x3D; request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build()</span><br><span class="line">    return CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存存储逻辑"><a href="#缓存存储逻辑" class="headerlink" title="缓存存储逻辑"></a>缓存存储逻辑</h3><h4 id="Cache-put"><a href="#Cache-put" class="headerlink" title="Cache.put"></a>Cache.put</h4><p>⚠️ 对于非GET请求，不做缓存逻辑，原因：POST请求虽然可以做到缓存逻辑，但是实现复杂度和收益比非常低，所以没有处理非Get的请求缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">internal fun put(response: Response): CacheRequest? &#123;</span><br><span class="line">   &#x2F;&#x2F; 请求方法</span><br><span class="line">   val requestMethod &#x3D; response.request.method</span><br><span class="line">   &#x2F;&#x2F; 如果是非Get则为true</span><br><span class="line">   if (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       remove(response.request) &#x2F;&#x2F; 移除缓存</span><br><span class="line">     &#125; catch (_: IOException) &#123;</span><br><span class="line">       &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">     &#125;</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 对于非GET请求，不做缓存逻辑，原因：POST请求虽然可以做到缓存逻辑，但是实现复杂度和收益比非常低，所以没有做处理</span><br><span class="line">   if (requestMethod !&#x3D; &quot;GET&quot;) &#123;</span><br><span class="line">     &#x2F;&#x2F; Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache HEAD requests and some</span><br><span class="line">     &#x2F;&#x2F; POST requests, but the complexity of doing so is high and the benefit is low.</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (response.hasVaryAll()) &#123;</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造 Entry</span><br><span class="line">   val entry &#x3D; Entry(response)</span><br><span class="line">   var editor: DiskLruCache.Editor? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Entry 编辑器，数据书写</span><br><span class="line">     editor &#x3D; cache.edit(key(response.request.url)) ?: return null</span><br><span class="line">     entry.writeTo(editor)</span><br><span class="line">     &#x2F;&#x2F; 构造一个 RealCacheRequest返回 </span><br><span class="line">     return RealCacheRequest(editor)</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     abortQuietly(editor)</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-edit"><a href="#DiskLruCache-edit" class="headerlink" title="DiskLruCache.edit"></a>DiskLruCache.edit</h4><p>主要是获取编辑器，编辑器获取的同时，DiskLruCache内存缓存中会存储对应的key和Entry，entry会指定对应的Editor，且会写入一条数据到日志中，目前日志key对应的数据是DIRTY</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">fun edit(key: String, expectedSequenceNumber: Long &#x3D; ANY_SEQUENCE_NUMBER): Editor? &#123;</span><br><span class="line">   initialize()</span><br><span class="line"></span><br><span class="line">   checkNotClosed()</span><br><span class="line">   validateKey(key)</span><br><span class="line">   &#x2F;&#x2F; key对应Entry</span><br><span class="line">   var entry: Entry? &#x3D; lruEntries[key] </span><br><span class="line">   if (expectedSequenceNumber !&#x3D; ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">       (entry &#x3D;&#x3D; null || entry.sequenceNumber !&#x3D; expectedSequenceNumber)) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Snapshot is stale.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 是否正在编辑</span><br><span class="line">   if (entry?.currentEditor !&#x3D; null) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Another edit is in progress.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 是否需要执行clean</span><br><span class="line">   if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 写入 key 到日志中 ，目前对应是 DIRTY</span><br><span class="line">   val journalWriter &#x3D; this.journalWriter!!</span><br><span class="line">   journalWriter.writeUtf8(DIRTY)</span><br><span class="line">       .writeByte(&#39; &#39;.toInt())</span><br><span class="line">       .writeUtf8(key)</span><br><span class="line">       .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">   journalWriter.flush()</span><br><span class="line"></span><br><span class="line">   if (hasJournalErrors) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Don&#39;t edit; the journal can&#39;t be written.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造Entry，存储到map中</span><br><span class="line">   if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">     entry &#x3D; Entry(key)</span><br><span class="line">     lruEntries[key] &#x3D; entry</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造编辑器，及Etry赋值当前编辑器</span><br><span class="line">   val editor &#x3D; Editor(entry)</span><br><span class="line">   entry.currentEditor &#x3D; editor</span><br><span class="line">   return editor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cache-writeTo"><a href="#Cache-writeTo" class="headerlink" title="Cache.writeTo"></a>Cache.writeTo</h4><p>通过Okio将响应数据写入到本地缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun writeTo(editor: DiskLruCache.Editor) &#123;</span><br><span class="line">      val sink &#x3D; editor.newSink(ENTRY_METADATA).buffer()</span><br><span class="line">      sink.writeUtf8(url).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      sink.writeUtf8(requestMethod).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      for (i in 0 until varyHeaders.size) &#123;</span><br><span class="line">        sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">            .writeUtf8(&quot;: &quot;)</span><br><span class="line">            .writeUtf8(varyHeaders.value(i))</span><br><span class="line">            .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 写入数据</span><br><span class="line">      ...</span><br><span class="line">      sink.close()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/be6d09f2656b" target="_blank" rel="noopener">下一篇 OkHttp 4源码（4）— 连接机制分析</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Afree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://afree8909.github.io/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89%E2%80%94%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">https://afree8909.github.io/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89%E2%80%94%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/OkHttp/">OkHttp</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/afree8909/pictures/master/blogbranch_comparison.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%884%EF%BC%89%E2%80%94%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"><img class="prev_cover lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428143236.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">OkHttp 4源码（4）—连接机制分析</div></div></a></div><div class="next-post pull_right"><a href="/blog/2020/01/12/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%882%EF%BC%89%E2%80%94%20%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"><img class="next_cover lazyload" data-src="https://i.loli.net/2019/11/10/rJbFpE65tmxPv7R.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">OkHttp 4源码（2）— 拦截器机制分析</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/blog/2020/01/30/OkHttp 4源码（7）— 总结/" title="OkHttp 4源码（7）— 总结"><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428143202.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-30</div><div class="relatedPosts_title">OkHttp 4源码（7）— 总结</div></div></a></div><div class="relatedPosts_item"><a href="/blog/2020/01/11/OkHttp 4源码（1）—OkHttp初始化和请求构造分析 /" title="OkHttp 4源码（1）—OkHttp初始化和请求构造分析 "><img class="relatedPosts_cover lazyload"data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144805.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-11</div><div class="relatedPosts_title">OkHttp 4源码（1）—OkHttp初始化和请求构造分析 </div></div></a></div><div class="relatedPosts_item"><a href="/blog/2020/01/12/OkHttp 4源码（2）— 拦截器机制分析/" title="OkHttp 4源码（2）— 拦截器机制分析"><img class="relatedPosts_cover lazyload"data-src="https://i.loli.net/2019/11/10/rJbFpE65tmxPv7R.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-12</div><div class="relatedPosts_title">OkHttp 4源码（2）— 拦截器机制分析</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'cb1555f9c0cbd64760a2',
  clientSecret: '1b7216ee7c340092507f7fa63a1435dcb5ad8bed',
  repo: 'blog-comment',
  owner: 'afree8909',
  admin: ['afree8909'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428144613.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Afree</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode far fa-sun" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/blog/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>