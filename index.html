<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"afree8909.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":20},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Afree&#39;s blog">
<meta property="og:url" content="https://afree8909.github.io/blog/index.html">
<meta property="og:site_name" content="Afree&#39;s blog">
<meta property="article:author" content="Afree">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://afree8909.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Afree's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Afree's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">保持好奇心，不畏边界，持续学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/04/27/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/27/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 15:08:57 / Modified: 18:40:52" itemprop="dateCreated datePublished" datetime="2020-04-27T15:08:57+08:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>分支模型的抉择可以概括为围绕 <strong>持续集成</strong> 和 <strong>特性隔离</strong> 两个特征进行博弈。</p>
<h3 id="分支模型对比结论"><a href="#分支模型对比结论" class="headerlink" title="分支模型对比结论"></a>分支模型对比结论</h3><h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p><a href="https://trunkbaseddevelopment.com/alternative-branching-models/index.html#modern-claimed-high-throughput-branching-models" target="_blank" rel="noopener">TBD说明</a></p>
<p><img src="https://raw.githubusercontent.com/afree8909/pictures/master/blogbranch_comparison.png" alt=""></p>
<h4 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a>使用分析</h4><table>
<thead>
<tr>
<th>分支模型</th>
<th>主干数</th>
<th>特性分支数</th>
<th>集成频率</th>
<th>多版本并行开发</th>
<th>需求中途撤销</th>
<th>打包方式</th>
</tr>
</thead>
<tbody><tr>
<td>Git Flow</td>
<td>2</td>
<td>5类</td>
<td>特性分支完成后一起集成</td>
<td>特性分支</td>
<td>合并前：删除特性分支 合并后：手动剔除代码</td>
<td>开发分支和发布分支分别打包</td>
</tr>
<tr>
<td>Aone FLow</td>
<td>1</td>
<td>3类</td>
<td>指定特性分支频繁集成</td>
<td>特性分支且控制合并时间</td>
<td>删除特性分支重新集成</td>
<td>发布分支分别打包</td>
</tr>
<tr>
<td>GitHub Flow</td>
<td>1</td>
<td>1类</td>
<td>特性分支立即集成</td>
<td>特性分支</td>
<td>手工剔除代码</td>
<td>特性分支打包</td>
</tr>
<tr>
<td>TBD</td>
<td>1</td>
<td>1类</td>
<td>所有提交立即集成</td>
<td>特性开关</td>
<td>手工剔除代码</td>
<td>一次打包多次部署</td>
</tr>
</tbody></table>
<h3 id="分支模型详细分析"><a href="#分支模型详细分析" class="headerlink" title="分支模型详细分析"></a>分支模型详细分析</h3><h4 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h4><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">详情参考</a></p>
<h5 id="分支情况"><a href="#分支情况" class="headerlink" title="分支情况"></a>分支情况</h5><ul>
<li>主干分支（长期）<ul>
<li>主分支：master</li>
<li>开发分支：develop</li>
</ul>
</li>
<li>特性分支（短期）<ul>
<li>功能分支：feature</li>
<li>预发分支：release</li>
<li>补丁分支：hotfix</li>
</ul>
</li>
</ul>
<h5 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h5><ul>
<li>开发&amp;发布<ul>
<li>develop分支创建feature分支</li>
</ul>
</li>
</ul>
<pre><code>* feature开发、测试完提pr到develop分支
* code review 和合并进develop
* 等待各个feature合并到develop
* develop创建release分支并进行测试
* release 开始发布，进行bug fix 且需要合并回develop
* release 发布完成，merge到master和develop</code></pre><ul>
<li>修复<ul>
<li>通过tag创建对应hotfix进行修复，然后合并回develop和master</li>
</ul>
</li>
</ul>
<p><img src="test/15865841815899.jpg" alt=""></p>
<h4 id="GitHubFlow"><a href="#GitHubFlow" class="headerlink" title="GitHubFlow"></a>GitHubFlow</h4><p><a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">详情参考</a></p>
<p><img src="test/15865853526049.jpg" alt="15865853526049"></p>
<h5 id="分支情况-1"><a href="#分支情况-1" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master<br>特性分支：feature</p>
<h5 id="玩法-1"><a href="#玩法-1" class="headerlink" title="玩法"></a>玩法</h5><p>开发：主分支创建feature分支进行开发、PR、Review、发布完成后，建立PR回master<br>修复：特性分支未合入master前特性分支修复，合入后针对tag单开分支修复并合入主干分支</p>
<p>它有一个变种版本，更好的支持多环境和多版本 ，可以参考 <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" target="_blank" rel="noopener">GitLab Flow</a></p>
<h4 id="TBD"><a href="#TBD" class="headerlink" title="TBD"></a>TBD</h4><p><a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">详情参考</a></p>
<p><img src="test/15865853448663.jpg" alt=""></p>
<h5 id="分支情况-2"><a href="#分支情况-2" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master</p>
<h5 id="玩法-2"><a href="#玩法-2" class="headerlink" title="玩法"></a>玩法</h5><p>开发：所有团队成员都在单个主干分支上进行开发，<br>符合约定后commit到主干分支。也可创建短周期分支进行开发rebase主干分支后提交PR</p>
<p>发布：优先Tag，Tag不能满足则创建发布分支</p>
<p>修复：主干分支修复，cherry pick到发布分支，新tag与发布</p>
<p>其它辅助方案策略</p>
<ul>
<li>如何避免引入未完成feature？ feature toggle（功能开关）</li>
<li>如果重构？ BBA（抽象分支）</li>
</ul>
<h4 id="AoneFlow"><a href="#AoneFlow" class="headerlink" title="AoneFlow"></a>AoneFlow</h4><p><a href="https://mp.weixin.qq.com/sJsBX3UPgZL_HUOTCIopr_A" target="_blank" rel="noopener">详情参考</a><br><img src="test/15865853069197.jpg" alt=""><br><img src="test/15865853131220.jpg" alt=""><br><img src="test/15865853182812.jpg" alt=""></p>
<h5 id="分支情况-3"><a href="#分支情况-3" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master<br>特性分支：feature、release</p>
<h5 id="玩法-3"><a href="#玩法-3" class="headerlink" title="玩法"></a>玩法</h5><ul>
<li>开始工作前，从主干创建特性分支。</li>
<li>通过合并特性分支，形成发布分支。</li>
<li>发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/04/27/Git%E4%B8%BB%E6%B5%81%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/27/Git%E4%B8%BB%E6%B5%81%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Git主流分支模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 14:36:51 / Modified: 14:39:45" itemprop="dateCreated datePublished" datetime="2020-04-27T14:36:51+08:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>分支模型的抉择可以概括为围绕 <strong>持续集成</strong> 和 <strong>特性隔离</strong> 两个特征进行博弈。</p>
<h3 id="分支模型对比结论"><a href="#分支模型对比结论" class="headerlink" title="分支模型对比结论"></a>分支模型对比结论</h3><h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p><a href="https://trunkbaseddevelopment.com/alternative-branching-models/index.html#modern-claimed-high-throughput-branching-models" target="_blank" rel="noopener">TBD说明</a></p>
<p><img src="media/docs.png" alt="docs"></p>
<h4 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a>使用分析</h4><table>
<thead>
<tr>
<th>分支模型</th>
<th>主干数</th>
<th>特性分支数</th>
<th>集成频率</th>
<th>多版本并行开发</th>
<th>需求中途撤销</th>
<th>打包方式</th>
</tr>
</thead>
<tbody><tr>
<td>Git Flow</td>
<td>2</td>
<td>5类</td>
<td>特性分支完成后一起集成</td>
<td>特性分支</td>
<td>合并前：删除特性分支 合并后：手动剔除代码</td>
<td>开发分支和发布分支分别打包</td>
</tr>
<tr>
<td>Aone FLow</td>
<td>1</td>
<td>3类</td>
<td>指定特性分支频繁集成</td>
<td>特性分支且控制合并时间</td>
<td>删除特性分支重新集成</td>
<td>发布分支分别打包</td>
</tr>
<tr>
<td>GitHub Flow</td>
<td>1</td>
<td>1类</td>
<td>特性分支立即集成</td>
<td>特性分支</td>
<td>手工剔除代码</td>
<td>特性分支打包</td>
</tr>
<tr>
<td>TBD</td>
<td>1</td>
<td>1类</td>
<td>所有提交立即集成</td>
<td>特性开关</td>
<td>手工剔除代码</td>
<td>一次打包多次部署</td>
</tr>
</tbody></table>
<h3 id="分支模型详细分析"><a href="#分支模型详细分析" class="headerlink" title="分支模型详细分析"></a>分支模型详细分析</h3><h4 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h4><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">详情参考</a></p>
<h5 id="分支情况"><a href="#分支情况" class="headerlink" title="分支情况"></a>分支情况</h5><ul>
<li>主干分支（长期）<ul>
<li>主分支：master</li>
<li>开发分支：develop</li>
</ul>
</li>
<li>特性分支（短期）<ul>
<li>功能分支：feature</li>
<li>预发分支：release</li>
<li>补丁分支：hotfix</li>
</ul>
</li>
</ul>
<h5 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h5><ul>
<li>开发&amp;发布<ul>
<li>develop分支创建feature分支</li>
</ul>
</li>
</ul>
<pre><code>* feature开发、测试完提pr到develop分支
* code review 和合并进develop
* 等待各个feature合并到develop
* develop创建release分支并进行测试
* release 开始发布，进行bug fix 且需要合并回develop
* release 发布完成，merge到master和develop</code></pre><ul>
<li>修复<ul>
<li>通过tag创建对应hotfix进行修复，然后合并回develop和master</li>
</ul>
</li>
</ul>
<p><img src="media/15865841815899.jpg" alt=""></p>
<h4 id="GitHubFlow"><a href="#GitHubFlow" class="headerlink" title="GitHubFlow"></a>GitHubFlow</h4><p><a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">详情参考</a></p>
<p><img src="media/15865853526049.jpg" alt="15865853526049"></p>
<h5 id="分支情况-1"><a href="#分支情况-1" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master<br>特性分支：feature</p>
<h5 id="玩法-1"><a href="#玩法-1" class="headerlink" title="玩法"></a>玩法</h5><p>开发：主分支创建feature分支进行开发、PR、Review、发布完成后，建立PR回master<br>修复：特性分支未合入master前特性分支修复，合入后针对tag单开分支修复并合入主干分支</p>
<p>它有一个变种版本，更好的支持多环境和多版本 ，可以参考 <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" target="_blank" rel="noopener">GitLab Flow</a></p>
<h4 id="TBD"><a href="#TBD" class="headerlink" title="TBD"></a>TBD</h4><p><a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">详情参考</a></p>
<p><img src="media/15865853448663.jpg" alt=""></p>
<h5 id="分支情况-2"><a href="#分支情况-2" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master</p>
<h5 id="玩法-2"><a href="#玩法-2" class="headerlink" title="玩法"></a>玩法</h5><p>开发：所有团队成员都在单个主干分支上进行开发，<br>符合约定后commit到主干分支。也可创建短周期分支进行开发rebase主干分支后提交PR</p>
<p>发布：优先Tag，Tag不能满足则创建发布分支</p>
<p>修复：主干分支修复，cherry pick到发布分支，新tag与发布</p>
<p>其它辅助方案策略</p>
<ul>
<li>如何避免引入未完成feature？ feature toggle（功能开关）</li>
<li>如果重构？ BBA（抽象分支）</li>
</ul>
<h4 id="AoneFlow"><a href="#AoneFlow" class="headerlink" title="AoneFlow"></a>AoneFlow</h4><p><a href="https://mp.weixin.qq.com/sJsBX3UPgZL_HUOTCIopr_A" target="_blank" rel="noopener">详情参考</a><br><img src="media/15865853069197.jpg" alt=""><br><img src="media/15865853131220.jpg" alt=""><br><img src="media/15865853182812.jpg" alt=""></p>
<h5 id="分支情况-3"><a href="#分支情况-3" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master<br>特性分支：feature、release</p>
<h5 id="玩法-3"><a href="#玩法-3" class="headerlink" title="玩法"></a>玩法</h5><ul>
<li>开始工作前，从主干创建特性分支。</li>
<li>通过合并特性分支，形成发布分支。</li>
<li>发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/04/27/RececlerView%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/27/RececlerView%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">RececlerView 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-27 14:34:16 / Modified: 14:36:39" itemprop="dateCreated datePublished" datetime="2020-04-27T14:34:16+08:00">2020-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于 V7-25.3.1</p>
</blockquote>
<p>[toc]</p>
<h2 id="图文总结"><a href="#图文总结" class="headerlink" title="图文总结"></a>图文总结</h2><h3 id="RecyclerView优点"><a href="#RecyclerView优点" class="headerlink" title="RecyclerView优点"></a>RecyclerView优点</h3><ul>
<li>更好的灵活配置能力，在LayoutManager（布局）、Adapter（数据适配）和动画的兼容上都更优雅</li>
<li>缓存能力增强，离屏缓存相对较优，另增加了一层缓存池缓存</li>
<li>支持局部刷新，对于一些交互处理多的情况下，会带来更好的性能</li>
</ul>
<h3 id="RecyclerView类图"><a href="#RecyclerView类图" class="headerlink" title="RecyclerView类图"></a>RecyclerView类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-0e590e9ca20936f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="RecyclerView绘制流程图"><a href="#RecyclerView绘制流程图" class="headerlink" title="RecyclerView绘制流程图"></a>RecyclerView绘制流程图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-d11e769f60925314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="RecyclerView滑动流程图"><a href="#RecyclerView滑动流程图" class="headerlink" title="RecyclerView滑动流程图"></a>RecyclerView滑动流程图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-f7996a0bc4414e28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="RecyclerView缓存介绍图"><a href="#RecyclerView缓存介绍图" class="headerlink" title="RecyclerView缓存介绍图"></a>RecyclerView缓存介绍图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-7c9f5b7dc3b9e75e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="RecyclerView使用方法分分析"><a href="#RecyclerView使用方法分分析" class="headerlink" title="RecyclerView使用方法分分析"></a>RecyclerView使用方法分分析</h3><h4 id="RecyclerView-构造方法"><a href="#RecyclerView-构造方法" class="headerlink" title="RecyclerView 构造方法"></a>RecyclerView 构造方法</h4><ul>
<li>进行View相关配置属性设置，触摸范围、滑动速度等</li>
<li>设置Item动画监听器</li>
<li>初始化AdapterManager，创建AdapterHelper（负责Adapter里的数据集发生变化时的预处理操作）</li>
<li>初始化ChildHelper（负责管理和访问 RecyclerView 的子视图）</li>
<li>如果配置了LayoutManager 则通过反射方法创建它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">       super(context, attrs, defStyle);</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; View配置相关属性设置</span><br><span class="line">       final ViewConfiguration vc &#x3D; ViewConfiguration.get(context);</span><br><span class="line">       mTouchSlop &#x3D; vc.getScaledTouchSlop();</span><br><span class="line">       mMinFlingVelocity &#x3D; vc.getScaledMinimumFlingVelocity();</span><br><span class="line">       mMaxFlingVelocity &#x3D; vc.getScaledMaximumFlingVelocity();</span><br><span class="line">       setWillNotDraw(getOverScrollMode() &#x3D;&#x3D; View.OVER_SCROLL_NEVER);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 设置Item动画监听器</span><br><span class="line">       mItemAnimator.setListener(mItemAnimatorListener);</span><br><span class="line">       &#x2F;&#x2F; 设置 AdapterManager</span><br><span class="line">       initAdapterManager();</span><br><span class="line">       &#x2F;&#x2F; 设置 ChildrenHelper </span><br><span class="line">       initChildrenHelper();</span><br><span class="line">       &#x2F;&#x2F; 硬件加速相关属性设置</span><br><span class="line">       if (ViewCompat.getImportantForAccessibility(this)</span><br><span class="line">               &#x3D;&#x3D; ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">           ViewCompat.setImportantForAccessibility(this,</span><br><span class="line">                   ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">       &#125;</span><br><span class="line">       mAccessibilityManager &#x3D; (AccessibilityManager) getContext()</span><br><span class="line">               .getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class="line">       setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 如果attrs指定了LayoutManager，则创建LayoutManager</span><br><span class="line">       boolean nestedScrollingEnabled &#x3D; true;</span><br><span class="line">       </span><br><span class="line">       if (attrs !&#x3D; null) &#123;</span><br><span class="line">           int defStyleRes &#x3D; 0;</span><br><span class="line">           TypedArray a &#x3D; context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,</span><br><span class="line">                   defStyle, defStyleRes);</span><br><span class="line">           String layoutManagerName &#x3D; a.getString(R.styleable.RecyclerView_layoutManager);</span><br><span class="line">           int descendantFocusability &#x3D; a.getInt(</span><br><span class="line">                   R.styleable.RecyclerView_android_descendantFocusability, -1);</span><br><span class="line">           if (descendantFocusability &#x3D;&#x3D; -1) &#123;</span><br><span class="line">               setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">           &#125;</span><br><span class="line">           a.recycle();</span><br><span class="line">           &#x2F;&#x2F; 反射方法创建 LayoutManager</span><br><span class="line">           createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);</span><br><span class="line"></span><br><span class="line">           if (Build.VERSION.SDK_INT &gt;&#x3D; 21) &#123;</span><br><span class="line">               &#x2F;&#x2F; SDK &gt;&#x3D;21下 ，nestedScrollingEnabled状态支持变更</span><br><span class="line">               a &#x3D; context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,</span><br><span class="line">                       defStyle, defStyleRes);</span><br><span class="line">               nestedScrollingEnabled &#x3D; a.getBoolean(0, true);</span><br><span class="line">               a.recycle();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 重置nestedScrollingEnabled状态 SDK 21以下默认true</span><br><span class="line">       setNestedScrollingEnabled(nestedScrollingEnabled);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="setLayoutManager"><a href="#setLayoutManager" class="headerlink" title="setLayoutManager"></a>setLayoutManager</h4><ul>
<li>处理重新设置一个新的LayoutManager的一些逻辑</li>
<li>设置this给到LayoutManager，并如果attach了则执行LayoutManger的attach分发实践</li>
<li>跟新缓存大小，并请求重新布局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void setLayoutManager(LayoutManager layout) &#123;</span><br><span class="line">        if (layout &#x3D;&#x3D; mLayout) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        stopScroll();</span><br><span class="line">        &#x2F;&#x2F; 设置新的layout情况下的一些处理逻辑</span><br><span class="line">        ... </span><br><span class="line">        </span><br><span class="line">        mChildHelper.removeAllViewsUnfiltered();</span><br><span class="line">        mLayout &#x3D; layout;</span><br><span class="line">        if (layout !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; layout只能绑定一个mRecyclerView </span><br><span class="line">            if (layout.mRecyclerView !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +</span><br><span class="line">                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置this引用给LayoutManager</span><br><span class="line">            mLayout.setRecyclerView(this);</span><br><span class="line">            if (mIsAttached) &#123;</span><br><span class="line">                &#x2F;&#x2F; 分发attach事件</span><br><span class="line">                mLayout.dispatchAttachedToWindow(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 重新更新缓存大小 及请求重新布局</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="setAdapter"><a href="#setAdapter" class="headerlink" title="setAdapter"></a>setAdapter</h4><ul>
<li>接触frozen状态</li>
<li>设置新的Adapter，并触发一系列监听事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void setAdapter(Adapter adapter) &#123;</span><br><span class="line">   &#x2F;&#x2F; 解除frozen状态</span><br><span class="line">   setLayoutFrozen(false);</span><br><span class="line">   &#x2F;&#x2F; 替换到当前Adapter，并触发监听</span><br><span class="line">   setAdapterInternal(adapter, false, true);</span><br><span class="line">   requestLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,</span><br><span class="line">            boolean removeAndRecycleViews) &#123;</span><br><span class="line">        &#x2F;&#x2F; 旧Adapter进行解绑数据监听 和 RecyclerView的引用</span><br><span class="line">        if (mAdapter !&#x3D; null) &#123;</span><br><span class="line">            mAdapter.unregisterAdapterDataObserver(mObserver);</span><br><span class="line">            mAdapter.onDetachedFromRecyclerView(this);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!compatibleWithPrevious || removeAndRecycleViews) &#123;</span><br><span class="line">            removeAndRecycleViews(); &#x2F;&#x2F; 移除缓存的View</span><br><span class="line">        &#125;</span><br><span class="line">        mAdapterHelper.reset();</span><br><span class="line">        final Adapter oldAdapter &#x3D; mAdapter;</span><br><span class="line">        mAdapter &#x3D; adapter;</span><br><span class="line">        if (adapter !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理新设置的Adapter的关联监听和RecyclerView</span><br><span class="line">            adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">            adapter.onAttachedToRecyclerView(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通知LayoutManager Adapter变更</span><br><span class="line">        if (mLayout !&#x3D; null) &#123;</span><br><span class="line">            mLayout.onAdapterChanged(oldAdapter, mAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 触发Recycler Adapter变更事件</span><br><span class="line">        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</span><br><span class="line">        &#x2F;&#x2F; 状态置为 mStructureChanged </span><br><span class="line">        mState.mStructureChanged &#x3D; true;</span><br><span class="line">        markKnownViewsInvalid();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecyclerView绘制方法分析"><a href="#RecyclerView绘制方法分析" class="headerlink" title="RecyclerView绘制方法分析"></a>RecyclerView绘制方法分析</h3><h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><ul>
<li>未赋值layoutManager情况下，走默认measure，结果是无展示</li>
<li>系统提供的LayoutManager默认AutoMeasure。执行LayoutManger的onMeasure方法</li>
<li>如果未指定确定宽高的尺寸规格，则会进行布局，继而获得子View的大小。此过程可能执行两次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">   if (mLayout &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 无LayoutManger</span><br><span class="line">       defaultOnMeasure(widthSpec, heightSpec); </span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; Android提供的三个LayoutManger，都是AutoMeasure</span><br><span class="line">   if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取测量规格</span><br><span class="line">       final int widthMode &#x3D; MeasureSpec.getMode(widthSpec);</span><br><span class="line">       final int heightMode &#x3D; MeasureSpec.getMode(heightSpec);</span><br><span class="line">       final boolean skipMeasure &#x3D; widthMode &#x3D;&#x3D; MeasureSpec.EXACTLY</span><br><span class="line">               &amp;&amp; heightMode &#x3D;&#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">       &#x2F;&#x2F; 执行LayoutManager的onMeasure方法</span><br><span class="line">       mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">       </span><br><span class="line">       if (skipMeasure || mAdapter &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 如果测量规格不确定 且设置了Adapter，则先执行一次layout</span><br><span class="line">       if (mState.mLayoutStep &#x3D;&#x3D; State.STEP_START) &#123;</span><br><span class="line">           dispatchLayoutStep1();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 设置测量规格</span><br><span class="line">       mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">       mState.mIsMeasuring &#x3D; true;</span><br><span class="line">       dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 设置 获取到子View的宽高</span><br><span class="line">       mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;二次测量，宽高不确定情况下</span><br><span class="line">       if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">           mLayout.setMeasureSpecs(</span><br><span class="line">                   MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                   MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">           mState.mIsMeasuring &#x3D; true;</span><br><span class="line">           dispatchLayoutStep2();</span><br><span class="line">           &#x2F;&#x2F; now we can get the width and height from the children.</span><br><span class="line">           mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RecyclerView-onLayout"><a href="#RecyclerView-onLayout" class="headerlink" title="RecyclerView.onLayout"></a>RecyclerView.onLayout</h4><ul>
<li>执行DispatchLayout方法</li>
<li>根据不同State状态，分别执行Step1、Step2、Step3方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">   TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">   dispatchLayout();</span><br><span class="line">   TraceCompat.endSection();</span><br><span class="line">   mFirstLayoutComplete &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">    void dispatchLayout() &#123;</span><br><span class="line">        mState.mIsMeasuring &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 如果State状态是 State.STEP_START 则执行 Step1 和Step2</span><br><span class="line">        if (mState.mLayoutStep &#x3D;&#x3D; State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() !&#x3D; getWidth() </span><br><span class="line">            &#x2F;&#x2F; 直接执行 step2</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 执行Step3 ，主要保存一些View信息和动画执行</span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4><ul>
<li>第一步layout方法</li>
<li>处理adapter变更</li>
<li>确定需要执行的动画</li>
<li>针对当前的Views进行信息缓存</li>
<li>如有必要，则进行预布局并缓存信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep1() &#123;</span><br><span class="line">   &#x2F;&#x2F;  State状态断言 </span><br><span class="line">   mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">   mState.mIsMeasuring &#x3D; false;</span><br><span class="line">   &#x2F;&#x2F; 是否过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1</span><br><span class="line">   eatRequestLayout();</span><br><span class="line">   &#x2F;&#x2F; 清楚 ViewInfo 所有状态和其存在的数据</span><br><span class="line">   mViewInfoStore.clear();</span><br><span class="line">   &#x2F;&#x2F; 执行进入 layout或者scroll行为标志</span><br><span class="line">   onEnterLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 执行Adapter变更及计算那些需要执行的动画</span><br><span class="line">   processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">   &#x2F;&#x2F; 存储焦点信息</span><br><span class="line">   saveFocusInfo();</span><br><span class="line">   &#x2F;&#x2F; state状态信息设置</span><br><span class="line">   mState.mTrackOldChangeHolders &#x3D; mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">   mItemsAddedOrRemoved &#x3D; mItemsChanged &#x3D; false;</span><br><span class="line">   mState.mInPreLayout &#x3D; mState.mRunPredictiveAnimations;</span><br><span class="line">   mState.mItemCount &#x3D; mAdapter.getItemCount();</span><br><span class="line">   &#x2F;&#x2F; 寻找 layout过程中position的最大和最小值</span><br><span class="line">   findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line">   </span><br><span class="line">   if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">       ...  </span><br><span class="line">       int count &#x3D; mChildHelper.getChildCount();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; count; ++i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历VieHolder</span><br><span class="line">           final ViewHolder holder &#x3D; getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">           if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 创建 ItemHolderInfo</span><br><span class="line">           final ItemHolderInfo animationInfo &#x3D; mItemAnimator</span><br><span class="line">                   .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                           ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                           holder.getUnmodifiedPayloads());</span><br><span class="line">           &#x2F;&#x2F; mViewInfoStore存储 holder及其对应animation信息</span><br><span class="line">           mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">           if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">               &#x2F;&#x2F; 如果holder确定要更新，就把它添加到 oldChangeHolders 集合中</span><br><span class="line">               mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">   if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">      ... &#x2F;&#x2F; 运行预布局</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 执行退出 layout或者scroll行为标志</span><br><span class="line">   onExitLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 对应 mEatRequestLayout -1</span><br><span class="line">   resumeRequestLayout(false);</span><br><span class="line">   &#x2F;&#x2F; 状态进入 State.STEP_LAYOUT</span><br><span class="line">   mState.mLayoutStep &#x3D; State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void processAdapterUpdatesAndSetAnimationFlags() &#123;</span><br><span class="line">   if (predictiveItemAnimationsEnabled()) &#123;</span><br><span class="line">       mAdapterHelper.preProcess(); &#x2F;&#x2F; 预处理</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">   &#125;</span><br><span class="line">   boolean animationTypeSupported &#x3D; mItemsAddedOrRemoved || mItemsChanged;</span><br><span class="line">   &#x2F;&#x2F; 计算 mRunSimpleAnimations 和 mRunPredictiveAnimations</span><br><span class="line">   &#x2F;&#x2F; mDataSetHasChangedAfterLayout 数据是否变化</span><br><span class="line">   mState.mRunSimpleAnimations &#x3D; mFirstLayoutComplete</span><br><span class="line">           &amp;&amp; mItemAnimator !&#x3D; null</span><br><span class="line">           &amp;&amp; (mDataSetHasChangedAfterLayout</span><br><span class="line">           || animationTypeSupported</span><br><span class="line">           || mLayout.mRequestedSimpleAnimations)</span><br><span class="line">           &amp;&amp; (!mDataSetHasChangedAfterLayout</span><br><span class="line">           || mAdapter.hasStableIds());</span><br><span class="line">   mState.mRunPredictiveAnimations &#x3D; mState.mRunSimpleAnimations</span><br><span class="line">           &amp;&amp; animationTypeSupported</span><br><span class="line">           &amp;&amp; !mDataSetHasChangedAfterLayout</span><br><span class="line">           &amp;&amp; predictiveItemAnimationsEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4><ul>
<li>执行最终的View布局操作，该过程由LayoutManager完成</li>
<li>该方法可能会被多次执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep2() &#123;</span><br><span class="line">   &#x2F;&#x2F; 过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1。对应resumeRequestLayout方法进行消费</span><br><span class="line">   eatRequestLayout();</span><br><span class="line">   &#x2F;&#x2F; 对应 onExitLayoutOrScroll</span><br><span class="line">   onEnterLayoutOrScroll();</span><br><span class="line">   mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">   &#x2F;&#x2F; 跳过预处理过程，一次性执行完所有的update</span><br><span class="line">   mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">   mState.mItemCount &#x3D; mAdapter.getItemCount(); &#x2F;&#x2F; 赋值 itemCOunt</span><br><span class="line">   mState.mDeletedInvisibleItemCountSincePreviousLayout &#x3D; 0; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   mState.mInPreLayout &#x3D; false;</span><br><span class="line">   &#x2F;&#x2F; 执行 layout （执行 LayoutManager 布局）</span><br><span class="line">   mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">   mState.mStructureChanged &#x3D; false;</span><br><span class="line">   mPendingSavedState &#x3D; null;</span><br><span class="line">   mState.mRunSimpleAnimations &#x3D; mState.mRunSimpleAnimations &amp;&amp; mItemAnimator !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; State状态进入 State.STEP_ANIMATIONS</span><br><span class="line">   mState.mLayoutStep &#x3D; State.STEP_ANIMATIONS;</span><br><span class="line">   &#x2F;&#x2F; 对应 onExitLayoutOrScroll</span><br><span class="line">   onExitLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 对应eatRequestLayout方法</span><br><span class="line">   resumeRequestLayout(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><p>layout过程最后一步，执行相关动画和一些清理事项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchLayoutStep3() &#123;</span><br><span class="line">   ...</span><br><span class="line">   if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">       &#x2F;&#x2F; 执行相关动画</span><br><span class="line">       ... </span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 一些清理动作   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h4><p>主要涉及Item装饰的绘制和动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas c) &#123;</span><br><span class="line">   super.draw(c);</span><br><span class="line"></span><br><span class="line">   final int count &#x3D; mItemDecorations.size();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">       mItemDecorations.get(i).onDrawOver(c, this, mState);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   boolean needsInvalidate &#x3D; false;</span><br><span class="line">   ...</span><br><span class="line">   if (!needsInvalidate &amp;&amp; mItemAnimator !&#x3D; null &amp;&amp; mItemDecorations.size() &gt; 0 &amp;&amp;</span><br><span class="line">           mItemAnimator.isRunning()) &#123;</span><br><span class="line">       needsInvalidate &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (needsInvalidate) &#123;</span><br><span class="line">       ViewCompat.postInvalidateOnAnimation(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void onDraw(Canvas c) &#123;</span><br><span class="line">   super.onDraw(c);</span><br><span class="line"></span><br><span class="line">   final int count &#x3D; mItemDecorations.size();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">       mItemDecorations.get(i).onDraw(c, this, mState);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinearLayoutManager-填充子View过程"><a href="#LinearLayoutManager-填充子View过程" class="headerlink" title="LinearLayoutManager 填充子View过程"></a>LinearLayoutManager 填充子View过程</h3><h4 id="LinearLayoutManager-onLayoutChildren"><a href="#LinearLayoutManager-onLayoutChildren" class="headerlink" title="LinearLayoutManager.onLayoutChildren"></a>LinearLayoutManager.onLayoutChildren</h4><ul>
<li>Child布局执行核心方法</li>
<li>布局方式，通过确定锚点，首先以锚点为基准上到下布局，在以锚点为基准从下往上布局。如果还有空间，继续从上到下布局。最后确认整个间隙是正确的。（反向布局及横向反之则可）</li>
<li>该方法为LayoutManager布局核心执行方法，Child的测量和添加工作在fill这个重要方法执行，接下来会阐述 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">    </span><br><span class="line">       &#x2F;&#x2F; 确定是否需要反向布局</span><br><span class="line">       &#x2F;&#x2F; 确定锚点及偏移量 (1. 优先焦点child 2. 如果是反向布局，则找recycler里面最最接近尾部的child 3. 如果是正向，则找最接近头部的child)</span><br><span class="line">       &#x2F;&#x2F; 计算额外的偏移量（RecyclerView padding） </span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 锚点准备ready        </span><br><span class="line">       onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">       &#x2F;&#x2F; 临时 detach和回收当前的view 第一次 measure 的时候不会产生效果，因为此时 RecyclerView 还没有子 View。 而在第二第三次 layout 时，它会把子 View 从 RecyclerView 中 remove 或 detach ，并缓存子 View，以便之后重新 add 回来或 attach 回来，避免重复加载相同的子 View</span><br><span class="line">       detachAndScrapAttachedViews(recycler); </span><br><span class="line">       mLayoutState.mInfinite &#x3D; resolveIsInfinite(); </span><br><span class="line">       mLayoutState.mIsPreLayout &#x3D; state.isPreLayout();</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 开始填充view</span><br><span class="line">       if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">          ... &#x2F;&#x2F; 反向填充</span><br><span class="line">       &#125; else &#123; &#x2F;&#x2F; 正向填充</span><br><span class="line">           &#x2F;&#x2F; （基于锚点位置先 由上到下||由左到右）更新锚点信息</span><br><span class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">           mLayoutState.mExtra &#x3D; extraForEnd; &#x2F;&#x2F; 额外的尾部偏移量</span><br><span class="line">           &#x2F;&#x2F; 开始填充 View布局主要方法</span><br><span class="line">           fill(recycler, mLayoutState, state, false);</span><br><span class="line">           &#x2F;&#x2F; 尾部位移</span><br><span class="line">           endOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           final int lastElement &#x3D; mLayoutState.mCurrentPosition;</span><br><span class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">               extraForStart +&#x3D; mLayoutState.mAvailable;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; （基于锚点位置 由下到上||由右到左）更新锚点信息</span><br><span class="line">           updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">           mLayoutState.mExtra &#x3D; extraForStart;</span><br><span class="line">           mLayoutState.mCurrentPosition +&#x3D; mLayoutState.mItemDirection;</span><br><span class="line">           &#x2F;&#x2F; 二次填充</span><br><span class="line">           fill(recycler, mLayoutState, state, false);</span><br><span class="line">           startOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           &#x2F;&#x2F; 仍有可用空间</span><br><span class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">               extraForEnd &#x3D; mLayoutState.mAvailable;</span><br><span class="line">               &#x2F;&#x2F; 继续 （基于锚点位置先 由上到下||由左到右）更新信息并填充View</span><br><span class="line">               updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">               mLayoutState.mExtra &#x3D; extraForEnd;</span><br><span class="line">               fill(recycler, mLayoutState, state, false);</span><br><span class="line">               endOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       &#x2F;&#x2F; 有滑动位置导致的gap间隙修复处理</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 预布局动画处理</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-fill"><a href="#LinearLayoutManager-fill" class="headerlink" title="LinearLayoutManager.fill"></a>LinearLayoutManager.fill</h4><ul>
<li>如果是滑动流程，则根据情况进行回收流程</li>
<li>LayoutState中部分成员变量含义，mOffset：填充起始坐标，mCurrentPosition：填充起始数据的position，mAvailable：本次滑动可填充的距离，mScrollingOffset：滑动过的总量循环依次加载子View</li>
<li>确定可布局大小，直至布局大小消费完成</li>
<li>加载子View在 layoutChunk 中执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</span><br><span class="line">            </span><br><span class="line">   &#x2F;&#x2F; 可布局的位移</span><br><span class="line">   final int start &#x3D; layoutState.mAvailable;</span><br><span class="line">   &#x2F;&#x2F; 滑动偏移的情况下</span><br><span class="line">   if (layoutState.mScrollingOffset !&#x3D; LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">       if (layoutState.mAvailable &lt; 0) &#123;</span><br><span class="line">           layoutState.mScrollingOffset +&#x3D; layoutState.mAvailable;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 执行回收流程</span><br><span class="line">       recycleByLayoutState(recycler, layoutState);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 余量大小</span><br><span class="line">   int remainingSpace &#x3D; layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">   &#x2F;&#x2F; 每次布局结果中间记录 方便运算  </span><br><span class="line">   LayoutChunkResult layoutChunkResult &#x3D; mLayoutChunkResult;</span><br><span class="line">   while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">       layoutChunkResult.resetInternal();</span><br><span class="line">       &#x2F;&#x2F; 加载子View</span><br><span class="line">       layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line"></span><br><span class="line">       if (layoutChunkResult.mFinished) &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       layoutState.mOffset +&#x3D; layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">       &#x2F;&#x2F; 计算布局使用过的大小值</span><br><span class="line">       if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList !&#x3D; null</span><br><span class="line">               || !state.isPreLayout()) &#123;</span><br><span class="line">           layoutState.mAvailable -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">           remainingSpace -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">       &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果当前正在滚动屏幕</span><br><span class="line">       if (layoutState.mScrollingOffset !&#x3D; LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">           layoutState.mScrollingOffset +&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">           if (layoutState.mAvailable &lt; 0) &#123;</span><br><span class="line">               layoutState.mScrollingOffset +&#x3D; layoutState.mAvailable;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 把移出屏幕的 View 缓存到 mCachedViews 里面</span><br><span class="line">           recycleByLayoutState(recycler, layoutState);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-layoutChunk"><a href="#LinearLayoutManager-layoutChunk" class="headerlink" title="LinearLayoutManager.layoutChunk"></a>LinearLayoutManager.layoutChunk</h4><ul>
<li>通过layoutState.next(recycler)获取目标布局View</li>
<li>获取目标View完毕后，进行含装饰的Margin计算，并执行布局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,</span><br><span class="line">            LayoutState layoutState, LayoutChunkResult result) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取下一个布局View （核心方法）</span><br><span class="line">        View view &#x3D; layoutState.next(recycler);</span><br><span class="line">        </span><br><span class="line">        LayoutParams params &#x3D; (LayoutParams) view.getLayoutParams();</span><br><span class="line">        if (layoutState.mScrapList &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 除非特殊指定，否则mScrapList为null</span><br><span class="line">            &#x2F;&#x2F; 执行 addView </span><br><span class="line">            if (mShouldReverseLayout &#x3D;&#x3D; (layoutState.mLayoutDirection</span><br><span class="line">                    &#x3D;&#x3D; LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 添加到末尾</span><br><span class="line">                addView(view); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addView(view, 0); &#x2F;&#x2F; 添加到第一个位置</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...      </span><br><span class="line">        &#125;</span><br><span class="line">        measureChildWithMargins(view, 0, 0); &#x2F;&#x2F; 测量子View的Margins</span><br><span class="line">        &#x2F;&#x2F; 计算 含装饰的Margin值的大小</span><br><span class="line">        result.mConsumed &#x3D; mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">        int left, top, right, bottom;</span><br><span class="line">        &#x2F;&#x2F; 计算 r、l、t、b的值</span><br><span class="line">        if (mOrientation &#x3D;&#x3D; VERTICAL) &#123;</span><br><span class="line">            if (isLayoutRTL()) &#123;</span><br><span class="line">                right &#x3D; getWidth() - getPaddingRight();</span><br><span class="line">                left &#x3D; right - mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left &#x3D; getPaddingLeft();</span><br><span class="line">                right &#x3D; left + mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">            &#125;</span><br><span class="line">            if (layoutState.mLayoutDirection &#x3D;&#x3D; LayoutState.LAYOUT_START) &#123;</span><br><span class="line">                bottom &#x3D; layoutState.mOffset;</span><br><span class="line">                top &#x3D; layoutState.mOffset - result.mConsumed;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                top &#x3D; layoutState.mOffset;</span><br><span class="line">                bottom &#x3D; layoutState.mOffset + result.mConsumed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 对View进行布局</span><br><span class="line">        layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">        &#x2F;&#x2F; 部分状态改变 </span><br><span class="line">        if (params.isItemRemoved() || params.isItemChanged()) &#123;</span><br><span class="line">            result.mIgnoreConsumed &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        result.mFocusable &#x3D; view.hasFocusable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-next"><a href="#LinearLayoutManager-next" class="headerlink" title="LinearLayoutManager.next"></a>LinearLayoutManager.next</h4><p>通过RecyclerView.Recycler获取对应Pos的View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">View next(RecyclerView.Recycler recycler) &#123;</span><br><span class="line">  if (mScrapList !&#x3D; null) &#123; &#x2F;&#x2F; 除非定制View，不然为null</span><br><span class="line">      return nextViewFromScrapList();</span><br><span class="line">  &#125;</span><br><span class="line">  通过RecyclerView.Recycler 获取目标position对应的View </span><br><span class="line">  final View view &#x3D; recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">  mCurrentPosition +&#x3D; mItemDirection; &#x2F;&#x2F; 当前pos 增加</span><br><span class="line">  return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Recycler获取VH的缓存和创建过程"><a href="#Recycler获取VH的缓存和创建过程" class="headerlink" title="Recycler获取VH的缓存和创建过程"></a>Recycler获取VH的缓存和创建过程</h3><h4 id="Recycler-getViewForPosition"><a href="#Recycler-getViewForPosition" class="headerlink" title="Recycler.getViewForPosition"></a>Recycler.getViewForPosition</h4><p>根据Pos获取View方法，最终执行tryGetViewHolderForPositionByDeadline获取View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public View getViewForPosition(int position) &#123;</span><br><span class="line">  return getViewForPosition(position, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">  return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Recycler-tryGetViewHolderForPositionByDeadline"><a href="#Recycler-tryGetViewHolderForPositionByDeadline" class="headerlink" title="Recycler.tryGetViewHolderForPositionByDeadline"></a>Recycler.tryGetViewHolderForPositionByDeadline</h4><ul>
<li>获取ViewHolder方法</li>
<li>如果是预布局，线通过ChangeScrap中获取</li>
<li>第一次尝试获取VH，依次从Scrap、Hidden、Cache中获取VH</li>
<li>第二次尝试获取VH，针对具有StableId的Adapter，根据id依次从Scrap和Cache获取</li>
<li>第三次尝试从自定义缓存中获取VH</li>
<li>第四次尝试从Recycler获取VH</li>
<li>最后直接创建VH</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">  </span><br><span class="line">  boolean fromScrapOrHiddenOrCache &#x3D; false;</span><br><span class="line">  ViewHolder holder &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 0) 如果是预布局， 从mChangedScrap中获取 </span><br><span class="line">  if (mState.isPreLayout()) &#123;</span><br><span class="line">      holder &#x3D; getChangedScrapViewForPosition(position);</span><br><span class="line">      fromScrapOrHiddenOrCache &#x3D; holder !&#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 1) 第一次尝试获取，依次从Scrap、Hidden、Cache中获取VH</span><br><span class="line">  if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 依次从Scrap、Hidden、Cache中获取VH</span><br><span class="line">      holder &#x3D; getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">      ... </span><br><span class="line">  &#125;</span><br><span class="line">  if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">      final int type &#x3D; mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">      &#x2F;&#x2F; 2) 第二次尝试获取，当Adapter具备StableIds情况</span><br><span class="line">      if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">          holder &#x3D; getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                  type, dryRun);</span><br><span class="line">          if (holder !&#x3D; null) &#123;</span><br><span class="line">              &#x2F;&#x2F; update position</span><br><span class="line">              holder.mPosition &#x3D; offsetPosition;</span><br><span class="line">              fromScrapOrHiddenOrCache &#x3D; true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 3) 第三次尝试从 自定义缓存获取</span><br><span class="line">      if (holder &#x3D;&#x3D; null &amp;&amp; mViewCacheExtension !&#x3D; null) &#123;</span><br><span class="line">                   final View view &#x3D; mViewCacheExtension</span><br><span class="line">                  .getViewForPositionAndType(this, position, type);</span><br><span class="line">          if (view !&#x3D; null) &#123;</span><br><span class="line">              holder &#x3D; getChildViewHolder(view);</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 4) 第四次尝试 从 RecyclerPool中获取</span><br><span class="line">      if (holder &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; fallback to pool</span><br><span class="line">          holder &#x3D; getRecycledViewPool().getRecycledView(type);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 5) 开始创建</span><br><span class="line">      if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">          long start &#x3D; getNanoTime();</span><br><span class="line">          &#x2F;&#x2F; 创建VH</span><br><span class="line">          holder &#x3D; mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">          ... </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">       boolean bound &#x3D; false;</span><br><span class="line">       if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">           holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">       &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 为bind过，执行bind方法</span><br><span class="line">           final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">           bound &#x3D; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        private boolean tryBindViewHolderByDeadline(ViewHolder holder, int offsetPosition,</span><br><span class="line">                int position, long deadlineNs) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 执行Adapter bindViewHolder方法</span><br><span class="line">            mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">            ...</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="00-从ChangeScrap获取"><a href="#00-从ChangeScrap获取" class="headerlink" title="00 从ChangeScrap获取"></a>00 从ChangeScrap获取</h4><p>针对的是预布局状态，从mChangedScrap中获取目标ViewHolder<br>ScrapView：View仍然attach在其父RecyclerView上且可以被重复绑定数据及重复使用。将View标记为Scrap过程中分为两大类mAttachedScrap 和 mChangedScrap。<br>mAttachedScrap：VH有ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID这两个Flag，或者VH是没有被更新过的，或者是可以被重新更新的VH。<br>其它则是mChangedScrap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder getChangedScrapViewForPosition(int position) &#123;</span><br><span class="line">  &#x2F;&#x2F; 必须是预布局状态，取mChangedScrap中的ViewHolder</span><br><span class="line">  final int changedScrapSize;</span><br><span class="line">  if (mChangedScrap &#x3D;&#x3D; null || (changedScrapSize &#x3D; mChangedScrap.size()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 通过position获取</span><br><span class="line">  for (int i &#x3D; 0; i &lt; changedScrapSize; i++) &#123;</span><br><span class="line">      final ViewHolder holder &#x3D; mChangedScrap.get(i);</span><br><span class="line">      if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position) &#123;</span><br><span class="line">          holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">          return holder;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果Adapter是固定id，尝试从Adapter获取</span><br><span class="line">  if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">      final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">      if (offsetPosition &gt; 0 &amp;&amp; offsetPosition &lt; mAdapter.getItemCount()) &#123;</span><br><span class="line">          final long id &#x3D; mAdapter.getItemId(offsetPosition);</span><br><span class="line">          for (int i &#x3D; 0; i &lt; changedScrapSize; i++) &#123;</span><br><span class="line">              final ViewHolder holder &#x3D; mChangedScrap.get(i);</span><br><span class="line">              if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getItemId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">                  holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">                  return holder;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mark an attached view as scrap.</span><br><span class="line">void scrapView(View view) &#123;</span><br><span class="line">       final ViewHolder holder &#x3D; getChildViewHolderInt(view);</span><br><span class="line">       if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">               || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">           holder.setScrapContainer(this, false);</span><br><span class="line">           mAttachedScrap.add(holder);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (mChangedScrap &#x3D;&#x3D; null) &#123;</span><br><span class="line">               mChangedScrap &#x3D; new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">           &#125;</span><br><span class="line">           holder.setScrapContainer(this, true);</span><br><span class="line">           mChangedScrap.add(holder);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="第一次尝试获取VH（AttachScrap、Hidden、CacheView）"><a href="#第一次尝试获取VH（AttachScrap、Hidden、CacheView）" class="headerlink" title="第一次尝试获取VH（AttachScrap、Hidden、CacheView）"></a>第一次尝试获取VH（AttachScrap、Hidden、CacheView）</h4><ul>
<li>先从 mAttachedScrap中获取VH</li>
<li>从隐藏且未移出的View中获取 View</li>
<li>从一级缓存CacheView中获取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">       final int scrapCount &#x3D; mAttachedScrap.size();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 先从 mAttachedScrap中获取VH</span><br><span class="line">       for (int i &#x3D; 0; i &lt; scrapCount; i++) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mAttachedScrap.get(i);</span><br><span class="line">           &#x2F;&#x2F; 验证VH是否可用，若可用，则直接返回该VH</span><br><span class="line">           if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position</span><br><span class="line">                   &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;</span><br><span class="line">               holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">               return holder;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; dryRun 传递是false（代表VH在scrap、cache中可以被Removed）</span><br><span class="line">       if (!dryRun) &#123;</span><br><span class="line">           &#x2F;&#x2F; 从隐藏且未移出的View中获取 View</span><br><span class="line">           View view &#x3D; mChildHelper.findHiddenNonRemovedView(position);</span><br><span class="line">           if (view !&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; View可用，则进行可视、detach、scrap缓存</span><br><span class="line">               final ViewHolder vh &#x3D; getChildViewHolderInt(view);</span><br><span class="line">               mChildHelper.unhide(view);</span><br><span class="line">               int layoutIndex &#x3D; mChildHelper.indexOfChild(view);</span><br><span class="line">               mChildHelper.detachViewFromParent(layoutIndex);</span><br><span class="line">               scrapView(view);</span><br><span class="line">               vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP</span><br><span class="line">                       | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">               return vh;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 从第一级缓存View中获取</span><br><span class="line">       final int cacheSize &#x3D; mCachedViews.size();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; cacheSize; i++) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mCachedViews.get(i);</span><br><span class="line">           &#x2F;&#x2F; VH是有效的</span><br><span class="line">           if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position) &#123;</span><br><span class="line">               if (!dryRun) &#123;</span><br><span class="line">                   mCachedViews.remove(i); &#x2F;&#x2F; 移出获取的cache</span><br><span class="line">               &#125;</span><br><span class="line">               return holder; &#x2F;&#x2F; 返回VH</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二次尝试获取VH（Adapter有稳定id情况）"><a href="#第二次尝试获取VH（Adapter有稳定id情况）" class="headerlink" title="第二次尝试获取VH（Adapter有稳定id情况）"></a>第二次尝试获取VH（Adapter有稳定id情况）</h4><ul>
<li>Adapter配置的id是稳定的，稳定指数据集变化的时候，对于同一数据对应的id是唯一的</li>
<li>先尝试从Scrap获取VH，非dryRun下，将未命中的从Scrap中移出，并加入到Cache或Pool缓存</li>
<li>在尝试从Cache获取VH，将未命中的从Cache中移出，并加入到Pool缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) &#123;</span><br><span class="line">       &#x2F;&#x2F; 从AttachedScrap中 尝试获取VH</span><br><span class="line">       final int count &#x3D; mAttachedScrap.size();</span><br><span class="line">       for (int i &#x3D; count - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mAttachedScrap.get(i);</span><br><span class="line">           &#x2F;&#x2F; id 相等 且 holder 非Scrap返回</span><br><span class="line">           if (holder.getItemId() &#x3D;&#x3D; id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">               if (type &#x3D;&#x3D; holder.getItemViewType()) &#123;</span><br><span class="line">                   holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">                   if (holder.isRemoved()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 从事</span><br><span class="line">                       if (!mState.isPreLayout()) &#123;</span><br><span class="line">                           holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE</span><br><span class="line">                                   | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return holder;</span><br><span class="line">               &#125; else if (!dryRun) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 从AttachedScrap移除</span><br><span class="line">                   mAttachedScrap.remove(i);</span><br><span class="line">                   removeDetachedView(holder.itemView, false);</span><br><span class="line">                   &#x2F;&#x2F; 回收加入至 cache 或者 pool</span><br><span class="line">                   quickRecycleScrapView(holder.itemView);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 从CacheView中尝试获取</span><br><span class="line">       final int cacheSize &#x3D; mCachedViews.size();</span><br><span class="line">       for (int i &#x3D; cacheSize - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mCachedViews.get(i);</span><br><span class="line">           if (holder.getItemId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">               if (type &#x3D;&#x3D; holder.getItemViewType()) &#123;</span><br><span class="line">                   if (!dryRun) &#123;</span><br><span class="line">                       mCachedViews.remove(i); &#x2F;&#x2F; 从Cache中移出</span><br><span class="line">                   &#125;</span><br><span class="line">                   return holder;</span><br><span class="line">               &#125; else if (!dryRun) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 从Cache中移出，放到pool中</span><br><span class="line">                   recycleCachedViewAt(i);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecyclerView滑动机制分析"><a href="#RecyclerView滑动机制分析" class="headerlink" title="RecyclerView滑动机制分析"></a>RecyclerView滑动机制分析</h3><p>根据View事件机制可以直接来看onTouchEvent方法。<br>重点查看move事件。move事件执行了scrollByInternal方法。该方法最后会执行LayoutManager的Scroll方法，以LinearLayoutManager为例，它的ScrollBy方法最终执行到fill方法。也就是上文提到的ItemView填充方法，滑动过程中会不断执行获取对应位置的ViewHolder，然后进行View的展示。从而实现RecyclerView的滑动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent e) &#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   switch (action) &#123;</span><br><span class="line">       case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">          ...</span><br><span class="line">       case MotionEventCompat.ACTION_POINTER_DOWN: </span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_MOVE: &#123; &#x2F;&#x2F; 触摸时间-move</span><br><span class="line">           ...</span><br><span class="line">           if (mScrollState &#x3D;&#x3D; SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">               mLastTouchX &#x3D; x - mScrollOffset[0];</span><br><span class="line">               mLastTouchY &#x3D; y - mScrollOffset[1];</span><br><span class="line">                &#x2F;&#x2F; 执行内部滑动方法</span><br><span class="line">               if (scrollByInternal(</span><br><span class="line">                       canScrollHorizontally ? dx : 0,</span><br><span class="line">                       canScrollVertically ? dy : 0,</span><br><span class="line">                       vtev)) &#123;</span><br><span class="line">                   getParent().requestDisallowInterceptTouchEvent(true);</span><br><span class="line">               &#125;</span><br><span class="line">               ...           &#125;</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEventCompat.ACTION_POINTER_UP: &#123;</span><br><span class="line">           onPointerUp(e);</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_UP: &#123; &#x2F;&#x2F; 触摸事件-up</span><br><span class="line">           &#x2F;&#x2F; 执行 fling方法 ，主要做一些item和scroller动画等操作</span><br><span class="line">           if (!((xvel !&#x3D; 0 || yvel !&#x3D; 0) &amp;&amp; fling((int) xvel, (int) yvel))) &#123;</span><br><span class="line">               setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">           &#125;</span><br><span class="line">           resetTouch();</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">           cancelTouch();</span><br><span class="line">       &#125; break;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scrollByInternal"><a href="#scrollByInternal" class="headerlink" title="scrollByInternal"></a>scrollByInternal</h4><ul>
<li>内部Scroll执行方法，此处会执行LayoutManager的Scroll方法</li>
<li>其它处罚Nested、OnScroll等事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean scrollByInternal(int x, int y, MotionEvent ev) &#123;</span><br><span class="line">   int unconsumedX &#x3D; 0, unconsumedY &#x3D; 0;</span><br><span class="line">   int consumedX &#x3D; 0, consumedY &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   consumePendingUpdateOperations();</span><br><span class="line">   if (mAdapter !&#x3D; null) &#123;</span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">       if (x !&#x3D; 0) &#123;</span><br><span class="line">           consumedX &#x3D; mLayout.scrollHorizontallyBy(x, mRecycler, mState);</span><br><span class="line">           unconsumedX &#x3D; x - consumedX;</span><br><span class="line">       &#125;</span><br><span class="line">       if (y !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; LinearLayout 竖向布局为例，走LayoutManager滑动放啊放</span><br><span class="line">           consumedY &#x3D; mLayout.scrollVerticallyBy(y, mRecycler, mState);</span><br><span class="line">           unconsumedY &#x3D; y - consumedY;</span><br><span class="line">       &#125;</span><br><span class="line">       TraceCompat.endSection();</span><br><span class="line">       repositionShadowingViews();</span><br><span class="line">       onExitLayoutOrScroll();</span><br><span class="line">       resumeRequestLayout(false);</span><br><span class="line">   &#125;</span><br><span class="line">   if (!mItemDecorations.isEmpty()) &#123;</span><br><span class="line">       invalidate();</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 分发 NestedScroll事件</span><br><span class="line">   if (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">   if (consumedX !&#x3D; 0 || consumedY !&#x3D; 0) &#123;</span><br><span class="line">       dispatchOnScrolled(consumedX, consumedY); &#x2F;&#x2F; 分发onScrolled事件</span><br><span class="line">   &#125;</span><br><span class="line">   if (!awakenScrollBars()) &#123;</span><br><span class="line">       invalidate();</span><br><span class="line">   &#125;</span><br><span class="line">   return consumedX !&#x3D; 0 || consumedY !&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager执行滑动处理"><a href="#LinearLayoutManager执行滑动处理" class="headerlink" title="LinearLayoutManager执行滑动处理"></a>LinearLayoutManager执行滑动处理</h4><ul>
<li>执行scrollBy方法</li>
<li>scrollBy方法最终走到 fill方法（上面提到的填充子View方法）</li>
<li>该方法则会进行 ItemView的填充。从而完成Recycler滑动时，View的重新创建或者重新绑定一系列过程</li>
<li>平移整个View的child，实现滑动效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,</span><br><span class="line">       RecyclerView.State state) &#123;</span><br><span class="line">   if (mOrientation &#x3D;&#x3D; HORIZONTAL) &#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   return scrollBy(dy, recycler, state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">   ...</span><br><span class="line">   mLayoutState.mRecycle &#x3D; true;</span><br><span class="line">   ensureLayoutState();</span><br><span class="line">   final int layoutDirection &#x3D; dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">   final int absDy &#x3D; Math.abs(dy);</span><br><span class="line">   &#x2F;&#x2F; 更新LayoutState，布局方向和偏移值。目的是让LayoutManager知道从开始还是末尾进行回收和填充</span><br><span class="line">   updateLayoutState(layoutDirection, absDy, true, state);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 执行 LinearLayout的fill 方法</span><br><span class="line">   final int consumed &#x3D; mLayoutState.mScrollingOffset</span><br><span class="line">           + fill(recycler, mLayoutState, state, false);</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 平移整个view的child</span><br><span class="line">   mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">   </span><br><span class="line">   return scrolled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 执行回收流程</span><br><span class="line">    recycleByLayoutState(recycler, layoutState);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 执行填充流程（参考上面layoutChunk方法）</span><br><span class="line">    layoutChunk(recycler, state, layoutState,layoutChunkResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager回收流程"><a href="#LinearLayoutManager回收流程" class="headerlink" title="LinearLayoutManager回收流程"></a>LinearLayoutManager回收流程</h4><ul>
<li>根据不同的布局方向进行不同方向的回收。以Start为例介绍</li>
<li>计算位移limit值，根据limit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123;</span><br><span class="line">   &#x2F;&#x2F; 假设是 初始方向布局，则开始末尾View回收。反之亦然</span><br><span class="line">   if (layoutState.mLayoutDirection &#x3D;&#x3D; LayoutState.LAYOUT_START) &#123;</span><br><span class="line">       recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) &#123;</span><br><span class="line">   final int limit &#x3D; dt;</span><br><span class="line">   final int childCount &#x3D; getChildCount();</span><br><span class="line">   if (mShouldReverseLayout) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; childCount; i++) &#123;</span><br><span class="line">           View child &#x3D; getChildAt(i);</span><br><span class="line">           &#x2F;&#x2F; 遍历child，当超过限制大小时候，开始回收</span><br><span class="line">           if (mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">                   || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">               recycleChildren(recycler, 0, i); &#x2F;&#x2F; 执行Children回收流程</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) &#123;</span><br><span class="line">   if (endIndex &gt; startIndex) &#123;</span><br><span class="line">       for (int i &#x3D; endIndex - 1; i &gt;&#x3D; startIndex; i--) &#123;</span><br><span class="line">           removeAndRecycleViewAt(i, recycler); &#x2F;&#x2F; 执行RecyclerView的移出和回收方法</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (int i &#x3D; startIndex; i &gt; endIndex; i--) &#123;</span><br><span class="line">           removeAndRecycleViewAt(i, recycler);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RecyclerView-removeAndRecycleViewAt"><a href="#RecyclerView-removeAndRecycleViewAt" class="headerlink" title="RecyclerView.removeAndRecycleViewAt"></a>RecyclerView.removeAndRecycleViewAt</h4><ul>
<li>移出和回收View方法</li>
<li>执行ChildHelper的移出View方法。内部Bucket移出和回掉CallBack进行View移出</li>
<li>执行Recycler回收方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void removeAndRecycleViewAt(int index, Recycler recycler) &#123;</span><br><span class="line">  final View view &#x3D; getChildAt(index); &#x2F;&#x2F; 获取目标View</span><br><span class="line">  removeViewAt(index); &#x2F;&#x2F; 执行ChildHelper移出</span><br><span class="line">  recycler.recycleView(view); &#x2F;&#x2F; 回收View</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeViewAt(int index) &#123;</span><br><span class="line">  final View child &#x3D; getChildAt(index); </span><br><span class="line">  if (child !&#x3D; null) &#123;</span><br><span class="line">      mChildHelper.removeViewAt(index); &#x2F;&#x2F; 执行ChildHelper移出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void recycleView(View view) &#123;</span><br><span class="line">  ViewHolder holder &#x3D; getChildViewHolderInt(view); &#x2F;&#x2F; 获取VH</span><br><span class="line">  &#x2F;&#x2F; ViewHolder 回收前，需要完全detach、且不是Scrap</span><br><span class="line">  if (holder.isTmpDetached()) &#123;</span><br><span class="line">      removeDetachedView(view, false); </span><br><span class="line">  &#125;</span><br><span class="line">  if (holder.isScrap()) &#123;</span><br><span class="line">      holder.unScrap();</span><br><span class="line">  &#125; else if (holder.wasReturnedFromScrap())&#123;</span><br><span class="line">      holder.clearReturnedFromScrapFlag();</span><br><span class="line">  &#125;</span><br><span class="line">  recycleViewHolderInternal(holder); &#x2F;&#x2F; 执行回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="RecyclerView-recycleViewHolderInternal"><a href="#RecyclerView-recycleViewHolderInternal" class="headerlink" title="RecyclerView.recycleViewHolderInternal"></a>RecyclerView.recycleViewHolderInternal</h4><ul>
<li>内部缓存VH方法</li>
<li>如果CacheView满了，则移出一个Cache到Pool中</li>
<li>将目标VH缓存到Cache末尾</li>
<li>如果没有Cache成功，则直接缓存到Pool中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> void recycleViewHolderInternal(ViewHolder holder) &#123;  </span><br><span class="line">      if (mViewCacheMax &gt; 0</span><br><span class="line">              &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">              | ViewHolder.FLAG_REMOVED</span><br><span class="line">              | ViewHolder.FLAG_UPDATE</span><br><span class="line">              | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</span><br><span class="line">          &#x2F;&#x2F; Cache缓存个数超了，则直接回收CacheView到RecyclerPool</span><br><span class="line">          int cachedViewSize &#x3D; mCachedViews.size();</span><br><span class="line">          if (cachedViewSize &gt;&#x3D; mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</span><br><span class="line">              recycleCachedViewAt(0);</span><br><span class="line">              cachedViewSize--;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          int targetCacheIndex &#x3D; cachedViewSize;</span><br><span class="line">          &#x2F;&#x2F; 将VH缓存到CacheView中</span><br><span class="line">          mCachedViews.add(targetCacheIndex, holder);</span><br><span class="line">          cached &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果未CacheView缓存，则直接缓存RecyclerViewPool中</span><br><span class="line">      if (!cached) &#123;</span><br><span class="line">          addViewHolderToRecycledViewPool(holder, true);</span><br><span class="line">          recycled &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="局部刷新"><a href="#局部刷新" class="headerlink" title="局部刷新"></a>局部刷新</h3><h4 id="Adapter数据操作对外API"><a href="#Adapter数据操作对外API" class="headerlink" title="Adapter数据操作对外API"></a>Adapter数据操作对外API</h4><p>RecyclerView.Adapter提供局部数据变化通知方法，然后执行到RecyclerViewDataObserver对应的各种数据操作方法上。</p>
<h4 id="RecyclerViewDataObserver"><a href="#RecyclerViewDataObserver" class="headerlink" title="RecyclerViewDataObserver"></a>RecyclerViewDataObserver</h4><ul>
<li>通过mAdapterHelper进行数据变化处理操作</li>
<li>然后触发更新处理</li>
<li>下面介绍下 ItemChanged操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void onItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onItemRangeInserted(int positionStart, int itemCount) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onItemRangeRemoved(int positionStart, int itemCount) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AdapterHelper-onItemRangeChanged"><a href="#AdapterHelper-onItemRangeChanged" class="headerlink" title="AdapterHelper.onItemRangeChanged"></a>AdapterHelper.onItemRangeChanged</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean onItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加一个更新操作 ，标志为update、记录pos、item相关信息</span><br><span class="line">   mPendingUpdates.add(obtainUpdateOp(UpdateOp.UPDATE, positionStart, itemCount, payload));</span><br><span class="line">   mExistingUpdateTypes |&#x3D; UpdateOp.UPDATE;</span><br><span class="line">   &#x2F;&#x2F; 如果只有一个待处理操作则为true，true则执行后续更新处理。如果是多个，则会忽略，因为在第一次出发后，就会集中处理</span><br><span class="line">   return mPendingUpdates.size() &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RecyclerViewDataObserver-triggerUpdateProcessor"><a href="#RecyclerViewDataObserver-triggerUpdateProcessor" class="headerlink" title="RecyclerViewDataObserver.triggerUpdateProcessor"></a>RecyclerViewDataObserver.triggerUpdateProcessor</h4><ol>
<li>当RecyclerView有固定大小，且已经Attached了。则走Runnable更新</li>
<li>否则直接走requestLayout方式更新，即重新走绘制流程 onMeasure、onLayout等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void triggerUpdateProcessor() &#123;</span><br><span class="line">  if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">      &#x2F;&#x2F; RecyclerView有固定大小的时候 会执行mUpdateChildViewsRunnable 来处理更新</span><br><span class="line">      ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 直接走 requestLayout方式来处理</span><br><span class="line">      mAdapterUpdateDuringMeasure &#x3D; true;</span><br><span class="line">      requestLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="triggerUpdateProcessor下requestLayout"><a href="#triggerUpdateProcessor下requestLayout" class="headerlink" title="triggerUpdateProcessor下requestLayout"></a>triggerUpdateProcessor下requestLayout</h4><p>requestLayout下 onMeasure -&gt; dispatchLayout -&gt; dispatchLayoutStep2 -&gt; layoutChildren -&gt; fill -&gt; layoutChunk -&gt; next -&gt; tryGetViewHolderForPositionByDeadline<br>最终对Item进行重新绑定 实现局部刷新逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">                </span><br><span class="line">           if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">                holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">            &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行数据变化的Holder的重新bind，从而实现局部刷新              </span><br><span class="line">                final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                bound &#x3D; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="triggerUpdateProcessor下mUpdateChildViewsRunnable"><a href="#triggerUpdateProcessor下mUpdateChildViewsRunnable" class="headerlink" title="triggerUpdateProcessor下mUpdateChildViewsRunnable"></a>triggerUpdateProcessor下mUpdateChildViewsRunnable</h4><p>当RecyclerView有固定大小时，则不需要Measure，直接走dispatchLayout方法进行刷新操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final Runnable mUpdateChildViewsRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 消费 等待执行的操作 </span><br><span class="line">        consumePendingUpdateOperations();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumePendingUpdateOperations() &#123;</span><br><span class="line">        </span><br><span class="line">      if (mAdapterHelper.hasAnyUpdateTypes(AdapterHelper.UpdateOp.UPDATE) &amp;&amp; !mAdapterHelper</span><br><span class="line">           .hasAnyUpdateTypes(AdapterHelper.UpdateOp.ADD | AdapterHelper.UpdateOp.REMOVE</span><br><span class="line">                   | AdapterHelper.UpdateOp.MOVE)) &#123;</span><br><span class="line">        &#x2F;&#x2F; update 情况下 逻辑</span><br><span class="line">       </span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       &#x2F;&#x2F; 数据预处理 </span><br><span class="line">       mAdapterHelper.preProcess();</span><br><span class="line">       if (!mLayoutRequestEaten) &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行 dispatchLayout 进行局部刷新处理</span><br><span class="line">           if (hasUpdatedView()) &#123;</span><br><span class="line">               dispatchLayout();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; no need to layout, clean state</span><br><span class="line">               mAdapterHelper.consumePostponedUpdates();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125; else if (mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">       &#x2F;&#x2F; add、remove等操作，直接执行dispatchLayout</span><br><span class="line">       dispatchLayout();</span><br><span class="line">       TraceCompat.endSection();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/30/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%887%EF%BC%89%E2%80%94%20%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/30/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%887%EF%BC%89%E2%80%94%20%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">OkHttp 4源码（7）— 总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 10:14:38" itemprop="dateCreated datePublished" datetime="2020-01-30T10:14:38+08:00">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:58:54" itemprop="dateModified" datetime="2020-02-07T00:58:54+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于OkHttp 4.3.1源码分析 Okio 2.4.3源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a><br><a href="https://square.github.io/okio/" target="_blank" rel="noopener">Okio - 官方地址</a><br><a href="https://github.com/square/okio" target="_blank" rel="noopener">Okio - GitHub代码地址</a></p>
</blockquote>
<h2 id="OkHttp-介绍"><a href="#OkHttp-介绍" class="headerlink" title="OkHttp 介绍"></a>OkHttp 介绍</h2><h3 id="OkHttp-是什么"><a href="#OkHttp-是什么" class="headerlink" title="OkHttp 是什么"></a>OkHttp 是什么</h3><p>超文本传输协议（HTTP）是一个用于传输超媒体或者数据的应用层协议。高效应用HTTP可以获得更快的传输速度以及更节省的流量<br>OkHttp来源Square公司，它是针对HTTP进行高效封装的一套网络库</p>
<h3 id="Okio-优点"><a href="#Okio-优点" class="headerlink" title="Okio 优点"></a>Okio 优点</h3><h4 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h4><ul>
<li>支持HTTP/2</li>
<li>连接池技术，避免频繁的请求连接和断开 （非HTTP2情况下）</li>
<li>支持GZIP压缩</li>
<li>缓存支持，避免重复请求</li>
</ul>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ul>
<li>连接重试，支持多IP重试，支持IPV4和IPV6隧道连接</li>
<li>支持TLS特性</li>
<li>请求和响应Api简洁明了，支持同步和异步请求</li>
</ul>
<h2 id="OkHttp-图文总结"><a href="#OkHttp-图文总结" class="headerlink" title="OkHttp 图文总结"></a>OkHttp 图文总结</h2><p><a href="https://www.jianshu.com/p/ff836d3cacd1" target="_blank" rel="noopener">OkHttp 4源码（1）— OkHttp初始化和请求构造分析</a><br><a href="https://www.jianshu.com/p/0c830962c6e3" target="_blank" rel="noopener">OkHttp 4源码（2）— 拦截器机制分析</a><br><a href="https://www.jianshu.com/p/2eafcd161dd9" target="_blank" rel="noopener">OkHttp 4源码（3）— 缓存机制分析</a><br><a href="https://www.jianshu.com/p/be6d09f2656b" target="_blank" rel="noopener">OkHttp 4源码（4）— 连接机制分析</a><br><a href="https://www.jianshu.com/p/097b1904f580" target="_blank" rel="noopener">OkHttp 4源码（5）— 请求和响应 I/O操作</a><br><a href="https://www.jianshu.com/p/7b7ba4333c5e" target="_blank" rel="noopener">OkHttp 4源码（6）— Okio源码解析</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-87cf14865f96650a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OkHttp整体流程"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-d901334cea97e334.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求创建和分发流程"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-037f59b6d4bbf080.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拦截器时序图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-e9f7b43d56529039.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP缓存流程图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-9a68e72386c130ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存处理流程图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-c629851ea8fb73d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连接时序图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-d16e8389d436637b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP不同协议连接区分"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-4f71931e4b7a5416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO操作流程图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-70458cdb60301a91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Okio类图"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-a8366af16cf02cb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Okio Buffer相关数据结构"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/19/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%886%EF%BC%89%E2%80%94Okio%E5%88%86%E6%9E%90./">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/19/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%886%EF%BC%89%E2%80%94Okio%E5%88%86%E6%9E%90./" class="post-title-link" itemprop="url">OkHttp 4源码（6）—Okio分析.</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-19 10:19:50" itemprop="dateCreated datePublished" datetime="2020-01-19T10:19:50+08:00">2020-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:59:04" itemprop="dateModified" datetime="2020-02-07T00:59:04+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于Okio 2.4.3源码分析<br><a href="https://square.github.io/okio/" target="_blank" rel="noopener">Okio - 官方地址</a><br><a href="https://github.com/square/okio" target="_blank" rel="noopener">Okio - GitHub代码地址</a></p>
</blockquote>
<h2 id="Okio-介绍"><a href="#Okio-介绍" class="headerlink" title="Okio 介绍"></a>Okio 介绍</h2><h3 id="Okio是什么"><a href="#Okio是什么" class="headerlink" title="Okio是什么"></a>Okio是什么</h3><p>Okio来源Square公司，它是对java.io和java.nio的进一步封装实现，使得更容易处理、访问、缓存数据。它最初是作为OkHttp网络库的组件</p>
<h3 id="Okio-特点"><a href="#Okio-特点" class="headerlink" title="Okio 特点"></a>Okio 特点</h3><h4 id="Buffer-and-ByteString"><a href="#Buffer-and-ByteString" class="headerlink" title="Buffer and ByteString"></a>Buffer and ByteString</h4><p>目标：更好的CPU和Memory综合表现</p>
<ul>
<li>Buffer：通过双向链表的Segment缓存结构，当从一个Buffer转移数据到另一个Buffer的时候，提供重新分配拥有权达到无需拷贝，相比一次深拷贝，效率大大增加。</li>
<li>ByteString：Encode UTF-8 String到byteString过程会缓存原string，Decode过程中则可以直接使用</li>
</ul>
<h4 id="Source-and-Sink"><a href="#Source-and-Sink" class="headerlink" title="Source and Sink"></a>Source and Sink</h4><ul>
<li>支持超时机制</li>
<li>非常轻便，便于实现、使用、测试</li>
</ul>
<h3 id="Okio-图文概括"><a href="#Okio-图文概括" class="headerlink" title="Okio 图文概括"></a>Okio 图文概括</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-70458cdb60301a91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-a8366af16cf02cb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="测试代码示例"><a href="#测试代码示例" class="headerlink" title="测试代码示例"></a>测试代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class OkioTest &#123;</span><br><span class="line">  @Rule public TemporaryFolder temporaryFolder &#x3D; new TemporaryFolder();</span><br><span class="line"></span><br><span class="line">  @Test public void readWriteFile() throws Exception &#123;</span><br><span class="line">    File file &#x3D; temporaryFolder.newFile();</span><br><span class="line">    &#x2F;&#x2F; 写</span><br><span class="line">    BufferedSink sink &#x3D; Okio.buffer(Okio.sink(file));</span><br><span class="line">    sink.writeUtf8(&quot;Hello, java.io file!&quot;);</span><br><span class="line">    sink.close();</span><br><span class="line">    assertTrue(file.exists());</span><br><span class="line">    assertEquals(20, file.length());</span><br><span class="line">    &#x2F;&#x2F; 读</span><br><span class="line">    BufferedSource source &#x3D; Okio.buffer(Okio.source(file));</span><br><span class="line">    assertEquals(&quot;Hello, java.io file!&quot;, source.readUtf8());</span><br><span class="line">    source.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据写入-Sink"><a href="#数据写入-Sink" class="headerlink" title="数据写入 Sink"></a>数据写入 Sink</h3><ul>
<li>实现类：OutputStreamSink</li>
<li>实现原理：依旧是借助OutputStream进行写入操作</li>
<li>写入流程<ol>
<li>超时判断</li>
<li>根据入参的所需写入数据大小，循环写入数据</li>
<li>取Buffer中第一个Segment，计算可读取的数据，写入到目标输出流中</li>
<li>每次循环写入的数据大小=min（剩余要写入数据大小，此次循环取到的Segment中的可读取数据大小），直至完成目标数据大小的写入</li>
<li>每次写入完毕，对Segment进行移除和回收</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个Sink</span><br><span class="line">fun File.sink(append: Boolean &#x3D; false): Sink &#x3D; FileOutputStream(this, append).sink()</span><br><span class="line"></span><br><span class="line">fun OutputStream.sink(): Sink &#x3D; OutputStreamSink(this, Timeout())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sink实现类</span><br><span class="line">private class OutputStreamSink(</span><br><span class="line">  private val out: OutputStream, &#x2F;&#x2F; java底层输出流</span><br><span class="line">  private val timeout: Timeout &#x2F;&#x2F; 超时机制</span><br><span class="line">) : Sink &#123;</span><br><span class="line">  &#x2F;&#x2F;  buffer写入到输出流</span><br><span class="line">  override fun write(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">    checkOffsetAndCount(source.size, 0, byteCount)</span><br><span class="line">    var remaining &#x3D; byteCount</span><br><span class="line">    &#x2F;&#x2F; 循环读取 所需读取数据大小</span><br><span class="line">    while (remaining &gt; 0) &#123;</span><br><span class="line">      timeout.throwIfReached() &#x2F;&#x2F; 是否超时</span><br><span class="line">      &#x2F;&#x2F; Buffer的缓存数据是由 Segment双向链表数据结构缓存</span><br><span class="line">      &#x2F;&#x2F; 取Buffer的第一个Segment（缓存片段）</span><br><span class="line">      val head &#x3D; source.head!!</span><br><span class="line">      &#x2F;&#x2F; segment中limit-pos即数据大小，这里取两者最小的那个数据大小</span><br><span class="line">      val toCopy &#x3D; minOf(remaining, head.limit - head.pos).toInt()</span><br><span class="line">      &#x2F;&#x2F; 将目标读取数据 写入到 OutputStream中</span><br><span class="line">      out.write(head.data, head.pos, toCopy)</span><br><span class="line">      &#x2F;&#x2F; segment 读指针迁移 写入数据大小</span><br><span class="line">      head.pos +&#x3D; toCopy</span><br><span class="line">      &#x2F;&#x2F; 读取数据大小减少 写入数据大小</span><br><span class="line">      remaining -&#x3D; toCopy</span><br><span class="line">      &#x2F;&#x2F; source即buffer中数据大小减少 写入数据大小</span><br><span class="line">      source.size -&#x3D; toCopy</span><br><span class="line">      &#x2F;&#x2F; 如果读数据指针等于写数据指针，证明segment无有效数据，则脸表移除该Segment，并执行Segment回收方法</span><br><span class="line">      if (head.pos &#x3D;&#x3D; head.limit) &#123;</span><br><span class="line">        source.head &#x3D; head.pop()</span><br><span class="line">        SegmentPool.recycle(head)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; flush 执行OutputStream的flush方法</span><br><span class="line">  override fun flush() &#x3D; out.flush()</span><br><span class="line">  &#x2F;&#x2F; close 执行OutputStream的close方法</span><br><span class="line">  override fun close() &#x3D; out.close()</span><br><span class="line">  &#x2F;&#x2F; 超时机制</span><br><span class="line">  override fun timeout() &#x3D; timeout</span><br><span class="line"></span><br><span class="line">  override fun toString() &#x3D; &quot;sink($out)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据读取-Source"><a href="#数据读取-Source" class="headerlink" title="数据读取 Source"></a>数据读取 Source</h3><ul>
<li>实现类：InputStreamSource</li>
<li>实现原理：依旧是借助InputStream进行写入操作</li>
<li>读取流程<ol>
<li>超时判断，目标读取数据大小合法判断</li>
<li>获取Buffer的尾部Segment，并计算该Segment可写入的数据最大值 ，与目标读取数据大小值进行比较，取其中小的一个</li>
<li>读取数据到Buffer中</li>
<li>返回读取数据大小</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回File的一个Source</span><br><span class="line">fun File.source(): Source &#x3D; inputStream().source()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建InputStreamSource作为Source返回</span><br><span class="line">fun InputStream.source(): Source &#x3D; InputStreamSource(this, Timeout())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; InputStreamSource实现类</span><br><span class="line">private class InputStreamSource(</span><br><span class="line">  private val input: InputStream,</span><br><span class="line">  private val timeout: Timeout</span><br><span class="line">) : Source &#123;</span><br><span class="line">  &#x2F;&#x2F; 核心read方法实现</span><br><span class="line">  override fun read(sink: Buffer, byteCount: Long): Long &#123;</span><br><span class="line">    if (byteCount &#x3D;&#x3D; 0L) return 0</span><br><span class="line">    require(byteCount &gt;&#x3D; 0) &#123; &quot;byteCount &lt; 0: $byteCount&quot; &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 是否超时</span><br><span class="line">      timeout.throwIfReached()</span><br><span class="line">      &#x2F;&#x2F; 获取一个可写入数据的 Segment</span><br><span class="line">      val tail &#x3D; sink.writableSegment(1)</span><br><span class="line">      &#x2F;&#x2F; 最大可写入到Buffer中的大小（一个Segment数据最大大小 减去 该Segment已经写入的数据大小）</span><br><span class="line">      val maxToCopy &#x3D; minOf(byteCount, Segment.SIZE - tail.limit).toInt()</span><br><span class="line">      &#x2F;&#x2F; 从目标读取流中 ，读取制定大小数据到Segment中</span><br><span class="line">      val bytesRead &#x3D; input.read(tail.data, tail.limit, maxToCopy)</span><br><span class="line">      &#x2F;&#x2F; 读取大小-1异常情况处理</span><br><span class="line">      if (bytesRead &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        if (tail.pos &#x3D;&#x3D; tail.limit) &#123;</span><br><span class="line">          &#x2F;&#x2F; 没有数据，移除Segment并回收</span><br><span class="line">          sink.head &#x3D; tail.pop()</span><br><span class="line">          SegmentPool.recycle(tail)</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Segment的limit增加读取的数据大小</span><br><span class="line">      tail.limit +&#x3D; bytesRead</span><br><span class="line">      &#x2F;&#x2F; buffer数据大小增加 读取的数据大小</span><br><span class="line">      sink.size +&#x3D; bytesRead</span><br><span class="line">      &#x2F;&#x2F; 返回本次读取数据的大小</span><br><span class="line">      return bytesRead.toLong() </span><br><span class="line">    &#125; catch (e: AssertionError) &#123;</span><br><span class="line">      if (e.isAndroidGetsocknameError) throw IOException(e)</span><br><span class="line">      throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun close() &#x3D; input.close()</span><br><span class="line"></span><br><span class="line">  override fun timeout() &#x3D; timeout</span><br><span class="line"></span><br><span class="line">  override fun toString() &#x3D; &quot;source($input)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据缓存-Buffer"><a href="#数据缓存-Buffer" class="headerlink" title="数据缓存 Buffer"></a>数据缓存 Buffer</h3><h4 id="写入缓存"><a href="#写入缓存" class="headerlink" title="写入缓存"></a>写入缓存</h4><h5 id="BufferedSink-接口"><a href="#BufferedSink-接口" class="headerlink" title="BufferedSink 接口"></a>BufferedSink 接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">actual interface BufferedSink : Sink, WritableByteChannel &#123;</span><br><span class="line">  &#x2F;&#x2F; Buffer</span><br><span class="line">  actual val buffer: Buffer</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 write方法</span><br><span class="line">  actual fun writeXXX(...): BufferedSink</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将Buffer中数据写入到Sink中</span><br><span class="line">  actual fun emitCompleteSegments(): BufferedSink</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RealBufferedSink-实现类"><a href="#RealBufferedSink-实现类" class="headerlink" title="RealBufferedSink 实现类"></a>RealBufferedSink 实现类</h5><ul>
<li>BufferedSink实现类，含有两个重要成员Sink和Buffer</li>
<li>接口方法基本上都经过 internal/RealBufferedSink一层封装，方法实现皆借助Buffer进行写入操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">internal actual class RealBufferedSink actual constructor(</span><br><span class="line">  @JvmField actual val sink: Sink &#x2F;&#x2F; 目标写入Sink</span><br><span class="line">) : BufferedSink &#123;</span><br><span class="line"></span><br><span class="line">  @JvmField val bufferField &#x3D; Buffer() &#x2F;&#x2F; 创建Buffer，buffer逻辑实现核心类</span><br><span class="line"></span><br><span class="line">  @JvmField actual var closed: Boolean &#x3D; false &#x2F;&#x2F; 是否关闭</span><br><span class="line"></span><br><span class="line">  @Suppress(&quot;OVERRIDE_BY_INLINE&quot;) &#x2F;&#x2F; 重载父类buffer getter方法</span><br><span class="line">   override val buffer: Buffer</span><br><span class="line">    inline get() &#x3D; bufferField</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 write方法 。实现逻辑都是通过internal&#x2F;RealBufferSink进行实现，里面都是通过Buffer进行写操作</span><br><span class="line">  override fun writeAll(source: Source) &#x3D; commonWriteAll(source)</span><br><span class="line">  override fun write(source: Source, byteCount: Long): BufferedSink &#x3D; commonWrite(source, byteCount)</span><br><span class="line">  override fun writeByte(b: Int) &#x3D; commonWriteByte(b)</span><br><span class="line">  override fun writeShort(s: Int) &#x3D; commonWriteShort(s)</span><br><span class="line">  override fun writeShortLe(s: Int) &#x3D; commonWriteShortLe(s)</span><br><span class="line">  override fun writeInt(i: Int) &#x3D; commonWriteInt(i)</span><br><span class="line">  override fun writeIntLe(i: Int) &#x3D; commonWriteIntLe(i)</span><br><span class="line">  override fun writeLong(v: Long) &#x3D; commonWriteLong(v)</span><br><span class="line">  override fun writeLongLe(v: Long) &#x3D; commonWriteLongLe(v)</span><br><span class="line">  override fun writeDecimalLong(v: Long) &#x3D; commonWriteDecimalLong(v)</span><br><span class="line">  override fun writeHexadecimalUnsignedLong(v: Long) &#x3D; commonWriteHexadecimalUnsignedLong(v)</span><br><span class="line">  override fun emitCompleteSegments() &#x3D; commonEmitCompleteSegments()</span><br><span class="line">  override fun emit() &#x3D; commonEmit()</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取缓存"><a href="#读取缓存" class="headerlink" title="读取缓存"></a>读取缓存</h4><h5 id="BufferedSource-接口"><a href="#BufferedSource-接口" class="headerlink" title="BufferedSource 接口"></a>BufferedSource 接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actual interface BufferedSource : Source, ReadableByteChannel &#123;</span><br><span class="line">  &#x2F;&#x2F; Buffer</span><br><span class="line">  actual val buffer: Buffer</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 read方法</span><br><span class="line">  actual fun readXXX(...): XXX</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RealBufferedSource-实现类"><a href="#RealBufferedSource-实现类" class="headerlink" title="RealBufferedSource 实现类"></a>RealBufferedSource 实现类</h5><ul>
<li>BufferedSource实现类，含有两个重要成员Source和Buffer</li>
<li>接口方法基本上都经过 internal/RealBufferedSource一层封装，方法实现皆借助Buffer进行读取操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal actual class RealBufferedSource actual constructor(</span><br><span class="line">  @JvmField actual val source: Source</span><br><span class="line">) : BufferedSource &#123;</span><br><span class="line">  @JvmField val bufferField &#x3D; Buffer() &#x2F;&#x2F; 创建一个Buffer</span><br><span class="line">  @JvmField actual var closed: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  @Suppress(&quot;OVERRIDE_BY_INLINE&quot;) &#x2F;&#x2F; 重载父类buffer getter方法</span><br><span class="line">  override val buffer: Buffer</span><br><span class="line">    inline get() &#x3D; bufferField</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 read方法 。实现逻辑都是通过internal&#x2F;RealBufferSource进行实现，里面都是通过Buffer进行写操作</span><br><span class="line">  override fun readByte(): Byte &#x3D; commonReadByte()</span><br><span class="line">  override fun readByteString(): ByteString &#x3D; commonReadByteString()</span><br><span class="line">  override fun readByteString(byteCount: Long): ByteString &#x3D; commonReadByteString(byteCount)</span><br><span class="line">  override fun readFully(sink: Buffer, byteCount: Long): Unit &#x3D; commonReadFully(sink, byteCount)</span><br><span class="line">  override fun readAll(sink: Sink): Long &#x3D; commonReadAll(sink)</span><br><span class="line">  override fun readUtf8(): String &#x3D; commonReadUtf8()</span><br><span class="line">  override fun readUtf8(byteCount: Long): String &#x3D; commonReadUtf8(byteCount)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存实现类-Buffer"><a href="#缓存实现类-Buffer" class="headerlink" title="缓存实现类 Buffer"></a>缓存实现类 Buffer</h4><p>缓存逻辑实现核心类，对RealBufferedSource和RealBufferedSink中暴露的Api进行了实现，重点看下Buffer的读写方法，其核心设计原则就是兼顾CPU（时间）和Memory（空间）</p>
<ul>
<li>每一个Buffer中，包含Segment双向链表结构，进行缓存数据存储，多个固定的Segment有助于避免内存的申请和回收，减少内存片段</li>
<li>Buffer既充当了缓存写入角色，又充当了缓存读取角色，更有利于实现buffer平滑实现一次拷贝</li>
<li>读Buffer数据转移到写Buffer，1. 如果写Buffer可以容纳，则直接拷贝存储；2.如果写Buffer不可以容纳，则通过split方法在来一个Segment进行存储</li>
</ul>
<p>Buffer、Segment、SegmentPool巧妙的设计，兼顾了CPU和Memory的平衡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">internal inline fun Buffer.commonRead(sink: Buffer, byteCount: Long): Long &#123;</span><br><span class="line">  var byteCount &#x3D; byteCount</span><br><span class="line">  require(byteCount &gt;&#x3D; 0) &#123; &quot;byteCount &lt; 0: $byteCount&quot; &#125;</span><br><span class="line"></span><br><span class="line">  if (size &#x3D;&#x3D; 0L) return -1L</span><br><span class="line">  if (byteCount &gt; size) byteCount &#x3D; size</span><br><span class="line">  &#x2F;&#x2F; 执行 Buffer的write方法</span><br><span class="line">  sink.write(this, byteCount)</span><br><span class="line">  return byteCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal inline fun Buffer.commonWrite(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">  var byteCount &#x3D; byteCount &#x2F;&#x2F; 写入大小</span><br><span class="line">  &#x2F;&#x2F; 逻辑判断</span><br><span class="line">  require(source !&#x3D;&#x3D; this) &#123; &quot;source &#x3D;&#x3D; this&quot; &#125;</span><br><span class="line">  checkOffsetAndCount(source.size, 0, byteCount)</span><br><span class="line"></span><br><span class="line">  while (byteCount &gt; 0L) &#123;</span><br><span class="line">    &#x2F;&#x2F; source对应的Segment数据大小是否 大于 目标写入大小，大于则只写入一部分数据</span><br><span class="line">    if (byteCount &lt; source.head!!.limit - source.head!!.pos) &#123;</span><br><span class="line">      &#x2F;&#x2F; 取尾部Segment</span><br><span class="line">      val tail &#x3D; if (head !&#x3D; null) head!!.prev else null</span><br><span class="line">      &#x2F;&#x2F; 尾部不为空，且拥有数据写入权 且 拥有足够写入的空间</span><br><span class="line">      if (tail !&#x3D; null &amp;&amp; tail.owner &amp;&amp;</span><br><span class="line">        byteCount + tail.limit - (if (tail.shared) 0 else tail.pos) &lt;&#x3D; Segment.SIZE) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将读取Buffer的数据写入到 本Buffer的尾部Segment中</span><br><span class="line">        &#x2F;&#x2F; writeTo方法 可能是深拷贝或者是浅拷贝，后面有分析</span><br><span class="line">        source.head!!.writeTo(tail, byteCount.toInt())</span><br><span class="line">        &#x2F;&#x2F; 重置source的size 和本Buffer的size</span><br><span class="line">        source.size -&#x3D; byteCount</span><br><span class="line">        size +&#x3D; byteCount</span><br><span class="line">        return</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 装不下读取的数据，则需要新的Segment来写入 ，新的segement可能通过shareCopy或者SegemntPool来（见Segment分析）</span><br><span class="line">        source.head &#x3D; source.head!!.split(byteCount.toInt())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Remove the source&#39;s head segment and append it to our tail.</span><br><span class="line">    &#x2F;&#x2F; source对应Buffer中的head Segment数据读取完毕，对Buffer中的Segment进行移除</span><br><span class="line">    val segmentToMove &#x3D; source.head</span><br><span class="line">    val movedByteCount &#x3D; (segmentToMove!!.limit - segmentToMove.pos).toLong()</span><br><span class="line">    source.head &#x3D; segmentToMove.pop()</span><br><span class="line">    &#x2F;&#x2F; 移除后，因为它有可能含有共享的数据（见Segment），所以将其加入本Buffer的tail</span><br><span class="line">    &#x2F;&#x2F; 从而巧妙实现 Buffer 读写的复用</span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; head为空，直接赋值head</span><br><span class="line">      head &#x3D; segmentToMove</span><br><span class="line">      segmentToMove.prev &#x3D; segmentToMove</span><br><span class="line">      segmentToMove.next &#x3D; segmentToMove.prev</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; head不为空，赋值到尾部</span><br><span class="line">      var tail &#x3D; head!!.prev</span><br><span class="line">      tail &#x3D; tail!!.push(segmentToMove)</span><br><span class="line">      &#x2F;&#x2F; 新的tail加入，确认是否需要压缩</span><br><span class="line">      tail.compact()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 重置source大小，和本Buffer的size大小</span><br><span class="line">    source.size -&#x3D; movedByteCount</span><br><span class="line">    size +&#x3D; movedByteCount</span><br><span class="line">    byteCount -&#x3D; movedByteCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存数据片段-Segment"><a href="#缓存数据片段-Segment" class="headerlink" title="缓存数据片段 Segment"></a>缓存数据片段 Segment</h3><p>Buffer数据存储片段，目标数据都存储在Segment中的data字段中，Segment双向链表结构，提供pop、push进行Segment的增加和移除。split和compact对Segment进行拆分和合并，shareCopy为共享数据提供一次拷贝便利等</p>
<h4 id="共享机制"><a href="#共享机制" class="headerlink" title="共享机制"></a>共享机制</h4><p>两个字段（shared、owner）和两个方法（sharedCopy、unsharedCopy）来实现<br>浅拷贝的应用会直接减少一次I/O操作，大大提高I/O效率</p>
<ul>
<li>shared：代表该Segment的数据是否共享</li>
<li>owner：代表该Segment是否拥有对数据的写入权利</li>
<li>sharedCopy：data浅拷贝，共享复制的Segment中的data数据，其中owner为false（即拷贝的Segment只能读不能写）</li>
<li>unsharedCopy：data深拷贝，完全复制一个Segment</li>
</ul>
<h4 id="拆分与合并"><a href="#拆分与合并" class="headerlink" title="拆分与合并"></a>拆分与合并</h4><p>为了Segment的回收，以及更加合理化存储数据，提供两个方法</p>
<ul>
<li>compact：合并，如果本Segment与前一个Segment两者数据可以合为一个，则可以通过compact方法合并为一个Segment，然后回收本Segment</li>
<li>split：分割，当存储的数据大于当前Segment的容量时，则需要一个新的Segment，此时会有两种情况，1.如果数据量大于1024则浅拷贝一个Segment来装数据，如果不是，则直接深拷贝数据创建一个新的Segment</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">internal class Segment &#123;</span><br><span class="line">  &#x2F;&#x2F; 缓存的数据</span><br><span class="line">  @JvmField val data: ByteArray</span><br><span class="line"></span><br><span class="line">  &#x2F;** 读取数据的指针  *&#x2F;</span><br><span class="line">  @JvmField var pos: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">  &#x2F;** 写入数据的的指针 *&#x2F;</span><br><span class="line">  @JvmField var limit: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">  &#x2F;** 数据是否共享  *&#x2F;</span><br><span class="line">  @JvmField var shared: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;** limit扩展字段，数据是否属于当前的Segment，true即可以写入 *&#x2F;</span><br><span class="line">  @JvmField var owner: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;** 链表数据结构的next字段 *&#x2F;</span><br><span class="line">  @JvmField var next: Segment? &#x3D; null</span><br><span class="line"></span><br><span class="line">  &#x2F;** 链表数据结构的prev字段  *&#x2F;</span><br><span class="line">  @JvmField var prev: Segment? &#x3D; null</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.data &#x3D; ByteArray(SIZE)</span><br><span class="line">    this.owner &#x3D; true</span><br><span class="line">    this.shared &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(data: ByteArray, pos: Int, limit: Int, shared: Boolean, owner: Boolean) &#123;</span><br><span class="line">    this.data &#x3D; data</span><br><span class="line">    this.pos &#x3D; pos</span><br><span class="line">    this.limit &#x3D; limit</span><br><span class="line">    this.shared &#x3D; shared</span><br><span class="line">    this.owner &#x3D; owner</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; data浅拷贝，创建一个共享的Segment，owner为false</span><br><span class="line">  fun sharedCopy(): Segment &#123;</span><br><span class="line">    shared &#x3D; true</span><br><span class="line">    return Segment(data, pos, limit, true, false)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; data深拷贝，创建一个非共享的Segment，</span><br><span class="line">  fun unsharedCopy() &#x3D; Segment(data.copyOf(), pos, limit, false, true)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 移除本Segment对象</span><br><span class="line">  fun pop(): Segment? &#123;</span><br><span class="line">    val result &#x3D; if (next !&#x3D;&#x3D; this) next else null</span><br><span class="line">    prev!!.next &#x3D; next</span><br><span class="line">    next!!.prev &#x3D; prev</span><br><span class="line">    next &#x3D; null</span><br><span class="line">    prev &#x3D; null</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 添加一个segment到链表中</span><br><span class="line">  fun push(segment: Segment): Segment &#123;</span><br><span class="line">    segment.prev &#x3D; this</span><br><span class="line">    segment.next &#x3D; next</span><br><span class="line">    next!!.prev &#x3D; segment</span><br><span class="line">    next &#x3D; segment</span><br><span class="line">    return segment</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 分割为两个Segment，数据起始点分别为 &#96;[pos..pos+byteCount)&#96;、&#96;[pos+byteCount..limit)&#96;</span><br><span class="line">  fun split(byteCount: Int): Segment &#123;</span><br><span class="line">    require(byteCount &gt; 0 &amp;&amp; byteCount &lt;&#x3D; limit - pos) &#123; &quot;byteCount out of range&quot; &#125;</span><br><span class="line">    val prefix: Segment</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1\. 尽量减少二次拷贝；2\. 共享拷贝在一定大小才执行，避免过多的短小的Segment</span><br><span class="line">    if (byteCount &gt;&#x3D; SHARE_MINIMUM) &#123;</span><br><span class="line">      prefix &#x3D; sharedCopy() &#x2F;&#x2F; 共享拷贝</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      prefix &#x3D; SegmentPool.take() &#x2F;&#x2F; 直接拷贝</span><br><span class="line">      data.copyInto(prefix.data, startIndex &#x3D; pos, endIndex &#x3D; pos + byteCount)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; prefix赋值 limit pos</span><br><span class="line">    prefix.limit &#x3D; prefix.pos + byteCount</span><br><span class="line">    pos +&#x3D; byteCount</span><br><span class="line">    prev!!.push(prefix)</span><br><span class="line">    return prefix</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 合并压缩</span><br><span class="line">  fun compact() &#123;</span><br><span class="line">    check(prev !&#x3D;&#x3D; this) &#123; &quot;cannot compact&quot; &#125;</span><br><span class="line">    if (!prev!!.owner) return </span><br><span class="line">    &#x2F;&#x2F; 本Segment数据大小</span><br><span class="line">    val byteCount &#x3D; limit - pos</span><br><span class="line">    &#x2F;&#x2F; 前一个Segment剩余可写入空间大小</span><br><span class="line">    val availableByteCount &#x3D; SIZE - prev!!.limit + if (prev!!.shared) 0 else prev!!.pos</span><br><span class="line">    if (byteCount &gt; availableByteCount) return     </span><br><span class="line">    &#x2F;&#x2F; 如果有足够的空间，则将本Segment数据写入到前一个Segment</span><br><span class="line">    writeTo(prev!!, byteCount)</span><br><span class="line">    &#x2F;&#x2F; pop，然后执行回收</span><br><span class="line">    pop()</span><br><span class="line">    SegmentPool.recycle(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 将数据写入到buffer的segment中 *&#x2F;</span><br><span class="line">  fun writeTo(sink: Segment, byteCount: Int) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只有owner为true才能写入数据</span><br><span class="line">    check(sink.owner) &#123; &quot;only owner can write&quot; &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果被写入的sink limit+byteCount大于了最大值，则需要先充值下pos和limit</span><br><span class="line">    if (sink.limit + byteCount &gt; SIZE) &#123;</span><br><span class="line">      if (sink.shared) throw IllegalArgumentException()</span><br><span class="line">      &#x2F;&#x2F; 如果所有空闲都容纳不下 ，则抛出异常</span><br><span class="line">      if (sink.limit + byteCount - sink.pos &gt; SIZE) throw IllegalArgumentException()</span><br><span class="line">      &#x2F;&#x2F; 将被写入的segment中的数据复制到 [ 0,limit-pos)</span><br><span class="line">      sink.data.copyInto(sink.data, startIndex &#x3D; sink.pos, endIndex &#x3D; sink.limit)</span><br><span class="line">      &#x2F;&#x2F; 重置 pos和limit</span><br><span class="line">      sink.limit -&#x3D; sink.pos</span><br><span class="line">      sink.pos &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将本Segment的data复制到sink的data中，偏移大小为limit，起点为pos</span><br><span class="line">    data.copyInto(sink.data, destinationOffset &#x3D; sink.limit, startIndex &#x3D; pos,</span><br><span class="line">        endIndex &#x3D; pos + byteCount)</span><br><span class="line">    sink.limit +&#x3D; byteCount</span><br><span class="line">    pos +&#x3D; byteCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  companion object &#123;</span><br><span class="line">    &#x2F;** Segment 大小 bytes  *&#x2F;</span><br><span class="line">    const val SIZE &#x3D; 8192</span><br><span class="line"></span><br><span class="line">    &#x2F;** 共享数据大小  *&#x2F;</span><br><span class="line">    const val SHARE_MINIMUM &#x3D; 1024</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存片段池-SegmentPool"><a href="#缓存片段池-SegmentPool" class="headerlink" title="缓存片段池 SegmentPool"></a>缓存片段池 SegmentPool</h3><ul>
<li>大小：64 * 1024 Kib，一个Segment大小8192，相当于8个Segment</li>
<li>结构：单链表结构，提供take（取）和recycle（存）Segment方法，且线程安全</li>
<li>作用：防止已申请的资源被回收，增加资源的重复利用，提高效率，减少GC,避免内存抖动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">internal object SegmentPool &#123;</span><br><span class="line">  &#x2F;&#x2F; 缓存Segment池总大小 </span><br><span class="line">  const val MAX_SIZE &#x3D; 64 * 1024L &#x2F;&#x2F; 64 KiB.</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单链表next指针</span><br><span class="line">  var next: Segment? &#x3D; null</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; segment缓存池使用大小</span><br><span class="line">  var byteCount &#x3D; 0L</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 取 segment方法  （线程安全） </span><br><span class="line">  fun take(): Segment &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      &#x2F;&#x2F; 先从链表中获取</span><br><span class="line">      next?.let &#123; result -&gt;</span><br><span class="line">        &#x2F;&#x2F; 将缓存池next指针后移到下一个next</span><br><span class="line">        next &#x3D; result.next </span><br><span class="line">        &#x2F;&#x2F; 目标segment中next指引为null</span><br><span class="line">        result.next &#x3D; null</span><br><span class="line">        &#x2F;&#x2F; 总大小 减去</span><br><span class="line">        byteCount -&#x3D; Segment.SIZE</span><br><span class="line">        return result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Segment() &#x2F;&#x2F; 创建一个新的segment</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 存（回收） segment方法</span><br><span class="line">  fun recycle(segment: Segment) &#123;</span><br><span class="line">    require(segment.next &#x3D;&#x3D; null &amp;&amp; segment.prev &#x3D;&#x3D; null)</span><br><span class="line">    if (segment.shared) return &#x2F;&#x2F; 共用segment，不可回收使用</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      &#x2F;&#x2F; 目前segment池大小已经满了，不在回收</span><br><span class="line">      if (byteCount + Segment.SIZE &gt; MAX_SIZE) return &#x2F;&#x2F; Pool is full.</span><br><span class="line">      &#x2F;&#x2F; 回收目标segment，增加大小、更换next指引、重置segment</span><br><span class="line">      byteCount +&#x3D; Segment.SIZE</span><br><span class="line">      segment.next &#x3D; next</span><br><span class="line">      segment.limit &#x3D; 0</span><br><span class="line">      segment.pos &#x3D; segment.limit</span><br><span class="line">      next &#x3D; segment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/c988d0416020" target="_blank" rel="noopener">下一篇 OkHttp 4源码（7）— 总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/16/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%885%EF%BC%89%E2%80%94%E8%AF%B7%E6%B1%82%E5%86%99%E5%85%A5%E5%92%8C%E5%93%8D%E5%BA%94%E8%AF%BB%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/16/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%885%EF%BC%89%E2%80%94%E8%AF%B7%E6%B1%82%E5%86%99%E5%85%A5%E5%92%8C%E5%93%8D%E5%BA%94%E8%AF%BB%E5%8F%96/" class="post-title-link" itemprop="url">OkHttp 4源码（5）—请求写入和响应读取</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-16 15:33:21" itemprop="dateCreated datePublished" datetime="2020-01-16T15:33:21+08:00">2020-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:59:10" itemprop="dateModified" datetime="2020-02-07T00:59:10+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）<br><img src="https://upload-images.jianshu.io/upload_images/9696036-45a52add159e06b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>IO流程图<br><img src="https://upload-images.jianshu.io/upload_images/9696036-4f71931e4b7a5416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><h4 id="CallServerInterceptor-intercept"><a href="#CallServerInterceptor-intercept" class="headerlink" title="CallServerInterceptor.intercept"></a>CallServerInterceptor.intercept</h4><p>整体可以划分6个步骤，根据不同协议执行实现逻辑区分Http1.x和Http2</p>
<ol>
<li>写请求头</li>
<li>创建请求体</li>
<li>写请求体</li>
<li>完成请求写入</li>
<li>读取响应头</li>
<li>返回响应结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line">    &#x2F;&#x2F; 写入请求头</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 针对支持body的请求，且body不为空的情况进行请求体写入</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 对 “100-continue” 进行处理</span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; 写入请求体</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest() &#x2F;&#x2F; 写入请求</span><br><span class="line">    &#125;</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 读取响应头，写入到创建的ResponseBuilder</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建响应</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; 响应码为100的情况下，再次读取响应头，重新构建response</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 读取响应头结束</span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; webSocket &amp; 101情况下，返回一个empty的reponse</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 输入响应体，创建响应</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... &#x2F;&#x2F; check</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="写请求头"><a href="#写请求头" class="headerlink" title="写请求头"></a>写请求头</h3><h4 id="Exchange-writeRequestHeaders"><a href="#Exchange-writeRequestHeaders" class="headerlink" title="Exchange.writeRequestHeaders"></a>Exchange.writeRequestHeaders</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    eventListener.requestHeadersStart(call)</span><br><span class="line">    codec.writeRequestHeaders(request) &#x2F;&#x2F; 调用codec执行写headers</span><br><span class="line">    eventListener.requestHeadersEnd(call, request)</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建请求体"><a href="#创建请求体" class="headerlink" title="创建请求体"></a>创建请求体</h3><h4 id="Exchange-createRequestBody"><a href="#Exchange-createRequestBody" class="headerlink" title="Exchange.createRequestBody"></a>Exchange.createRequestBody</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun createRequestBody(request: Request, duplex: Boolean): Sink &#123;</span><br><span class="line">  this.isDuplex &#x3D; duplex</span><br><span class="line">  val contentLength &#x3D; request.body!!.contentLength()</span><br><span class="line">  eventListener.requestBodyStart(call)</span><br><span class="line">  &#x2F;&#x2F; 执行编码器创建请求体</span><br><span class="line">  val rawRequestBody &#x3D; codec.createRequestBody(request, contentLength)</span><br><span class="line">  return RequestBodySink(rawRequestBody, contentLength)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写请求体"><a href="#写请求体" class="headerlink" title="写请求体"></a>写请求体</h3><h4 id="RequestBodySink-write"><a href="#RequestBodySink-write" class="headerlink" title="RequestBodySink.write"></a>RequestBodySink.write</h4><p>根据创建的RequestBodySink进行写入操作<br>Http/1.x ，newKnownLengthSink或者newChunkedSink</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun write(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">  check(!closed) &#123; &quot;closed&quot; &#125;</span><br><span class="line">  if (contentLength !&#x3D; -1L &amp;&amp; bytesReceived + byteCount &gt; contentLength) &#123;</span><br><span class="line">    throw ProtocolException(</span><br><span class="line">        &quot;expected $contentLength bytes but received $&#123;bytesReceived + byteCount&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行写入操作 </span><br><span class="line">    super.write(source, byteCount) </span><br><span class="line">    this.bytesReceived +&#x3D; byteCount</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    throw complete(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成请求写入"><a href="#完成请求写入" class="headerlink" title="完成请求写入"></a>完成请求写入</h3><h4 id="Exchange-finishRequest"><a href="#Exchange-finishRequest" class="headerlink" title="Exchange.finishRequest"></a>Exchange.finishRequest</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun finishRequest() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    codec.finishRequest() &#x2F;&#x2F; 执行请求写入</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    eventListener.requestFailed(call, e)</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    throw e</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取响应头"><a href="#读取响应头" class="headerlink" title="读取响应头"></a>读取响应头</h3><h4 id="Exchange-readResponseHeaders"><a href="#Exchange-readResponseHeaders" class="headerlink" title="Exchange.readResponseHeaders"></a>Exchange.readResponseHeaders</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun readResponseHeaders(expectContinue: Boolean): Response.Builder? &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    val result &#x3D; codec.readResponseHeaders(expectContinue)</span><br><span class="line">    result?.initExchange(this)</span><br><span class="line">    return result</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    eventListener.responseFailed(call, e)</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    throw e</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取响应体"><a href="#读取响应体" class="headerlink" title="读取响应体"></a>读取响应体</h3><h4 id="Exchange-openResponseBody"><a href="#Exchange-openResponseBody" class="headerlink" title="Exchange.openResponseBody"></a>Exchange.openResponseBody</h4><p>创建响应体封装实例，含有响应体的读取流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun openResponseBody(response: Response): ResponseBody &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据类型</span><br><span class="line">    val contentType &#x3D; response.header(&quot;Content-Type&quot;)</span><br><span class="line">    &#x2F;&#x2F; 数据大小</span><br><span class="line">    val contentLength &#x3D; codec.reportedContentLength(response)</span><br><span class="line">    &#x2F;&#x2F; 编码器创建读取原生流</span><br><span class="line">    val rawSource &#x3D; codec.openResponseBodySource(response)</span><br><span class="line">    &#x2F;&#x2F; 创建响应体的Source</span><br><span class="line">    val source &#x3D; ResponseBodySource(rawSource, contentLength)</span><br><span class="line">    return RealResponseBody(contentType, contentLength, source.buffer())</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    eventListener.responseFailed(call, e)</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    throw e</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTP1-x对应实现"><a href="#HTTP1-x对应实现" class="headerlink" title="HTTP1.x对应实现"></a>HTTP1.x对应实现</h3><h4 id="Http1ExchangeCodec-writeRequestHeaders"><a href="#Http1ExchangeCodec-writeRequestHeaders" class="headerlink" title="Http1ExchangeCodec.writeRequestHeaders"></a>Http1ExchangeCodec.writeRequestHeaders</h4><p>创建RequestLine，执行写入headers方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取RequestLine实例，进行request输入</span><br><span class="line">  val requestLine &#x3D; RequestLine.get(</span><br><span class="line">      request, realConnection!!.route().proxy.type())</span><br><span class="line">  &#x2F;&#x2F; 写入headers</span><br><span class="line">  writeRequest(request.headers, requestLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-writeRequest"><a href="#Http1ExchangeCodec-writeRequest" class="headerlink" title="Http1ExchangeCodec.writeRequest"></a>Http1ExchangeCodec.writeRequest</h4><p>通过Okio的Sink实例 写入headers</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun writeRequest(headers: Headers, requestLine: String) &#123;</span><br><span class="line">  check(state &#x3D;&#x3D; STATE_IDLE) &#123; &quot;state: $state&quot; &#125;</span><br><span class="line">  sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;)</span><br><span class="line">  &#x2F;&#x2F; 写入headers</span><br><span class="line">  for (i in 0 until headers.size) &#123;</span><br><span class="line">    sink.writeUtf8(headers.name(i))</span><br><span class="line">        .writeUtf8(&quot;: &quot;)</span><br><span class="line">        .writeUtf8(headers.value(i))</span><br><span class="line">        .writeUtf8(&quot;\r\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  sink.writeUtf8(&quot;\r\n&quot;)</span><br><span class="line">  state &#x3D; STATE_OPEN_REQUEST_BODY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-createRequestBody"><a href="#Http1ExchangeCodec-createRequestBody" class="headerlink" title="Http1ExchangeCodec.createRequestBody"></a>Http1ExchangeCodec.createRequestBody</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override fun createRequestBody(request: Request, contentLength: Long): Sink &#123;</span><br><span class="line">  return when &#123;</span><br><span class="line">    request.body !&#x3D; null &amp;&amp; request.body.isDuplex() -&gt; throw ProtocolException(</span><br><span class="line">        &quot;Duplex connections are not supported for HTTP&#x2F;1&quot;)</span><br><span class="line">    request.isChunked() -&gt; newChunkedSink() &#x2F;&#x2F;  创建未知大小的SInk</span><br><span class="line">    contentLength !&#x3D; -1L -&gt; newKnownLengthSink() &#x2F;&#x2F; 创建已知大小的Sink</span><br><span class="line">    else -&gt; &#x2F;&#x2F; Stream a request body of a known length.</span><br><span class="line">      throw IllegalStateException(</span><br><span class="line">          &quot;Cannot stream a request body without chunked encoding or a known content length!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-finishRequest"><a href="#Http1ExchangeCodec-finishRequest" class="headerlink" title="Http1ExchangeCodec.finishRequest"></a>Http1ExchangeCodec.finishRequest</h4><p>请求写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override fun finishRequest() &#123;</span><br><span class="line">  sink.flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http1ExchangeCodec-readResponseHeaders"><a href="#Http1ExchangeCodec-readResponseHeaders" class="headerlink" title="Http1ExchangeCodec.readResponseHeaders"></a>Http1ExchangeCodec.readResponseHeaders</h4><ul>
<li>读取响应头信息，根据StatusLine解析协议类型、响应码、Message</li>
<li>构建ResponseBuilder接受响应头信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? &#123;</span><br><span class="line">    check(state &#x3D;&#x3D; STATE_OPEN_REQUEST_BODY || state &#x3D;&#x3D; STATE_READ_RESPONSE_HEADERS) &#123;</span><br><span class="line">      &quot;state: $state&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 读取statusLine，响应状态信息</span><br><span class="line">      val statusLine &#x3D; StatusLine.parse(readHeaderLine())</span><br><span class="line">      &#x2F;&#x2F; 创建 Response，赋值status信息和header信息</span><br><span class="line">      val responseBuilder &#x3D; Response.Builder()</span><br><span class="line">          .protocol(statusLine.protocol)</span><br><span class="line">          .code(statusLine.code)</span><br><span class="line">          .message(statusLine.message)</span><br><span class="line">          .headers(readHeaders())</span><br><span class="line">      &#x2F;&#x2F; 返回responseBuilder</span><br><span class="line">      return when &#123;</span><br><span class="line">        expectContinue &amp;&amp; statusLine.code &#x3D;&#x3D; HTTP_CONTINUE -&gt; &#123;</span><br><span class="line">          null</span><br><span class="line">        &#125;</span><br><span class="line">        statusLine.code &#x3D;&#x3D; HTTP_CONTINUE -&gt; &#123;</span><br><span class="line">          state &#x3D; STATE_READ_RESPONSE_HEADERS</span><br><span class="line">          responseBuilder</span><br><span class="line">        &#125;</span><br><span class="line">        else -&gt; &#123;</span><br><span class="line">          state &#x3D; STATE_OPEN_RESPONSE_BODY</span><br><span class="line">          responseBuilder</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e: EOFException) &#123;</span><br><span class="line">        ...</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-openResponseBodySource"><a href="#Http1ExchangeCodec-openResponseBodySource" class="headerlink" title="Http1ExchangeCodec.openResponseBodySource"></a>Http1ExchangeCodec.openResponseBodySource</h4><p>根据响应体chunked特性和大小是否已知创建不同的Source流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun openResponseBodySource(response: Response): Source &#123;</span><br><span class="line">  return when &#123;</span><br><span class="line">    !response.promisesBody() -&gt; newFixedLengthSource(0) &#x2F;&#x2F; 固定长度Source</span><br><span class="line">    response.isChunked() -&gt; newChunkedSource(response.request.url) &#x2F;&#x2F; ChunkedSource</span><br><span class="line">    else -&gt; &#123;</span><br><span class="line">      val contentLength &#x3D; response.headersContentLength()</span><br><span class="line">      if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">        newFixedLengthSource(contentLength)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        newUnknownLengthSource() &#x2F;&#x2F; 未知长度Source</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTP2对应实现"><a href="#HTTP2对应实现" class="headerlink" title="HTTP2对应实现"></a>HTTP2对应实现</h3><h4 id="Http2ExchangeCodec-writeRequestHeaders"><a href="#Http2ExchangeCodec-writeRequestHeaders" class="headerlink" title="Http2ExchangeCodec.writeRequestHeaders"></a>Http2ExchangeCodec.writeRequestHeaders</h4><p>创建RequestLine，执行写入headers方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">  if (stream !&#x3D; null) return</span><br><span class="line"></span><br><span class="line">  val hasRequestBody &#x3D; request.body !&#x3D; null</span><br><span class="line">  &#x2F;&#x2F; 将request中的Headers 转换为一个含有Header的List集合</span><br><span class="line">  val requestHeaders &#x3D; http2HeadersList(request) </span><br><span class="line">  &#x2F;&#x2F; 创建 本地发起的双向流 （过程会写入header）</span><br><span class="line">  stream &#x3D; connection.newStream(requestHeaders, hasRequestBody)</span><br><span class="line">  </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http2ExchangeCodec-newStream"><a href="#Http2ExchangeCodec-newStream" class="headerlink" title="Http2ExchangeCodec.newStream"></a>Http2ExchangeCodec.newStream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private fun newStream(</span><br><span class="line">   associatedStreamId: Int,</span><br><span class="line">   requestHeaders: List&lt;Header&gt;,</span><br><span class="line">   out: Boolean</span><br><span class="line"> ): Http2Stream &#123;</span><br><span class="line">   val outFinished &#x3D; !out</span><br><span class="line">   val inFinished &#x3D; false</span><br><span class="line">   val flushHeaders: Boolean</span><br><span class="line">   val stream: Http2Stream</span><br><span class="line">   val streamId: Int</span><br><span class="line"></span><br><span class="line">   synchronized(writer) &#123;</span><br><span class="line">     synchronized(this) &#123;</span><br><span class="line">       if (nextStreamId &gt; Int.MAX_VALUE &#x2F; 2) &#123;</span><br><span class="line">         shutdown(REFUSED_STREAM)</span><br><span class="line">       &#125;</span><br><span class="line">       if (isShutdown) &#123;</span><br><span class="line">         throw ConnectionShutdownException()</span><br><span class="line">       &#125;</span><br><span class="line">       streamId &#x3D; nextStreamId</span><br><span class="line">       nextStreamId +&#x3D; 2</span><br><span class="line">       &#x2F;&#x2F; 创建Http2Stream</span><br><span class="line">       stream &#x3D; Http2Stream(streamId, this, outFinished, inFinished, null)</span><br><span class="line">       </span><br><span class="line">       flushHeaders &#x3D; !out ||</span><br><span class="line">           writeBytesTotal &gt;&#x3D; writeBytesMaximum ||</span><br><span class="line">           stream.writeBytesTotal &gt;&#x3D; stream.writeBytesMaximum</span><br><span class="line">       if (stream.isOpen) &#123;</span><br><span class="line">         streams[streamId] &#x3D; stream</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if (associatedStreamId &#x3D;&#x3D; 0) &#123; </span><br><span class="line">       &#x2F;&#x2F; 写入headers</span><br><span class="line">       writer.headers(outFinished, streamId, requestHeaders)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       require(!client) &#123; &quot;client streams shouldn&#39;t have associated stream IDs&quot; &#125;</span><br><span class="line">       &#x2F;&#x2F; HTTP&#x2F;2 has a PUSH_PROMISE frame.</span><br><span class="line">       writer.pushPromise(associatedStreamId, streamId, requestHeaders)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (flushHeaders) &#123;</span><br><span class="line">     writer.flush()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return stream</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Writer-headers"><a href="#Http2Writer-headers" class="headerlink" title="Http2Writer.headers"></a>Http2Writer.headers</h4><ul>
<li>HPACK加密数据</li>
<li>写入帧头数据</li>
<li>写入加密过的Header数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun headers(</span><br><span class="line">  outFinished: Boolean,</span><br><span class="line">  streamId: Int,</span><br><span class="line">  headerBlock: List&lt;Header&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  if (closed) throw IOException(&quot;closed&quot;)</span><br><span class="line">  &#x2F;&#x2F; 通过Hpack进行headers 的HPACK加密</span><br><span class="line">  hpackWriter.writeHeaders(headerBlock)</span><br><span class="line"></span><br><span class="line">  val byteCount &#x3D; hpackBuffer.size</span><br><span class="line">  val length &#x3D; minOf(maxFrameSize.toLong(), byteCount)</span><br><span class="line">  var flags &#x3D; if (byteCount &#x3D;&#x3D; length) FLAG_END_HEADERS else 0</span><br><span class="line">  if (outFinished) flags &#x3D; flags or FLAG_END_STREAM</span><br><span class="line">  &#x2F;&#x2F; 写入帧头</span><br><span class="line">  frameHeader(</span><br><span class="line">      streamId &#x3D; streamId,</span><br><span class="line">      length &#x3D; length.toInt(),</span><br><span class="line">      type &#x3D; TYPE_HEADERS,</span><br><span class="line">      flags &#x3D; flags</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 写入加密过的header数据</span><br><span class="line">  sink.write(hpackBuffer, length)</span><br><span class="line"></span><br><span class="line">  if (byteCount &gt; length) writeContinuationFrames(streamId, byteCount - length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Http2ExchangeCodec-createRequestBody"><a href="#Http2ExchangeCodec-createRequestBody" class="headerlink" title="Http2ExchangeCodec.createRequestBody"></a>Http2ExchangeCodec.createRequestBody</h4><p>返回一个 FramingSink 对象 ，RequestBodySink.writeTo(bufferedRequestBody)最后会调用其成员变量delegate即sink对象的write方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override fun createRequestBody(request: Request, contentLength: Long): Sink &#123;</span><br><span class="line">  return stream!!.getSink() &#x2F;&#x2F; FramingSink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FramingSink-write"><a href="#FramingSink-write" class="headerlink" title="FramingSink.write"></a>FramingSink.write</h4><p>写入帧数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun write(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">  this@Http2Stream.assertThreadDoesntHoldLock()</span><br><span class="line">  &#x2F;&#x2F; buffer写入source数据</span><br><span class="line">  sendBuffer.write(source, byteCount)</span><br><span class="line">  while (sendBuffer.size &gt;&#x3D; EMIT_BUFFER_SIZE) &#123;</span><br><span class="line">    emitFrame(false) &#x2F;&#x2F; 当buffer数据大于EMIT_BUFFER_SIZE 则执行发送frame数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FramingSink-emitFrame"><a href="#FramingSink-emitFrame" class="headerlink" title="FramingSink.emitFrame"></a>FramingSink.emitFrame</h4><blockquote>
<p>Emit a single data frame to the connection. The frame’s size be limited by this stream’s write window. This method will block until the write window is nonempty.</p>
</blockquote>
<p>往连接中写入Frame数据，当写入的数据超过了写入的最大值就阻塞直到唤起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private fun emitFrame(outFinishedOnLastFrame: Boolean) &#123;</span><br><span class="line">  val toWrite: Long</span><br><span class="line">  val outFinished: Boolean</span><br><span class="line">  synchronized(this@Http2Stream) &#123;</span><br><span class="line">    writeTimeout.enter()</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 当写入的总数据大小 大于 最大写入值的时候 阻塞</span><br><span class="line">      while (writeBytesTotal &gt;&#x3D; writeBytesMaximum &amp;&amp;</span><br><span class="line">          !finished &amp;&amp;</span><br><span class="line">          !closed &amp;&amp;</span><br><span class="line">          errorCode &#x3D;&#x3D; null) &#123;</span><br><span class="line">        waitForIo() &#x2F;&#x2F; 阻塞直到 接受  WINDOW_UPDATE </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      writeTimeout.exitAndThrowIfTimedOut()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkOutNotClosed() &#x2F;&#x2F; </span><br><span class="line">    toWrite &#x3D; minOf(writeBytesMaximum - writeBytesTotal, sendBuffer.size)</span><br><span class="line">    writeBytesTotal +&#x3D; toWrite</span><br><span class="line">    outFinished &#x3D; outFinishedOnLastFrame &amp;&amp; toWrite &#x3D;&#x3D; sendBuffer.size &amp;&amp; errorCode &#x3D;&#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  writeTimeout.enter()</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 写入数据</span><br><span class="line">    connection.writeData(id, outFinished, sendBuffer, toWrite)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    writeTimeout.exitAndThrowIfTimedOut()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Connection-writeData"><a href="#Http2Connection-writeData" class="headerlink" title="Http2Connection.writeData"></a>Http2Connection.writeData</h4><p>连接写入数据，当写入的数据超过了写入的最大值就阻塞直到唤起<br>writeBytesMaximum = 16384（每个帧限制大小）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">fun writeData(</span><br><span class="line">    streamId: Int,</span><br><span class="line">    outFinished: Boolean,</span><br><span class="line">    buffer: Buffer?,</span><br><span class="line">    byteCount: Long</span><br><span class="line">  ) &#123;</span><br><span class="line">    var byteCount &#x3D; byteCount</span><br><span class="line">    while (byteCount &gt; 0L) &#123;</span><br><span class="line">      var toWrite: Int</span><br><span class="line">      synchronized(this@Http2Connection) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        </span><br><span class="line">          while (writeBytesTotal &gt;&#x3D; writeBytesMaximum) &#123; &#x2F;&#x2F; 待写入数据超了</span><br><span class="line">            if (!streams.containsKey(streamId)) &#123;</span><br><span class="line">              throw IOException(&quot;stream closed&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            this@Http2Connection.wait() &#x2F;&#x2F; 阻塞</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">          Thread.currentThread().interrupt() &#x2F;&#x2F; Retain interrupted status.</span><br><span class="line">          throw InterruptedIOException()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toWrite &#x3D; minOf(byteCount, writeBytesMaximum - writeBytesTotal).toInt()</span><br><span class="line">        toWrite &#x3D; minOf(toWrite, writer.maxDataLength())</span><br><span class="line">        writeBytesTotal +&#x3D; toWrite.toLong()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      byteCount -&#x3D; toWrite.toLong()</span><br><span class="line">      &#x2F;&#x2F;写入数据 </span><br><span class="line">      writer.data(outFinished &amp;&amp; byteCount &#x3D;&#x3D; 0L, streamId, buffer, toWrite)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http2Write-data"><a href="#Http2Write-data" class="headerlink" title="Http2Write.data"></a>Http2Write.data</h4><p>数据帧的写入执行方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun data(outFinished: Boolean, streamId: Int, source: Buffer?, byteCount: Int) &#123;</span><br><span class="line">  if (closed) throw IOException(&quot;closed&quot;)</span><br><span class="line">  var flags &#x3D; FLAG_NONE</span><br><span class="line">  if (outFinished) flags &#x3D; flags or FLAG_END_STREAM</span><br><span class="line">  &#x2F;&#x2F; 帧数据写入</span><br><span class="line">  dataFrame(streamId, flags, source, byteCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">fun dataFrame(streamId: Int, flags: Int, buffer: Buffer?, byteCount: Int) &#123;</span><br><span class="line">  &#x2F;&#x2F; 写入帧头</span><br><span class="line">  frameHeader(</span><br><span class="line">      streamId &#x3D; streamId,</span><br><span class="line">      length &#x3D; byteCount,</span><br><span class="line">      type &#x3D; TYPE_DATA,</span><br><span class="line">      flags &#x3D; flags</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 写入数据</span><br><span class="line">  if (byteCount &gt; 0) &#123;</span><br><span class="line">    sink.write(buffer!!, byteCount.toLong())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Http2ExchangeCodec-readResponseHeaders"><a href="#Http2ExchangeCodec-readResponseHeaders" class="headerlink" title="Http2ExchangeCodec.readResponseHeaders"></a>Http2ExchangeCodec.readResponseHeaders</h4><ul>
<li>阻塞等待获取Headers数据 </li>
<li>获取Headers数据，转换为Response中headers，以及其它响应头信息，创建ResponseBuilder</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? &#123;</span><br><span class="line">  val headers &#x3D; stream!!.takeHeaders() &#x2F;&#x2F; 取headers</span><br><span class="line">  val responseBuilder &#x3D; readHttp2HeadersList(headers, protocol) &#x2F;&#x2F; 读取到headers集合并创建建响应Buidler</span><br><span class="line">  return if (expectContinue &amp;&amp; responseBuilder.code &#x3D;&#x3D; HTTP_CONTINUE) &#123;</span><br><span class="line">    null</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    responseBuilder</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Stream-takeHeaders"><a href="#Http2Stream-takeHeaders" class="headerlink" title="Http2Stream.takeHeaders"></a>Http2Stream.takeHeaders</h4><p>阻塞等待headers数据，在拿到headers后，返回数据<br>headers数据在receiveHeaders方法中会添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun takeHeaders(): Headers &#123;</span><br><span class="line">  readTimeout.enter()</span><br><span class="line">  try &#123;</span><br><span class="line">    while (headersQueue.isEmpty() &amp;&amp; errorCode &#x3D;&#x3D; null) &#123;</span><br><span class="line">      waitForIo() &#x2F;&#x2F; 如果为空，则阻塞等待 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    readTimeout.exitAndThrowIfTimedOut()</span><br><span class="line">  &#125;</span><br><span class="line">  if (headersQueue.isNotEmpty()) &#123;</span><br><span class="line">    return headersQueue.removeFirst() &#x2F;&#x2F;取headers 返回</span><br><span class="line">  &#125;</span><br><span class="line">  throw errorException ?: StreamResetException(errorCode!!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Stream-receiveHeaders"><a href="#Http2Stream-receiveHeaders" class="headerlink" title="Http2Stream.receiveHeaders"></a>Http2Stream.receiveHeaders</h4><p>从数据源接受header后，存储到headers队列中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun receiveHeaders(headers: Headers, inFinished: Boolean) &#123;</span><br><span class="line">  this@Http2Stream.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  val open: Boolean</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    if (!hasResponseHeaders || !inFinished) &#123;</span><br><span class="line">      hasResponseHeaders &#x3D; true</span><br><span class="line">      headersQueue +&#x3D; headers &#x2F;&#x2F; 加入headers</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.source.trailers &#x3D; headers</span><br><span class="line">    &#125;</span><br><span class="line">    if (inFinished) &#123;</span><br><span class="line">      this.source.finished &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">    open &#x3D; isOpen</span><br><span class="line">    notifyAll() </span><br><span class="line">  &#125;</span><br><span class="line">  if (!open) &#123;</span><br><span class="line">    connection.removeStream(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReaderRunnable-run"><a href="#ReaderRunnable-run" class="headerlink" title="ReaderRunnable.run"></a>ReaderRunnable.run</h4><p>在Http2Connection.start的时候，最后会执行一个此线程方法<br>当读取完preface之后，就一直循环读取下一个帧数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun run() &#123;</span><br><span class="line">  var connectionErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">  var streamErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">  var errorException: IOException? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    reader.readConnectionPreface(this) </span><br><span class="line">    &#x2F;&#x2F; 循环读取帧数据</span><br><span class="line">    while (reader.nextFrame(false, this)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    connectionErrorCode &#x3D; ErrorCode.NO_ERROR</span><br><span class="line">    streamErrorCode &#x3D; ErrorCode.CANCEL</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Reader-nextFrame"><a href="#Http2Reader-nextFrame" class="headerlink" title="Http2Reader.nextFrame"></a>Http2Reader.nextFrame</h4><p>读取响应数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">fun nextFrame(requireSettings: Boolean, handler: Handler): Boolean &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    source.require(9) &#x2F;&#x2F; Frame header size.</span><br><span class="line">  &#125; catch (e: EOFException) &#123;</span><br><span class="line">    return false &#x2F;&#x2F; This might be a normal socket close.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val length &#x3D; source.readMedium()</span><br><span class="line">  if (length &gt; INITIAL_MAX_FRAME_SIZE) &#123;</span><br><span class="line">    throw IOException(&quot;FRAME_SIZE_ERROR: $length&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  val type &#x3D; source.readByte() and 0xff</span><br><span class="line">  if (requireSettings &amp;&amp; type !&#x3D; TYPE_SETTINGS) &#123;</span><br><span class="line">    throw IOException(&quot;Expected a SETTINGS frame but was $type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  val flags &#x3D; source.readByte() and 0xff</span><br><span class="line">  val streamId &#x3D; source.readInt() and 0x7fffffff &#x2F;&#x2F; Ignore reserved bit.</span><br><span class="line">  if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags))</span><br><span class="line">  &#x2F;&#x2F; 读取不同类型数据</span><br><span class="line">  when (type) &#123;</span><br><span class="line">    TYPE_DATA -&gt; readData(handler, length, flags, streamId)</span><br><span class="line">    TYPE_HEADERS -&gt; readHeaders(handler, length, flags, streamId)</span><br><span class="line">    TYPE_PRIORITY -&gt; readPriority(handler, length, flags, streamId)</span><br><span class="line">    TYPE_RST_STREAM -&gt; readRstStream(handler, length, flags, streamId)</span><br><span class="line">    TYPE_SETTINGS -&gt; readSettings(handler, length, flags, streamId)</span><br><span class="line">    TYPE_PUSH_PROMISE -&gt; readPushPromise(handler, length, flags, streamId)</span><br><span class="line">    TYPE_PING -&gt; readPing(handler, length, flags, streamId)</span><br><span class="line">    TYPE_GOAWAY -&gt; readGoAway(handler, length, flags, streamId)</span><br><span class="line">    TYPE_WINDOW_UPDATE -&gt; readWindowUpdate(handler, length, flags, streamId)</span><br><span class="line">    else -&gt; source.skip(length.toLong()) &#x2F;&#x2F; Implementations MUST discard frames of unknown types.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### FramingSource.read</span><br></pre></td></tr></table></figure>
<p>override fun read(sink: Buffer, byteCount: Long): Long {<br>      require(byteCount &gt;= 0L) { “byteCount &lt; 0: $byteCount” }</p>
<pre><code>  while (true) {
    var tryAgain = false
    var readBytesDelivered = -1L
    var errorExceptionToDeliver: IOException? = null

    // 1. Decide what to do in a synchronized block.

    synchronized(this@Http2Stream) {
      readTimeout.enter()
      try {
        if (errorCode != null) {
          // Prepare to deliver an error.
          errorExceptionToDeliver = errorException ?: StreamResetException(errorCode!!)
        }

        if (closed) {
          throw IOException(&quot;stream closed&quot;)
        } else if (readBuffer.size &gt; 0L) {
          // Prepare to read bytes. Start by moving them to the caller&apos;s buffer.
          readBytesDelivered = readBuffer.read(sink, minOf(byteCount, readBuffer.size))
          readBytesTotal += readBytesDelivered

          val unacknowledgedBytesRead = readBytesTotal - readBytesAcknowledged
          if (errorExceptionToDeliver == null &amp;&amp;
              unacknowledgedBytesRead &gt;= connection.okHttpSettings.initialWindowSize / 2) {
            // Flow control: notify the peer that we&apos;re ready for more data! Only send a
            // WINDOW_UPDATE if the stream isn&apos;t in error.
            connection.writeWindowUpdateLater(id, unacknowledgedBytesRead)
            readBytesAcknowledged = readBytesTotal
          }
        } else if (!finished &amp;&amp; errorExceptionToDeliver == null) {
          // Nothing to do. Wait until that changes then try again.
          waitForIo()
          tryAgain = true
        }
      } finally {
        readTimeout.exitAndThrowIfTimedOut()
      }
    }

    // 2. Do it outside of the synchronized block and timeout.

    if (tryAgain) {
      continue
    }

    if (readBytesDelivered != -1L) {
      // Update connection.unacknowledgedBytesRead outside the synchronized block.
      updateConnectionFlowControl(readBytesDelivered)
      return readBytesDelivered
    }

    ...

    return -1L // This source is exhausted.
  }
}</code></pre><pre><code>[下一篇 OkHttp 4源码（6）— Okio源码解析](https://www.jianshu.com/p/7b7ba4333c5e)

</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%884%EF%BC%89%E2%80%94%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%884%EF%BC%89%E2%80%94%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 4源码（4）—连接机制分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 10:33:09" itemprop="dateCreated datePublished" datetime="2020-01-13T10:33:09+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:59:18" itemprop="dateModified" datetime="2020-02-07T00:59:18+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）<br><img src="https://upload-images.jianshu.io/upload_images/9696036-074bde427d6e3cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>连接时序图<br><img src="https://upload-images.jianshu.io/upload_images/9696036-c629851ea8fb73d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>HTTP不同协议连接区分<br>参考：<a href="https://halfrost.com/http2_begin/" target="_blank" rel="noopener">HTTP/2 是如何建立连接的</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-d16e8389d436637b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><ul>
<li>获取发射机</li>
<li>获取有效连接，RealConnection</li>
<li>创建编码器，ExchangeCodex，实际I/O工作逻辑</li>
<li>创建一个Exchange，封装上面结果，为后续网络读写工作提供API </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">object ConnectInterceptor : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    &#x2F;&#x2F; 取发射机，RealCall 创建时默认会创建一个实例</span><br><span class="line">    val transmitter &#x3D; realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于非GET请求 检查为true</span><br><span class="line">    val doExtensiveHealthChecks &#x3D; request.method !&#x3D; &quot;GET&quot;</span><br><span class="line">    &#x2F;&#x2F; 构建Exchange </span><br><span class="line">    val exchange &#x3D; transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, transmitter, exchange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发射机-Transmitter"><a href="#发射机-Transmitter" class="headerlink" title="发射机 Transmitter"></a>发射机 Transmitter</h3><blockquote>
<p>Bridge between OkHttp’s application and network layers. This class exposes high-level application layer primitives: connections, requests, responses, and streams.</p>
</blockquote>
<p>OkHttp 应用层和网络层的桥梁，它提供了应用层连接、请求、响应的最上层函数</p>
<h4 id="Transmitter构造方法"><a href="#Transmitter构造方法" class="headerlink" title="Transmitter构造方法"></a>Transmitter构造方法</h4><p>RealCall 创建时默认会创建一个实例，持有client、call、connectionPool的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Transmitter(</span><br><span class="line">  private val client: OkHttpClient,</span><br><span class="line">  private val call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 持有连接池引用</span><br><span class="line">  private val connectionPool: RealConnectionPool &#x3D; client.connectionPool.delegate</span><br><span class="line">  &#x2F;&#x2F; 监听器</span><br><span class="line">  private val eventListener: EventListener &#x3D; client.eventListenerFactory.create(call)</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Transmitter-prepareToConnect"><a href="#Transmitter-prepareToConnect" class="headerlink" title="Transmitter.prepareToConnect"></a>Transmitter.prepareToConnect</h4><p>准备连接，触发时机：重试桥开始会执行此方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun prepareToConnect(request: Request) &#123;</span><br><span class="line">  if (this.request !&#x3D; null) &#123;</span><br><span class="line">    if (this.request!!.url.canReuseConnectionFor(request.url) &amp;&amp; exchangeFinder!!.hasRouteToTry()) &#123;</span><br><span class="line">      return &#x2F;&#x2F; 可以重用下，结束</span><br><span class="line">    &#125;</span><br><span class="line">    check(exchange &#x3D;&#x3D; null)</span><br><span class="line">    &#x2F;&#x2F; 重置</span><br><span class="line">    if (exchangeFinder !&#x3D; null) &#123;</span><br><span class="line">      maybeReleaseConnection(null, true)</span><br><span class="line">      exchangeFinder &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 构造一个ExchangeFinder实例（下面介绍）</span><br><span class="line">  this.request &#x3D; request</span><br><span class="line">  this.exchangeFinder &#x3D; ExchangeFinder(</span><br><span class="line">      this, connectionPool, createAddress(request.url), call, eventListener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p>核心类</p>
<ul>
<li>Exchange ，单个Http请求，传输交换数据实现类</li>
<li>ExchangeFinder ，请求连接获取，请求编解码实例构建，逻辑累</li>
<li>ExchangeCodec，Http连接I/O操作上层封装类</li>
</ul>
<h4 id="Transmitter-newExchange"><a href="#Transmitter-newExchange" class="headerlink" title="Transmitter.newExchange"></a>Transmitter.newExchange</h4><ul>
<li>获取连接 RealConnection</li>
<li>构造连接的编码器，ExchangeCodec</li>
<li>创建Exchange，它主要负责HTTP连接的维护管理及通知ExchangeCodec编码器进行实际的I/O操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 建立连接初始方法，获取连接后，会创建一个ExchangeCodec用于I&#x2F;O工作</span><br><span class="line">  val codec &#x3D; exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)</span><br><span class="line">  &#x2F;&#x2F; 创建一个 Exchange </span><br><span class="line">  val result &#x3D; Exchange(this, call, eventListener, exchangeFinder!!, codec)</span><br><span class="line"></span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    this.exchange &#x3D; result</span><br><span class="line">    this.exchangeRequestDone &#x3D; false</span><br><span class="line">    this.exchangeResponseDone &#x3D; false</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ExchangeFinder-find"><a href="#ExchangeFinder-find" class="headerlink" title="ExchangeFinder.find"></a>ExchangeFinder.find</h4><ul>
<li>获取连接 RealConnection</li>
<li>构造连接的编码器，ExchangeCodec</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fun find(</span><br><span class="line">  client: OkHttpClient,</span><br><span class="line">  chain: Interceptor.Chain,</span><br><span class="line">  doExtensiveHealthChecks: Boolean</span><br><span class="line">): ExchangeCodec &#123;</span><br><span class="line">  val connectTimeout &#x3D; chain.connectTimeoutMillis()</span><br><span class="line">  val readTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">  val writeTimeout &#x3D; chain.writeTimeoutMillis()</span><br><span class="line">  val pingIntervalMillis &#x3D; client.pingIntervalMillis</span><br><span class="line">  val connectionRetryEnabled &#x3D; client.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取有效连接</span><br><span class="line">    val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">        connectTimeout &#x3D; connectTimeout,</span><br><span class="line">        readTimeout &#x3D; readTimeout,</span><br><span class="line">        writeTimeout &#x3D; writeTimeout,</span><br><span class="line">        pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled &#x3D; connectionRetryEnabled,</span><br><span class="line">        doExtensiveHealthChecks &#x3D; doExtensiveHealthChecks</span><br><span class="line">    )</span><br><span class="line">    &#x2F;&#x2F; 创建 编码器</span><br><span class="line">    return resultConnection.newCodec(client, chain)</span><br><span class="line">  &#125; catch (e: RouteException) &#123;</span><br><span class="line">    trackFailure()</span><br><span class="line">    throw e</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    trackFailure()</span><br><span class="line">    throw RouteException(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ExchangeFinder-findHealthyConnection"><a href="#ExchangeFinder-findHealthyConnection" class="headerlink" title="ExchangeFinder.findHealthyConnection"></a>ExchangeFinder.findHealthyConnection</h4><ul>
<li>执行获取连接方法，获取连接</li>
<li>如果连接是新创建的连接，则直接返回结果</li>
<li>如果连接是复用连接池的连接，则继续判断该连接是否可用，可用则返回，不可用则继续find</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private fun findHealthyConnection(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   connectionRetryEnabled: Boolean,</span><br><span class="line">   doExtensiveHealthChecks: Boolean</span><br><span class="line"> ): RealConnection &#123;</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     &#x2F;&#x2F; 执行连接获取方法</span><br><span class="line">     val candidate &#x3D; findConnection(</span><br><span class="line">         connectTimeout &#x3D; connectTimeout,</span><br><span class="line">         readTimeout &#x3D; readTimeout,</span><br><span class="line">         writeTimeout &#x3D; writeTimeout,</span><br><span class="line">         pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">         connectionRetryEnabled &#x3D; connectionRetryEnabled</span><br><span class="line">     )</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 新创建的连接，无需判断可用，可以直接返回连接结果</span><br><span class="line">     synchronized(connectionPool) &#123;</span><br><span class="line">       if (candidate.successCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         return candidate</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 判断该连接是否可用</span><br><span class="line">     if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">       candidate.noNewExchanges()</span><br><span class="line">       continue</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return candidate</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ExchangeFinder-findConnection"><a href="#ExchangeFinder-findConnection" class="headerlink" title="ExchangeFinder.findConnection"></a>ExchangeFinder.findConnection</h4><p>获取连接过程</p>
<ol>
<li>第一次，先从连接池获取连接</li>
<li>第二次，选择新的路由，再次尝试从连接池获取</li>
<li>构造一个新的连接</li>
<li>第三次，在高并发情况下，尝试走HTTP2的多路复用连接</li>
<li>如果连接池没有获取到连接，则走构造的那个新的连接，新的连接会加入到连接池</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">private fun findConnection(</span><br><span class="line">  connectTimeout: Int,</span><br><span class="line">  readTimeout: Int,</span><br><span class="line">  writeTimeout: Int,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  connectionRetryEnabled: Boolean</span><br><span class="line">): RealConnection &#123;</span><br><span class="line">  var foundPooledConnection &#x3D; false</span><br><span class="line">  var result: RealConnection? &#x3D; null</span><br><span class="line">  var selectedRoute: Route? &#x3D; null</span><br><span class="line">  var releasedConnection: RealConnection?</span><br><span class="line">  val toClose: Socket?</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    hasStreamFailure &#x3D; false</span><br><span class="line">    &#x2F;&#x2F; 之前的连接 </span><br><span class="line">    releasedConnection &#x3D; transmitter.connection</span><br><span class="line">    &#x2F;&#x2F; 前连接不为null 且不支持新的ExChange了则释放连接 否则toClose 赋值null</span><br><span class="line">    toClose &#x3D; if (transmitter.connection !&#x3D; null &amp;&amp; transmitter.connection!!.noNewExchanges) &#123;</span><br><span class="line">      transmitter.releaseConnectionNoEvents()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      null</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (transmitter.connection !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 之前的连接可用，直接赋值result</span><br><span class="line">      result &#x3D; transmitter.connection</span><br><span class="line">      releasedConnection &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有可用连接，则尝试获取新的连接</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 先从连接池获取链接</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">        selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">        nextRouteToTry &#x3D; null</span><br><span class="line">      &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">        selectedRoute &#x3D; transmitter.connection!!.route()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果等待close的连接不为null则关闭掉</span><br><span class="line">  toClose?.closeQuietly()</span><br><span class="line">  &#x2F;&#x2F; 释放的连接不为空，事件通知连接回收</span><br><span class="line">  if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">    eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 连接池获取的连接不为空，事件通知连接连接获得</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  &#125;</span><br><span class="line">  if (result !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到了连接，返回连接，结束方法</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果至此没有获取到可用连接，则尝试更改路由，在连接</span><br><span class="line">  var newRouteSelection &#x3D; false</span><br><span class="line">  if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">    &#x2F;&#x2F; 有新的路由，则标记选了新的路由，以及获取新的路由</span><br><span class="line">    newRouteSelection &#x3D; true</span><br><span class="line">    routeSelection &#x3D; routeSelector.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">    if (newRouteSelection) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果更改了路由，则有新的一批地址，尝试从新的一批地址获取可用连接</span><br><span class="line">      routes &#x3D; routeSelection!!.routes</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">              address, transmitter, routes, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    if (!foundPooledConnection) &#123;</span><br><span class="line">      if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">        selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果仍然没有获取到可用连接，则直接创建一个新的连接实例</span><br><span class="line">      result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">      connectingConnection &#x3D; result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果第二次从连接池中找到了可用连接，则直接返回该连接</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果没有找到直接用的连接，则尝试TCP+TLC握手（阻塞过程）</span><br><span class="line">  result!!.connect(</span><br><span class="line">      connectTimeout,</span><br><span class="line">      readTimeout,</span><br><span class="line">      writeTimeout,</span><br><span class="line">      pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled,</span><br><span class="line">      call,</span><br><span class="line">      eventListener</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 连接 可用，则从路由黑名单中移除 该路由地址</span><br><span class="line">  connectionPool.routeDatabase.connected(result!!.route())</span><br><span class="line">  </span><br><span class="line">  var socket: Socket? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    connectingConnection &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 最后一次尝试连接 （这个只在一个host多个并发连接情况下发生）</span><br><span class="line">    if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果成功，则优先使用连接池的连接，并关闭之前创建的连接socket</span><br><span class="line">      result!!.noNewExchanges &#x3D; true</span><br><span class="line">      socket &#x3D; result!!.socket()</span><br><span class="line">      result &#x3D; transmitter.connection</span><br><span class="line"></span><br><span class="line">      nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 没有从连接池获取到连接，则把之前创建的连接存储进入</span><br><span class="line">      connectionPool.put(result!!)</span><br><span class="line">      transmitter.acquireConnectionNoEvents(result!!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  return result!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h4><p>OkHttpClient.Builder构造时，会默认构造一个连接池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> class Builder constructor() &#123;</span><br><span class="line">    internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConnectionPool"><a href="#ConnectionPool" class="headerlink" title="ConnectionPool"></a>ConnectionPool</h4><p>连接池，管理HTTP 和HTTP/2的所有连接，维护一定的连接，清理超过配置的连接，及提供可复用的连接。<br>默认最大空闲连接数目5个，最长连接时长5分钟</p>
<p>结构：内部持有delegate为RealConnectionPool，它是连接池管理的逻辑实现类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ConnectionPool internal constructor(</span><br><span class="line">  internal val delegate: RealConnectionPool &#x2F;&#x2F; 连接池管理逻辑真正实现类</span><br><span class="line">) &#123;</span><br><span class="line">  constructor(</span><br><span class="line">    maxIdleConnections: Int,</span><br><span class="line">    keepAliveDuration: Long,</span><br><span class="line">    timeUnit: TimeUnit</span><br><span class="line">  ) : this(RealConnectionPool(</span><br><span class="line">      taskRunner &#x3D; TaskRunner.INSTANCE, &#x2F;&#x2F; 工作线程</span><br><span class="line">      maxIdleConnections &#x3D; maxIdleConnections, &#x2F;&#x2F; 最大空闲连接数5</span><br><span class="line">      keepAliveDuration &#x3D; keepAliveDuration, &#x2F;&#x2F; 最长连接时长5min</span><br><span class="line">      timeUnit &#x3D; timeUnit</span><br><span class="line">  ))</span><br><span class="line"></span><br><span class="line">  constructor() : this(5, 5, TimeUnit.MINUTES)</span><br><span class="line"></span><br><span class="line">  fun idleConnectionCount(): Int &#x3D; delegate.idleConnectionCount()</span><br><span class="line"></span><br><span class="line">  fun connectionCount(): Int &#x3D; delegate.connectionCount()</span><br><span class="line"></span><br><span class="line">  &#x2F;** Close and remove all idle connections in the pool. *&#x2F;</span><br><span class="line">  fun evictAll() &#123;</span><br><span class="line">    delegate.evictAll()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-transmitterAcquirePooledConnection"><a href="#RealConnectionPool-transmitterAcquirePooledConnection" class="headerlink" title="RealConnectionPool.transmitterAcquirePooledConnection"></a>RealConnectionPool.transmitterAcquirePooledConnection</h4><p>前面我们知道Transmitter持有ConnectionPool，且看它持有的变量是直接以RealConnectionPool作为类型的，可以显示执行到它的其它方法<br>transmitterAcquirePooledConnection尝试获取连接池中的连接，达到复用连接的目的<br>一共两种情况可以使用复用的连接，1.需要多路复用连接且有支持多路复用的连接；2.能给目标Address分配stream的连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun transmitterAcquirePooledConnection(</span><br><span class="line">  address: Address,</span><br><span class="line">  transmitter: Transmitter,</span><br><span class="line">  routes: List&lt;Route&gt;?,</span><br><span class="line">  requireMultiplexed: Boolean</span><br><span class="line">): Boolean &#123;</span><br><span class="line">  this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  for (connection in connections) &#123;</span><br><span class="line">    &#x2F;&#x2F; 需要复用连接 &amp;&amp; 该连接不支持复用连接（HTTP2） 则该连接不可用</span><br><span class="line">    if (requireMultiplexed &amp;&amp; !connection.isMultiplexed) continue</span><br><span class="line">    &#x2F;&#x2F; 如果该连接可以给对应的 address 分配stream 则返回true</span><br><span class="line">    if (!connection.isEligible(address, routes)) continue</span><br><span class="line">    &#x2F;&#x2F; 满足条件下，获取</span><br><span class="line">    transmitter.acquireConnectionNoEvents(connection)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-acquireConnectionNoEvents"><a href="#RealConnectionPool-acquireConnectionNoEvents" class="headerlink" title="RealConnectionPool.acquireConnectionNoEvents"></a>RealConnectionPool.acquireConnectionNoEvents</h4><p>获取连接，然后在连接实例中的transmitters中添加对应承载的Transmitter弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun acquireConnectionNoEvents(connection: RealConnection) &#123;</span><br><span class="line">  connectionPool.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  check(this.connection &#x3D;&#x3D; null)</span><br><span class="line">  this.connection &#x3D; connection</span><br><span class="line">  &#x2F;&#x2F; 连接的transmitters集合添加一个弱引用</span><br><span class="line">  connection.transmitters.add(TransmitterReference(this, callStackTrace))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-put"><a href="#RealConnectionPool-put" class="headerlink" title="RealConnectionPool.put"></a>RealConnectionPool.put</h4><p>ExchangeFinder最后find的connection是创建的新的connection，则会执行Pool的put新连接方法<br>put方法 先将新的连接添加到连接集合中，然后执行清理任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun put(connection: RealConnection) &#123;</span><br><span class="line">  this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  connections.add(connection)</span><br><span class="line">  cleanupQueue.schedule(cleanupTask) &#x2F;&#x2F; 执行清理任务一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-cleanup"><a href="#RealConnectionPool-cleanup" class="headerlink" title="RealConnectionPool.cleanup"></a>RealConnectionPool.cleanup</h4><p>对连接池的连接进行维护，主要是清理长时间无用的连接（超过空闲连接个数且超过最大空闲时长）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">fun cleanup(now: Long): Long &#123;</span><br><span class="line">    var inUseConnectionCount &#x3D; 0</span><br><span class="line">    var idleConnectionCount &#x3D; 0</span><br><span class="line">    var longestIdleConnection: RealConnection? &#x3D; null</span><br><span class="line">    var longestIdleDurationNs &#x3D; Long.MIN_VALUE</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      for (connection in connections) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果该连接正在被使用，则继续遍历，使用连接数+1</span><br><span class="line">        if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123;</span><br><span class="line">          inUseConnectionCount++</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 空闲连接数+1</span><br><span class="line">        idleConnectionCount++</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 记录最长空闲时长，以及最长空闲时长对应的连接</span><br><span class="line">        val idleDurationNs &#x3D; now - connection.idleAtNanos</span><br><span class="line">        if (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs &#x3D; idleDurationNs</span><br><span class="line">          longestIdleConnection &#x3D; connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      when &#123;</span><br><span class="line">        &#x2F;&#x2F; 当连接最长空闲时长大于配置的时长 &amp; 空闲连接个是&gt; 配置的个数</span><br><span class="line">        longestIdleDurationNs &gt;&#x3D; this.keepAliveDurationNs</span><br><span class="line">            || idleConnectionCount &gt; this.maxIdleConnections -&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 则移除 最大的那个空闲连接</span><br><span class="line">          connections.remove(longestIdleConnection)</span><br><span class="line">          &#x2F;&#x2F; 如果连接为空了，则停止所有的清除任务</span><br><span class="line">          if (connections.isEmpty()) cleanupQueue.cancelAll()</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 其它情况则结束语句</span><br><span class="line">        ...      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 关闭被移除的连接，释放资源</span><br><span class="line">    longestIdleConnection!!.socket().closeQuietly()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cleanup again immediately.</span><br><span class="line">    return 0L</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="RealConnection-connect"><a href="#RealConnection-connect" class="headerlink" title="RealConnection.connect"></a>RealConnection.connect</h4><p>连接操作，根据是否代理会做两个逻辑区分，最后都是执行socket连接，然后进行协议的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">fun connect(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    call: Call,</span><br><span class="line">    eventListener: EventListener</span><br><span class="line">  ) &#123;</span><br><span class="line">    check(protocol &#x3D;&#x3D; null) &#123; &quot;already connected&quot; &#125;</span><br><span class="line"></span><br><span class="line">    var routeException: RouteException? &#x3D; null</span><br><span class="line">    val connectionSpecs &#x3D; route.address.connectionSpecs</span><br><span class="line">    val connectionSpecSelector &#x3D; ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否走代理通道， 即一个HTTPS请求 但是其有HTTP的代理通道</span><br><span class="line">        if (route.requiresTunnel()) &#123;</span><br><span class="line">          &#x2F;&#x2F; 通过代理通道建立连接 ，也叫隧道连接</span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">          if (rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; We were </span><br><span class="line">            break</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 建立连接</span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        &#125;</span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">        break</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        ... &#x2F;&#x2F; 异常处理</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (route.requiresTunnel() &amp;&amp; rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw RouteException(ProtocolException(</span><br><span class="line">          &quot;Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-connectSocket"><a href="#RealConnection-connectSocket" class="headerlink" title="RealConnection.connectSocket"></a>RealConnection.connectSocket</h4><ul>
<li>创建原生Socket</li>
<li>进行Socket连接，至此对应的底层Socket通道已经建立</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private fun connectSocket(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   val proxy &#x3D; route.proxy</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line">   &#x2F;&#x2F; 创建原生Socket</span><br><span class="line">   val rawSocket &#x3D; when (proxy.type()) &#123;</span><br><span class="line">     Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">     else -&gt; Socket(proxy)</span><br><span class="line">   &#125;</span><br><span class="line">   this.rawSocket &#x3D; rawSocket</span><br><span class="line">   &#x2F;&#x2F; 发送开始连接事件</span><br><span class="line">   eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">   rawSocket.soTimeout &#x3D; readTimeout</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 找应用对应的平台 进行连接</span><br><span class="line">     Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">   &#125; catch (e: ConnectException) &#123;</span><br><span class="line">     throw ConnectException(&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;).apply &#123;</span><br><span class="line">       initCause(e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-establishProtocol"><a href="#RealConnection-establishProtocol" class="headerlink" title="RealConnection.establishProtocol"></a>RealConnection.establishProtocol</h4><p>前面已经建立Socket连接通道，现在是对各个协议进行支持</p>
<ul>
<li>非HTTPS，1. 支持HTTP2情况下，优先走HTTP/2协议连接，2. 不支持，则走HTTP/1协议</li>
<li>HTTPS，则先进行TLS握手，握手成功后，如果是HTTP/2协议，则走HTTP/2连接方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private fun establishProtocol(</span><br><span class="line">  connectionSpecSelector: ConnectionSpecSelector,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  call: Call,</span><br><span class="line">  eventListener: EventListener</span><br><span class="line">) &#123;</span><br><span class="line">  if (route.address.sslSocketFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">      &#x2F;&#x2F; 非HTTPS，支持HTTP2，优先走HTTP2</span><br><span class="line">      socket &#x3D; rawSocket</span><br><span class="line">      protocol &#x3D; Protocol.H2_PRIOR_KNOWLEDGE</span><br><span class="line">      startHttp2(pingIntervalMillis)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socket &#x3D; rawSocket</span><br><span class="line">    protocol &#x3D; Protocol.HTTP_1_1</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 加密连接开始</span><br><span class="line">  eventListener.secureConnectStart(call)</span><br><span class="line">  &#x2F;&#x2F; 开始Tls连接</span><br><span class="line">  connectTls(connectionSpecSelector)</span><br><span class="line">  &#x2F;&#x2F; 加密连接结束</span><br><span class="line">  eventListener.secureConnectEnd(call, handshake)</span><br><span class="line"></span><br><span class="line">  if (protocol &#x3D;&#x3D;&#x3D; Protocol.HTTP_2) &#123;</span><br><span class="line">    startHttp2(pingIntervalMillis)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-connectTls"><a href="#RealConnection-connectTls" class="headerlink" title="RealConnection.connectTls"></a>RealConnection.connectTls</h4><p>进行Tls连接</p>
<ul>
<li>基于之前的原生Socket建立包装的SSLSocket</li>
<li>对SSLSocket进行相关安全信息的配置</li>
<li>通过SSLSocket进行握手，及握手过程中，进行一些证书信息校验</li>
<li>握手成功，构建对应连接的source及sink读写流</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) &#123;</span><br><span class="line">  val address &#x3D; route.address</span><br><span class="line">  val sslSocketFactory &#x3D; address.sslSocketFactory</span><br><span class="line">  var success &#x3D; false</span><br><span class="line">  var sslSocket: SSLSocket? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 基于之前创建的原生Socket 建立一个SSLSocket</span><br><span class="line">    sslSocket &#x3D; sslSocketFactory!!.createSocket(</span><br><span class="line">        rawSocket, address.url.host, address.url.port, true &#x2F;* autoClose *&#x2F;) as SSLSocket</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对sslSocket进行 安全连接的配置 以及Tls的扩展配置</span><br><span class="line">    val connectionSpec &#x3D; connectionSpecSelector.configureSecureSocket(sslSocket)</span><br><span class="line">    if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">      Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 开始握手</span><br><span class="line">    sslSocket.startHandshake()</span><br><span class="line">    &#x2F;&#x2F; 获取sslSession</span><br><span class="line">    val sslSocketSession &#x3D; sslSocket.session</span><br><span class="line">    val unverifiedHandshake &#x3D; sslSocketSession.handshake()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 验证证书对主机是否ok </span><br><span class="line">    if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123;</span><br><span class="line">      val peerCertificates &#x3D; unverifiedHandshake.peerCertificates</span><br><span class="line">      if (peerCertificates.isNotEmpty()) &#123;</span><br><span class="line">        val cert &#x3D; peerCertificates[0] as X509Certificate</span><br><span class="line">        throw SSLPeerUnverifiedException(&quot;&quot;&quot;</span><br><span class="line">            |Hostname $&#123;address.url.host&#125; not verified:</span><br><span class="line">            |    certificate: $&#123;CertificatePinner.pin(cert)&#125;</span><br><span class="line">            |    DN: $&#123;cert.subjectDN.name&#125;</span><br><span class="line">            |    subjectAltNames: $&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125;</span><br><span class="line">            &quot;&quot;&quot;.trimMargin())</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw SSLPeerUnverifiedException(</span><br><span class="line">            &quot;Hostname $&#123;address.url.host&#125; not verified (no certificates)&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val certificatePinner &#x3D; address.certificatePinner!!</span><br><span class="line"></span><br><span class="line">    handshake &#x3D; Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,</span><br><span class="line">        unverifiedHandshake.localCertificates) &#123;</span><br><span class="line">      certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,</span><br><span class="line">          address.url.host)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the certificate pinner is satisfied by the certificates presented.</span><br><span class="line">    certificatePinner.check(address.url.host) &#123;</span><br><span class="line">      handshake!!.peerCertificates.map &#123; it as X509Certificate &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Success! Save the handshake and the ALPN protocol.</span><br><span class="line">    val maybeProtocol &#x3D; if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">      Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      null</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 握手成功，获取source和sink流</span><br><span class="line">    socket &#x3D; sslSocket</span><br><span class="line">    source &#x3D; sslSocket.source().buffer()</span><br><span class="line">    sink &#x3D; sslSocket.sink().buffer()</span><br><span class="line">    protocol &#x3D; if (maybeProtocol !&#x3D; null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1</span><br><span class="line">    success &#x3D; true</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (sslSocket !&#x3D; null) &#123;</span><br><span class="line">      Platform.get().afterHandshake(sslSocket)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">      sslSocket?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-startHttp2"><a href="#RealConnection-startHttp2" class="headerlink" title="RealConnection.startHttp2"></a>RealConnection.startHttp2</h4><p>构建一个Http2Connection，然后启动HTTP/2协议连接，<br>http2连接实现是OkHttp中http2的包模块进行实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private fun startHttp2(pingIntervalMillis: Int) &#123;</span><br><span class="line">  val socket &#x3D; this.socket!!  </span><br><span class="line">  val source &#x3D; this.source!!</span><br><span class="line">  val sink &#x3D; this.sink!!</span><br><span class="line">  socket.soTimeout &#x3D; 0 </span><br><span class="line">  &#x2F;&#x2F; 构建Http2Connection ，然后启动</span><br><span class="line">  val http2Connection &#x3D; Http2Connection.Builder(client &#x3D; true, taskRunner &#x3D; TaskRunner.INSTANCE)</span><br><span class="line">      .socket(socket, route.address.url.host, source, sink)</span><br><span class="line">      .listener(this) &#x2F;&#x2F; 添加RealConnection作为listerner</span><br><span class="line">      .pingIntervalMillis(pingIntervalMillis)</span><br><span class="line">      .build()</span><br><span class="line">  this.http2Connection &#x3D; http2Connection</span><br><span class="line">  this.allocationLimit &#x3D; Http2Connection.DEFAULT_SETTINGS.getMaxConcurrentStreams()</span><br><span class="line">  http2Connection.start() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-newCodec"><a href="#RealConnection-newCodec" class="headerlink" title="RealConnection.newCodec"></a>RealConnection.newCodec</h4><p>构造编码器，Http2ExchangeCodec 或者 Http1ExchangeCodec，它们的作用封装了对请求和响应的读写操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Throws(SocketException::class)</span><br><span class="line">internal fun newCodec(client: OkHttpClient, chain: Interceptor.Chain): ExchangeCodec &#123;</span><br><span class="line">  val socket &#x3D; this.socket!!</span><br><span class="line">  val source &#x3D; this.source!!</span><br><span class="line">  val sink &#x3D; this.sink!!</span><br><span class="line">  val http2Connection &#x3D; this.http2Connection</span><br><span class="line"></span><br><span class="line">  return if (http2Connection !&#x3D; null) &#123;</span><br><span class="line">    Http2ExchangeCodec(client, this, chain, http2Connection)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    socket.soTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">    source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)</span><br><span class="line">    sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)</span><br><span class="line">    Http1ExchangeCodec(client, this, source, sink)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HTTP2连接"><a href="#HTTP2连接" class="headerlink" title="HTTP2连接"></a>HTTP2连接</h3><h4 id="Http2Connection-start"><a href="#Http2Connection-start" class="headerlink" title="Http2Connection.start"></a>Http2Connection.start</h4><p>配置HTTP2的请求前置信息，开启线程进行连接前置的信息读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun start(sendConnectionPreface: Boolean &#x3D; true) &#123;</span><br><span class="line">  if (sendConnectionPreface) &#123; &#x2F;&#x2F; 必为true</span><br><span class="line">    &#x2F;&#x2F; 配置“连接前奏”，每个端点都需要发送连接前奏作为正在使用的协议的最终确认，并建立 HTTP&#x2F;2 连接的初始设置。</span><br><span class="line">    writer.connectionPreface() </span><br><span class="line">    writer.settings(okHttpSettings)</span><br><span class="line">    val windowSize &#x3D; okHttpSettings.initialWindowSize</span><br><span class="line">    if (windowSize !&#x3D; DEFAULT_INITIAL_WINDOW_SIZE) &#123;</span><br><span class="line">      writer.windowUpdate(0, (windowSize - DEFAULT_INITIAL_WINDOW_SIZE).toLong())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 开启线程 进行连接前奏的读取工作</span><br><span class="line">  Thread(readerRunnable, connectionName).start() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http2Connection-ReaderRunnable"><a href="#Http2Connection-ReaderRunnable" class="headerlink" title="Http2Connection.ReaderRunnable"></a>Http2Connection.ReaderRunnable</h4><p>读取连接前奏信息，确认连接正常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">inner class ReaderRunnable internal constructor(</span><br><span class="line">  internal val reader: Http2Reader</span><br><span class="line">) : Runnable, Http2Reader.Handler &#123;</span><br><span class="line">  override fun run() &#123;</span><br><span class="line">    var connectionErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">    var streamErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">    var errorException: IOException? &#x3D; null</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 读取连接前奏信息</span><br><span class="line">      reader.readConnectionPreface(this)</span><br><span class="line">      while (reader.nextFrame(false, this)) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      connectionErrorCode &#x3D; ErrorCode.NO_ERROR</span><br><span class="line">      streamErrorCode &#x3D; ErrorCode.CANCEL</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      errorException &#x3D; e</span><br><span class="line">      connectionErrorCode &#x3D; ErrorCode.PROTOCOL_ERROR</span><br><span class="line">      streamErrorCode &#x3D; ErrorCode.PROTOCOL_ERROR</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      close(connectionErrorCode, streamErrorCode, errorException)</span><br><span class="line">      reader.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/097b1904f580" target="_blank" rel="noopener">下一篇 OkHttp 4源码（5）— 请求和响应 I/O操作</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89%E2%80%94%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89%E2%80%94%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 4源码（3）—缓存机制分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 10:32:35" itemprop="dateCreated datePublished" datetime="2020-01-13T10:32:35+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:59:23" itemprop="dateModified" datetime="2020-02-07T00:59:23+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a href="https://www.jianshu.com/p/6ec0d13d85bb" target="_blank" rel="noopener">HTTP缓存原理</a><br><img src="https://upload-images.jianshu.io/upload_images/9696036-e9f7b43d56529039.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP缓存流程图"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-5ced29d142fd9623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>缓存处理流程<br><img src="https://upload-images.jianshu.io/upload_images/9696036-9a68e72386c130ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>缓存文件夹<br><img src="https://upload-images.jianshu.io/upload_images/9696036-265537b559561175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>缓存日志格式<br><img src="https://upload-images.jianshu.io/upload_images/9696036-f083541448afa4a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>如果需要缓存机制，那么在构造OkHttpClient的时候需要传入一个Cache实例。<br>下面是OkHttp提供的一个CacheResponse的用例，除了传入一个Cache构造OkHttpClient，其它完全一样。<br>OkHttp实现缓存的切入点依旧是拦截器，之前的文章我们知道拦截器处理对象可以接受命令对象并根据自身情况选择处理还是不处理，所以接下来就是直接从CacheInterceptor开始分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final class CacheResponse &#123;</span><br><span class="line">  private final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public CacheResponse(File cacheDirectory) throws Exception &#123;</span><br><span class="line">    int cacheSize &#x3D; 10 * 1024 * 1024; &#x2F;&#x2F; 10 MiB 大小</span><br><span class="line">    Cache cache &#x3D; new Cache(cacheDirectory, cacheSize); &#x2F;&#x2F; 路径</span><br><span class="line">    &#x2F;&#x2F; 要使用缓存功能，需要在构造OkHttpClient的时候传入 cache （缓存大小，缓存路径地址）</span><br><span class="line">    client &#x3D; new OkHttpClient.Builder()</span><br><span class="line">        .cache(cache)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run() throws Exception &#123;</span><br><span class="line">    Request request &#x3D; new Request.Builder()</span><br><span class="line">        .url(&quot;http:&#x2F;&#x2F;publicobject.com&#x2F;helloworld.txt&quot;)</span><br><span class="line">        .build();</span><br><span class="line">    </span><br><span class="line">    String response1Body;</span><br><span class="line">    try (Response response1 &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String response2Body;</span><br><span class="line">    try (Response response2 &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两次请求结果一致</span><br><span class="line">    System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) throws Exception &#123;</span><br><span class="line">    new CacheResponse(new File(&quot;CacheResponse.tmp&quot;)).run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存拦截器逻辑"><a href="#缓存拦截器逻辑" class="headerlink" title="缓存拦截器逻辑"></a>缓存拦截器逻辑</h3><h4 id="CacheInterceptor-intercept"><a href="#CacheInterceptor-intercept" class="headerlink" title="CacheInterceptor.intercept"></a>CacheInterceptor.intercept</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; </span><br><span class="line">   val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">   val now &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">   val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">   val networkRequest &#x3D; strategy.networkRequest</span><br><span class="line">   val cacheResponse &#x3D; strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 缓存追踪，网络请求数、命中缓存数，两者比值可以查看缓存命中率</span><br><span class="line">   cache?.trackResponse(strategy)</span><br><span class="line"></span><br><span class="line">   if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">     cacheCandidate.body?.closeQuietly()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 异常情况</span><br><span class="line">   if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return Response.Builder()</span><br><span class="line">         .request(chain.request())</span><br><span class="line">         .protocol(Protocol.HTTP_1_1)</span><br><span class="line">         .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">         .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">         .body(EMPTY_RESPONSE)</span><br><span class="line">         .sentRequestAtMillis(-1L)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果networkRequest为null，则直接使用缓存数据，拦截器处理至此终结，开始响应阶段</span><br><span class="line">   if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return cacheResponse!!.newBuilder()</span><br><span class="line">         .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   var networkResponse: Response? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 继续执行 拦截器链处理方法，最终发送网络请求，到读取网络数据</span><br><span class="line">     networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">       cacheCandidate.body?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">     if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123; &#x2F;&#x2F; 304</span><br><span class="line">     &#x2F;&#x2F; 如果网络数据标志性没有改变，开始返回数据</span><br><span class="line">       val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">           .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">           .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">           .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">           .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">           .networkResponse(stripBody(networkResponse))</span><br><span class="line">           .build()</span><br><span class="line"></span><br><span class="line">       networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">       &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">       cache!!.trackConditionalCacheHit()</span><br><span class="line">       cache.update(cacheResponse, response)</span><br><span class="line">       return response</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       cacheResponse.body?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">       .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">       .networkResponse(stripBody(networkResponse))</span><br><span class="line">       .build()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   if (cache !&#x3D; null) &#123;</span><br><span class="line">     if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">       &#x2F;&#x2F; 对响应数据进行缓存</span><br><span class="line">       val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">       &#x2F;&#x2F; 返回一个带有new Source的body读取流 的 Response</span><br><span class="line">       return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">     &#125;</span><br><span class="line">       </span><br><span class="line">     if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         cache.remove(networkRequest)</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return response</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存获取逻辑"><a href="#缓存获取逻辑" class="headerlink" title="缓存获取逻辑"></a>缓存获取逻辑</h3><h4 id="Cache-get"><a href="#Cache-get" class="headerlink" title="Cache.get"></a>Cache.get</h4><ul>
<li>生成请求对应的唯一标志key</li>
<li>通过DiskLruCache获取对应key的缓存快照数据</li>
<li>如果有快照，则将快照对应的缓存资源数据通过Okio中流读写转换成内存数据</li>
<li>最后返回构造好的Response</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">internal fun get(request: Request): Response? &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据请求url字符串进行md5作为缓存对应的key标识</span><br><span class="line">  val key &#x3D; key(request.url)</span><br><span class="line">  &#x2F;&#x2F; Cache成员变量DiskLruCache，缓存逻辑实现类</span><br><span class="line">  &#x2F;&#x2F; snapshot</span><br><span class="line">  val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">    &#x2F;&#x2F; 从DiskLruCache中取缓存</span><br><span class="line">    cache[key] ?: return null</span><br><span class="line">  &#125; catch (_: IOException) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 读取快照中的缓存资源流 ，构造数据Entry</span><br><span class="line">  val entry: Entry &#x3D; try &#123;</span><br><span class="line">    Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">  &#125; catch (_: IOException) &#123;</span><br><span class="line">    snapshot.closeQuietly()</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 取 response</span><br><span class="line">  val response &#x3D; entry.response(snapshot)</span><br><span class="line">  if (!entry.matches(request, response)) &#123; </span><br><span class="line">    response.body?.closeQuietly() &#x2F;&#x2F; 响应和请求 不匹配则关闭</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response &#x2F;&#x2F; 返回响应数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cache-Entry-构造"><a href="#Cache-Entry-构造" class="headerlink" title="Cache.Entry 构造"></a>Cache.Entry 构造</h4><p>缓存数据实例，DiskLruCache中lruEntries存储了请求key对应的快照，快照里有key对应的本地文件读取流，根据读取流读取本地数据，转换输出构造Entry实例，最终应用构造出一个缓存的Response</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">internal constructor(rawSource: Source) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        val source &#x3D; rawSource.buffer()</span><br><span class="line">        &#x2F;&#x2F; 从缓存文件流中 读取数据 ，写入到Entry中</span><br><span class="line">        ... &#x2F;&#x2F; 一堆 读取流 写入内存操作</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">        rawSource.close()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="DiskLruCache-get"><a href="#DiskLruCache-get" class="headerlink" title="DiskLruCache.get"></a>DiskLruCache.get</h4><ul>
<li>初始化或者确认初始化（主要目的是将key和对应缓存本地文件标识存储到内存Map中，便于查询）</li>
<li>如果找到了就返回一个快照对象，没有则为null</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">operator fun get(key: String): Snapshot? &#123;</span><br><span class="line">  initialize() &#x2F;&#x2F; 初始化 || 确认已经初始化</span><br><span class="line"></span><br><span class="line">  checkNotClosed() &#x2F;&#x2F; check cache是否关闭</span><br><span class="line">  validateKey(key) &#x2F;&#x2F; 确认key 符合 写入的规则</span><br><span class="line">  &#x2F;&#x2F; 找key对应的缓存entry</span><br><span class="line">  val entry &#x3D; lruEntries[key] ?: return null </span><br><span class="line">  if (!entry.readable) return null</span><br><span class="line">  &#x2F;&#x2F; 有缓存entry 取对应的快照</span><br><span class="line">  val snapshot &#x3D; entry.snapshot() ?: return null</span><br><span class="line">  &#x2F;&#x2F; 标识一次操作</span><br><span class="line">  redundantOpCount++ </span><br><span class="line">  &#x2F;&#x2F; 写入 标记READ 和对应 key 一行</span><br><span class="line">  journalWriter!!.writeUtf8(READ)</span><br><span class="line">      .writeByte(&#39; &#39;.toInt())</span><br><span class="line">      .writeUtf8(key)</span><br><span class="line">      .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">  &#x2F;&#x2F; 如果操作&gt;2000次了，则需要重新清理 日志 </span><br><span class="line">  if (journalRebuildRequired()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行清理任务</span><br><span class="line">    cleanupQueue.schedule(cleanupTask)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回快照</span><br><span class="line">  return snapshot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-initialize"><a href="#DiskLruCache-initialize" class="headerlink" title="DiskLruCache.initialize"></a>DiskLruCache.initialize</h4><ul>
<li>整理日志文件，删除backup或者重命名bakcup日志文件</li>
<li>读取日志文件，生成lruEntries内存缓存</li>
<li>处理日志文件</li>
<li>按需是否重新构建日志文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化方法</span><br><span class="line">fun initialize() &#123;</span><br><span class="line">   this.assertThreadHoldsLock()</span><br><span class="line">   &#x2F;&#x2F; 是否已经初始化 ，内存缓存</span><br><span class="line">   if (initialized) &#123;</span><br><span class="line">     return &#x2F;&#x2F; Already initialized.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 开始初始化工作</span><br><span class="line">   &#x2F;&#x2F; 如果存在backup的日志文件，</span><br><span class="line">   &#x2F;&#x2F; 则看是否存在日志文件，如果存在日志文件则删除backup的，</span><br><span class="line">   &#x2F;&#x2F; 如果没有则将backup文件转化为日志文件</span><br><span class="line">   if (fileSystem.exists(journalFileBackup)) &#123;</span><br><span class="line">     if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">       fileSystem.delete(journalFileBackup)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       fileSystem.rename(journalFileBackup, journalFile)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; journal文件存在 开始读取工作</span><br><span class="line">   if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       readJournal()</span><br><span class="line">       processJournal()</span><br><span class="line">       initialized &#x3D; true</span><br><span class="line">       return</span><br><span class="line">     &#125; catch (journalIsCorrupt: IOException) &#123;</span><br><span class="line">       Platform.get().log(</span><br><span class="line">           &quot;DiskLruCache $directory is corrupt: $&#123;journalIsCorrupt.message&#125;, removing&quot;,</span><br><span class="line">           WARN,</span><br><span class="line">           journalIsCorrupt)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span><br><span class="line">     &#x2F;&#x2F; we&#39;ll let that propagate out as it likely means there is a severe filesystem problem.</span><br><span class="line">     try &#123;</span><br><span class="line">       delete()</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       closed &#x3D; false</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   rebuildJournal()</span><br><span class="line"></span><br><span class="line">   initialized &#x3D; true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-readJournal"><a href="#DiskLruCache-readJournal" class="headerlink" title="DiskLruCache.readJournal"></a>DiskLruCache.readJournal</h4><ul>
<li>读取日志，判断日志是否可用</li>
<li>日志可用，则读取每行日志，构建Key、Entry的map到内存缓存</li>
<li>如果读取过程中有问题，则根据tmp日志重新构建日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取日志文件，构造[key,entry]内存缓存集合</span><br><span class="line">private fun readJournal() &#123;</span><br><span class="line">  fileSystem.source(journalFile).buffer().use &#123; source -&gt;</span><br><span class="line">    &#x2F;&#x2F; 基于Okio读写本地数据</span><br><span class="line">    &#x2F;&#x2F; libcore.io.DiskLruCache</span><br><span class="line">    val magic &#x3D; source.readUtf8LineStrict() </span><br><span class="line">    val version &#x3D; source.readUtf8LineStrict() &#x2F;&#x2F; 版本 1</span><br><span class="line">    val appVersionString &#x3D; source.readUtf8LineStrict() &#x2F;&#x2F; app version</span><br><span class="line">    val valueCountString &#x3D; source.readUtf8LineStrict()&#x2F;&#x2F; </span><br><span class="line">    val blank &#x3D; source.readUtf8LineStrict()</span><br><span class="line"></span><br><span class="line">    if (MAGIC !&#x3D; magic ||</span><br><span class="line">        VERSION_1 !&#x3D; version ||</span><br><span class="line">        appVersion.toString() !&#x3D; appVersionString ||</span><br><span class="line">        valueCount.toString() !&#x3D; valueCountString ||</span><br><span class="line">        blank.isNotEmpty()) &#123;</span><br><span class="line">      throw IOException(</span><br><span class="line">          &quot;unexpected journal header: [$magic, $version, $valueCountString, $blank]&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var lineCount &#x3D; 0</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 见readJournalLine方法分析（读取key，构造entry）</span><br><span class="line">        readJournalLine(source.readUtf8LineStrict())</span><br><span class="line">        lineCount++</span><br><span class="line">      &#125; catch (_: EOFException) &#123;</span><br><span class="line">        break &#x2F;&#x2F; End of journal.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 无用的line数目</span><br><span class="line">    redundantOpCount &#x3D; lineCount - lruEntries.size</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果读取有无，则重构建日志</span><br><span class="line">    if (!source.exhausted()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 通过Okio读取tmp日志文件重新写Journal文件</span><br><span class="line">      rebuildJournal() </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      journalWriter &#x3D; newJournalWriter() &#x2F;&#x2F; 创建日志writer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-readJournalLine"><a href="#DiskLruCache-readJournalLine" class="headerlink" title="DiskLruCache.readJournalLine"></a>DiskLruCache.readJournalLine</h4><ul>
<li>读取每一行日志</li>
<li>根据行日志属性，CLEAN、DIRTY、REMOVE、READ进行对应的处理</li>
<li>缓存到内存缓存LruEntries的Map中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取每一行日志，存储到LruEntries Map中</span><br><span class="line">private fun readJournalLine(line: String) &#123;</span><br><span class="line">  &#x2F;&#x2F; 找 第一个空格的 指引</span><br><span class="line">  val firstSpace &#x3D; line.indexOf(&#39; &#39;)</span><br><span class="line">  if (firstSpace &#x3D;&#x3D; -1) throw IOException(&quot;unexpected journal line: $line&quot;)</span><br><span class="line">  &#x2F;&#x2F; 从第一个空格指引+1位置开始找第二个空格指引</span><br><span class="line">  val keyBegin &#x3D; firstSpace + 1</span><br><span class="line">  val secondSpace &#x3D; line.indexOf(&#39; &#39;, keyBegin)</span><br><span class="line">  val key: String</span><br><span class="line">  &#x2F;&#x2F; 如果第二个空格指引没有找到</span><br><span class="line">  if (secondSpace &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 截取第一个空格指引到字符串最后的字段，截取的字段赋值key</span><br><span class="line">    key &#x3D; line.substring(keyBegin)</span><br><span class="line">    &#x2F;&#x2F; 如果第一个空格指引大小为Remove长度或者line是以remove开头</span><br><span class="line">    if (firstSpace &#x3D;&#x3D; REMOVE.length &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">      &#x2F;&#x2F; lruEntries 移除key</span><br><span class="line">      lruEntries.remove(key)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果第二个空格存在，则key赋值为第一个空格和第二个空格之间的字符串值</span><br><span class="line">    key &#x3D; line.substring(keyBegin, secondSpace)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 取key对应的Entry</span><br><span class="line">  var entry: Entry? &#x3D; lruEntries[key]</span><br><span class="line">  if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 不存砸，则创建Entry并赋值</span><br><span class="line">    entry &#x3D; Entry(key)</span><br><span class="line">    lruEntries[key] &#x3D; entry</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  when &#123;</span><br><span class="line">    secondSpace !&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; CLEAN.length &amp;&amp; line.startsWith(CLEAN) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 示例数据 CLEAN 4b217e04ba52215f3a6b64d28f6729c6 333 194</span><br><span class="line">      &#x2F;&#x2F; 读line间隔有多少个 方便存储对应大小数据</span><br><span class="line">      val parts &#x3D; line.substring(secondSpace + 1)</span><br><span class="line">          .split(&#39; &#39;)</span><br><span class="line">      entry.readable &#x3D; true &#x2F;&#x2F; 设置可读</span><br><span class="line">      entry.currentEditor &#x3D; null &#x2F;&#x2F; 重置null</span><br><span class="line">      entry.setLengths(parts) &#x2F;&#x2F; 根据文件个数，设置每个文件大小</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 示例数据：DIRTY 4b217e04ba52215f3a6b64d28f6729c6</span><br><span class="line">    secondSpace &#x3D;&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; DIRTY.length &amp;&amp; line.startsWith(DIRTY) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 赋值currentEditor为对应Entry的Editor</span><br><span class="line">      entry.currentEditor &#x3D; Editor(entry)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; READ，不做处理</span><br><span class="line">    secondSpace &#x3D;&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; READ.length &amp;&amp; line.startsWith(READ) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; This work was already done by calling lruEntries.get().</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else -&gt; throw IOException(&quot;unexpected journal line: $line&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-processJournal"><a href="#DiskLruCache-processJournal" class="headerlink" title="DiskLruCache.processJournal"></a>DiskLruCache.processJournal</h4><ul>
<li>计算有效文件的总大小值</li>
<li>删除无效本地缓存文件和内存缓存key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private fun processJournal() &#123;</span><br><span class="line">  &#x2F;&#x2F; 删除journal.tmp临时文件</span><br><span class="line">  fileSystem.delete(journalFileTmp)</span><br><span class="line">  val i &#x3D; lruEntries.values.iterator()</span><br><span class="line">  &#x2F;&#x2F; 遍历lruEntries ，计算currentEditor为null对应的文件总大小</span><br><span class="line">  while (i.hasNext()) &#123; </span><br><span class="line">    val entry &#x3D; i.next()</span><br><span class="line">    if (entry.currentEditor &#x3D;&#x3D; null) &#123;</span><br><span class="line">      for (t in 0 until valueCount) &#123;</span><br><span class="line">        size +&#x3D; entry.lengths[t]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      entry.currentEditor &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; 删除currentEditor文件（对应Dirty文件）</span><br><span class="line">      for (t in 0 until valueCount) &#123;</span><br><span class="line">        fileSystem.delete(entry.cleanFiles[t])</span><br><span class="line">        fileSystem.delete(entry.dirtyFiles[t])</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存使用策略逻辑"><a href="#缓存使用策略逻辑" class="headerlink" title="缓存使用策略逻辑"></a>缓存使用策略逻辑</h3><p>缓存使用策略：给定请求和缓存响应，决策出用网络响应还是缓存响应，或者两者都有</p>
<h4 id="CacheStrategy-init"><a href="#CacheStrategy-init" class="headerlink" title="CacheStrategy.init"></a>CacheStrategy.init</h4><ul>
<li>读取请求时间戳、响应时间戳</li>
<li>读取缓存策略决策的关键Header，Date、Expires、Last-Modified、ETag</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">      if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">        this.sentRequestMillis &#x3D; cacheResponse.sentRequestAtMillis</span><br><span class="line">        this.receivedResponseMillis &#x3D; cacheResponse.receivedResponseAtMillis</span><br><span class="line">        val headers &#x3D; cacheResponse.headers</span><br><span class="line">        for (i in 0 until headers.size) &#123;</span><br><span class="line">          val fieldName &#x3D; headers.name(i)</span><br><span class="line">          val value &#x3D; headers.value(i)</span><br><span class="line">          when &#123;</span><br><span class="line">            &#x2F;&#x2F; 读取缓存策略决策的关键Header</span><br><span class="line">            &#x2F;&#x2F; Date、Expires、Last-Modified、ETag</span><br><span class="line">            fieldName.equals(&quot;Date&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              servedDate &#x3D; value.toHttpDateOrNull()</span><br><span class="line">              servedDateString &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Expires&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              expires &#x3D; value.toHttpDateOrNull()</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Last-Modified&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              lastModified &#x3D; value.toHttpDateOrNull()</span><br><span class="line">              lastModifiedString &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;ETag&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              etag &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Age&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              ageSeconds &#x3D; value.toNonNegativeInt(-1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheStrategy-compute"><a href="#CacheStrategy-compute" class="headerlink" title="CacheStrategy.compute"></a>CacheStrategy.compute</h4><p>执行CacheStrategy.computeCandidate策略，最后返回四种策略结果</p>
<ol>
<li>CacheStrategy(request, null)； 无缓存，需要取网络数据</li>
<li>CacheStrategy(null, cacheResponse)；直接使用缓存</li>
<li>CacheStrategy(conditionalRequestHeaders,cacheResponse)；构建新的网络请求（加Header）需要新的网络请求返回后判断是否使用哪一个</li>
<li>CacheStrategy(null, null)； 错误场景</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun compute(): CacheStrategy &#123;</span><br><span class="line">  val candidate &#x3D; computeCandidate()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 禁止构建新的请求 且 缓存数据有没有，则返回null，这一般是个错误场景</span><br><span class="line">  if (candidate.networkRequest !&#x3D; null &amp;&amp; request.cacheControl.onlyIfCached) &#123;</span><br><span class="line">    return CacheStrategy(null, null)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return candidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheStrategy-computeCandidate"><a href="#CacheStrategy-computeCandidate" class="headerlink" title="CacheStrategy.computeCandidate"></a>CacheStrategy.computeCandidate</h4><p>缓存策略一系列判断，最后有三种策略返回结果</p>
<ol>
<li>CacheStrategy(request, null)； 无缓存，需要取网络数据</li>
<li>CacheStrategy(null, cacheResponse)；直接使用缓存</li>
<li>CacheStrategy(conditionalRequestHeaders,cacheResponse)；构建新的网络请求（加Header）需要新的网络请求返回后判断是否使用哪一个</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">private fun computeCandidate(): CacheStrategy &#123;</span><br><span class="line">    &#x2F;&#x2F; 无缓存</span><br><span class="line">    if (cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; https请求 且无handshake数据</span><br><span class="line">    if (request.isHttps &amp;&amp; cacheResponse.handshake &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 不支持缓存</span><br><span class="line">    if (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 配置了cacheControl字段 说明不需要cache</span><br><span class="line">    val requestCaching &#x3D; request.cacheControl</span><br><span class="line">    if (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算!noCache情况Header下，是否过期，是否可以直接使用Cache数据</span><br><span class="line">    val responseCaching &#x3D; cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">    val ageMillis &#x3D; cacheResponseAge()</span><br><span class="line">    var freshMillis &#x3D; computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">    if (requestCaching.maxAgeSeconds !&#x3D; -1) &#123;</span><br><span class="line">      freshMillis &#x3D; minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var minFreshMillis: Long &#x3D; 0</span><br><span class="line">    if (requestCaching.minFreshSeconds !&#x3D; -1) &#123;</span><br><span class="line">      minFreshMillis &#x3D; SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var maxStaleMillis: Long &#x3D; 0</span><br><span class="line">    if (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds !&#x3D; -1) &#123;</span><br><span class="line">      maxStaleMillis &#x3D; SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; !noCache Header标志，且缓存数据未过期，则直接使用</span><br><span class="line">    if (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">      val builder &#x3D; cacheResponse.newBuilder()</span><br><span class="line">      if (ageMillis + minFreshMillis &gt;&#x3D; freshMillis) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      val oneDayMillis &#x3D; 24 * 60 * 60 * 1000L</span><br><span class="line">      if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return CacheStrategy(null, builder.build())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将header数据取出，带入新的请求header中</span><br><span class="line">    val conditionName: String</span><br><span class="line">    val conditionValue: String?</span><br><span class="line">    when &#123;</span><br><span class="line">      etag !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-None-Match&quot;</span><br><span class="line">        conditionValue &#x3D; etag</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastModified !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; lastModifiedString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      servedDate !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; servedDateString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      else -&gt; return CacheStrategy(request, null) &#x2F;&#x2F; No condition! Make a regular request.</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 构建新的网络请求，返回带有新的网络请求+cacheReponse数据</span><br><span class="line">    val conditionalRequestHeaders &#x3D; request.headers.newBuilder()</span><br><span class="line">    conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">    val conditionalRequest &#x3D; request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build()</span><br><span class="line">    return CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存存储逻辑"><a href="#缓存存储逻辑" class="headerlink" title="缓存存储逻辑"></a>缓存存储逻辑</h3><h4 id="Cache-put"><a href="#Cache-put" class="headerlink" title="Cache.put"></a>Cache.put</h4><p>⚠️ 对于非GET请求，不做缓存逻辑，原因：POST请求虽然可以做到缓存逻辑，但是实现复杂度和收益比非常低，所以没有处理非Get的请求缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">internal fun put(response: Response): CacheRequest? &#123;</span><br><span class="line">   &#x2F;&#x2F; 请求方法</span><br><span class="line">   val requestMethod &#x3D; response.request.method</span><br><span class="line">   &#x2F;&#x2F; 如果是非Get则为true</span><br><span class="line">   if (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       remove(response.request) &#x2F;&#x2F; 移除缓存</span><br><span class="line">     &#125; catch (_: IOException) &#123;</span><br><span class="line">       &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">     &#125;</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 对于非GET请求，不做缓存逻辑，原因：POST请求虽然可以做到缓存逻辑，但是实现复杂度和收益比非常低，所以没有做处理</span><br><span class="line">   if (requestMethod !&#x3D; &quot;GET&quot;) &#123;</span><br><span class="line">     &#x2F;&#x2F; Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache HEAD requests and some</span><br><span class="line">     &#x2F;&#x2F; POST requests, but the complexity of doing so is high and the benefit is low.</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (response.hasVaryAll()) &#123;</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造 Entry</span><br><span class="line">   val entry &#x3D; Entry(response)</span><br><span class="line">   var editor: DiskLruCache.Editor? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Entry 编辑器，数据书写</span><br><span class="line">     editor &#x3D; cache.edit(key(response.request.url)) ?: return null</span><br><span class="line">     entry.writeTo(editor)</span><br><span class="line">     &#x2F;&#x2F; 构造一个 RealCacheRequest返回 </span><br><span class="line">     return RealCacheRequest(editor)</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     abortQuietly(editor)</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-edit"><a href="#DiskLruCache-edit" class="headerlink" title="DiskLruCache.edit"></a>DiskLruCache.edit</h4><p>主要是获取编辑器，编辑器获取的同时，DiskLruCache内存缓存中会存储对应的key和Entry，entry会指定对应的Editor，且会写入一条数据到日志中，目前日志key对应的数据是DIRTY</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">fun edit(key: String, expectedSequenceNumber: Long &#x3D; ANY_SEQUENCE_NUMBER): Editor? &#123;</span><br><span class="line">   initialize()</span><br><span class="line"></span><br><span class="line">   checkNotClosed()</span><br><span class="line">   validateKey(key)</span><br><span class="line">   &#x2F;&#x2F; key对应Entry</span><br><span class="line">   var entry: Entry? &#x3D; lruEntries[key] </span><br><span class="line">   if (expectedSequenceNumber !&#x3D; ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">       (entry &#x3D;&#x3D; null || entry.sequenceNumber !&#x3D; expectedSequenceNumber)) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Snapshot is stale.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 是否正在编辑</span><br><span class="line">   if (entry?.currentEditor !&#x3D; null) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Another edit is in progress.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 是否需要执行clean</span><br><span class="line">   if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 写入 key 到日志中 ，目前对应是 DIRTY</span><br><span class="line">   val journalWriter &#x3D; this.journalWriter!!</span><br><span class="line">   journalWriter.writeUtf8(DIRTY)</span><br><span class="line">       .writeByte(&#39; &#39;.toInt())</span><br><span class="line">       .writeUtf8(key)</span><br><span class="line">       .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">   journalWriter.flush()</span><br><span class="line"></span><br><span class="line">   if (hasJournalErrors) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Don&#39;t edit; the journal can&#39;t be written.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造Entry，存储到map中</span><br><span class="line">   if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">     entry &#x3D; Entry(key)</span><br><span class="line">     lruEntries[key] &#x3D; entry</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造编辑器，及Etry赋值当前编辑器</span><br><span class="line">   val editor &#x3D; Editor(entry)</span><br><span class="line">   entry.currentEditor &#x3D; editor</span><br><span class="line">   return editor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cache-writeTo"><a href="#Cache-writeTo" class="headerlink" title="Cache.writeTo"></a>Cache.writeTo</h4><p>通过Okio将响应数据写入到本地缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun writeTo(editor: DiskLruCache.Editor) &#123;</span><br><span class="line">      val sink &#x3D; editor.newSink(ENTRY_METADATA).buffer()</span><br><span class="line">      sink.writeUtf8(url).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      sink.writeUtf8(requestMethod).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      for (i in 0 until varyHeaders.size) &#123;</span><br><span class="line">        sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">            .writeUtf8(&quot;: &quot;)</span><br><span class="line">            .writeUtf8(varyHeaders.value(i))</span><br><span class="line">            .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 写入数据</span><br><span class="line">      ...</span><br><span class="line">      sink.close()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/be6d09f2656b" target="_blank" rel="noopener">下一篇 OkHttp 4源码（4）— 连接机制分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/12/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%882%EF%BC%89%E2%80%94%20%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/12/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%882%EF%BC%89%E2%80%94%20%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 4源码（2）— 拦截器机制分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-12 17:21:04" itemprop="dateCreated datePublished" datetime="2020-01-12T17:21:04+08:00">2020-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:59:27" itemprop="dateModified" datetime="2020-02-07T00:59:27+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-f1141c1f5f161a09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Interceptor流程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-037f59b6d4bbf080.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>概念<br>责任链模式（Chain of Responsibility Pattern），包含命令对象和一系列实现了相同接口的处理对象，这些处理对象相互连接成为一条责任链。每一个处理对象能决定它能处理哪些命令对象，对于它不能处理的命令对象，将会传递给该链中的下一个处理对象。负责链模式就是对这种顺序处理事件的行为的抽象,通过接口来定义处理事件的方法，顺序分发/处理事件。</p>
<p>主要解决<br>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p>优点</p>
<ol>
<li>降低耦合度。它将请求的发送者和接收者解耦。 </li>
<li>简化了对象。使得对象不需要知道链的结构。 </li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li>
<li>增加新的请求处理类很方便。</li>
</ol>
<p>特点</p>
<ol>
<li>每个责任人实现相同的接口,处理一个事件对象</li>
<li>让事件对象责任人之间顺序传递</li>
<li>事件的处理结果的返回是逆序的</li>
<li>责任链中的每个责任人都可以有权不继续传递事件,以自身为终点处理事件返回结果</li>
</ol>
<p>OkHttp中应用<br>在 OkHttp 中，命令对象就是 Request 对象，处理对象就是每一个 Interceptor 对象。每个 interceptor 对 request 进行一些步骤的处理，而将其余的工作交给下一个 interceptor。另外，责任链中的处理对象如果可以全权处理命令对象，则不需要交给下一个处理对象。OkHttp 中的 CacheInterceptor 也是具有全权处理的能力。如果请求的结果已经缓存，则不需要再交给 ConnectInterceptor 等进行连接服务器、发送请求的处理，直接返回已缓存的 response 即可。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p>拦截器，即处理对象类，Chain和Interceptor共同实现顺序调用，最终反响依次返回Response<br>拦截器一般可以概括三个步骤</p>
<ol>
<li>请求前处理逻辑</li>
<li>执行 chain.proceed，顺序调用</li>
<li>获取响应结果后逻辑处理</li>
</ol>
<p>默认拦截器依次包括</p>
<ol>
<li>RetryAndFollowUpInterceptor （重试机制）</li>
<li>BridgeInterceptor    （Http连接转换桥）</li>
<li>CacheInterceptor     （缓存策略）</li>
<li>ConnectInterceptor   （连接）</li>
<li>CallServerInterceptor  （响应读取）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 拦截器，处理对象</span><br><span class="line">interface Interceptor &#123;</span><br><span class="line">  &#x2F;&#x2F; 拦截方法，接受拦截器链（包括命令对象Request及Call、和一系列辅助对象），返回处理结果</span><br><span class="line">  fun intercept(chain: Chain): Response</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 链接口</span><br><span class="line">  interface Chain &#123;</span><br><span class="line">    &#x2F;&#x2F; 核心方法， 顺序执行 处理方法</span><br><span class="line">    fun proceed(request: Request): Response</span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RealInterceptorChain-拦截器链"><a href="#RealInterceptorChain-拦截器链" class="headerlink" title="RealInterceptorChain 拦截器链"></a>RealInterceptorChain 拦截器链</h3><p>完成责任链模式核心类，拦截器顺序执行、反向返回及中途中断核心实现<br>前一篇文章知道，命令对象RealCall，执行RealInterceptorChain的proceed方法，该方法最后会按照拦截器的加入顺序，循环构建Chain对象，然后执行拦截器的拦截方法，执导最后一个拦截器或者是中途拦截器直接返回了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class RealInterceptorChain(</span><br><span class="line">  private val interceptors: List&lt;Interceptor&gt;, &#x2F;&#x2F; 拦截器，处理对象</span><br><span class="line">  private val transmitter: Transmitter, &#x2F;&#x2F; 发射机</span><br><span class="line">  private val exchange: Exchange?, &#x2F;&#x2F; 交换器 请求和响应 </span><br><span class="line">  private val index: Int,</span><br><span class="line">  private val request: Request, &#x2F;&#x2F; 请求</span><br><span class="line">  private val call: Call,  &#x2F;&#x2F; 一次请求和返回封装</span><br><span class="line">  private val connectTimeout: Int,</span><br><span class="line">  private val readTimeout: Int,</span><br><span class="line">  private val writeTimeout: Int</span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  override fun proceed(request: Request): Response &#123;</span><br><span class="line">    return proceed(request, transmitter, exchange)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 顺序调用方法 </span><br><span class="line">  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response &#123;</span><br><span class="line">    ...</span><br><span class="line">    calls++</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 构造一个 RealInterceptorChain</span><br><span class="line">    val next &#x3D; RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    &#x2F;&#x2F; 根据index 依次取拦截器</span><br><span class="line">    val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 所有拦截器顺序执行，拦截器方法中执行 chain.proceed完成reponse返回，将命令对象交给下一个拦截器进行处理，如果不执行chain.proceed则在该拦截器进行终结。</span><br><span class="line">    val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line">    ...</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>重试拦截器</p>
<h4 id="RetryAndFollowUpInterceptor-intercept"><a href="#RetryAndFollowUpInterceptor-intercept" class="headerlink" title="RetryAndFollowUpInterceptor.intercept"></a>RetryAndFollowUpInterceptor.intercept</h4><ul>
<li>请求连接准备工作</li>
<li>执行chain.proceed顺序执行，获取response</li>
<li>若出现异常，则判断是否需要进行重试机制</li>
<li>根据服务端返回的状态码，进行重定向请求生成</li>
<li>进行重试，直到不需要重试或者成功，最多20次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  var request &#x3D; chain.request()</span><br><span class="line">  val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">  val transmitter &#x3D; realChain.transmitter()</span><br><span class="line">  var followUpCount &#x3D; 0</span><br><span class="line">  var priorResponse: Response? &#x3D; null</span><br><span class="line">  while (true) &#123; &#x2F;&#x2F; 循环</span><br><span class="line">    &#x2F;&#x2F; 发射机 执行连接准备工作</span><br><span class="line">    transmitter.prepareToConnect(request)</span><br><span class="line">  </span><br><span class="line">    if (transmitter.isCanceled) &#123; &#x2F;&#x2F; 处理取消的请求</span><br><span class="line">      throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var response: Response</span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行 proceed顺序执行流程，最终获取response</span><br><span class="line">      response &#x3D; realChain.proceed(request, transmitter, null)</span><br><span class="line">      success &#x3D; true</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      &#x2F;&#x2F; 若不满足重试条件，则抛出异常</span><br><span class="line">      if (!recover(e.lastConnectException, transmitter, false, request)) &#123;</span><br><span class="line">        throw e.firstConnectException</span><br><span class="line">      &#125;</span><br><span class="line">      continue    &#x2F;&#x2F; 满足，则重试</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      &#x2F;&#x2F; 若不满足重试条件，则抛出异常</span><br><span class="line">      val requestSendStarted &#x3D; e !is ConnectionShutdownException</span><br><span class="line">      if (!recover(e, transmitter, requestSendStarted, request)) throw e</span><br><span class="line">      continue    &#x2F;&#x2F; 满足，则重试</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 异常抛出，则success&#x3D;false，执行释放资源</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        transmitter.exchangeDoneDueToException()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (priorResponse !&#x3D; null) &#123; &#x2F;&#x2F; 赋值上一次的response</span><br><span class="line">      response &#x3D; response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">              .body(null)</span><br><span class="line">              .build())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val exchange &#x3D; response.exchange</span><br><span class="line">    val route &#x3D; exchange?.connection()?.route()</span><br><span class="line">    &#x2F;&#x2F; 获取进一步重试的请求</span><br><span class="line">    val followUp &#x3D; followUpRequest(response, route)</span><br><span class="line"></span><br><span class="line">    if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (exchange !&#x3D; null &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">        transmitter.timeoutEarlyExit() &#x2F;&#x2F; 无重试，停止timeout并退出</span><br><span class="line">      &#125;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val followUpBody &#x3D; followUp.body</span><br><span class="line">    &#x2F;&#x2F; 如果期望执行一次，则结束</span><br><span class="line">    if (followUpBody !&#x3D; null &amp;&amp; followUpBody.isOneShot()) &#123; </span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.body?.closeQuietly()</span><br><span class="line">    if (transmitter.hasExchange()) &#123;</span><br><span class="line">      exchange?.detachWithViolence()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 重试不超过20此</span><br><span class="line">    if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 修改下次的请求</span><br><span class="line">    request &#x3D; followUp</span><br><span class="line">    &#x2F;&#x2F; 记录上一次的response</span><br><span class="line">    priorResponse &#x3D; response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RetryAndFollowUpInterceptor-followUpRequest"><a href="#RetryAndFollowUpInterceptor-followUpRequest" class="headerlink" title="RetryAndFollowUpInterceptor.followUpRequest"></a>RetryAndFollowUpInterceptor.followUpRequest</h4><p>主要针对重定向的几个状态码进行特殊里，从Header中取Location字段，构造重定向request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">private fun followUpRequest(userResponse: Response, route: Route?): Request? &#123;</span><br><span class="line">    val responseCode &#x3D; userResponse.code</span><br><span class="line"></span><br><span class="line">    val method &#x3D; userResponse.request.method</span><br><span class="line">    when (responseCode) &#123;</span><br><span class="line">      HTTP_PROXY_AUTH -&gt; &#123; &#x2F;&#x2F; 407</span><br><span class="line">        val selectedProxy &#x3D; route!!.proxy</span><br><span class="line">        if (selectedProxy.type() !&#x3D; Proxy.Type.HTTP) &#123;</span><br><span class="line">          throw ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 代理身份认证</span><br><span class="line">        return client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 身份认证</span><br><span class="line">      HTTP_UNAUTHORIZED -&gt; return client.authenticator.authenticate(route, userResponse)</span><br><span class="line">      &#x2F;&#x2F; 针对Get、Head请求 执行构建重定向请求</span><br><span class="line">      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -&gt; &#123; &#x2F;&#x2F; 307 、308</span><br><span class="line">        if (method !&#x3D; &quot;GET&quot; &amp;&amp; method !&#x3D; &quot;HEAD&quot;) &#123;</span><br><span class="line">          return null</span><br><span class="line">        &#125;</span><br><span class="line">        return buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 针对300、301、302、303 执行构建重定向请求</span><br><span class="line">      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">        return buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 408 ，说明需要重新发送一次相同的请求</span><br><span class="line">        ... &#x2F;&#x2F; 判断是否有必要重新发送</span><br><span class="line">        return userResponse.request</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAVAILABLE -&gt; &#123; &#x2F;&#x2F; 503</span><br><span class="line">        return null</span><br><span class="line">      &#125;</span><br><span class="line">      else -&gt; return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private fun buildRedirectRequest(userResponse: Response, method: String): Request? &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置不需要执行重定向</span><br><span class="line">    if (!client.followRedirects) return null</span><br><span class="line">    &#x2F;&#x2F; location header 是否支持</span><br><span class="line">    val location &#x3D; userResponse.header(&quot;Location&quot;) ?: return null</span><br><span class="line">    &#x2F;&#x2F; Don&#39;t follow redirects to unsupported protocols.</span><br><span class="line">    val url &#x3D; userResponse.request.url.resolve(location) ?: return null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果不允许SSL和Non-SSL之间的重定向，则返回null</span><br><span class="line">    val sameScheme &#x3D; url.scheme &#x3D;&#x3D; userResponse.request.url.scheme</span><br><span class="line">    if (!sameScheme &amp;&amp; !client.followSslRedirects) return null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Most redirects don&#39;t include a request body.</span><br><span class="line">    val requestBuilder &#x3D; userResponse.request.newBuilder()</span><br><span class="line">    if (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">      val maintainBody &#x3D; HttpMethod.redirectsWithBody(method)</span><br><span class="line">      if (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">        requestBuilder.method(&quot;GET&quot;, null)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val requestBody &#x3D; if (maintainBody) userResponse.request.body else null</span><br><span class="line">        requestBuilder.method(method, requestBody)</span><br><span class="line">      &#125;</span><br><span class="line">      if (!maintainBody) &#123;</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Type&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; When redirecting across hosts, drop all authentication headers. This</span><br><span class="line">    &#x2F;&#x2F; is potentially annoying to the application layer since they have no</span><br><span class="line">    &#x2F;&#x2F; way to retain them.</span><br><span class="line">    if (!userResponse.request.url.canReuseConnectionFor(url)) &#123;</span><br><span class="line">      requestBuilder.removeHeader(&quot;Authorization&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 构建 新的请求</span><br><span class="line">    return requestBuilder.url(url).build()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><blockquote>
<p>Bridges from application code to network code. </p>
</blockquote>
<p>连接应用层和网络层的桥梁</p>
<ul>
<li>主要针对请求Header进行处理，如gzip、cookie及其他Header字段等</li>
<li>响应则进行gzip解压</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val userRequest &#x3D; chain.request()</span><br><span class="line">    val requestBuilder &#x3D; userRequest.newBuilder()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将userRequest中的属性设置到request中</span><br><span class="line">    val body &#x3D; userRequest.body</span><br><span class="line">    if (body !&#x3D; null) &#123;</span><br><span class="line">      val contentType &#x3D; body.contentType()</span><br><span class="line">      if (contentType !&#x3D; null) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      val contentLength &#x3D; body.contentLength()</span><br><span class="line">      if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有设置Accept-Encoding，则自动设置为gzip</span><br><span class="line">    var transparentGzip &#x3D; false</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      transparentGzip &#x3D; true</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将userRequest中的cookie解析出来并设置到Request中的Cookie字段中</span><br><span class="line">    val cookies &#x3D; cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    if (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置 User-Agent</span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 顺序执行处理方法</span><br><span class="line">    val networkResponse &#x3D; chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理响应的headers，并缓存cookie</span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    val responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line">    &#x2F;&#x2F; 设置了Gzip，且响应结果支持gzip，则进行Gzip解析</span><br><span class="line">    if (transparentGzip &amp;&amp;</span><br><span class="line">        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase &#x3D; true) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">        </span><br><span class="line">      val responseBody &#x3D; networkResponse.body</span><br><span class="line">      if (responseBody !&#x3D; null) &#123;</span><br><span class="line">        val gzipSource &#x3D; GzipSource(responseBody.source())</span><br><span class="line">        val strippedHeaders &#x3D; networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">            .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        val contentType &#x3D; networkResponse.header(&quot;Content-Type&quot;)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Returns a &#39;Cookie&#39; HTTP request header with all cookies, like &#96;a&#x3D;b; c&#x3D;d&#96;. *&#x2F;</span><br><span class="line">  private fun cookieHeader(cookies: List&lt;Cookie&gt;): String &#x3D; buildString &#123;</span><br><span class="line">    cookies.forEachIndexed &#123; index, cookie -&gt;</span><br><span class="line">      if (index &gt; 0) append(&quot;; &quot;)</span><br><span class="line">      append(cookie.name).append(&#39;&#x3D;&#39;).append(cookie.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/2eafcd161dd9" target="_blank" rel="noopener">下一篇 OkHttp 4源码（3）— 缓存机制分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/11/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%881%EF%BC%89%E2%80%94OkHttp%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%9E%84%E9%80%A0%E5%88%86%E6%9E%90%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/11/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%881%EF%BC%89%E2%80%94OkHttp%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%9E%84%E9%80%A0%E5%88%86%E6%9E%90%20/" class="post-title-link" itemprop="url">OkHttp 4源码（1）—OkHttp初始化和请求构造分析 </a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-11 15:06:26" itemprop="dateCreated datePublished" datetime="2020-01-11T15:06:26+08:00">2020-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:59:33" itemprop="dateModified" datetime="2020-02-07T00:59:33+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>本篇主要从OkHttp的两个请求示例开始，对Okhttp的初始化工作，和请求从构造、分发到执行的流程进行源码分析介绍</p>
<p>OkHttp整体流程（本文覆盖红色部分）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-5b2b658e081918d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>本文覆盖代码流程图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-d901334cea97e334.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用OkHttp一般流程，初始化一个共享OkHttpClient，构建Request，然后OkHttpClient根据Request构建Call，接着执行call，最后进行Response处理</p>
<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class GetExample &#123;</span><br><span class="line">  OkHttpClient client &#x3D; new OkHttpClient(); &#x2F;&#x2F; 构建共享的Client</span><br><span class="line"></span><br><span class="line">  String run(String url) throws IOException &#123;</span><br><span class="line">    Request request &#x3D; new Request.Builder() &#x2F;&#x2F; 构建request</span><br><span class="line">        .url(url)</span><br><span class="line">        .build();</span><br><span class="line">    &#x2F;&#x2F; 构建Call，执行</span><br><span class="line">    try (Response response &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">      return response.body().string();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    GetExample example &#x3D; new GetExample();</span><br><span class="line">    String response &#x3D; example.run(&quot;https:&#x2F;&#x2F;raw.github.com&#x2F;square&#x2F;okhttp&#x2F;master&#x2F;README.md&quot;);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final class AsynchronousGet &#123;</span><br><span class="line">  private final OkHttpClient client &#x3D; new OkHttpClient();&#x2F;&#x2F; 构建共享Client</span><br><span class="line"></span><br><span class="line">  public void run() throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 构建Request</span><br><span class="line">    Request request &#x3D; new Request.Builder()</span><br><span class="line">        .url(&quot;http:&#x2F;&#x2F;publicobject.com&#x2F;helloworld.txt&quot;)</span><br><span class="line">        .build();</span><br><span class="line">    &#x2F;&#x2F; 构建Call，执行，回调接受处理</span><br><span class="line">    client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">      @Override public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">        try (ResponseBody responseBody &#x3D; response.body()) &#123;</span><br><span class="line">          if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class="line"></span><br><span class="line">          Headers responseHeaders &#x3D; response.headers();</span><br><span class="line">          for (int i &#x3D; 0, size &#x3D; responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(responseBody.string());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) throws Exception &#123;</span><br><span class="line">    new AsynchronousGet().run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构建OkHttpClient"><a href="#构建OkHttpClient" class="headerlink" title="构建OkHttpClient"></a>构建OkHttpClient</h3><ul>
<li>OkHttpClient是Call的一个工厂类，OkHttpClient应该是共享的，或者说是单例</li>
<li>可以通过newBuilder来自定义Client</li>
<li>没有必要关心 关闭和资源释放</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Factory for [calls][Call], which can be used to send HTTP requests and read their responses.</span><br><span class="line"> * ## OkHttpClients Should Be Shared</span><br><span class="line"> * ## Customize Your Client With newBuilder()</span><br><span class="line"> * ## Shutdown Isn&#39;t Necessary</span><br><span class="line"> * &#x2F;</span><br><span class="line">open class OkHttpClient internal constructor(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">    &#x2F;&#x2F; 3. 成员变量初始化</span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1. 内部无参数构造函数</span><br><span class="line">    constructor() : this(Builder())</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 4. OkHttpClient函数初始化 </span><br><span class="line">    init &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化证书和拦截器等判断逻辑</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2. Builder构造函数</span><br><span class="line">    class Builder constructor() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="OkHttpClient-Builder"><a href="#OkHttpClient-Builder" class="headerlink" title="OkHttpClient.Builder"></a>OkHttpClient.Builder</h4><p>Builder模式，提供自定义配置化能力，同时有一份无需关心的默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Builder constructor() &#123;</span><br><span class="line">      internal var dispatcher: Dispatcher &#x3D; Dispatcher()</span><br><span class="line">      internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()</span><br><span class="line">      internal val interceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()</span><br><span class="line">      internal val networkInterceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()</span><br><span class="line">      internal var eventListenerFactory: EventListener.Factory &#x3D; EventListener.NONE.asFactory()</span><br><span class="line">      internal var retryOnConnectionFailure &#x3D; true</span><br><span class="line">      internal var authenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">      internal var followRedirects &#x3D; true</span><br><span class="line">      internal var followSslRedirects &#x3D; true</span><br><span class="line">      internal var cookieJar: CookieJar &#x3D; CookieJar.NO_COOKIES</span><br><span class="line">      internal var cache: Cache? &#x3D; null</span><br><span class="line">      internal var dns: Dns &#x3D; Dns.SYSTEM</span><br><span class="line">      internal var proxy: Proxy? &#x3D; null</span><br><span class="line">      internal var proxySelector: ProxySelector? &#x3D; null</span><br><span class="line">      internal var proxyAuthenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">      internal var socketFactory: SocketFactory &#x3D; SocketFactory.getDefault()</span><br><span class="line">      internal var sslSocketFactoryOrNull: SSLSocketFactory? &#x3D; null</span><br><span class="line">      internal var x509TrustManagerOrNull: X509TrustManager? &#x3D; null</span><br><span class="line">      internal var connectionSpecs: List&lt;ConnectionSpec&gt; &#x3D; DEFAULT_CONNECTION_SPECS</span><br><span class="line">      internal var protocols: List&lt;Protocol&gt; &#x3D; DEFAULT_PROTOCOLS</span><br><span class="line">      internal var hostnameVerifier: HostnameVerifier &#x3D; OkHostnameVerifier</span><br><span class="line">      internal var certificatePinner: CertificatePinner &#x3D; CertificatePinner.DEFAULT</span><br><span class="line">      internal var certificateChainCleaner: CertificateChainCleaner? &#x3D; null</span><br><span class="line">      internal var callTimeout &#x3D; 0</span><br><span class="line">      internal var connectTimeout &#x3D; 10_000</span><br><span class="line">      internal var readTimeout &#x3D; 10_000</span><br><span class="line">      internal var writeTimeout &#x3D; 10_000</span><br><span class="line">      internal var pingInterval &#x3D; 0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="OkHttpClient成员变量初始化"><a href="#OkHttpClient成员变量初始化" class="headerlink" title="OkHttpClient成员变量初始化"></a>OkHttpClient成员变量初始化</h4><ul>
<li>初始化成员变量</li>
<li>JvmName是为了支持兼容3.x</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@get:JvmName(&quot;dispatcher&quot;) val dispatcher: Dispatcher &#x3D; builder.dispatcher</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;connectionPool&quot;) val connectionPool: ConnectionPool &#x3D; builder.connectionPool</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;interceptors&quot;) val interceptors: List&lt;Interceptor&gt; &#x3D;</span><br><span class="line">    builder.interceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;networkInterceptors&quot;) val networkInterceptors: List&lt;Interceptor&gt; &#x3D;</span><br><span class="line">    builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;eventListenerFactory&quot;) val eventListenerFactory: EventListener.Factory &#x3D;</span><br><span class="line">    builder.eventListenerFactory</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;retryOnConnectionFailure&quot;) val retryOnConnectionFailure: Boolean &#x3D;</span><br><span class="line">    builder.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;cookieJar&quot;) val cookieJar: CookieJar &#x3D; builder.cookieJar</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;cache&quot;) val cache: Cache? &#x3D; builder.cache</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h3 id="构建Request"><a href="#构建Request" class="headerlink" title="构建Request"></a>构建Request</h3><p>Request 对应HTTP请求中的Request，OkHttp依旧是Builder构建模式构建Request</p>
<h4 id="Request-Builder"><a href="#Request-Builder" class="headerlink" title="Request.Builder"></a>Request.Builder</h4><p>支持url、method、headers、body的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> open class Builder &#123;</span><br><span class="line">    internal var url: HttpUrl? &#x3D; null </span><br><span class="line">    internal var method: String</span><br><span class="line">    internal var headers: Headers.Builder</span><br><span class="line">    internal var body: RequestBody? &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 构造Request</span><br><span class="line">    open fun build(): Request &#123;</span><br><span class="line">      return Request(</span><br><span class="line">          checkNotNull(url) &#123; &quot;url &#x3D;&#x3D; null&quot; &#125;,</span><br><span class="line">          method,</span><br><span class="line">          headers.build(),</span><br><span class="line">          body,</span><br><span class="line">          tags.toImmutableMap()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>通过Request.Builder构造Request实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Request internal constructor(</span><br><span class="line">  @get:JvmName(&quot;url&quot;) val url: HttpUrl,</span><br><span class="line">  @get:JvmName(&quot;method&quot;) val method: String,</span><br><span class="line">  @get:JvmName(&quot;headers&quot;) val headers: Headers,</span><br><span class="line">  @get:JvmName(&quot;body&quot;) val body: RequestBody?,</span><br><span class="line">  internal val tags: Map&lt;Class&lt;*&gt;, Any&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建Call"><a href="#构建Call" class="headerlink" title="构建Call"></a>构建Call</h3><h4 id="OkHttpClient-newCall"><a href="#OkHttpClient-newCall" class="headerlink" title="OkHttpClient.newCall"></a>OkHttpClient.newCall</h4><p>OkHttpClient 实现了Call.Factory，作为Call的构造工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override fun newCall(request: Request): Call &#123;</span><br><span class="line">  &#x2F;&#x2F; 执行 RealCall的构造call方法</span><br><span class="line">  return RealCall.newRealCall(this, request, forWebSocket &#x3D; false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealCall-newRealCall"><a href="#RealCall-newRealCall" class="headerlink" title="RealCall.newRealCall"></a>RealCall.newRealCall</h4><p>构造Call真正方法，另外创建了一个 发射器，接下来先了解下Call</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">    fun newRealCall(</span><br><span class="line">      client: OkHttpClient,</span><br><span class="line">      originalRequest: Request,</span><br><span class="line">      forWebSocket: Boolean</span><br><span class="line">    ): RealCall &#123;</span><br><span class="line">      </span><br><span class="line">      return RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">       &#x2F;&#x2F; 构造了一个 发射器，它是应用层和网络层交互的桥梁，后面会着重介绍</span><br><span class="line">        transmitter &#x3D; Transmitter(client, this) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h4><p>Call定义为一个准备好执行的请求，它是能被取消的，且它只能被执行一次（http请求也是一次执行）<br><strong>包括一个核心成员变量 Transmitter ，两个重要方法 execute（同步） 和 enqueue（异步）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">internal class RealCall private constructor(</span><br><span class="line">  val client: OkHttpClient,</span><br><span class="line">  &#x2F;** The application&#39;s original request unadulterated by redirects or auth headers. *&#x2F;</span><br><span class="line">  val originalRequest: Request,</span><br><span class="line">  val forWebSocket: Boolean</span><br><span class="line">) : Call &#123;</span><br><span class="line"> &#x2F;&#x2F; 发射机</span><br><span class="line"> private lateinit var transmitter: Transmitter</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 同步请求执行方法</span><br><span class="line"> override fun execute(): Response &#123;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">  &#x2F;&#x2F; 异步请求执行方法 </span><br><span class="line">  override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 取消请求</span><br><span class="line">  override fun cancel() &#123;</span><br><span class="line">    transmitter.cancel()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步请求-1"><a href="#同步请求-1" class="headerlink" title="同步请求"></a>同步请求</h3><h4 id="RealCall-execute"><a href="#RealCall-execute" class="headerlink" title="RealCall.execute"></a>RealCall.execute</h4><ul>
<li>请求前校验逻辑，仅能执行一次，和过期时间逻辑判断逻辑</li>
<li>通知请求start事件，便于metrics 指标数据收集</li>
<li>将call加入分发器的同步请求队列中</li>
<li>通过拦截器责任链模式进行请求和返回一系列逻辑处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">override fun execute(): Response &#123;</span><br><span class="line">  &#x2F;&#x2F; 检查是否已经执行</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 过期时间逻辑，如果配置了会有WatchDog线程进行Watch然后执行退出逻辑</span><br><span class="line">  transmitter.timeoutEnter()</span><br><span class="line">  &#x2F;&#x2F; 通知start，最后会通过 EventListener 发出时间，主要目的是收集 metrics events</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用client的dispatcher分发器执行call（将call加入同步call队列）</span><br><span class="line">    client.dispatcher.executed(this)</span><br><span class="line">    &#x2F;&#x2F; 通过拦截器责任链模式进行请求和返回处理等一系类逻辑</span><br><span class="line">    return getResponseWithInterceptorChain()</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    client.dispatcher.finished(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealCall-getResponseWithInterceptorChain"><a href="#RealCall-getResponseWithInterceptorChain" class="headerlink" title="RealCall.getResponseWithInterceptorChain"></a>RealCall.getResponseWithInterceptorChain</h4><ul>
<li>配置拦截器，所有请求和响应处理逻辑解耦到各个拦截器负责模块</li>
<li>构造拦截器链式调用处理类RealInterceptorChain实例</li>
<li>chain.proceed 进行拦截器的链式调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">  &#x2F;&#x2F; 构建所有的拦截器</span><br><span class="line">  val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  interceptors +&#x3D; client.interceptors &#x2F;&#x2F; client配置的拦截器</span><br><span class="line">  interceptors +&#x3D; RetryAndFollowUpInterceptor(client) &#x2F;&#x2F; 重试机制拦截器</span><br><span class="line">  interceptors +&#x3D; BridgeInterceptor(client.cookieJar) &#x2F;&#x2F; 请求和返回桥（http信息配置和解析）拦截器</span><br><span class="line">  interceptors +&#x3D; CacheInterceptor(client.cache) &#x2F;&#x2F; 缓存拦截</span><br><span class="line">  interceptors +&#x3D; ConnectInterceptor &#x2F;&#x2F; 连接拦截器</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors +&#x3D; CallServerInterceptor(forWebSocket)  &#x2F;&#x2F; 执行拦截器</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 拦截器核心处理类 </span><br><span class="line">  val chain &#x3D; RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,</span><br><span class="line">      client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">  var calledNoMoreExchanges &#x3D; false</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 链式调用</span><br><span class="line">    val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">    if (transmitter.isCanceled) &#123; &#x2F;&#x2F; 处理取消</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response &#x2F;&#x2F;返回请求结果</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges &#x3D; true</span><br><span class="line">    throw transmitter.noMoreExchanges(e) as Throwable</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h3><h4 id="RealCall-enqueue"><a href="#RealCall-enqueue" class="headerlink" title="RealCall.enqueue"></a>RealCall.enqueue</h4><ul>
<li>构造一个异步call</li>
<li>调用dispatcher 入队AsyncCall</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">  synchronized(this) &#123; </span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  &#x2F;&#x2F; 构造 AsyncCall ，接着分发器入队操作</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatcher-分发器队Call进行分发执行"><a href="#Dispatcher-分发器队Call进行分发执行" class="headerlink" title="Dispatcher 分发器队Call进行分发执行"></a>Dispatcher 分发器队Call进行分发执行</h4><p><a href="https://www.jianshu.com/p/d9e46d5a4af9" target="_blank" rel="noopener">参考：线程池理解</a></p>
<ul>
<li>初始化时，构造分发器的线程池，及对应执行参数</li>
<li>主要管理异步请求的处理（异步Call入队、并发执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class Dispatcher constructor() &#123;</span><br><span class="line">  &#x2F;&#x2F; 默认最大请求数 64</span><br><span class="line">  @get:Synchronized var maxRequests &#x3D; 64</span><br><span class="line">  &#x2F;&#x2F; 默认最大并发Host 5</span><br><span class="line">  @get:Synchronized var maxRequestsPerHost &#x3D; 5</span><br><span class="line">  &#x2F;&#x2F; 线程池执行器 默认创建可缓存线程池 </span><br><span class="line">  @get:JvmName(&quot;executorService&quot;) val executorService: ExecutorService</span><br><span class="line">    get() &#123;</span><br><span class="line">      if (executorServiceOrNull &#x3D;&#x3D; null) &#123;</span><br><span class="line">        executorServiceOrNull &#x3D; ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">            SynchronousQueue(), threadFactory(&quot;OkHttp Dispatcher&quot;, false))</span><br><span class="line">      &#125;</span><br><span class="line">      return executorServiceOrNull!!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#x2F;** 准备好的异步Call对列 *&#x2F;</span><br><span class="line">  private val readyAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 执行中异步call对列 *&#x2F;</span><br><span class="line">  private val runningAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 同步call对列 *&#x2F;</span><br><span class="line">  private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 异步Call 入队操作  </span><br><span class="line">  internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line">      &#x2F;&#x2F; same host情况下的复用逻辑处理</span><br><span class="line">      if (!call.get().forWebSocket) &#123;</span><br><span class="line">        val existingCall &#x3D; findExistingCallWithHost(call.host())</span><br><span class="line">        if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute() &#x2F;&#x2F; 准备线程池执行器，及执行</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行Call</span><br><span class="line">private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line">    this.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    val isRunning: Boolean</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      &#x2F;&#x2F; 遍历所有的ready 异步 call</span><br><span class="line">      val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">      while (i.hasNext()) &#123;</span><br><span class="line">        val asyncCall &#x3D; i.next()</span><br><span class="line"></span><br><span class="line">        if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.</span><br><span class="line">        if (asyncCall.callsPerHost().get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity.</span><br><span class="line"></span><br><span class="line">        i.remove()</span><br><span class="line">        asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">        executableCalls.add(asyncCall) &#x2F;&#x2F; 加入此次执行队列缓存</span><br><span class="line">        runningAsyncCalls.add(asyncCall) &#x2F;&#x2F; 加入正在执行队列</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">      val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">      asyncCall.executeOn(executorService) &#x2F;&#x2F; 将线程执行器传入call，在Call中进行执行</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isRunning</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;** 同步call，添加到队列 *&#x2F;</span><br><span class="line">  @Synchronized internal fun executed(call: RealCall) &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AsyncCall执行"><a href="#AsyncCall执行" class="headerlink" title="AsyncCall执行"></a>AsyncCall执行</h4><ul>
<li>executeOn ，线程池执行器执行Runnable</li>
<li>run，通过拦截器进行请求和获取响应结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line">    </span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池 执行器执行</span><br><span class="line">        executorService.execute(this)</span><br><span class="line">        success &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 执行方法</span><br><span class="line">override fun run() &#123;</span><br><span class="line">    threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">        var signalledCallback &#x3D; false</span><br><span class="line">        transmitter.timeoutEnter()</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 同“同步请求” 最终执行拦截器链式调用</span><br><span class="line">            val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">            signalledCallback &#x3D; true</span><br><span class="line">            &#x2F;&#x2F; 响应 回调</span><br><span class="line">            responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">        &#125; catch (e: IOException) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            client.dispatcher.finished(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://www.jianshu.com/p/0c830962c6e3" target="_blank" rel="noopener">下一篇 OkHttp 4源码（2）— 拦截器机制分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/6/">6</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Afree</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Afree</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  


</body>
</html>
