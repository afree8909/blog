<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"afree8909.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":20},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Afree&#39;s blog">
<meta property="og:url" content="https://afree8909.github.io/blog/page/5/index.html">
<meta property="og:site_name" content="Afree&#39;s blog">
<meta property="article:author" content="Afree">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://afree8909.github.io/blog/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Afree's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Afree's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">保持好奇心，不畏边界，持续学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/03/16/Android%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/03/16/Android%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android线程消息机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-16 10:08:04" itemprop="dateCreated datePublished" datetime="2019-03-16T10:08:04+08:00">2019-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:42:40" itemprop="dateModified" datetime="2020-02-07T00:42:40+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android应用程序有主线程和子线程之分，其中主线程由AMS请求Zygote进程创建；而子线程则由主线程或者其它子线程创建。我们知道Android规定只能在主线程中执行与界面相关工作（严格意义是界面创建元素对应的线程），一旦我们在主线程执行的任务过重，就可能导致UI绘制无法及时完成，产生掉帧现象，或者更严重直接ANR。所以为了避霾类似问题，我们需要多线程技术方案，把那些复杂或者非重要的任务移到其它线程执行，来提升体验。<br>我们知道对于不定期的后台任务，一般有两种处理方式。第一种方式是每当条件满足的时，就创建一个子线程来执行一个不定期的后台任务，当这个不定期的任务执行完成之后，这个新创建子线程就随之推出。第二种方式是创建一个具有消息循环的子线程，每当条件满足时，就将一个不定期后台任务封装成一个消息发送到子线程的消息队列中去执行，而当条件不满足时，这个子线程就会因问它的消息队列为空而进入睡眠等待状态。虽然第一种方式创建的子线程不需要消息循环机制，但是频繁的创建和销毁子线程是有代价的，因此更倾向于第二种方式来执行那些不定期的后台任务。Android应用程序主线程和子线程都是具有消息循环机制的。<br>下面我们将从Android消息机制原理、Android线程消息循环模型和Android线程和线程池进行全面理解。</p>
<h3 id="Android消息机制"><a href="#Android消息机制" class="headerlink" title="Android消息机制"></a>Android消息机制</h3><p>Android的消息机制主要指Handler的运行机制及它附带的MessageQueue和Looper的工作过程。</p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p><strong>主要用途</strong></p>
<ol>
<li>在未来某个时间点处理 Messages 或者执行 Runnables</li>
<li>将任务切换到另一个线程执行</li>
</ol>
<p><strong>源码分析</strong><br>大致流程：构造Handler -&gt; 发送Runnable -&gt; 组合Message -&gt; Message入队 -&gt; Looper轮训Message执行任务 -&gt; 取Message对应Handler执行消息回调处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字段</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Set this flag to true to detect anonymous, local or member classes</span><br><span class="line"> * that extend this Handler class and that are not static. These kind</span><br><span class="line"> * of classes can potentially create leaks.</span><br><span class="line"> * 非static的匿名内部类、局部变量或成员变量都将可能造成内存泄漏</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final boolean FIND_POTENTIAL_LEAKS &#x3D; false;</span><br><span class="line">final Looper mLooper; &#x2F;&#x2F; 持有对应Looper，获取对应queue</span><br><span class="line">final MessageQueue mQueue; &#x2F;&#x2F; 持有对应的消息队列，进行消息入队操作</span><br><span class="line">final Callback mCallback; &#x2F;&#x2F; hook，非null 优先回调处理消息</span><br><span class="line">final boolean mAsynchronous; &#x2F;&#x2F; 是否异步消息标识</span><br><span class="line">IMessenger mMessenger; &#x2F;&#x2F; 作用进程间通信</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数 Handler持有对应线程的Looper，同时持有对应Looper的MessageQueue</span><br><span class="line">public Handler() &#123;  ...  &#125;</span><br><span class="line">public Handler(Callback) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper,Callback) &#123;  ...  &#125;</span><br><span class="line">public Handler(boolean) &#123;  ...  &#125;</span><br><span class="line">public Handler(Callback,boolean) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper,Callback,boolean) &#123;  ...  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post方法，针对不同执行时间的Runnable的方法，最终Runnable转为Message，调用发消息方法插入队列</span><br><span class="line">public final boolean post(Runnable r)&#123; ... &#125;</span><br><span class="line">public final boolean postAtFrontOfQueuepo(Runnable r)&#123; ... &#125;</span><br><span class="line">public final boolean postAtTime(Runnable r,long uptimeMillis)&#123; ... &#125;</span><br><span class="line">public final boolean postAtTime(Runnable r,Object token,long uptimeMillis)&#123; ... &#125;</span><br><span class="line">public final boolean postDelayed(Runnable r,long delayMillis)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将runnable转为Message</span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;...&#125;</span><br><span class="line">private static Message getPostMessage(Runnable r, Object token) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  sendMessage方法，内部实现就是将Message入MessageQueue</span><br><span class="line">public final boolean sendMessage(Message msg)&#123; ... &#125;</span><br><span class="line">public final boolean sendEmptyMessage(int what)&#123; ... &#125;</span><br><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis)&#123; ... &#125;</span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; ... &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Message插入MessageQueue，</span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this; &#x2F;&#x2F; 指定Msg处理对象为当前Handler</span><br><span class="line">    if (mAsynchronous) &#123; &#x2F;&#x2F; 是否异步消息，即跳过屏障执行。</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis); &#x2F;&#x2F; 执行等待时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Looper轮训到执行任务消息时，便调用Message的target即此Handler的这个发送消息方法进行处理</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback !&#x3D; null) &#123; &#x2F;&#x2F; 优先尝试msg的callback回调</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback !&#x3D; null) &#123; &#x2F;&#x2F; Handler构造callBack</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg); &#x2F;&#x2F; 子类实现处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>数据结构主要包含一个int标识，一个long执行时间标识，一个Object数据传输对象，一个Bundle类型data存储对象，记录对应的Hanlder对象。<br>另外维护了一个默认50大小的单链表，用于Message创建，后续系统会回收Message</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个可以发送给 Handler 的消息，包含描述和任意数据对象。消息对象有两个额外的 int 字段和一个 object 字段，这可以满足大部分场景的需求了。</span><br><span class="line">&#x2F;&#x2F; 推荐通过Message.obtain()构建Message而不是直接new，里面维护了默认50大小的链表Message的sPool </span><br><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line">    public int what; &#x2F;&#x2F; 消息标识</span><br><span class="line">    public Object obj; &#x2F;&#x2F; 消息数据存储，用于非bundle传输</span><br><span class="line">    &#x2F;&#x2F; Flag标识（是否使用、是否异步消息）</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAG_IN_USE &#x3D; 1 &lt;&lt; 0;</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAG_ASYNCHRONOUS &#x3D; 1 &lt;&lt; 1;</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAGS_TO_CLEAR_ON_COPY_FROM &#x3D; FLAG_IN_USE;</span><br><span class="line">    &#x2F;*package*&#x2F; int flags;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*package*&#x2F; long when; &#x2F;&#x2F; 执行时间</span><br><span class="line">    &#x2F;*package*&#x2F; Bundle data; &#x2F;&#x2F; 非obj传输情况</span><br><span class="line">    &#x2F;*package*&#x2F; Handler target; &#x2F;&#x2F; 发送的Handler</span><br><span class="line">    &#x2F;*package*&#x2F; Runnable callback; &#x2F;</span><br><span class="line">    &#x2F;&#x2F; sometimes we store linked lists of these things</span><br><span class="line">    &#x2F;*package*&#x2F; Message next; &#x2F;&#x2F; Message单链表指向 </span><br><span class="line"></span><br><span class="line">    private static final Object sPoolSync &#x3D; new Object();</span><br><span class="line">    private static Message sPool; &#x2F;&#x2F; Message 链表池</span><br><span class="line">    private static int sPoolSize &#x3D; 0;</span><br><span class="line">    private static final int MAX_POOL_SIZE &#x3D; 50;</span><br><span class="line">    private static boolean gCheckRecycle &#x3D; true; &#x2F;&#x2F; 回收标识</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 各种Message构建方法 </span><br><span class="line">    public static Message obtain(Handler h, int what, int arg1, int arg2) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>通过ThreadLocal实现各线程持有自己的Looper<br>loop方法进行消息轮训，获取消息，调用目标Handler分发任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 扮演消息循环角色，从MessageQueue取消息，有就执行，无则阻塞等待</span><br><span class="line">public final class Looper &#123;</span><br><span class="line">    &#x2F;&#x2F; 重要字段</span><br><span class="line">    &#x2F;&#x2F; ThreadLocal缓存，实现各线程持有各自Looper对象。参考https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;8a7fe7d592f8</span><br><span class="line">    static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    private static Looper sMainLooper;  &#x2F;&#x2F; 持有主线程Looper，便于其它线程交互</span><br><span class="line"></span><br><span class="line">    final MessageQueue mQueue; &#x2F;&#x2F; Looper对应的MessageQueue</span><br><span class="line">    final Thread mThread; &#x2F;&#x2F; Looper对应当前线程</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数私有，必须通过prepare方法来构建</span><br><span class="line">    private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class="line">        mThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 构建Looper，通过ThreadLocal维护Looper（各线程对应一个Looper）</span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        &#x2F;&#x2F; 主线程消息轮训不允许退出，一直循环处理</span><br><span class="line">        &#x2F;&#x2F; 子线程消息轮训可以退出</span><br><span class="line">        if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 主线程构建Looper方法（ActivityThread调用）</span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper &#x3D; myLooper(); &#x2F;&#x2F; 此处缓存主线程Looper，便于后续与主线程的交互</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最重要的 loop 方法，消息轮训实现 （部分关键代码）</span><br><span class="line">    public static void loop() &#123;</span><br><span class="line">        final Looper me &#x3D; myLooper(); &#x2F;&#x2F; 获取当前线程对应的loop</span><br><span class="line">        final MessageQueue queue &#x3D; me.mQueue;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 循环去消息 （MessageQueue取过程可能阻塞）</span><br><span class="line">            Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block （参考MessageQueue next方法）</span><br><span class="line">            if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            msg.target.dispatchMessage(msg);&#x2F;&#x2F; 派发消息到对应Handler</span><br><span class="line">             </span><br><span class="line">            msg.recycleUnchecked(); &#x2F;&#x2F; 释放message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>重点关注 next取message 和 enqueueMessage插入message方法</p>
<blockquote>
<p>主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，详情见Android消息机制1-Handler(Java层)，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基于Native JNI实现，重点看next和enqueueMessage方法</span><br><span class="line">public final class MessageQueue &#123;</span><br><span class="line"></span><br><span class="line">    private long mPtr; &#x2F;&#x2F; 保存Native层的MessageQueue的对象</span><br><span class="line"></span><br><span class="line">    Message mMessages; &#x2F;&#x2F; 即将执行的message（链表头部）</span><br><span class="line">    private final ArrayList&lt;IdleHandler&gt; mIdleHandlers &#x3D; new ArrayList&lt;IdleHandler&gt;(); &#x2F;&#x2F; 空闲handler列表（用于添加空闲任务）</span><br><span class="line">    private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">    private IdleHandler[] mPendingIdleHandlers; &#x2F;&#x2F; IdleHandler数组</span><br><span class="line">    private boolean mQuitting; &#x2F;&#x2F; 是否终止</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span><br><span class="line">    private boolean mBlocked; &#x2F;&#x2F; 表明next方法是否block 当调用JNI pollOnce方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The next barrier token.</span><br><span class="line">    &#x2F;&#x2F; Barriers are indicated by messages with a null target whose arg1 field carries the token.</span><br><span class="line">    private int mNextBarrierToken;</span><br><span class="line">    &#x2F;&#x2F; JNI 方法</span><br><span class="line">    private native static long nativeInit();</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed &#x3D; quitAllowed;</span><br><span class="line">        mPtr &#x3D; nativeInit(); &#x2F;&#x2F; 进行native层初始化</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点方法 ，获取下一个待处理任务 （部分重点代码）</span><br><span class="line">    Message next() &#123;</span><br><span class="line">        int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; 用于IdleHandler任务处理</span><br><span class="line">        int nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis); &#x2F;&#x2F;Native Looper的epoll</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">             </span><br><span class="line">                final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg &#x3D; null;</span><br><span class="line">                Message msg &#x3D; mMessages;</span><br><span class="line">                if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 处理无target的异步消息 （暂时忽略）</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg &#x3D; msg;</span><br><span class="line">                        msg &#x3D; msg.next;</span><br><span class="line">                    &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (msg !&#x3D; null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 标记下一次轮训时间</span><br><span class="line">                        nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        </span><br><span class="line">                        mBlocked &#x3D; false;</span><br><span class="line">                        if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                            prevMsg.next &#x3D; msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages &#x3D; msg.next; &#x2F;&#x2F; 记录下一个头部message</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next &#x3D; null;</span><br><span class="line">                        </span><br><span class="line">                        msg.markInUse(); &#x2F;&#x2F; 标记message状态</span><br><span class="line">                        return msg; &#x2F;&#x2F; 返回message</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                if (mQuitting) &#123; &#x2F;&#x2F; 终止</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 后面是 IdleHandler相关处理逻辑（暂时忽略）</span><br><span class="line">                ......</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点方法 ，Message入队 （部分重点代码）</span><br><span class="line">    boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            msg.markInUse(); &#x2F;&#x2F; </span><br><span class="line">            msg.when &#x3D; when;</span><br><span class="line">            Message p &#x3D; mMessages;</span><br><span class="line">            boolean needWake;</span><br><span class="line">            if (p &#x3D;&#x3D; null || when &#x3D;&#x3D; 0 || when &lt; p.when) &#123;</span><br><span class="line">                &#x2F;&#x2F; 立即执行任务，标记为head message。</span><br><span class="line">                msg.next &#x3D; p;</span><br><span class="line">                mMessages &#x3D; msg;</span><br><span class="line">                needWake &#x3D; mBlocked; &#x2F;&#x2F; 唤醒，如果处于blocked状态</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 考虑是否异步任务</span><br><span class="line">                needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                &#x2F;&#x2F; 根据执行时间先后，插入message链表队列</span><br><span class="line">                for (;;) &#123; </span><br><span class="line">                    prev &#x3D; p;</span><br><span class="line">                    p &#x3D; p.next;</span><br><span class="line">                    if (p &#x3D;&#x3D; null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next &#x3D; p; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next</span><br><span class="line">                prev.next &#x3D; msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 唤醒. 参考JNI方法</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JNI方法（参考）<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Native层</a></p>
<p>MessageQueue通过mPtr变量保存NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Looper.cpp</span><br><span class="line"></span><br><span class="line">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        result &#x3D; pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Looper::pollInner(int timeoutMillis) &#123;</span><br><span class="line">	...</span><br><span class="line">    &#x2F;&#x2F; Poll.</span><br><span class="line">    int result &#x3D; POLL_WAKE;</span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We are about to idle.</span><br><span class="line">    mIdling &#x3D; true;</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">	&#x2F;&#x2F;阻塞等待可以读取管道的通知</span><br><span class="line">    int eventCount &#x3D; epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No longer idling.</span><br><span class="line">    mIdling &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Acquire lock.</span><br><span class="line">    mLock.lock();</span><br><span class="line">	...</span><br><span class="line">    for (int i &#x3D; 0; i &lt; eventCount; i++) &#123;</span><br><span class="line">        int fd &#x3D; eventItems[i].data.fd;</span><br><span class="line">        uint32_t epollEvents &#x3D; eventItems[i].events;</span><br><span class="line">        if (fd &#x3D;&#x3D; mWakeReadPipeFd) &#123;</span><br><span class="line">            if (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();&#x2F;&#x2F; 关键代码方法</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Looper::awoken() &#123; &#x2F;&#x2F; 唤醒方法 （enqueueMessage方法调用）</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ awoken&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    char buffer[16];</span><br><span class="line">    ssize_t nRead;</span><br><span class="line">    do &#123;</span><br><span class="line">        nRead &#x3D; read(mWakeReadPipeFd, buffer, sizeof(buffer));&#x2F;&#x2F;可以看到读取了管道中的内容</span><br><span class="line">    &#125; while ((nRead &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EINTR) || nRead &#x3D;&#x3D; sizeof(buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Looper::wake() &#123; &#x2F;&#x2F; 最终调用到 native wake方法</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ wake&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ssize_t nWrite;</span><br><span class="line">    do &#123;</span><br><span class="line">        nWrite &#x3D; write(mWakeWritePipeFd, &quot;W&quot;, 1);&#x2F;&#x2F;进行了写操作</span><br><span class="line">    &#125; while (nWrite &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EINTR);</span><br><span class="line"></span><br><span class="line">    if (nWrite !&#x3D; 1) &#123;</span><br><span class="line">        if (errno !&#x3D; EAGAIN) &#123;</span><br><span class="line">            ALOGW(&quot;Could not write wake signal, errno&#x3D;%d&quot;, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Android线程消息循环模型"><a href="#Android线程消息循环模型" class="headerlink" title="Android线程消息循环模型"></a>Android线程消息循环模型</h3><h4 id="主线程消息循环模型"><a href="#主线程消息循环模型" class="headerlink" title="主线程消息循环模型"></a>主线程消息循环模型</h4><p>ActivityThread通过ApplicationThread和AMS进行进程间通讯，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，</p>
<p>system_server进程：<br>系统进程，包含了大量的系统服务。如图中ApplicationThreadProxy、ActivityManagerService，这两个服务都运行在system_server进程的不同线程中。另外ATP、AMS都是基于IBinder接口，属于binder线程，都是由binder底层驱动创建和销毁</p>
<p>App进程：<br>即应用程序，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作；另外每个App进程至少都有两个Binder线程，ApplicationThread和ActivityManagerProxy。</p>
<p>Binder<br>用于不同进程之间通信</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-5f594a326e5a7d2e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程消息循环模型"></p>
<h4 id="主线程与子线程交互的消息循环模型"><a href="#主线程与子线程交互的消息循环模型" class="headerlink" title="主线程与子线程交互的消息循环模型"></a>主线程与子线程交互的消息循环模型</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-cb9d80fde5fadfb6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程与子线程交互的消息循环模型.jpg"></p>
<h3 id="Android线程和线程池相关概念"><a href="#Android线程和线程池相关概念" class="headerlink" title="Android线程和线程池相关概念"></a>Android线程和线程池相关概念</h3><p>参考：<a href="[https://www.jianshu.com/p/d9e46d5a4af9](https://www.jianshu.com/p/d9e46d5a4af9">Java线程池理解</a></p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h5 id="Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？"><a href="#Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？" class="headerlink" title="Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？"></a>Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？</h5><p>见MessageQueue的next方法，涉及到Linux pipe/epoll机制，因为在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next ()中的nativePollOnce方法里，这是主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事物发生。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 </p>
<h5 id="主线程的消息循环机制是什么（死循环如何处理其它事务）？"><a href="#主线程的消息循环机制是什么（死循环如何处理其它事务）？" class="headerlink" title="主线程的消息循环机制是什么（死循环如何处理其它事务）？"></a>主线程的消息循环机制是什么（死循环如何处理其它事务）？</h5><p>参考前面的主线程消息模型图例</p>
<h5 id="ActivityThread-的动力是什么？（ActivityThread执行Looper的线程是什么）"><a href="#ActivityThread-的动力是什么？（ActivityThread执行Looper的线程是什么）" class="headerlink" title="ActivityThread 的动力是什么？（ActivityThread执行Looper的线程是什么）"></a>ActivityThread 的动力是什么？（ActivityThread执行Looper的线程是什么）</h5><p>ActivityThread通过main方法执行，也就是咱们的Runtime线程。该线程默认是不可quit的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  程序入口，runtime线程执行</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">       Looper.prepareMainLooper(); &#x2F;&#x2F; 将该线程对应Looper标记为MainLooper</span><br><span class="line"></span><br><span class="line">       ActivityThread thread &#x3D; new ActivityThread(); </span><br><span class="line">       thread.attach(false, startSeq);  &#x2F;&#x2F; 初始化ActivityThread</span><br><span class="line">       if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">           sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Looper.loop(); &#x2F;&#x2F; 循环</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="Handler-是如何能够线程切换，发送Message的？（线程间通讯）"><a href="#Handler-是如何能够线程切换，发送Message的？（线程间通讯）" class="headerlink" title="Handler 是如何能够线程切换，发送Message的？（线程间通讯）"></a>Handler 是如何能够线程切换，发送Message的？（线程间通讯）</h5><p>主线程到其它线程，只需要创建线程执行任务就可以。其它线程切回主线程，只需要拿到或者创建主线程Handler既可以发送消息切换回去</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/03/10/Reference%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/03/10/Reference%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Reference子类源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-10 16:04:25" itemprop="dateCreated datePublished" datetime="2019-03-10T16:04:25+08:00">2019-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:42:16" itemprop="dateModified" datetime="2020-02-07T00:42:16+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SoftReference和WeakReference"><a href="#SoftReference和WeakReference" class="headerlink" title="SoftReference和WeakReference"></a>SoftReference和WeakReference</h3><p>我们知道这两个类基本功能相似，区别在于当引用对象为空的时候，WeakRefreence对象会在GC回收的时候被回收，而SoftReference则需要更苛刻的条件</p>
<h4 id="SoftReference实现原理"><a href="#SoftReference实现原理" class="headerlink" title="SoftReference实现原理"></a>SoftReference实现原理</h4><p>总结：GC回收时计算 SoftReference存活时间与剩余内存换算得出的时间进行大小比较（内存剩余空间*设定系数仅过换算规则计算得出），如果大于测认为需要回收，反之亦然</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;memory&#x2F;referenceProcessor.cpp</span><br><span class="line">if (rt &#x3D;&#x3D; REF_SOFT) &#123;</span><br><span class="line">    &#x2F;&#x2F; 是否需要清除软引用</span><br><span class="line">    if (!_current_soft_ref_policy-&gt;should_clear_reference(obj, _soft_ref_timestamp_clock)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; should_clear_reference 实现如下</span><br><span class="line">bool LRUMaxHeapPolicy::should_clear_reference(oop p,</span><br><span class="line">                                             jlong timestamp_clock) &#123;</span><br><span class="line">  jlong interval &#x3D; timestamp_clock - java_lang_ref_SoftReference::timestamp(p);</span><br><span class="line">  assert(interval &gt;&#x3D; 0, &quot;Sanity check&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The interval will be zero if the ref was accessed since the last scavenge&#x2F;gc.</span><br><span class="line">  if(interval &lt;&#x3D; _max_interval) &#123; &#x2F;&#x2F; 与_max_interval比较</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Capture state (of-the-VM) information needed to evaluate the policy</span><br><span class="line">void LRUMaxHeapPolicy::setup() &#123;</span><br><span class="line">  size_t max_heap &#x3D; MaxHeapSize;</span><br><span class="line">  max_heap -&#x3D; Universe::get_heap_used_at_last_gc();</span><br><span class="line">  max_heap &#x2F;&#x3D; M;</span><br><span class="line"></span><br><span class="line">  _max_interval &#x3D; max_heap * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">  &#x2F;&#x2F; _max_interval 计算</span><br><span class="line">  assert(_max_interval &gt;&#x3D; 0,&quot;Sanity check&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SoftReference对象记录两个时间，目的就是为了GC判断是否需要清除</span><br><span class="line">public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 由JVM负责更新的，记录了上一次GC发生的时间。</span><br><span class="line">    static private long clock;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每次调用 get 方法都会更新，记录了当前Reference最后一次被访问的时间。</span><br><span class="line">    private long timestamp;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent) &#123;</span><br><span class="line">        super(referent);</span><br><span class="line">        this.timestamp &#x3D; clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">        this.timestamp &#x3D; clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 和super.get的逻辑最大的不同，就在于每次调用get都会把上次发生GC的时间，也就是</span><br><span class="line">    &#x2F;&#x2F; clock 更新到 timestamp 中去。</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        T o &#x3D; super.get();</span><br><span class="line">        if (o !&#x3D; null &amp;&amp; this.timestamp !&#x3D; clock)</span><br><span class="line">            this.timestamp &#x3D; clock;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PhantomReference和Cleaner"><a href="#PhantomReference和Cleaner" class="headerlink" title="PhantomReference和Cleaner"></a>PhantomReference和Cleaner</h3><ul>
<li>不能访问到referent</li>
<li>Cleaner继承PhantomReference，它们本质流程都是Reference流程，有GC标记，ReferenceHandler处理</li>
<li>Cleaner的clean方法由ReferenceHandler调用，最终到thunk线程进行自定义资源回收处理，以及自己的释放</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; get方法永远是null，所以无法获得referent</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class Cleaner extends PhantomReference&lt;Object&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; Reference需要Queue，但Cleaner自己管理ref，所以虚构个无用Queue</span><br><span class="line">    private static final ReferenceQueue&lt;Object&gt; dummyQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 所有的cleaner都会被加到一个双向链表中去，确保回收前这些Cleaner都是存活的。</span><br><span class="line">    static private Cleaner first &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private Cleaner</span><br><span class="line">        next &#x3D; null,</span><br><span class="line">        prev &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造的时候把自己加到双向链表中去</span><br><span class="line">    private static synchronized Cleaner add(Cleaner cl) &#123;</span><br><span class="line">        if (first !&#x3D; null) &#123;</span><br><span class="line">            cl.next &#x3D; first;</span><br><span class="line">            first.prev &#x3D; cl;</span><br><span class="line">        &#125;</span><br><span class="line">        first &#x3D; cl;</span><br><span class="line">        return cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; clean方法会调用remove把当前的cleaner从链表中删除。</span><br><span class="line">    private static synchronized boolean remove(Cleaner cl) &#123;</span><br><span class="line">        &#x2F;&#x2F; If already removed, do nothing</span><br><span class="line">        if (cl.next &#x3D;&#x3D; cl)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update list</span><br><span class="line">        if (first &#x3D;&#x3D; cl) &#123;</span><br><span class="line">            if (cl.next !&#x3D; null)</span><br><span class="line">                first &#x3D; cl.next;</span><br><span class="line">            else</span><br><span class="line">                first &#x3D; cl.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cl.next !&#x3D; null)</span><br><span class="line">            cl.next.prev &#x3D; cl.prev;</span><br><span class="line">        if (cl.prev !&#x3D; null)</span><br><span class="line">            cl.prev.next &#x3D; cl.next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Indicate removal by pointing the cleaner to itself</span><br><span class="line">        cl.next &#x3D; cl;</span><br><span class="line">        cl.prev &#x3D; cl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用户自定义的一个Runnable对象，</span><br><span class="line">    private final Runnable thunk;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有有构造函数，保证了用户无法单独地使用new来创建Cleaner。</span><br><span class="line">    private Cleaner(Object referent, Runnable thunk) &#123;</span><br><span class="line">        super(referent, dummyQueue);</span><br><span class="line">        this.thunk &#x3D; thunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 所有的Cleaner都必须通过create方法进行创建。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Cleaner create(Object ob, Runnable thunk) &#123;</span><br><span class="line">        if (thunk &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        return add(new Cleaner(ob, thunk));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Reference Handler线程调用，来清理资源。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void clean() &#123;</span><br><span class="line">        if (!remove(this))</span><br><span class="line">            return;</span><br><span class="line">        try &#123;</span><br><span class="line">            thunk.run();</span><br><span class="line">        &#125; catch (final Throwable x) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        if (System.err !&#x3D; null)</span><br><span class="line">                            new Error(&quot;Cleaner terminated abnormally&quot;, x)</span><br><span class="line">                                .printStackTrace();</span><br><span class="line">                        System.exit(1);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FinalReference和Finalizer"><a href="#FinalReference和Finalizer" class="headerlink" title="FinalReference和Finalizer"></a>FinalReference和Finalizer</h3><ul>
<li>它本质流程依然与Reference类似</li>
<li>Finalizer的构造是通过标志由JVM构造（JVM构造的时候会判断finalize方法是否非空，最终会调用到register进行构造）</li>
<li>Finalizer加入的queue会被Finalizer线程进行处理</li>
<li>finalize方法只会调用一次，通过hasBeenFinalized这个tag保证</li>
<li>⚠️ finalize可以通过获取referent复活对象，其中存在很多安全隐患</li>
<li>⚠️ FinalizerThread为守护线程，优先级很低，很有可能抢占不到资源而导致资源无法回收</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/03/05/Reference%E5%92%8CReferenceQueue%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/03/05/Reference%E5%92%8CReferenceQueue%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Reference和ReferenceQueue相关源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-05 21:33:49" itemprop="dateCreated datePublished" datetime="2019-03-05T21:33:49+08:00">2019-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:41:41" itemprop="dateModified" datetime="2020-02-07T00:41:41+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="为什么需要引用？"><a href="#为什么需要引用？" class="headerlink" title="为什么需要引用？"></a>为什么需要引用？</h3><p>我们知道在最早的JVM实现里，是使用“跟踪回收”算法从GC ROOTS出发，按照BFS或者DFS遍历所有可达对象，针对不不可达对象进行回收。但随着Java演进，暴露出一些不能覆盖的场景，例如：某些场景下使用方希望在回收具体对象的同时还能辅助回收这个对象绑定的一些资源（如socket、堆外内存等）、某些场景下希望使用堆内缓存尽可能缓存更多更久的数据但不OOM。基于此，JDK在1.2引入了Refreence及其子类来支持一些新特性和功能</p>
<h3 id="Reference介绍"><a href="#Reference介绍" class="headerlink" title="Reference介绍"></a>Reference介绍</h3><h5 id="Reference类图"><a href="#Reference类图" class="headerlink" title="Reference类图"></a>Reference类图</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-fec84bdd662d2c10.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><strong>FinalReference</strong>，一种保底策略，因为GC只能管理自动内存资源而无法管理其它资源（如堆外内存、file handle、socket等），这些需要使用方手动对资源进行管理</li>
<li><strong>SoftReference</strong>，软引用，只有在堆内存不足时，垃圾回收器会回收对应引用。所以比较适合用来实现不是特别重要的缓存</li>
<li><strong>WeakReference</strong>，弱引用，每次垃圾回收都会回收其引用，一般在需要控制内存但又又想要尽量用到内存的场景下使用</li>
<li><strong>PhantomReference</strong>，虚引用，对引用无影响，只用于获取对象被回收的通知。和软引用以及弱引用不同的是幻影引用指向的对象没有其他强引用、软引用指向时不会自动被GC清理。</li>
</ul>
<p>⚠️ 因为默认的引用就是强引用，所以没有强引用的Reference实现类。<br>详情：<a href="https://www.jianshu.com/p/7ff38dfbb5a8" target="_blank" rel="noopener">Reference子类源码解析</a></p>
<h4 id="Reference生命周期"><a href="#Reference生命周期" class="headerlink" title="Reference生命周期"></a>Reference生命周期</h4><p>Referent被GC回收，则会根据是持有ReferenceQueue，而加入到对应到ReferenceQueue中，这样可以通过RQ来监听reference是否回收状态</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-78514b107996e4a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Reference运行结构"><a href="#Reference运行结构" class="headerlink" title="Reference运行结构"></a>Reference运行结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-0bd5881d52164f6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Reference源码"><a href="#Reference源码" class="headerlink" title="Reference源码"></a>Reference源码</h4><h6 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h6><ul>
<li>referent：  引用指向的对象</li>
<li>queue： ReferenceQueue，Reference构造的时候传入，其内部封装了单向链表的添加，删除和遍历等操作。用于Reference状态监听及管理</li>
<li>discovered：单向链表，由JVM维护</li>
<li>next：指向ReferenceQueue中下一个元素，ReferenceQueue链表指针</li>
<li>pending：discovered链表表头，在referent被回收后的reference<br>将有JVM标记，等待入队处理</li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ul>
<li>static代码块：构造ReferenceHandler线程，循环执行tryHandlePending方法</li>
<li>tryHandlePending：循环处理pending链表头，维护discovered链表，如果pending不为空，则进行插入ReferenceQueue进行后续操作。（这里如果是cleaner，则先进行clean操作）</li>
</ul>
<h6 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h6><ul>
<li>ReferenceHandler，线程实现类，run方法中循环调用Refreence的静态方法tryHandlePending</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于控制垃圾回收器操作与Pending状态的Reference入队操作不冲突执行的全局锁</span><br><span class="line">&#x2F;&#x2F; 垃圾回收器开始一轮垃圾回收前要获取此锁</span><br><span class="line">&#x2F;&#x2F; 所以所有占用这个锁的代码必须尽快完成，不能生成新对象，也不能调用用户代码</span><br><span class="line">static private class Lock &#123; &#125;;</span><br><span class="line">private static Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        super(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个线程一直执行</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Reference&lt;Object&gt; r;</span><br><span class="line">            &#x2F;&#x2F; 获取锁，避免与垃圾回收器同时操作</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断pending-Reference链表是否有数据</span><br><span class="line">                if (pending !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果有Pending Reference，从列表中取出</span><br><span class="line">                    r &#x3D; pending;</span><br><span class="line">                    pending &#x3D; r.discovered;</span><br><span class="line">                    r.discovered &#x3D; null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果没有Pending Reference，调用wait等待</span><br><span class="line">                    &#x2F;&#x2F; </span><br><span class="line">                    &#x2F;&#x2F; wait等待锁，是可能抛出OOME的，</span><br><span class="line">                    &#x2F;&#x2F; 因为可能发生InterruptedException异常，然后就需要实例化这个异常对象，</span><br><span class="line">                    &#x2F;&#x2F; 如果此时内存不足，就可能抛出OOME，所以这里需要捕获OutOfMemoryError，</span><br><span class="line">                    &#x2F;&#x2F; 避免因为OOME而导致ReferenceHandler进程静默退出</span><br><span class="line">                    try &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; catch (OutOfMemoryError x) &#123; &#125;</span><br><span class="line">                    &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Reference是Cleaner，调用其clean方法</span><br><span class="line">            &#x2F;&#x2F; 这与Cleaner机制有关系，不在此文的讨论访问</span><br><span class="line">            if (r instanceof Cleaner) &#123;</span><br><span class="line">                ((Cleaner)r).clean();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 把Reference添加到关联的ReferenceQueue中</span><br><span class="line">            &#x2F;&#x2F; 如果Reference构造时没有关联ReferenceQueue，会关联ReferenceQueue.NULL，这里就不会进行入队操作了</span><br><span class="line">            ReferenceQueue&lt;Object&gt; q &#x3D; r.queue;</span><br><span class="line">            if (q !&#x3D; ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReferenceQueue源码"><a href="#ReferenceQueue源码" class="headerlink" title="ReferenceQueue源码"></a>ReferenceQueue源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceQueue&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 单向链表</span><br><span class="line">    private volatile Reference&lt;? extends T&gt; head &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; </span><br><span class="line">    &#x2F;* Called only by Reference class *&#x2F;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">		&#x2F;&#x2F; 判断Reference是否需要入队</span><br><span class="line">        ReferenceQueue&lt;?&gt; queue &#x3D; r.queue;</span><br><span class="line">        if ((queue &#x3D;&#x3D; NULL) || (queue &#x3D;&#x3D; ENQUEUED)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        assert queue &#x3D;&#x3D; this;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Reference入队后，其queue变量设置为ENQUEUED</span><br><span class="line">        r.queue &#x3D; ENQUEUED;</span><br><span class="line">        &#x2F;&#x2F; Reference的next变量指向ReferenceQueue中下一个元素</span><br><span class="line">        r.next &#x3D; (head &#x3D;&#x3D; null) ? r : head;</span><br><span class="line">        head &#x3D; r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        if (r instanceof FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Reference&lt;? extends T&gt; poll() &#123;</span><br><span class="line">        &#x2F;&#x2F; 出队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Reference类解决的三个问题"><a href="#Reference类解决的三个问题" class="headerlink" title="Reference类解决的三个问题"></a>Reference类解决的三个问题</h3><ul>
<li>实现特定的引用类型，支持不同功能</li>
<li>使用者可以在对象被回收后得到通知</li>
<li>使用者可以自定义回收，进行非GC回收的资源释放</li>
</ul>
<p>参考<br><a href="https://coldwalker.com/2019/02//gc_intro/" target="_blank" rel="noopener">https://coldwalker.com/2019/02//gc_intro/</a><br><a href="https://github.com/zxiaofan/JDK/blob/master/JDK1.8/src/java/lang/ref/ReferenceQueue.java" target="_blank" rel="noopener">https://github.com/zxiaofan/JDK/blob/master/JDK1.8/src/java/lang/ref/ReferenceQueue.java</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2018/02/11/JVM%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E7%9A%84%E5%89%AF%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/02/11/JVM%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E7%9A%84%E5%89%AF%E6%9C%AC/" class="post-title-link" itemprop="url">JVM内存相关总结的副本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-11 14:08:39" itemprop="dateCreated datePublished" datetime="2018-02-11T14:08:39+08:00">2018-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:49:35" itemprop="dateModified" datetime="2020-02-07T00:49:35+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JVM大体结构图"><a href="#JVM大体结构图" class="headerlink" title="JVM大体结构图"></a>JVM大体结构图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-10ef43c4b4f8a6eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><ul>
<li>线程隔离数据区<ul>
<li>程序计算器<ul>
<li>当前线程执行字节码的行号指示器</li>
<li>如分支、循环、跳转、异常处理、线程恢复等</li>
</ul>
</li>
<li>虚拟机栈<ul>
<li>栈帧存储区域，栈帧包含局部变量、操作数栈、动态链接、方法出口等</li>
<li>异常情况，StackOverflowError、OutOfMemoryError</li>
</ul>
</li>
<li>本地方法栈 <ul>
<li>JNI服务使用的栈，作用于本地方法（C/C++） </li>
</ul>
</li>
</ul>
</li>
<li>线程共享数据区<ul>
<li>Java堆<ul>
<li>存储对象实例</li>
<li>异常情况， OutOfMemoryError、内存泄漏</li>
</ul>
</li>
<li>方法区 <ul>
<li>存储加载的类信息、常量、静态变量、JIT编译后的代码等数据</li>
<li>异常情况，OutOfMemoryError</li>
<li>运行时常量池，字面量、符号引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象创建与回收过程"><a href="#对象创建与回收过程" class="headerlink" title="对象创建与回收过程"></a>对象创建与回收过程</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-a2f5045f5ab5eccb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="JVM垃圾收集算法"><a href="#JVM垃圾收集算法" class="headerlink" title="JVM垃圾收集算法"></a>JVM垃圾收集算法</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul>
<li>内存分成大小相等的两块，每次使用其中一块，回收的时候，把存活的对象复制到另一块，然后把这块内存整个清理掉</li>
<li>优点，回收效率提高、不存在碎片化</li>
<li>缺点，内存利用率低</li>
<li>解决，采用非对称法，eden:survivor = 8:1<br><img src="http://upload-images.jianshu.io/upload_images/9696036-c07b3961929e9872.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><ul>
<li>标记阶段，确定所有要回收的对象，做标记</li>
<li>清除阶段，将标记阶段确定的回收对象进行清除</li>
<li>优点，简单，最基础算法 </li>
<li>缺点，效率低，碎片化<br><img src="http://upload-images.jianshu.io/upload_images/9696036-af74e3fbdcf1e7ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><ul>
<li>把存活对象移动到内存的一端，然后直接回收边界以外的内存</li>
<li>场景,适合老年代存活对象较多的情况，减少内存复制量</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-2af17d66179a1ad3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-8457b2b3c2eae67d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Serial-SerialOld"><a href="#Serial-SerialOld" class="headerlink" title="Serial/SerialOld"></a>Serial/SerialOld</h4><ul>
<li>过程<ol>
<li>收集GC_ROOTS</li>
<li>对象可达性分析</li>
<li>标记垃圾对象</li>
<li>清理垃圾对象 </li>
</ol>
</li>
<li>优点，简单高效    </li>
<li>缺点，STW，服务停顿时间长 </li>
<li>场景，几百兆以内客户端程序<br><img src="http://upload-images.jianshu.io/upload_images/9696036-1f48e73d09b24f8b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="Parnew-Parallel-Scavenge-Parallel-Old"><a href="#Parnew-Parallel-Scavenge-Parallel-Old" class="headerlink" title="Parnew/Parallel Scavenge/Parallel Old"></a>Parnew/Parallel Scavenge/Parallel Old</h4><h5 id="Serial算法多线程版"><a href="#Serial算法多线程版" class="headerlink" title="Serial算法多线程版"></a>Serial算法多线程版</h5><ul>
<li>优点，多线程，回收速度快 </li>
<li>缺点，依然会暂停服务</li>
<li>场景，对响应时间要求不高的Server端</li>
</ul>
<p>ParNew与Parallel Scanvenge区别</p>
<ul>
<li>Parnew关注回收速度，多线程减少单词GC时间</li>
<li>Parallel Scanvenge关注吞吐量，减少GC时间占比<br><img src="http://upload-images.jianshu.io/upload_images/9696036-ba913709dfc65c9c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="CMS-Concurrent-Mark-Sweep-算法"><a href="#CMS-Concurrent-Mark-Sweep-算法" class="headerlink" title="CMS(Concurrent Mark Sweep)算法"></a>CMS(Concurrent Mark Sweep)算法</h4><ul>
<li>优点，并发，暂停时间短</li>
<li>缺点，耗CPU、GC时间长，GC提前，浮动垃圾，碎片化</li>
<li>场景，对响应时间敏感的Server服务，大部分线上服务应该是CMS<br><img src="http://upload-images.jianshu.io/upload_images/9696036-6c2a95b66e1b3040.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h4><ul>
<li>新一代垃圾回收算法</li>
<li>场景，大内存、高响应的服务端应用<br><img src="http://upload-images.jianshu.io/upload_images/9696036-9fd6fdd04512a592.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h3 id="JVM工具集"><a href="#JVM工具集" class="headerlink" title="JVM工具集"></a>JVM工具集</h3><h4 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h4><ul>
<li>查看当前用户java进程，类似于ps</li>
<li>-q 只输出LVMID(与PID一致)，省略主类的名称 </li>
<li>-m 输出启动时传递给主类main函数的参数</li>
<li>-l 输出主类的全名，如果是jar包，输出jar路径</li>
<li>-v 输出启动时的jvm参数</li>
</ul>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><ul>
<li>用于监视虚拟机各种运行状态信息，例如类装载、内存、垃圾收集、 jit编译等运行参数</li>
<li>-class 监视类装载、卸载数量、总空间以及装载所耗费时间等</li>
<li>-gc 监视java堆状况，包括eden区，survivor区，老年代，永久代的容量、已用 空间和 GC时间等信息</li>
<li>-gcnew 监视新生代GC状况</li>
<li>-gcold 监视老年代GC状况</li>
<li>-compiler 输出JIT编译器编译过的方法、耗时等信息</li>
</ul>
<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul>
<li>java内存映像工具，用于生成堆转储快照，即dump文件，结合JHAT、MAT或者VisualVM等软件 来分析java内存的详细使用情况，便于排查java内存问题</li>
<li>-dump 生成堆转储快照</li>
<li>-finalizerinfo 显示在等待执行finalize方法的对象</li>
<li>-heap 显示java堆详细信息，如使用的回收器、参数配置、分代状况等</li>
<li>-histo 显示堆中对象统计信息，包括类、实例数量、合计容量等</li>
<li>-permstat 以classloader为统计口径显示永久代内存状态</li>
<li>-F 强制生成堆转出快照</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://plumbr.io/handbook/what-is-garbage-collection" target="_blank" rel="noopener">https://plumbr.io/handbook/what-is-garbage-collection</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2018/02/10/java%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/02/10/java%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">java对象生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-10 17:05:09" itemprop="dateCreated datePublished" datetime="2018-02-10T17:05:09+08:00">2018-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:48:35" itemprop="dateModified" datetime="2020-02-07T00:48:35+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Java对象生命周期图"><a href="#Java对象生命周期图" class="headerlink" title="Java对象生命周期图"></a>Java对象生命周期图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-0dd562d1863f77b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="创建阶段（Created）"><a href="#创建阶段（Created）" class="headerlink" title="创建阶段（Created）"></a>创建阶段（Created）</h3><ul>
<li>分配存储空间</li>
<li>开始构造对象</li>
<li>父类到子类依次初始化类变量</li>
<li>父类成员初始化，父类构造函数初始化</li>
<li>子类成员初始化，子类构造函数初始化</li>
</ul>
<h3 id="应用阶段（In-Use）"><a href="#应用阶段（In-Use）" class="headerlink" title="应用阶段（In Use）"></a>应用阶段（In Use）</h3><p>对象被一个或多个强引用持有，并且在作用域内</p>
<h3 id="不可见阶段（Invisible）"><a href="#不可见阶段（Invisible）" class="headerlink" title="不可见阶段（Invisible）"></a>不可见阶段（Invisible）</h3><p>其它区域已经不可以再引用它，本地变量超出了可见范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        Object a &#x3D; new Object();</span><br><span class="line">    &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    a.clone(); &#x2F;&#x2F; 该区域a不可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不可达阶段（Unreachable）"><a href="#不可达阶段（Unreachable）" class="headerlink" title="不可达阶段（Unreachable）"></a>不可达阶段（Unreachable）</h3><p>不再被任何强引用所持有</p>
<h3 id="收集阶段（Collected）"><a href="#收集阶段（Collected）" class="headerlink" title="收集阶段（Collected）"></a>收集阶段（Collected）</h3><p>对象不可达，并且垃圾回收器已经对该对象的内存空间重新分配做好准备时</p>
<h3 id="终结阶段（Finalized）"><a href="#终结阶段（Finalized）" class="headerlink" title="终结阶段（Finalized）"></a>终结阶段（Finalized）</h3><p>对象执行完finalize方法后，等待垃圾回收器对对象空间进行回收</p>
<h3 id="对象重新分配阶段（Deallocated）"><a href="#对象重新分配阶段（Deallocated）" class="headerlink" title="对象重新分配阶段（Deallocated）"></a>对象重新分配阶段（Deallocated）</h3><p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，此时称为对象空间重新分配阶段</p>
<h3 id="子父类代码执行顺序图"><a href="#子父类代码执行顺序图" class="headerlink" title="子父类代码执行顺序图"></a>子父类代码执行顺序图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-ad430f40c254dee1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2018/02/10/Java%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/02/10/Java%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">Java类生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-10 17:05:02" itemprop="dateCreated datePublished" datetime="2018-02-10T17:05:02+08:00">2018-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:48:56" itemprop="dateModified" datetime="2020-02-07T00:48:56+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Java类生命周期图"><a href="#Java类生命周期图" class="headerlink" title="Java类生命周期图"></a>Java类生命周期图</h3><p> <img src="http://upload-images.jianshu.io/upload_images/9696036-fbfb4eb49ba287ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li>验证是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>
<li>包括文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li>类变量分配内存，并设为jvm默认的初始值</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>将常量池内的符号引用替换为直接引用的过程</li>
<li>主要针对类或接口、字段、类方法、接口方法四类符号引用进行解析</li>
<li>符号引用<ul>
<li>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中</li>
</ul>
</li>
<li>直接引用<ul>
<li>可以是直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化阶段是执行类构造器clinit方法的过程</li>
<li>clinit方法<ul>
<li>由编译器自动收集所有类变量（静态非final） 赋值操作和静态代码块语句合并产生</li>
<li>收集顺序由出现顺序决定，定义在前面的不能访问定义在后面的类变量</li>
<li>虚拟机保证父类clinit方法先于子类clinit方法执行</li>
<li>类或接口不一定都有clinit方法</li>
<li>虚拟机保证clinit方法在多线程环境下被正确的加锁和同步</li>
</ul>
</li>
<li>时机<ul>
<li>new、操作该类类变量、调用类方法</li>
<li>对类反射</li>
<li>子类初始化的时候，父类还没有初始化，则会先进行父类初始化</li>
<li>main函数对应的类</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>参考对象生命周期</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>jvm回收条件</p>
<ul>
<li>该类所有的实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>Class对象没有任何地方被引用，且无法在任何地方通过反射访问该类的方法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2018/02/10/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/02/10/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">Java类加载器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-10 09:27:57" itemprop="dateCreated datePublished" datetime="2018-02-10T09:27:57+08:00">2018-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:48:08" itemprop="dateModified" datetime="2020-02-07T00:48:08+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>“通过一个类的全限定名来获取描述此类的二进制字节流。” ——实现这个动作的代码模块称为类加载器。</p>
<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><ul>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为 JVM 方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li>如果想维持双亲委派机制，则覆写findClass方法</li>
<li>如果想打破双亲委派机制，则覆写loadClass方法</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-bdec0871909f7e63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h5><ul>
<li><p>Java类库的隔离：不同应用程序使用不同的类加载器，可以实现Java类库的隔离。</p>
</li>
<li><p>Java类库的共享：通过Common类加载器和Shared类加载器可以实现Java类库的共享。</p>
</li>
<li><p>安全：服务器和应用程序有各自的类加载器加载Class文件。服务器的类库与应用程序的类库可以互相独立。</p>
</li>
<li><p>支持HotSwap（热替换）：JSP文件有独立的类加载器，服务器能通过替换JSP文件的类加载器来实现JSP的HotSwap功能。</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-6c2d2a58d8a20614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Android类加载图"><a href="#Android类加载图" class="headerlink" title="Android类加载图"></a>Android类加载图</h3><h4 id="加载阶段-1"><a href="#加载阶段-1" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>通过一个dex文件或者apk文件的路径完成类的加载</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>BootClassLoader，主要用于加载系统的类，包括java和Android系统的类库</li>
<li>PathClassLoader，主要用于加载应用内中的类，路径是固定的，只能加载/data/app中的apk，无法指定dex路径</li>
<li>DexClassLoader，可任意加载.apk、zip或jar等，实现动态加载</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-635865c5ccbce353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>类加载器相关应用，插件化、热补等</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2018/02/08/Java8%E4%B8%ADHashMap%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/02/08/Java8%E4%B8%ADHashMap%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Java8中HashMap分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-08 14:03:54" itemprop="dateCreated datePublished" datetime="2018-02-08T14:03:54+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:40:56" itemprop="dateModified" datetime="2020-02-07T00:40:56+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Put方法流程图"><a href="#Put方法流程图" class="headerlink" title="Put方法流程图"></a>Put方法流程图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-d3f845741e8a5756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>高16bit不变，低16bit和高16bit做了一个异或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><ul>
<li>map中存储的KV数目</li>
<li>值为2的n次幂<ul>
<li>哈希表是通过除法散列法，取模会用到除法运算，效率很低，而HashMap通过 h&amp;（length－1）替代取模</li>
<li>length 为2的整数次幂，是为了使不同hash值发生碰撞概率小即更均匀散列</li>
<li>length 的值为100..0，length－1为011..1，相当于对取模，而且保证了hash可以奇偶都有</li>
</ul>
</li>
</ul>
<h4 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h4><ul>
<li>阀值，=容量*loadFactor（负载因子，默认0.75）</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><ul>
<li>hash与旧链表大小做 &amp; 运算，=0不变，=1移动到原位置+旧链表大小的位置<br><img src="http://upload-images.jianshu.io/upload_images/9696036-07f14b44d2fd625b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h3 id="线程是否安全"><a href="#线程是否安全" class="headerlink" title="线程是否安全"></a>线程是否安全</h3><ul>
<li>JDK1.7，扩容前后链表导致，转移过程中修改了原来链表中节点引用关系，可能导致死循环</li>
<li>JDK1.8，不会引起死循环，但put／get不一定同步</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-08 14:03:54" itemprop="dateCreated datePublished" datetime="2018-02-08T14:03:54+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 11:12:53" itemprop="dateModified" datetime="2020-02-07T11:12:53+08:00">2020-02-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://upload-images.jianshu.io/upload_images/9696036-b89e727f8e21dc43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/9696036-959c5e557465806f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2018/02/08/%E8%87%AA%E5%AE%9A%E4%B9%89UUID-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/02/08/%E8%87%AA%E5%AE%9A%E4%B9%89UUID-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/" class="post-title-link" itemprop="url">自定义UUID-移动设备唯一标识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-08 14:03:54" itemprop="dateCreated datePublished" datetime="2018-02-08T14:03:54+08:00">2018-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 10:16:46" itemprop="dateModified" datetime="2020-02-07T10:16:46+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">应用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>希望自主生成用于所有移动业务上标识设备唯一性的标识符</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>业务支撑、日活和新增设备等数据统计、风控等</p>
<h3 id="uuid系统图"><a href="#uuid系统图" class="headerlink" title="uuid系统图"></a>uuid系统图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-3430540af001a4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="UUID生成"><a href="#UUID生成" class="headerlink" title="UUID生成"></a>UUID生成</h3><h4 id="移动端相关参数"><a href="#移动端相关参数" class="headerlink" title="移动端相关参数"></a>移动端相关参数</h4><h5 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h5><pre><code>IMEI

* International Mobile Equipment Identity，移动设备国际识别码，是手机的唯一识别号码。等价于DeviceId
* 仅支持具有通话功能的设备，例如平板没有
* 需要权限，并且在少数手机拿到的是不合法值
* 一定的重复率（约5%）

MAC Address

* 支持带有Wifi和蓝牙硬件的设备
* 需要权限

Sim Serial Number

* Sim卡序列号
* 对于CDMA设备，返回一个空值</code></pre><h5 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h5><pre><code>IDFA: 广告标志符,重置系统、还原广告会重新生成）
OpenUDID: 由OpenUDID的SDK包生成，该应用重置则会重新生成
keychain: 系统级存储，用于生成的标识存储
MACAddress和UDID:老版本兼容按需使用</code></pre><h4 id="uuid生成算法"><a href="#uuid生成算法" class="headerlink" title="uuid生成算法"></a>uuid生成算法</h4><p>相关参数：客户端类型、版本号、设备信息长度、设备信息内容（见上）、时间戳、设备信息类型、随机数<br>原则：生成uuid唯一，设备信息可反查，设备信息关联uuid，设备信息可校验等<br>算法：32位明文存储相关信息，AES64对称加密</p>
<h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><table>
<thead>
<tr>
<th>uuid</th>
<th>imei</th>
<th>mac</th>
<th>simid</th>
<th>idfa</th>
<th>keychainid</th>
<th>openudid</th>
<th>idfa</th>
<th align="left">udid</th>
<th align="left">Xxx</th>
</tr>
</thead>
</table>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>uuid没法保存<br>uuid合法性（去重、是否作弊）<br>兼容已有uuid<br>防止刷接口<br>防止伪造uuid</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/blog/page/6/">6</a><a class="extend next" rel="next" href="/blog/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Afree</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Afree</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  


</body>
</html>
