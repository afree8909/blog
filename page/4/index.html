<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"afree8909.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":20},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Afree&#39;s blog">
<meta property="og:url" content="https://afree8909.github.io/blog/page/4/index.html">
<meta property="og:site_name" content="Afree&#39;s blog">
<meta property="article:author" content="Afree">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://afree8909.github.io/blog/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Afree's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Afree's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">保持好奇心，不畏边界，持续学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/11/03/Android%E5%BA%94%E7%94%A8%E2%80%94%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/11/03/Android%E5%BA%94%E7%94%A8%E2%80%94%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Android应用—性能监控指标总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-03 17:37:33" itemprop="dateCreated datePublished" datetime="2019-11-03T17:37:33+08:00">2019-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:08:36" itemprop="dateModified" datetime="2020-02-07T01:08:36+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">应用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><h4 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h4><ul>
<li>来源  <ul>
<li>Java层：通过设置异常处理的Handler Thread.setDefaultUncaughtExceptionHandler实现</li>
<li>Native层：<a href="https://juejin.im/entry/5962e439f265da6c2810c8aa" target="_blank" rel="noopener">参考</a></li>
</ul>
</li>
</ul>
<h4 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h4><ul>
<li>来源<ul>
<li>通过FileObserver监听/data/anr目录变化，当有traces.txt文件时代表有新ANR发生</li>
<li>通过Handler定期发送消息，并计算5秒内消失是否被处理，如果没处理代表主线程消息队列被阻塞。</li>
</ul>
</li>
</ul>
<h3 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h3><h4 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h4><ul>
<li>来源<ul>
<li>在Anroid N以下版本中通过Choreographer的FrameCallback的doFrame中计算1秒内绘制的次数</li>
<li>在Android N及以上版本中是通过向window中添加Window.OnFrameMetricsAvailableListener，在回调中计算获得 </li>
</ul>
</li>
<li>页面FPS</li>
<li>滚动FPS</li>
<li>自动义FPS</li>
</ul>
<h4 id="启动时长"><a href="#启动时长" class="headerlink" title="启动时长"></a>启动时长</h4><ul>
<li>app冷启动时长<ul>
<li>来源，使用Linux进程启动时间作为冷启动开始时间，从”/proc/$pid/stat”文件中解析得到</li>
</ul>
</li>
<li>页面启动时长</li>
<li>页面首屏时长</li>
<li>自定义测速时长</li>
</ul>
<h3 id="耗损"><a href="#耗损" class="headerlink" title="耗损"></a>耗损</h3><h4 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h4><ul>
<li>来源<ul>
<li>系统路径：查看 /proc/net/xt_qtaguid/stats</li>
<li>系统函数： 调用接口TrafficStats.getUidRxBytes()和TrafficStats.getUidTxBytes()</li>
<li>系统路径： 进入 /proc/uid_stat/[uid命名的目录]/tcp_snd 和 /proc/uid_stat/[uid命名的目录]/tcp_rcv </li>
<li>AOP：流量的统计是在网络层在编译阶段通过gradle插件插入字节码基于AOP实现流量统计，针对不同网络库主要包含HttpClient、okhttp2/okhttp3、HttpUrlConnection、自定义网络框架。通过计算Request和Response body的大小统计上行和下行流量</li>
</ul>
</li>
</ul>
<h4 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h4><ul>
<li>来源<ul>
<li>一种是利用系统提供的Api（BatteryStatsHelper等）来计算，</li>
<li>一种是Battery Historian工具。</li>
</ul>
</li>
</ul>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul>
<li>来源<ul>
<li>CPU总使用率，在proc/stat下有具体的CPU使用情况</li>
</ul>
</li>
</ul>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul>
<li>来源<ul>
<li>内存的统计是通过Debug.getPss()抽样的获取PSS内存计算平均值所得 </li>
</ul>
</li>
</ul>
<h3 id="业务指标"><a href="#业务指标" class="headerlink" title="业务指标"></a>业务指标</h3><h4 id="端到端"><a href="#端到端" class="headerlink" title="端到端"></a>端到端</h4><ul>
<li>网络成功率</li>
<li>业务成功率<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4></li>
<li>加载显示成功率</li>
<li>加载平均耗时</li>
<li>大小监控</li>
</ul>
<h3 id="软硬件指标"><a href="#软硬件指标" class="headerlink" title="软硬件指标"></a>软硬件指标</h3><p>设备型号<br>操作系统<br>屏幕分辨率<br>手机RAM<br>root状态<br>存储空间<br>网络类型</p>
<h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><ul>
<li>指标定义、数据收集、问题分析、问题解决方案等方面一一分析</li>
<li>数据平台建设指导</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/08/25/Android%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/08/25/Android%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Android系统—进程创建流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-25 17:18:10" itemprop="dateCreated datePublished" datetime="2019-08-25T17:18:10+08:00">2019-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:08:12" itemprop="dateModified" datetime="2020-02-07T01:08:12+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p>
<h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>每个App在启动前必须先创建一个进程，该进程是由Zygote fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件。大多数情况一个App就运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程。<br>进程是能在系统中独立运行并作为资源分配的基本单位，是CPU分配资源的最小单位，它包括独立的地址空间，资源以及一至多个线程。</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是进程中的一个实体，是CPU调度的最小单位，没有独立空间地址，多线程共享所属进程的空间地址，线程主要负责是CPU执行代码的过程<br>APP应用启动时，系统会为应用创建一个名为“主线程”的执行线程。</p>
<h3 id="进程创建流程图"><a href="#进程创建流程图" class="headerlink" title="进程创建流程图"></a>进程创建流程图</h3><ol>
<li>进程创建起点，Process.start，然后告知ZygoteProcess执行启动，它会构造socket通道最后将构造指令及参数发送给zygote进程</li>
<li>zygote进程，socket会循环监听请求，在接受请求后，会封装好构建进程参数通过Zygote.forkAndSpecialize及其native方法fork出一个子进程</li>
<li>子进程fork后，会进行一系列fork后处理事项及Runtime的init初始化工作，最后回调到子进程的zygote.runSelectLoop方法抛出异常走到ActivityThread.main方法，进入子进程世</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-b317f94b27701458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="进程创建代码分析"><a href="#进程创建代码分析" class="headerlink" title="进程创建代码分析"></a>进程创建代码分析</h3><h5 id="进程创建入口"><a href="#进程创建入口" class="headerlink" title="进程创建入口"></a>进程创建入口</h5><p>Process.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                             final String niceName,</span><br><span class="line">                             int uid, int gid, int[] gids,</span><br><span class="line">                             int debugFlags, int mountExternal,</span><br><span class="line">                             int targetSdkVersion,</span><br><span class="line">                             String seInfo,</span><br><span class="line">                             String abi,</span><br><span class="line">                             String instructionSet,</span><br><span class="line">                             String appDataDir,</span><br><span class="line">                             String invokeWith,</span><br><span class="line">                             String[] zygoteArgs) &#123;</span><br><span class="line">   return zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">               debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">               abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进程创建参数准备"><a href="#进程创建参数准备" class="headerlink" title="进程创建参数准备"></a>进程创建参数准备</h5><p>主要工作是生成argsForZygote数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数。</p>
<p>ZygoteProcess.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final Process.ProcessStartResult start(final String processClass,</span><br><span class="line">                                             final String niceName,</span><br><span class="line">                                             int uid, int gid, int[] gids,</span><br><span class="line">                                             int debugFlags, int mountExternal,</span><br><span class="line">                                             int targetSdkVersion,</span><br><span class="line">                                             String seInfo,</span><br><span class="line">                                             String abi,</span><br><span class="line">                                             String instructionSet,</span><br><span class="line">                                             String appDataDir,</span><br><span class="line">                                             String invokeWith,</span><br><span class="line">                                             String[] zygoteArgs) &#123;</span><br><span class="line">    return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">         debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">         abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    synchronized(Process.class) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 生成argsForZygote数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数</span><br><span class="line">        argsForZygote.add(&quot;--runtime-args&quot;);</span><br><span class="line">        argsForZygote.add(&quot;--setuid&#x3D;&quot; + uid);</span><br><span class="line">        argsForZygote.add(&quot;--setgid&#x3D;&quot; + gid);</span><br><span class="line">        argsForZygote.add(&quot;--target-sdk-version&#x3D;&quot; + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        if (niceName !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--nice-name&#x3D;&quot; + niceName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (appDataDir !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--app-data-dir&#x3D;&quot; + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        if (extraArgs !&#x3D; null) &#123;</span><br><span class="line">            for (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="连接Zygote服务，写入创建指令并获取返回结果"><a href="#连接Zygote服务，写入创建指令并获取返回结果" class="headerlink" title="连接Zygote服务，写入创建指令并获取返回结果"></a>连接Zygote服务，写入创建指令并获取返回结果</h5><p>ZygoteProcess.java<br>通过socket向Zygote进程发送消息，从而唤醒Zygote进程，来响应socket客户端的请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;    </span><br><span class="line">    &#x2F;&#x2F; 向主zygote发起connect()操作</span><br><span class="line">    primaryZygoteState &#x3D; ZygoteState.connect(mSocket); </span><br><span class="line">    &#x2F;&#x2F;当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static Process.ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">       ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">       throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">         </span><br><span class="line">      final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">      final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line">       </span><br><span class="line">      writer.write(Integer.toString(args.size()));</span><br><span class="line">      writer.newLine();</span><br><span class="line">      &#x2F;&#x2F; 写入参数</span><br><span class="line">      for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">          String arg &#x3D; args.get(i);</span><br><span class="line">          writer.write(arg);</span><br><span class="line">          writer.newLine();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      writer.flush(); </span><br><span class="line">      </span><br><span class="line">      Process.ProcessStartResult result &#x3D; new Process.ProcessStartResult();</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F;等待socket服务端（即zygote）返回新创建的进程pid;</span><br><span class="line">      result.pid &#x3D; inputStream.readInt();</span><br><span class="line">      result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line">    </span><br><span class="line">      if (result.pid &lt; 0) &#123;</span><br><span class="line">          throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">      zygoteState.close();</span><br><span class="line">      throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Zygote接收客户端Socket请求"><a href="#Zygote接收客户端Socket请求" class="headerlink" title="Zygote接收客户端Socket请求"></a>Zygote接收客户端Socket请求</h5><p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务端等待请求，然后处理</span><br><span class="line">        zygoteServer.runSelectLoop(abiList); </span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        &#x2F;&#x2F; 新的进程会通过抛出异常后走到这里，通过反射调用main方法执行后续任务</span><br><span class="line">        caller.run(); </span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZygoteServer</p>
<ul>
<li>客户端通过openZygoteSocketIfNeeded()来跟zygote进程建立连接。zygote进程收到客户端连接请求后执行accept()；然后再创建ZygoteConnection对象,并添加到fds数组列表；</li>
<li>建立连接之后，可以跟客户端通信，进入runOnce()方法来接收客户端数据，并执行进程创建工作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void runSelectLoop(String abiList) throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    &#x2F;sServerSocket是socket通信中的服务端，即zygote进程 </span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line">        </span><br><span class="line">while (true) &#123;</span><br><span class="line">     StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">     for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">         pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">         pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">         pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">     &#125;</span><br><span class="line">     try &#123;</span><br><span class="line">         &#x2F;&#x2F;处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span><br><span class="line">         Os.poll(pollFds, -1);</span><br><span class="line">     &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">     &#125;</span><br><span class="line">     for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">         &#x2F;&#x2F;采用I&#x2F;O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；否则进入continue，跳出本次循环。</span><br><span class="line">         if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">             continue;</span><br><span class="line">         &#125;</span><br><span class="line">         if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求；则创建ZygoteConnection对象,并添加到fds。</span><br><span class="line">             ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);</span><br><span class="line">             peers.add(newPeer);</span><br><span class="line">             fds.add(newPeer.getFileDesciptor());</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;i&gt;0，则代表通过socket接收来自对端的数据，并执行 runOnce操作</span><br><span class="line">             boolean done &#x3D; peers.get(i).runOnce(this);</span><br><span class="line">             if (done) &#123;</span><br><span class="line">                 peers.remove(i);</span><br><span class="line">                 fds.remove(i);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ZygoteConnection acceptCommandPeer(String abiList) &#123;</span><br><span class="line">    &#x2F;&#x2F; 接收客户端发送过来的connect()操作，Zygote作为服务端执行accept()操作。 再后面客户端调用write()写数据，Zygote进程调用read()读数据。</span><br><span class="line">   return new ZygoteConnection(sServerSocket.accept(), abiList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="java层fork参数准备"><a href="#java层fork参数准备" class="headerlink" title="java层fork参数准备"></a>java层fork参数准备</h5><p>ZygoteConnection.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">boolean runOnce(ZygoteServer zygoteServer) throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs &#x3D; null;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 读取socket客户端发送过来的参数列表</span><br><span class="line">    args &#x3D; readArgumentList();</span><br><span class="line">    descriptors &#x3D; mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    </span><br><span class="line">    int pid &#x3D; -1;</span><br><span class="line">    FileDescriptor childPipeFd &#x3D; null;</span><br><span class="line">    FileDescriptor serverPipeFd &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备一系列fork进程的参数</span><br><span class="line">      parsedArgs &#x3D; new Arguments(args);</span><br><span class="line">      int[][] rlimits &#x3D; null;</span><br><span class="line">      if (parsedArgs.rlimits !&#x3D; null) &#123;</span><br><span class="line">          rlimits &#x3D; parsedArgs.rlimits.toArray(intArray2d);</span><br><span class="line">      &#125;</span><br><span class="line">      int[] fdsToIgnore &#x3D; null;</span><br><span class="line">      if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">          FileDescriptor[] pipeFds &#x3D; Os.pipe2(O_CLOEXEC);</span><br><span class="line">          childPipeFd &#x3D; pipeFds[1];</span><br><span class="line">          serverPipeFd &#x3D; pipeFds[0];</span><br><span class="line">          Os.fcntlInt(childPipeFd, F_SETFD, 0);</span><br><span class="line">          fdsToIgnore &#x3D; new int[] &#123; childPipeFd.getInt$(), serverPipeFd.getInt$() &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      int [] fdsToClose &#x3D; &#123; -1, -1 &#125;;</span><br><span class="line">      FileDescriptor fd &#x3D; mSocket.getFileDescriptor();</span><br><span class="line">      if (fd !&#x3D; null) &#123;</span><br><span class="line">          fdsToClose[0] &#x3D; fd.getInt$();</span><br><span class="line">      &#125;</span><br><span class="line">      fd &#x3D; zygoteServer.getServerSocketFileDescriptor();</span><br><span class="line">      if (fd !&#x3D; null) &#123;</span><br><span class="line">          fdsToClose[1] &#x3D; fd.getInt$();</span><br><span class="line">      &#125;</span><br><span class="line">      fd &#x3D; null;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 执行fork操作</span><br><span class="line">      pid &#x3D; Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">              parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">              parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,</span><br><span class="line">              parsedArgs.appDataDir);</span><br><span class="line">              </span><br><span class="line">    &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           &#x2F;&#x2F; 子进程 </span><br><span class="line">           zygoteServer.closeServerSocket();</span><br><span class="line">           IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">           serverPipeFd &#x3D; null;</span><br><span class="line">           &#x2F;&#x2F; 进程初始化操作（最后抛出异常 回到runSelectLoop捕获异常方法）</span><br><span class="line">           handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; should never get here, the child is expected to either throw Zygote.MethodAndArgsCaller or exec().</span><br><span class="line">           return true;</span><br><span class="line">       &#125; else &#123; &#x2F;&#x2F; 父进程 （zygote进程）</span><br><span class="line">           &#x2F;&#x2F; in parent...pid of &lt; 0 means failure</span><br><span class="line">           IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">           childPipeFd &#x3D; null;</span><br><span class="line">           return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">       IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="nativeFork前准备"><a href="#nativeFork前准备" class="headerlink" title="nativeFork前准备"></a>nativeFork前准备</h5><p>Zygote.java<br>调用虚拟机执行preFork工作：停止Daemon子线程、等待所有子线程结束、完成gc堆的初始化工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</span><br><span class="line">     int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</span><br><span class="line">     int[] fdsToIgnore, String instructionSet, String appDataDir) &#123;</span><br><span class="line">   VM_HOOKS.preFork();</span><br><span class="line">   &#x2F;&#x2F; Resets nice priority for zygote process.</span><br><span class="line">   resetNicePriority();</span><br><span class="line">   int pid &#x3D; nativeForkAndSpecialize(</span><br><span class="line">             uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">             fdsToIgnore, instructionSet, appDataDir);</span><br><span class="line">   VM_HOOKS.postForkCommon();</span><br><span class="line">   return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用native的fork方法"><a href="#调用native的fork方法" class="headerlink" title="调用native的fork方法"></a>调用native的fork方法</h5><p>com_android_internal_os_Zygote.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkSystemServer(</span><br><span class="line">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span><br><span class="line">        jlong effectiveCapabilities) &#123;</span><br><span class="line">  &#x2F;&#x2F; fork子进程，</span><br><span class="line">  pid_t pid &#x3D; ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities,effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,NULL, NULL);</span><br><span class="line">  ...</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span><br><span class="line">                                     jint debug_flags, jobjectArray javaRlimits,</span><br><span class="line">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span><br><span class="line">                                     jint mount_external,</span><br><span class="line">                                     jstring java_se_info, jstring java_se_name,</span><br><span class="line">                                     bool is_system_server, jintArray fdsToClose,</span><br><span class="line">                                     jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  pid_t pid &#x3D; fork(); &#x2F;&#x2F;!!! fork子进程 (COW 方式)</span><br><span class="line">  </span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;进入子进程，初始化设置等</span><br><span class="line">    DetachDescriptors(env, fdsToClose); &#x2F;&#x2F;关闭并清除文件描述符</span><br><span class="line"></span><br><span class="line">    if (!is_system_server) &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非system_server子进程，则创建进程组</span><br><span class="line">        int rc &#x3D; createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); &#x2F;&#x2F;设置设置group</span><br><span class="line">    SetRLimits(env, javaRlimits); &#x2F;&#x2F;设置资源limit</span><br><span class="line"></span><br><span class="line">    int rc &#x3D; setresgid(gid, gid, gid);</span><br><span class="line">    rc &#x3D; setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); &#x2F;&#x2F;设置调度策略</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;selinux上下文</span><br><span class="line">    rc &#x3D; selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    if (se_info_c_str &#x3D;&#x3D; NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str &#x3D; &quot;system_server&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (se_info_c_str !&#x3D; NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); &#x2F;&#x2F;设置线程名为system_server，方便调试</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为</span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line">    &#x2F;&#x2F;调用zygote.callPostForkChildHooks() </span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (pid &gt; 0) &#123; &#x2F;&#x2F;进入父进程，即zygote进程</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p>fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。父进程中，fork返回新创建的子进程的pid;子进程中，fork返回0；当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）</p>
<p>fork()的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。 Zygote进程是所有Android进程的母体，包括system_server和各个App进程。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-6fe66a172ebcb763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int fork() &#123;</span><br><span class="line">  __bionic_atfork_run_prepare(); &#x2F;&#x2F;[见小节2.1.1]</span><br><span class="line"></span><br><span class="line">  pthread_internal_t* self &#x3D; __get_thread();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;fork期间，获取父进程pid，并使其缓存值无效</span><br><span class="line">  pid_t parent_pid &#x3D; self-&gt;invalidate_cached_pid();</span><br><span class="line">  &#x2F;&#x2F;系统调用【见小节2.2】</span><br><span class="line">  int result &#x3D; syscall(__NR_clone, FORK_FLAGS, NULL, NULL, NULL, &amp;(self-&gt;tid));</span><br><span class="line">  if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    self-&gt;set_cached_pid(gettid());</span><br><span class="line">    __bionic_atfork_run_child(); &#x2F;&#x2F;fork完成执行子进程回调方法</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    self-&gt;set_cached_pid(parent_pid);</span><br><span class="line">    __bionic_atfork_run_parent(); &#x2F;&#x2F;fork完成执行父进程回调方法</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行子进程fork完成后的hooks"><a href="#执行子进程fork完成后的hooks" class="headerlink" title="执行子进程fork完成后的hooks"></a>执行子进程fork完成后的hooks</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用ZygoteHooks.postForkChild()</span><br><span class="line">    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);</span><br><span class="line">&#125;</span><br><span class="line">public void postForkChild(int debugFlags, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用native方法</span><br><span class="line">    nativePostForkChild(token, debugFlags, instructionSet);</span><br><span class="line">Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dalvik_system_ZygoteHooks.cc<br>设置新进程的主线程id，重置gc性能数据，设置信号处理函数等功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags, jstring instruction_set) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处token是由nativePreFork创建的，记录着当前线程</span><br><span class="line">    Thread* thread &#x3D; reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">    &#x2F;&#x2F;设置新进程的主线程id</span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    ..</span><br><span class="line">    if (instruction_set !&#x3D; nullptr) &#123;</span><br><span class="line">      ScopedUtfChars isa_string(env, instruction_set);</span><br><span class="line">      InstructionSet isa &#x3D; GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">      Runtime::NativeBridgeAction action &#x3D; Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">      if (isa !&#x3D; kNone &amp;&amp; isa !&#x3D; kRuntimeISA) &#123;</span><br><span class="line">        action &#x3D; Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;Runtime 执行 fork事项</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime.cc<br>创建Java堆处理的线程池、设置信号处理函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) &#123;</span><br><span class="line">  is_zygote_ &#x3D; false;</span><br><span class="line">  if (is_native_bridge_loaded_) &#123;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">      case NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge(); &#x2F;&#x2F;卸载用于跨平台的桥连库</span><br><span class="line">        is_native_bridge_loaded_ &#x3D; false;</span><br><span class="line">        break;</span><br><span class="line">      case NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);&#x2F;&#x2F;初始化用于跨平台的桥连库</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建Java堆处理的线程池</span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  &#x2F;&#x2F;重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line">  if (jit_.get() &#x3D;&#x3D; nullptr &amp;&amp; jit_options_-&gt;UseJIT()) &#123;</span><br><span class="line">    &#x2F;&#x2F;当flag被设置，并且还没有创建JIT时，则创建JIT</span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;设置信号处理函数</span><br><span class="line">  StartSignalCatcher();</span><br><span class="line">  &#x2F;&#x2F;启动JDWP线程，当命令debuger的flags指定&quot;suspend&#x3D;y&quot;时，则暂停runtime</span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="VM-HOOKS的fork后续操作"><a href="#VM-HOOKS的fork后续操作" class="headerlink" title="VM_HOOKS的fork后续操作"></a>VM_HOOKS的fork后续操作</h5><p>ZygoteHooks.java<br>主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void postForkCommon() &#123;</span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void start() &#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="新进程创建后的初始化事项"><a href="#新进程创建后的初始化事项" class="headerlink" title="新进程创建后的初始化事项"></a>新进程创建后的初始化事项</h5><p>ZygoteConnection.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void handleChildProc(Arguments parsedArgs,</span><br><span class="line">       FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span><br><span class="line">       throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">   &#x2F;&#x2F; 关闭子进程的socket链接</span><br><span class="line">   closeSocket();</span><br><span class="line">   if (descriptors !&#x3D; null) &#123;</span><br><span class="line">   </span><br><span class="line">   if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">       WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">               parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">               VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">               pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">   &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">       &#x2F;&#x2F; 初始化</span><br><span class="line">       ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">               parsedArgs.remainingArgs, null &#x2F;* classLoader *&#x2F;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RuntimeInit.java</p>
<ul>
<li>commonInit，初始化时区、代理、异常捕获处理类等</li>
<li>nativeZygoteInit，启动binder相关初始化</li>
<li>applicationInit，app相关初始化，最后抛出异常回到runSelectLoop，该方法的参数m是指main()方法, argv是指ActivityThread. 根据前面的中可知，下一步进入caller.run()方法，也就是执行ActivityThread的main方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">       throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">   ......</span><br><span class="line">   commonInit();</span><br><span class="line">   nativeZygoteInit();</span><br><span class="line">   applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置默认的未捕捉异常处理方法</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置市区，中国时区为&quot;Asia&#x2F;Shanghai&quot;</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置log配置</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span><br><span class="line">    String userAgent &#x3D; getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置socket的tag，用于网络流量统计</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123;</span><br><span class="line">   </span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp</span><br><span class="line">virtual void onZygoteInit()&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置虚拟机的内存利用率参数值为0.75 , 设置目标sdk</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args &#x3D; new Arguments(argv); &#x2F;&#x2F;解析参数</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用startClass的static方法 main()；args.startClass为”com.android.server.SystemServer</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">   Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line">   Method m;</span><br><span class="line">   try &#123;</span><br><span class="line">       m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">   &#125; catch (Exception ex) &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int modifiers &#x3D; m.getModifiers();</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ! 回到 ZygoteInit.main()方法中，直接进入catch语句（这样做好处是能清空栈帧，提高栈帧利用率，比较巧妙）</span><br><span class="line">   throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最后执行ActivityThread的main方法"><a href="#最后执行ActivityThread的main方法" class="headerlink" title="最后执行ActivityThread的main方法"></a>最后执行ActivityThread的main方法</h5><p>ActivityThread.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    &#x2F;&#x2F;创建主线程looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    &#x2F;&#x2F;attach到系统进程</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程进入循环状态</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/08/21/Android%E7%B3%BB%E7%BB%9F%E2%80%94Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/08/21/Android%E7%B3%BB%E7%BB%9F%E2%80%94Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Android系统—Launcher启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-21 22:28:23" itemprop="dateCreated datePublished" datetime="2019-08-21T22:28:23+08:00">2019-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:08:00" itemprop="dateModified" datetime="2020-02-07T01:08:00+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前期系列：<br><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote进程启动分析</a><br><a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">SystemServer启动分析</a><br><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">AMS启动分析</a></p>
<h3 id="Launcher启动期流程图"><a href="#Launcher启动期流程图" class="headerlink" title="Launcher启动期流程图"></a>Launcher启动期流程图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-2ade1db25b50bc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><h5 id="AMS系统ready方法中开始启动HomeActivity"><a href="#AMS系统ready方法中开始启动HomeActivity" class="headerlink" title="AMS系统ready方法中开始启动HomeActivity"></a>AMS系统ready方法中开始启动HomeActivity</h5><p>ActivityManagerService.java</p>
<ul>
<li>获取和生成HomeActivity的Intent信息，并析构出ActivityInfo</li>
<li>调用ActivityStarter的startHomeActivityLocked方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Start up initial activity.</span><br><span class="line">        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean startHomeActivityLocked(int userId, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构建 Home Intent</span><br><span class="line">    Intent intent &#x3D; getHomeIntent();</span><br><span class="line">    &#x2F;&#x2F; 通过PM 构建 ActivityInfo</span><br><span class="line">    ActivityInfo aInfo &#x3D;</span><br><span class="line">      resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">     </span><br><span class="line">    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">    &#x2F;&#x2F; 创建ActivityInfo 对象  </span><br><span class="line">    aInfo &#x3D; new ActivityInfo(aInfo);</span><br><span class="line">    aInfo.applicationInfo &#x3D; getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">    ProcessRecord app &#x3D; getProcessRecordLocked(aInfo.processName,</span><br><span class="line">         aInfo.applicationInfo.uid, true);</span><br><span class="line">      </span><br><span class="line">    intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    &#x2F;&#x2F; 通过ActivityStart 启动 </span><br><span class="line">    mActivityStarter.startHomeActivityLocked(intent, aInfo, myReason);    </span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取系统的启动页面Activity Intent</span><br><span class="line">Intent getHomeIntent() &#123;</span><br><span class="line">   &#x2F;&#x2F; mTOPAction &#x3D; Intent.ACTION_MAIN;</span><br><span class="line">   Intent intent &#x3D; new Intent(mTopAction, mTopData !&#x3D; null ? Uri.parse(mTopData) : null);</span><br><span class="line">   intent.setComponent(mTopComponent);</span><br><span class="line">   &#x2F;&#x2F; 添加 &quot;android.intent.category.HOME&quot;; </span><br><span class="line">   intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">   return intent;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过PM将HomeIntent解析出ActivityInfo</span><br><span class="line">private ActivityInfo resolveActivityInfo(Intent intent, int flags, int userId) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ResolveInfo info&#x3D; AppGlobals.getPackageManager().resolveIntent(intent,</span><br><span class="line">    intent.resolveTypeIfNeeded(mContext.getContentResolver()),</span><br><span class="line">    flags, userId);</span><br><span class="line">    ai &#x3D; info.activityInfo;</span><br><span class="line">    return ai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Activity启动前检查及任务栈管理等"><a href="#Activity启动前检查及任务栈管理等" class="headerlink" title="Activity启动前检查及任务栈管理等"></a>Activity启动前检查及任务栈管理等</h5><p>ActivityStarter.java</p>
<ul>
<li>startHomeActivityLocked，将HomeStack移至顶部（第一次为空）</li>
<li>startActivityLocked，调用startActivity，并重新记录lastStartActivityResult</li>
<li>startActivity，参数校验、权限检查等，构建ActivityRecord等</li>
<li>startActivityUnchecked，涉及启动模式和位运算，以及调用ActivityStack的startActivityLocked来处理回退栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">void startHomeActivityLocked(Intent intent, ActivityInfo aInfo, String reason) &#123;</span><br><span class="line">   &#x2F;&#x2F; 将HomeStack 移到top</span><br><span class="line">   mSupervisor.moveHomeStackTaskToTop(reason);</span><br><span class="line">   &#x2F;&#x2F; 执行 startActivityLocked</span><br><span class="line">   mLastHomeActivityStartResult &#x3D; startActivityLocked(null &#x2F;*caller*&#x2F;, intent,</span><br><span class="line">           null &#x2F;*ephemeralIntent*&#x2F;, null &#x2F;*resolvedType*&#x2F;, aInfo, null &#x2F;*rInfo*&#x2F;,</span><br><span class="line">           null &#x2F;*voiceSession*&#x2F;, null &#x2F;*voiceInteractor*&#x2F;, null &#x2F;*resultTo*&#x2F;,</span><br><span class="line">           null &#x2F;*resultWho*&#x2F;, 0 &#x2F;*requestCode*&#x2F;, 0 &#x2F;*callingPid*&#x2F;, 0 &#x2F;*callingUid*&#x2F;,</span><br><span class="line">           null &#x2F;*callingPackage*&#x2F;, 0 &#x2F;*realCallingPid*&#x2F;, 0 &#x2F;*realCallingUid*&#x2F;,</span><br><span class="line">           0 &#x2F;*startFlags*&#x2F;, null &#x2F;*options*&#x2F;, false &#x2F;*ignoreTargetSecurity*&#x2F;,</span><br><span class="line">           false &#x2F;*componentSpecified*&#x2F;, mLastHomeActivityStartRecord &#x2F;*outActivity*&#x2F;,</span><br><span class="line">           null &#x2F;*container*&#x2F;, null &#x2F;*inTask*&#x2F;, &quot;startHomeActivity: &quot; + reason);</span><br><span class="line">   if (mSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">       &#x2F;&#x2F; 调度</span><br><span class="line">       mSupervisor.scheduleResumeTopActivities();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int startActivityLocked(IApplicationThread caller,</span><br><span class="line">            Intent intent, String resolvedType, ActivityInfo aInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int callingPid, int callingUid, String callingPackage,</span><br><span class="line">            int realCallingPid, int realCallingUid, int startFlags, Bundle options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            ActivityContainer container, TaskRecord inTask) &#123;</span><br><span class="line">      </span><br><span class="line">   &#x2F;&#x2F; 参数校验、权限检查等工作，然后构建 ActivityRecord (存储Activity的重要信息)</span><br><span class="line">    ActivityRecord r &#x3D; new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">           callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">           resultRecord, resultWho, requestCode, componentSpecified, voiceSession !&#x3D; null,</span><br><span class="line">           mSupervisor, container, options, sourceRecord);</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 然后调用 startActivity</span><br><span class="line">   return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,</span><br><span class="line">                options, inTask, outActivity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int startActivity(...) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行 startActivityUnchecked</span><br><span class="line">    result &#x3D; startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">         startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">    IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,</span><br><span class="line">                                   boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">                                   ActivityRecord[] outActivity) &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化状态（该方法会校验Intent的Flag是否是特定的Flag，会涉及到各种启动模式和Android的位运算）</span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor);</span><br><span class="line">    &#x2F;&#x2F;判断是否需要启动新的task</span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    &#x2F;&#x2F;记录父Activity对应的TaskRecord信息</span><br><span class="line">    computeSourceStack();</span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line">    &#x2F;&#x2F;决定是否将新Activity插入到现有的Task中</span><br><span class="line">    ActivityRecord reusedActivity &#x3D; getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;任务栈历史栈配置（处理和WindowManagerService之间的交互、保证Activity对应的UI能在屏幕上显示出来）</span><br><span class="line">   mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">   </span><br><span class="line">    if (mDoResume) &#123; &#x2F;&#x2F; true </span><br><span class="line">        final ActivityRecord topTaskActivity &#x3D;</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        if (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity !&#x3D; null &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity !&#x3D; topTaskActivity)) &#123;</span><br><span class="line">            &#x2F;&#x2F;目标Task的focusable为false或者源Task栈顶Activity总是在其他Activity之上</span><br><span class="line">            &#x2F;&#x2F;不恢复目标Task，只需确保它可见</span><br><span class="line">            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">            &#x2F;&#x2F;通过WindowManagerService执行app启动动画</span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">            &#x2F;&#x2F;如果目标栈之前不是可聚焦状态，那么将目标栈变为可聚焦</span><br><span class="line">            if (mTargetStack.isFocusable( &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 最后走到ASS执行 resumeFocusedStackTopActivityLocked</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果不需要恢复，则将Activity加入到最近活动栈中</span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityStackSupervisor.java</p>
<ul>
<li>resumeFocusedStackTopActivityLocked,</li>
<li>resumeTopActivityInnerLocked,</li>
<li>resumeTopActivityInnerLocked, 暂停栈内所有Activity，继续调用</li>
<li>startSpecificActivityLocked, 查找ActivityRecord对应进程，存在则realStartActivityLocked，这里是第一次启动，不存在进程,调用AMS.startProcessLocked</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">  ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">    &#x2F;&#x2F;  执行 resumeTopActivityUncheckedLocked</span><br><span class="line">    return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ActivityStack.java</span><br><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    &#x2F;&#x2F;执行 resumeTopActivityInnerLocked</span><br><span class="line">    result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)&#123;</span><br><span class="line">    ...</span><br><span class="line">    final ActivityRecord next &#x3D; topRunningActivityLocked(true &#x2F;* focusableOnly *&#x2F;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;该方法会遍历所有任务栈，并调用ActivityStack#startPausingLocked()暂停处于栈内的所有Activity</span><br><span class="line">    boolean pausing &#x3D; mStackSupervisor.pauseBackStacks(userLeaving, next, false);</span><br><span class="line">    </span><br><span class="line">    if (next.app !&#x3D; null &amp;&amp; next.app.thread !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">        &#x2F;&#x2F;调用了startSpecificActivityLocked</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">                                 boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    &#x2F;&#x2F;这里根据processName和UID在系统中查找是否已经有相应的进程存在</span><br><span class="line">    &#x2F;&#x2F;如果之前app进程不存在，则app&#x3D;null</span><br><span class="line">    ProcessRecord app &#x3D; mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, true);</span><br><span class="line">    </span><br><span class="line">    if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if ((r.info.flags&amp; ActivityInfo.FLAG_MULTIPROCESS) &#x3D;&#x3D; 0</span><br><span class="line">                    || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                &#x2F;&#x2F;向PreocessRecord中增加对应的package信息</span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;若app进程存在，通知进程启动目标Activity</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;若进程不存在，则使用AMS开启一个新进程(进程不存在)</span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,&quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AMS开启进程启动"><a href="#AMS开启进程启动" class="headerlink" title="AMS开启进程启动"></a>AMS开启进程启动</h5><p>ActivityManagerService.java</p>
<ul>
<li><p>startProcessLocked, 进程的维护和清理等工作，然后调用重载方法</p>
</li>
<li><p>startProcessLocked, 该方法里主要干了三件事：</p>
<ol>
<li>设置了各种debug参数，若AndroidManifest.xml将android:debuggable设置为true，这些参数就会生效。</li>
<li>通过Process.start()开启一个新进程，实际上是通过Socket与Zygote通信，使用Zygote fork新进 程，同时将ActivityThread类加入到新进程,并调用ActivityThread.main()。</li>
<li>发送一条延时消息，若新创建的进程在消息接收前未与AMS交互，则进程启动失败</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName,</span><br><span class="line">       ApplicationInfo info, boolean knownToBeDead, int intentFlags,</span><br><span class="line">       String hostingType, ComponentName hostingName, boolean allowWhileBooting,</span><br><span class="line">       boolean isolated, boolean keepIfLarge) &#123;</span><br><span class="line">   return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">           hostingName, allowWhileBooting, isolated, 0 &#x2F;* isolatedUid *&#x2F;, keepIfLarge,</span><br><span class="line">           null &#x2F;* ABI override *&#x2F;, null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;,</span><br><span class="line">           null &#x2F;* crashHandler *&#x2F;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主要：创建或获取 ProcessRecord ，清理bad进程，然后启动进程</span><br><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">                                       boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    if (!isolated) &#123; &#x2F;&#x2F; 非孤立进程</span><br><span class="line">        &#x2F;&#x2F;根据进程名和UID查找相应的ProcessRecord，</span><br><span class="line">        &#x2F;&#x2F;当第一次启动app时这里返回值为null</span><br><span class="line">        app &#x3D; getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line"></span><br><span class="line">        if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果当前进程处于后台进程，检查当前进程是否为bad进程</span><br><span class="line">            if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;当用户明确要启动一个进程时，则清空它的crash次数</span><br><span class="line">            &#x2F;&#x2F;在看见crash对话框之前它才不会成为一个bad进程</span><br><span class="line">            mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">            if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                if (app !&#x3D; null) &#123;</span><br><span class="line">                    app.bad &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果它是一个孤立的进程，则它无法使用现存的进程</span><br><span class="line">        app &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当已经存在ProcessRecord且其pid大于0(app早已经运行或者正在启动)</span><br><span class="line">    &#x2F;&#x2F;则不会清理该进程</span><br><span class="line">    if (app !&#x3D; null &amp;&amp; app.pid &gt; 0) &#123;</span><br><span class="line">        if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果它是新的包，则将其添加到列表中</span><br><span class="line">            app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">            return app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;当ProcessRecord被attach到之前的进程，就清理它</span><br><span class="line">        killProcessGroup(app.uid, app.pid);</span><br><span class="line">        handleAppDiedLocked(app, true, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostingNameStr &#x3D; hostingName !&#x3D; null</span><br><span class="line">            ? hostingName.flattenToShortString() : null;</span><br><span class="line">    if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据ApplicationInfo、processName、UID创建一个ProcessRecord对象</span><br><span class="line">        app &#x3D; newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">        if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        app.crashHandler &#x3D; crashHandler;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果在进程中它是新的一个包，则添加它到列表里</span><br><span class="line">        app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果系统仍未准备好，则推迟启动它，将app加入hold列表</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;调用重载方法启动进程</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">    return (app.pid !&#x3D; 0) ? app : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果ProcessRecord的pid&gt;0且不为当前进程的pid</span><br><span class="line">    &#x2F;&#x2F;就从mPidsSelfLocked移除该pid</span><br><span class="line">    &#x2F;&#x2F;当进程不存在时，pid&#x3D;0</span><br><span class="line">    if (app.pid &gt; 0 &amp;&amp; app.pid !&#x3D; MY_PID) &#123;</span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            mPidsSelfLocked.remove(app.pid);</span><br><span class="line">            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">        &#125;</span><br><span class="line">        app.setPid(0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从hold列表移除该ProcessRecord</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line">    &#x2F;&#x2F;更新Cpu状态</span><br><span class="line">    updateCpuStats();</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final int userId &#x3D; UserHandle.getUserId(app.uid);</span><br><span class="line">            &#x2F;&#x2F;通过PMS检查待启动进程对应的package是否满足启动条件</span><br><span class="line">            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageNam     e, userId);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        if (!app.isolated) &#123;</span><br><span class="line">            int[] permGids &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                checkTime(startTime, &quot;startProcess: getting gids from package manager&quot;);</span><br><span class="line">                final IPackageManager pm &#x3D; AppGlobals.getPackageManager();</span><br><span class="line">                &#x2F;&#x2F;得到对应的GID</span><br><span class="line">                permGids &#x3D; pm.getPackageGids(app.info.packageName,</span><br><span class="line">                        MATCH_DEBUG_TRIAGED_MISSING, app.userId);</span><br><span class="line">                StorageManagerInternal storageManagerInternal &#x3D; LocalServices.getService(</span><br><span class="line">                        StorageManagerInternal.class);</span><br><span class="line">                &#x2F;&#x2F;获得进程对外部存储的访问模式</span><br><span class="line">                mountExternal &#x3D; storageManagerInternal.getExternalStorageMountMode(uid,</span><br><span class="line">                        app.info.packageName);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F;不同情况下设置debugFlags的值，具体的值请看Zygote类的static属性</span><br><span class="line">            ...</span><br><span class="line">            boolean isActivityProcess &#x3D; (entryPoint &#x3D;&#x3D; null);</span><br><span class="line">            &#x2F;&#x2F;当entryPoint为空的情况下，设置它的值</span><br><span class="line">            &#x2F;&#x2F;这里的entryPoint是第一个startProcessLocked()传进来的null值</span><br><span class="line">            &#x2F;&#x2F;这里是指定反射需要的className</span><br><span class="line">            if (entryPoint &#x3D;&#x3D; null) entryPoint &#x3D; &quot;android.app.ActivityThread&quot;;</span><br><span class="line"></span><br><span class="line">            ProcessStartResult startResult;</span><br><span class="line">            if (hostingType.equals(&quot;webview_service&quot;)) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">                &#x2F;&#x2F;开启新进程的</span><br><span class="line">                startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith, entryPointArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 启动进程后更新ProcessRecord</span><br><span class="line">        app.setPid(startResult.pid);</span><br><span class="line">        app.usingWrapper &#x3D; startResult.usingWrapper;</span><br><span class="line">        app.removed &#x3D; false;</span><br><span class="line">        app.killed &#x3D; false;</span><br><span class="line">        app.killedByAm &#x3D; false;</span><br><span class="line"></span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            &#x2F;&#x2F;将启动结果的pid和PreocessRecord添加到mPidsSelfLocked</span><br><span class="line">            this.mPidsSelfLocked.put(startResult.pid, app);</span><br><span class="line">            if (isActivityProcess) &#123;</span><br><span class="line">                &#x2F;&#x2F;发送一个延时消息</span><br><span class="line">                &#x2F;&#x2F; PROC_START_TIMEOUT 值为 10</span><br><span class="line">                &#x2F;&#x2F;在消息未被处理前，若新创建的进程没有和AMS交互，则该进程启动失败</span><br><span class="line">                Message msg &#x3D; mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">                msg.obj &#x3D; app;</span><br><span class="line">                mHandler.sendMessageDelayed(msg, startResult.usingWrapper</span><br><span class="line">                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(RuntimeException e)&#123;</span><br><span class="line">            &#x2F;&#x2F;当创建进程出现异常的时候就会清理相关的记录forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,    false, true, false, false, UserHandle.getUserId(app.userId), &quot;start failure&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进程fork"><a href="#进程fork" class="headerlink" title="进程fork"></a>进程fork</h5><p>Process.start<br>参考：<a href="https://www.jianshu.com/p/c7fb582987ad" target="_blank" rel="noopener">Android系统—进程创建流程分析</a></p>
<h5 id="ActivityThread-main方法"><a href="#ActivityThread-main方法" class="headerlink" title="ActivityThread.main方法"></a>ActivityThread.main方法</h5><ul>
<li>Looper.prepareMainLooper</li>
<li>attach AMS</li>
<li>Looper.loop</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper(); &#x2F;&#x2F; 准备 main looper 和消息队列</span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread(); &#x2F;&#x2F; 构建AT</span><br><span class="line">    &#x2F;&#x2F;将应用进程绑定到ActivityManagerService</span><br><span class="line">    thread.attach(false);</span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.loop(); &#x2F;&#x2F; 开启循环，接收message并分发处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void attach(boolean system) &#123; </span><br><span class="line">   sCurrentActivityThread &#x3D; this;</span><br><span class="line">   mSystemThread &#x3D; system; &#x2F;&#x2F; false</span><br><span class="line">   if (!system) &#123; &#x2F;&#x2F; true</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 获取 AMS，调用AMS的 attachApplication</span><br><span class="line">       final IActivityManager mgr &#x3D; ActivityManager.getService();</span><br><span class="line">       try &#123;</span><br><span class="line">           mgr.attachApplication(mAppThread);</span><br><span class="line">       &#125; catch (RemoteException ex) &#123;</span><br><span class="line">           throw ex.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Watch for getting close to heap limit.</span><br><span class="line">       ...</span><br><span class="line">   &#125; else &#123; &#x2F;&#x2F; 系统进程处理逻辑</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AMS-绑定Application"><a href="#AMS-绑定Application" class="headerlink" title="AMS 绑定Application"></a>AMS 绑定Application</h5><p>ActivityManagerService.java</p>
<ul>
<li>attachApplication, 获取当前调用pid，调用重载方法</li>
<li>attachApplication<ul>
<li>重置ProcessRecord信息   </li>
<li>将进程的ApplicationThread绑定到AMS，初始化Application</li>
<li>最后执行到 ASS.attachApplicationLocked方法进行Activity的启动</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">       final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">       attachApplicationLocked(thread, callingPid);</span><br><span class="line">       Binder.restoreCallingIdentity(origId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                              int pid) &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    ... &#x2F;&#x2F; 根据pid 获取 对应 ProcessRecord</span><br><span class="line">    &#x2F;&#x2F; 新进程的名字</span><br><span class="line">    final String processName &#x3D; app.processName;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;在这个地方会注册该进程的死亡回调 ， Thread指的是ApplicationThread</span><br><span class="line">        AppDeathRecipient adr &#x3D; new AppDeathRecipient(</span><br><span class="line">                app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, 0);</span><br><span class="line">        app.deathRecipient &#x3D; adr;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        &#x2F;&#x2F;出现异常则重新开启一个进程</span><br><span class="line">        startProcessLocked(app, &quot;link fail&quot;, processName);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;重置 ProcessRecord</span><br><span class="line">    app.makeActive(thread, mProcessStats); &#x2F;&#x2F;给ProcessRecord的thread赋值</span><br><span class="line">    app.curAdj &#x3D; app.setAdj &#x3D; app.verifiedAdj &#x3D; ProcessList.INVALID_ADJ;</span><br><span class="line">    app.curSchedGroup &#x3D; app.setSchedGroup &#x3D; ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    app.forcingToImportant &#x3D; null;</span><br><span class="line">    updateProcessForegroundLocked(app, false, false);</span><br><span class="line">    app.hasShownUi &#x3D; false;</span><br><span class="line">    app.debugging &#x3D; false;</span><br><span class="line">    app.cached &#x3D; false;</span><br><span class="line">    app.killedByAm &#x3D; false;</span><br><span class="line">    app.killed &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">    &#x2F;&#x2F; 移除startProcessLocked()中发出的延时消息</span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line"></span><br><span class="line">    boolean normalMode &#x3D; mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    ... &#x2F;&#x2F; contentProvider相关处理</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 这里通过AIDL调用了ApplicationThread. bindApplication方法，</span><br><span class="line">    &#x2F;&#x2F; 这里是将新进程的ApplicationThread对象绑定到AMS的真正操作 ，两个方法只是参数不同</span><br><span class="line">    &#x2F;&#x2F; app.instr 为ProcessRecord.ActiveInstrumentation对象</span><br><span class="line">    if (app.instr !&#x3D; null) &#123;</span><br><span class="line">        thread.bindApplication(&#x2F;*参数省略*&#x2F;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        thread.bindApplication(&#x2F;*参数省略*&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;更新进程情况</span><br><span class="line">    updateLruProcessLocked(app, false, null);</span><br><span class="line">    &#x2F;&#x2F;将ProcessRecord从正在启动列表和hold列表中移除</span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检查最顶层可见的Activity是否等待运行在该进程中</span><br><span class="line">    if (normalMode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;调用ActivityStackSupervisor# attachApplicationLocked</span><br><span class="line">            if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">            badApp &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查找所有可运行在该进程中的服务</span><br><span class="line">    &#x2F;&#x2F;检查这个进程中是否有下一个广播接收者</span><br><span class="line">    &#x2F;&#x2F;检查这个进程中是否有下一个备份代理</span><br><span class="line">    &#x2F;&#x2F;上述操作如果出现异常就杀死进程</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ActivityThread-ApplicationThread处理Application绑定"><a href="#ActivityThread-ApplicationThread处理Application绑定" class="headerlink" title="ActivityThread.ApplicationThread处理Application绑定"></a>ActivityThread.ApplicationThread处理Application绑定</h5><p>ActivityThread.ApplicationThread</p>
<ul>
<li>bindApplication，构造AppBindData，发送bind消息</li>
<li>handleBindApplication <ul>
<li>进程、系统配置等初始化设置</li>
<li>构建Instrumentation、Application等app对象</li>
<li>调用Application.onCreate 生命周期方法  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(&#x2F;*省略参数*&#x2F;)&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;&#x2F; 构造 AppBindData，并赋值</span><br><span class="line">	AppBindData data &#x3D; new AppBindData();</span><br><span class="line">	sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    &#x2F;&#x2F;注册UI线程到VMRuntime作为一个敏感线程</span><br><span class="line">    VMRuntime.registerSensitiveThread();</span><br><span class="line">    &#x2F;&#x2F;设置进程的启动时间</span><br><span class="line">    Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置进程名</span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());</span><br><span class="line">    &#x2F;&#x2F;当app版本&lt;&#x3D; 3.1 时，设置AsyncTask使用线程池实现</span><br><span class="line">    if (data.appInfo.targetSdkVersion &lt;&#x3D; android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重置时区（跟随系统时区）</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line">    LocaleList.setDefault(data.config.getLocales());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;更新系统配置</span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);</span><br><span class="line">        mCurDefaultDisplayDpi &#x3D; data.config.densityDpi;</span><br><span class="line">        applyCompatConfiguration(mCurDefaultDisplayDpi);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获得LoadedApk对象</span><br><span class="line">    data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line">    &#x2F;&#x2F;判断是否需要为进程设置新的分辨率密度</span><br><span class="line">    if ((data.appInfo.flags&amp; ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES)</span><br><span class="line">            &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        mDensityCompatMode &#x3D; true;</span><br><span class="line">        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">    updateDefaultDensity();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; StrictMode</span><br><span class="line">    &#x2F;&#x2F;表示只为系统应用(FLAG_SYSTEM, FLAG_UPDATED_SYSTEM_APP)开启了</span><br><span class="line">    &#x2F;&#x2F;StrictMode，其他应用还是需要自行开启</span><br><span class="line">    if ((data.appInfo.flags &amp;</span><br><span class="line">            (ApplicationInfo.FLAG_SYSTEM |</span><br><span class="line">                    ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) !&#x3D; 0) &#123;</span><br><span class="line">        StrictMode.conditionallyEnableDebugLogging();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;当api&gt;&#x3D;HONEYCOMB时,Android不允许在主线程中使用网络</span><br><span class="line">    if (data.appInfo.targetSdkVersion &gt;&#x3D; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        StrictMode.enableDeathOnNetwork();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Android 7.0以后，Android引入了FileProvider</span><br><span class="line">    if (data.appInfo.targetSdkVersion &gt;&#x3D; Build.VERSION_CODES.N) &#123;</span><br><span class="line">        StrictMode.enableDeathOnFileUriExposure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    final InstrumentationInfo ii;</span><br><span class="line">    &#x2F;&#x2F; Instrumentation信息会影响类加载器,所以应该在设置app context之前加载它</span><br><span class="line">    if (data.instrumentationName !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ii &#x3D; new ApplicationPackageManager(null, getPackageManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置InstrumentationInfo信息</span><br><span class="line">        ...</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        ii &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在这里创建了ContextImpl对象</span><br><span class="line">    final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;继续加载Instrumentation对象</span><br><span class="line">    if (ii !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl &#x3D; instrContext.getClassLoader();</span><br><span class="line">            &#x2F;&#x2F;创建Instrumentation对象</span><br><span class="line">            &#x2F;&#x2F; 之前提到，Instrumentation的作用就是监控系统和应用的交互，</span><br><span class="line">            &#x2F;&#x2F; 因此Activity的生命周期也会被Instrumentation所监控</span><br><span class="line">            mInstrumentation &#x3D;(Instrumentation)cl.loadClass(</span><br><span class="line">                    data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        final ComponentName component &#x3D; new ComponentName(ii.packageName, ii.name);</span><br><span class="line">        &#x2F;&#x2F;初始化Instrumentation参数</span><br><span class="line">        mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F; 构建 Applicaiton</span><br><span class="line">        Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">        &#x2F;&#x2F;设置ActivityThread.mInitialApplication</span><br><span class="line">        mInitialApplication &#x3D; app;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;这里会调用到Application的onCreate()方法</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch(Exception e)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行ASS的attachApplication"><a href="#执行ASS的attachApplication" class="headerlink" title="执行ASS的attachApplication"></a>执行ASS的attachApplication</h5><p>ActivityStackSupervisor.java</p>
<ul>
<li>attachApplicationLocked，找到对应ActivityRecord等</li>
<li>realStartActivityLocked，更新进程信息，获取发送启动Activity参数，最后调用ActivityThread中的ApplicationThread执行 scheduleLaunchActivity 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">   final String processName &#x3D; app.processName;</span><br><span class="line">   boolean didSomething &#x3D; false;</span><br><span class="line">   for (int displayNdx &#x3D; mActivityDisplays.size() - 1; displayNdx &gt;&#x3D; 0; --displayNdx) &#123;</span><br><span class="line">       ArrayList&lt;ActivityStack&gt; stacks &#x3D; mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">       for (int stackNdx &#x3D; stacks.size() - 1; stackNdx &gt;&#x3D; 0; --stackNdx) &#123;</span><br><span class="line">           final ActivityStack stack &#x3D; stacks.get(stackNdx);</span><br><span class="line">           if (!isFocusedStack(stack)) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 找到 当前stack 下的top ActivityRecord</span><br><span class="line">           ActivityRecord hr &#x3D; stack.topRunningActivityLocked();</span><br><span class="line">           if (hr !&#x3D; null) &#123;</span><br><span class="line">               if (hr.app &#x3D;&#x3D; null &amp;&amp; app.uid &#x3D;&#x3D; hr.info.applicationInfo.uid</span><br><span class="line">                       &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       &#x2F;&#x2F; 调用 realStartActivityLocked </span><br><span class="line">                       if (realStartActivityLocked(hr, app, true, true)) &#123;</span><br><span class="line">                           didSomething &#x3D; true;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   ...</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if (!didSomething) &#123;</span><br><span class="line">       ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">   &#125;</span><br><span class="line">   return didSomething;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">       boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;获得已存在的Task和Stack</span><br><span class="line">    final TaskRecord task &#x3D; r.getTask();</span><br><span class="line">    final ActivityStack stack &#x3D; task.getStack();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;推迟resume，避免在一个循环中多次resume</span><br><span class="line">    beginDeferResume();</span><br><span class="line">    &#x2F;&#x2F;开始冻结屏幕</span><br><span class="line">    r.startFreezingScreenLocked(app, 0);</span><br><span class="line">    &#x2F;&#x2F;开始收集启动信息</span><br><span class="line">    r.startLaunchTickingLocked();</span><br><span class="line">    r.app &#x3D; app;</span><br><span class="line"></span><br><span class="line">    if (checkConfig) &#123;</span><br><span class="line">        final int displayId &#x3D; r.getDisplayId();</span><br><span class="line">        final Configuration config &#x3D;mWindowManager.updateOrientationFromAppTokens(</span><br><span class="line">                getDisplayOverrideConfiguration(displayId),r.mayFreezeScreenLocked(app) ? r.appToken : null, displayId);</span><br><span class="line">        &#x2F;&#x2F;当显示方向改变时，推迟resume，防止启动多余的Activity</span><br><span class="line">        mService.updateDisplayOverrideConfigurationLocked(config, r, true &#x2F;* deferResume *&#x2F;,displayId);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;更新进程使用情况</span><br><span class="line">    mService.updateLruProcessLocked(app, true, null);</span><br><span class="line">    &#x2F;&#x2F;更新进程OomAdj</span><br><span class="line">    mService.updateOomAdjLocked();</span><br><span class="line">    try &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;通过Binder调用ApplicationThread的scheduleLaunchActivity()</span><br><span class="line">        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r),r.info,mergedConfiguration.getGlobalConfiguration(),mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;... 处理进程臃肿的情况</span><br><span class="line">    &#125; catch(RemoteException e)&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;会进行两次操作，第一次重启进程失败后再抛出异常执行第二次操作</span><br><span class="line">        &#x2F;&#x2F;第二次失败后就放弃</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ActivityThread-执行Activity启动"><a href="#ActivityThread-执行Activity启动" class="headerlink" title="ActivityThread 执行Activity启动"></a>ActivityThread 执行Activity启动</h5><ul>
<li>ActivityThread.Application.scheduleLaunchActivity，构建ActivityClientRecord，发送H.LAUNCH_ACTIVITY消息</li>
<li>ActivityThread.handleLaunchActivity，执行Activity启动后的生命周期方法</li>
<li>performLaunchActivity，主要是调用Activity的onCreate(),onStart(),onRestoreInstance(),onPostCreate()生命周期</li>
<li>handleResumeActivity()，回调Activity的onResume()方法，并将DecorView添加到WindowManager中，这里的WindowManager是a.getWindowManager()得到的，其实现是WindowManagerImpl，这步操作在onResume()方法之后执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(...) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line">    ActivityClientRecord r &#x3D; new ActivityClientRecord();</span><br><span class="line">    ...</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前进程正活跃，避免GC</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    &#x2F;&#x2F;确保使用的是最近的配置</span><br><span class="line">    handleConfigurationChanged(null, null);</span><br><span class="line">    &#x2F;&#x2F;在创建Activity之前初始化WindowManagerService</span><br><span class="line">    if (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL()</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;执行performLaunchActivity(),并返回Activity对象</span><br><span class="line">    Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a !&#x3D; null) &#123;</span><br><span class="line">        r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState &#x3D; r.state;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;启动成功后，恢复Activity</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">        &#x2F;&#x2F; ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ActivityInfo aInfo &#x3D; r.activityInfo;</span><br><span class="line">    if (r.packageInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;从PackageManagerService获取应用包信息</span><br><span class="line">        r.packageInfo &#x3D; getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component &#x3D; r.intent.getComponent();</span><br><span class="line">    if (component &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取组件信息</span><br><span class="line">        component &#x3D; r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果提前设置好了目标Activity，则重新设置组件信息</span><br><span class="line">    if (r.activityInfo.targetActivity !&#x3D; null) &#123;</span><br><span class="line">        component &#x3D; new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext &#x3D; createBaseContextForActivity(r);</span><br><span class="line">    Activity activity &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;利用ClassLoader去加载Activity</span><br><span class="line">        java.lang.ClassLoader cl &#x3D; appContext.getClassLoader();</span><br><span class="line">        &#x2F;&#x2F;利用Instrumentation创建Activity实例</span><br><span class="line">        activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state !&#x3D; null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        if (activity !&#x3D; null) &#123;</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config,r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;回调Activity的onCreate()方法</span><br><span class="line">        &#x2F;&#x2F;这里回调的重载函数由ActivityInfo的persistableMode参数决定</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        r.activity &#x3D; activity;</span><br><span class="line">        r.stopped &#x3D; true;</span><br><span class="line">        if (!r.activity.mFinished) &#123;</span><br><span class="line">            &#x2F;&#x2F;回调Activity的onStart()方法，同时会改变FragmentManager的状态信息</span><br><span class="line">            &#x2F;&#x2F; mInstrumentation.callActivityOnStart(this);</span><br><span class="line">            activity.performStart();</span><br><span class="line">            r.stopped &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;回调Activity的onRestoreInstanceState()方法</span><br><span class="line">        &#x2F;&#x2F;这里的回调方法同样由ActivityInfo的persistableMode参数决定</span><br><span class="line">        if (!r.activity.mFinished) &#123;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                if (r.state !&#x3D; null || r.persistentState !&#x3D; null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (r.state !&#x3D; null) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;回调Activity的OnPostCreate()方法</span><br><span class="line">        if (!r.activity.mFinished) &#123;</span><br><span class="line">            activity.mCalled &#x3D; false;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                        r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                                &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused &#x3D; true;</span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line">    &#125; catch(SuperNotCalledException e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">                                boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">    &#x2F;&#x2F;回调Activity的onResume()方法</span><br><span class="line">    r &#x3D; performResumeActivity(token, clearHide, reason);</span><br><span class="line">    if (r !&#x3D; null) &#123;</span><br><span class="line">        final Activity a &#x3D; r.activity;</span><br><span class="line">        final int forwardBit &#x3D; isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line">        &#x2F;&#x2F;显示window</span><br><span class="line">        if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">	          ...</span><br><span class="line">            ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">	          ...</span><br><span class="line">            &#x2F;&#x2F;将decorView添加到WindowManager中</span><br><span class="line">            wm.addView(decor, l);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;更新布局</span><br><span class="line">        wm.updateViewLayout(decor, l);</span><br><span class="line">        ...</span><br><span class="line">        if (reallyResume) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;通知AMS已经Resume了</span><br><span class="line">                ActivityManager.getService().activityResumed(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;如果在onResume之前抛出异常了,则通知AMS结束该Activity</span><br><span class="line">                ActivityManager.getService()</span><br><span class="line">                        .finishActivity(token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>您的👍，激励我的前行 👻👻👻</p>
</blockquote>
<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/08/19/Android%E7%B3%BB%E7%BB%9F%E2%80%94ActivityManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/08/19/Android%E7%B3%BB%E7%BB%9F%E2%80%94ActivityManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Android系统—ActivityManagerService启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-19 15:19:21" itemprop="dateCreated datePublished" datetime="2019-08-19T15:19:21+08:00">2019-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:07:47" itemprop="dateModified" datetime="2020-02-07T01:07:47+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一集：<a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">SystemServer启动分析</a></p>
<h4 id="系统服务启动AMS"><a href="#系统服务启动AMS" class="headerlink" title="系统服务启动AMS"></a>系统服务启动AMS</h4><p>SystemServer.startBootstrapServices</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    &#x2F;&#x2F; 启动 AMS </span><br><span class="line">    mActivityManagerService &#x3D; mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    &#x2F;&#x2F; AMS设置 系统服务管理器</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    &#x2F;&#x2F; AMS设置 APP安装器</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    &#x2F;&#x2F; 启动电源管理器，AMS对其进行初始化</span><br><span class="line">    mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    &#x2F;&#x2F; 设置系统进程及相关</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AMS构建和启动"><a href="#AMS构建和启动" class="headerlink" title="AMS构建和启动"></a>AMS构建和启动</h4><p>ActivityManagerService构造函数</p>
<ul>
<li>初始化一些对象属性，包括 Context、ActivityThread、ServiceThread、MainHandler、ActivityManagerConstants 等对象</li>
<li>创建和管理四大组件相关的类对象，包括 BroadcastQueue、ActiveServices、ProviderMap、ActivityStackSupervisor、RecentTasks 和 ActivityStarter 等对象</li>
<li>创建一个 CPU 监控线程 mProcessCpuThread</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static final class Lifecycle extends SystemService&#123;</span><br><span class="line">    private final ActivityManagerService mService;</span><br><span class="line">    &#x2F;&#x2F; ServiceManager反射调用构造方法构造</span><br><span class="line">    public Lifecycle(Context context) &#123;</span><br><span class="line">      super(context);</span><br><span class="line">      mService &#x3D; new ActivityManagerService(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">      mService.start(); &#x2F;&#x2F; AMS 启动</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">    mContext &#x3D; systemContext; &#x2F;&#x2F; 赋值 SystemServer的context</span><br><span class="line">    mFactoryTest &#x3D; FactoryTest.getMode();</span><br><span class="line">    &#x2F;&#x2F; 赋值 SystemServer 的ActivityThread</span><br><span class="line">    mSystemThread &#x3D;  ActivityThread.currentActivityThread();</span><br><span class="line">    &#x2F;&#x2F; 创建带Handler的前台线程和MainHandler，AMS内部通信用</span><br><span class="line">    mHandlerThread &#x3D; new ServiceThread(TAG,</span><br><span class="line">          android.os.Process.THREAD_PRIORITY_FOREGROUND, false);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    mHandler &#x3D; new MainHandler(mHandlerThread.getLooper());</span><br><span class="line">    &#x2F;&#x2F; 创建UIHandler，AMS所需要的界面交互用</span><br><span class="line">    mUiHandler &#x3D; new UiHandler(); </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建前台广播接受队列 和 后台广播接受队列</span><br><span class="line">    mFgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">          &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false);</span><br><span class="line">    mBgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">          &quot;background&quot;, BROADCAST_BG_TIMEOUT, true);</span><br><span class="line">    mBroadcastQueues[0] &#x3D; mFgBroadcastQueue;</span><br><span class="line">    mBroadcastQueues[1] &#x3D; mBgBroadcastQueue;</span><br><span class="line">    &#x2F;&#x2F; 创建Service 和Provider 容器</span><br><span class="line">    mServices &#x3D; new ActiveServices(this);</span><br><span class="line">    mProviderMap &#x3D; new ProviderMap(this);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建 &#x2F;data&#x2F;system 目录</span><br><span class="line">    File dataDir &#x3D; Environment.getDataDirectory();</span><br><span class="line">    File systemDir &#x3D; new File(dataDir, &quot;system&quot;);</span><br><span class="line">    systemDir.mkdirs();</span><br><span class="line">    &#x2F;&#x2F; 创建 电量统计服务</span><br><span class="line">    mBatteryStatsService &#x3D; new BatteryStatsService(systemDir, mHandler);</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">    mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">    mOnBattery &#x3D; DEBUG_POWER ? true</span><br><span class="line">          : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().setCallback(this);</span><br><span class="line">    &#x2F;&#x2F; 创建 进程统计服务</span><br><span class="line">    mProcessStats &#x3D; new ProcessStatsService(this, new File(systemDir, &quot;procstats&quot;));</span><br><span class="line">    </span><br><span class="line">    mAppOpsService &#x3D; new AppOpsService(new File(systemDir, &quot;appops.xml&quot;), mHandler);</span><br><span class="line">    </span><br><span class="line">    mGrantFile &#x3D; new AtomicFile(new File(systemDir, &quot;urigrants.xml&quot;));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; User 0 is the first and only user that runs at boot.</span><br><span class="line">    mStartedUsers.put(UserHandle.USER_OWNER, new UserState(UserHandle.OWNER, true));</span><br><span class="line">    mUserLru.add(UserHandle.USER_OWNER);</span><br><span class="line">    updateStartedUserArrayLocked();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; CPU 追踪器初始化</span><br><span class="line">    mProcessCpuTracker.init();</span><br><span class="line">    &#x2F;&#x2F; 创建Activity相关对象</span><br><span class="line">    mRecentTasks &#x3D; new RecentTasks(this);</span><br><span class="line">    mStackSupervisor &#x3D; new ActivityStackSupervisor(this, mRecentTasks);</span><br><span class="line">    mTaskPersister &#x3D; new TaskPersister(systemDir, mStackSupervisor, mRecentTasks);</span><br><span class="line">    &#x2F;&#x2F; 创建‘CpuTracker’的现场</span><br><span class="line">    mProcessCpuThread &#x3D; new Thread(&quot;CpuTracker&quot;) &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">               synchronized(this) &#123;</span><br><span class="line">                   ... &#x2F;&#x2F; 更新cpu状态</span><br><span class="line">                   updateCpuStatsNow();</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void start() &#123;</span><br><span class="line">    &#x2F;&#x2F; 启动 CPU 监控线程，在启动 CPU 监控线程之前，首先将进程复位</span><br><span class="line">    &#x2F;&#x2F; 注册电池状态服务和权限管理服务</span><br><span class="line">    Process.removeAllProcessGroups(); &#x2F;&#x2F;移除所有的进程组</span><br><span class="line">    mProcessCpuThread.start(); &#x2F;&#x2F;启动CpuTracker线程</span><br><span class="line">    &#x2F;&#x2F;启动电池统计服务</span><br><span class="line">    mBatteryStatsService.publish(mContext);</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    &#x2F;&#x2F;创建LocalService，并添加到LocalServices</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SystemServer调用AMS注册各种服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void setSystemProcess() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));</span><br><span class="line">        if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this));</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));</span><br><span class="line">        ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));</span><br><span class="line">        ApplicationInfo info &#x3D; mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                &quot;android&quot;, STOCK_PM_FLAGS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建用于性能统计的Profiler对象</span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建ProcessRecord对象</span><br><span class="line">            ProcessRecord app &#x3D; newProcessRecordLocked(info, info.processName, false, 0);</span><br><span class="line">            app.persistent &#x3D; true; &#x2F;&#x2F;设置为persistent进程</span><br><span class="line">            app.pid &#x3D; MY_PID;</span><br><span class="line">            app.maxAdj &#x3D; ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            updateLruProcessLocked(app, false, null);&#x2F;&#x2F;维护进程lru</span><br><span class="line">            updateOomAdjLocked(); &#x2F;&#x2F;更新adj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系统服务Ready-AMS"><a href="#系统服务Ready-AMS" class="headerlink" title="系统服务Ready-AMS"></a>系统服务Ready-AMS</h4><p>SystemServer.startOtherServices</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;安装系统Provider</span><br><span class="line">  mActivityManagerService.installSystemProviders();</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;调用AMS systemReady , 传递了 一个Runnable对象</span><br><span class="line">  mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         ... &#x2F;&#x2F; AMS的systemReady方法会执行该Runnable   </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS.systemReady</p>
<ul>
<li>task清理和恢复、是否更新广播、进程清理等systemReady前任务执行</li>
<li>系统准备好后,回调runnable，启动webView、系统UI、一系列服务ready和systemRunning</li>
<li>启动persistent进程，启动HomeActivity，发送系统广播等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    &#x2F;&#x2F; before goingCallback执行</span><br><span class="line">    &#x2F;&#x2F; goingCallback执行</span><br><span class="line">    &#x2F;&#x2F; after goingCallback执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    &#x2F;&#x2F; before goingCallback执行</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 同步执行 待 systemReady ok</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (mSystemReady) &#123;</span><br><span class="line">            if (goingCallback !&#x3D; null) &#123;</span><br><span class="line">                goingCallback.run();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        mLocalDeviceIdleController</span><br><span class="line">                &#x3D; LocalServices.getService(DeviceIdleController.LocalService.class);</span><br><span class="line">           </span><br><span class="line">        updateCurrentProfileIdsLocked();</span><br><span class="line">        &#x2F;&#x2F; 清理最近task，把需要恢复的task添加上</span><br><span class="line">        mRecentTasks.clear();</span><br><span class="line">        mRecentTasks.addAll(mTaskPersister.restoreTasksLocked());</span><br><span class="line">        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">        mTaskPersister.startPersisting();</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F; 检查是否需要更新</span><br><span class="line">        if (!mDidUpdate) &#123;</span><br><span class="line">            if (mWaitingUpdate) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            final ArrayList&lt;ComponentName&gt; doneReceivers &#x3D; new ArrayList&lt;ComponentName&gt;();</span><br><span class="line">            mWaitingUpdate &#x3D; deliverPreBootCompleted(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                        mDidUpdate &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    showBootMessage(mContext.getText(</span><br><span class="line">                            R.string.android_upgrading_complete),</span><br><span class="line">                            false);</span><br><span class="line">                    writeLastDonePreBootReceivers(doneReceivers);</span><br><span class="line">                    systemReady(goingCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, doneReceivers, UserHandle.USER_OWNER);</span><br><span class="line">           </span><br><span class="line">            if (mWaitingUpdate) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mDidUpdate &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        mAppOpsService.systemReady();</span><br><span class="line">        mSystemReady &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 将非persistent进程，添加到procsToKill</span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procsToKill &#x3D; null;</span><br><span class="line">    synchronized(mPidsSelfLocked) &#123;</span><br><span class="line">       for (int i&#x3D;mPidsSelfLocked.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">           ProcessRecord proc &#x3D; mPidsSelfLocked.valueAt(i);</span><br><span class="line">           if (!isAllowedWhileBooting(proc.info))&#123;</span><br><span class="line">               if (procsToKill &#x3D;&#x3D; null) &#123;</span><br><span class="line">                   procsToKill &#x3D; new ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">               &#125;</span><br><span class="line">               procsToKill.add(proc);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#x2F;&#x2F; 杀掉进程</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">       if (procsToKill !&#x3D; null) &#123;</span><br><span class="line">           for (int i&#x3D;procsToKill.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">               ProcessRecord proc &#x3D; procsToKill.get(i);</span><br><span class="line">               removeProcessLocked(proc, true, false, &quot;system update done&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 进程 ready    </span><br><span class="line">       mProcessesReady &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; system 现在进入ready 状态</span><br><span class="line">   Slog.i(TAG, &quot;System now ready&quot;);</span><br><span class="line">   EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,</span><br><span class="line">       SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   retrieveSettings();</span><br><span class="line">   loadResourcesOnSystemReady();</span><br><span class="line"></span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       readGrantedUriPermissionsLocked(); &#x2F;&#x2F; 权限检查</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; goingCallback 执行</span><br><span class="line">    if (goingCallback !&#x3D; null) goingCallback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      &#x2F;&#x2F; phase550</span><br><span class="line">      mSystemServiceManager.startBootPhase(</span><br><span class="line">              SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line"></span><br><span class="line">      mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">      &#x2F;&#x2F;启动WebView</span><br><span class="line">      WebViewFactory.prepareWebViewInSystemServer();</span><br><span class="line">      &#x2F;&#x2F;启动系统UI</span><br><span class="line">      startSystemUi(context);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 执行一系列服务的systemReady方法</span><br><span class="line">      networkScoreF.systemReady();</span><br><span class="line">      networkManagementF.systemReady();</span><br><span class="line">      networkStatsF.systemReady();</span><br><span class="line">      networkPolicyF.systemReady();</span><br><span class="line">      connectivityF.systemReady();</span><br><span class="line">      audioServiceF.systemReady();</span><br><span class="line">      Watchdog.getInstance().start(); &#x2F;&#x2F;Watchdog开始工作</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;phase600</span><br><span class="line">      mSystemServiceManager.startBootPhase(</span><br><span class="line">              SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;执行一系列服务的systemRunning方法</span><br><span class="line">      wallpaper.systemRunning();</span><br><span class="line">      inputMethodManager.systemRunning(statusBarF);</span><br><span class="line">      location.systemRunning();</span><br><span class="line">      countryDetector.systemRunning();</span><br><span class="line">      networkTimeUpdater.systemRunning();</span><br><span class="line">      commonTimeMgmtService.systemRunning();</span><br><span class="line">      textServiceManagerService.systemRunning();</span><br><span class="line">      assetAtlasService.systemRunning();</span><br><span class="line">      inputManager.systemRunning();</span><br><span class="line">      telephonyRegistry.systemRunning();</span><br><span class="line">      mediaRouter.systemRunning();</span><br><span class="line">      mmsService.systemRunning();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    ... &#x2F;&#x2F; before goingCallback执行</span><br><span class="line">    ... &#x2F;&#x2F; goingCallback执行</span><br><span class="line">    &#x2F;&#x2F; after goingCallback执行</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">    if (mFactoryTest !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过pms获取所有的persistent进程</span><br><span class="line">        List apps &#x3D; AppGlobals.getPackageManager().</span><br><span class="line">            getPersistentApplications(STOCK_PM_FLAGS);</span><br><span class="line">        if (apps !&#x3D; null) &#123;</span><br><span class="line">            int N &#x3D; apps.size();</span><br><span class="line">            int i;</span><br><span class="line">            for (i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                ApplicationInfo info &#x3D; (ApplicationInfo)apps.get(i);</span><br><span class="line">                if (info !&#x3D; null &amp;&amp; !info.packageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;启动persistent进程</span><br><span class="line">                    addAppLocked(info, false, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBooting &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F; 启动桌面Activity </span><br><span class="line">    startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    long ident &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;system发送广播USER_STARTED</span><br><span class="line">        Intent intent &#x3D; new Intent(Intent.ACTION_USER_STARTED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(...);  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;system发送广播USER_STARTING</span><br><span class="line">        intent &#x3D; new Intent(Intent.ACTION_USER_STARTING);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(...);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 恢复栈顶Activity</span><br><span class="line">    mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">    sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下一集：<a href="https://www.jianshu.com/p/6df6ddac15d5" target="_blank" rel="noopener">Launcher启动分析</a></p>
<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/08/18/Android%E7%B3%BB%E7%BB%9FSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/08/18/Android%E7%B3%BB%E7%BB%9FSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Android系统SystemServer启动流程分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-18 19:48:01" itemprop="dateCreated datePublished" datetime="2019-08-18T19:48:01+08:00">2019-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:07:30" itemprop="dateModified" datetime="2020-02-07T01:07:30+08:00">2020-02-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>tags: </p>
<ul>
<li>源码</li>
<li>启动流程</li>
<li>SystemServer<br>categories:</li>
<li>[Android, 系统]</li>
</ul>
<hr>
<h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><p><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote启动流程分析</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-de00110241787bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="源码追踪"><a href="#源码追踪" class="headerlink" title="源码追踪"></a>源码追踪</h3><h4 id="SystemServer启动"><a href="#SystemServer启动" class="headerlink" title="SystemServer启动"></a>SystemServer启动</h4><p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ......    </span><br><span class="line">            &#x2F;&#x2F; 调用启动 SystemServer方法</span><br><span class="line">            if (startSystemServer) &#123; </span><br><span class="line">                startSystemServer(abiList, socketName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">        ......  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">private static boolean startSystemServer(String abiList, String socketName)</span><br><span class="line">      throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">      </span><br><span class="line">    ... 参数准备</span><br><span class="line">    int pid;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 解析参数，生成目标格式</span><br><span class="line">      parsedArgs &#x3D; new ZygoteConnection.Arguments(args);</span><br><span class="line">      ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">      ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; fork SystemServer 进程 </span><br><span class="line">      pid &#x3D; Zygote.forkSystemServer(</span><br><span class="line">              parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">              parsedArgs.gids,</span><br><span class="line">              parsedArgs.debugFlags,</span><br><span class="line">              null,</span><br><span class="line">              parsedArgs.permittedCapabilities,</span><br><span class="line">              parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">      throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 子进程 SystemServer</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;    </span><br><span class="line">      &#x2F;&#x2F; 执行启动流程的剩余工作</span><br><span class="line">      handleSystemServerProcess(parsedArgs); </span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SystemServer进程fork"><a href="#SystemServer进程fork" class="headerlink" title="SystemServer进程fork"></a>SystemServer进程fork</h4><p>Zygote.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,</span><br><span class="line">        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用native方法fork system_server进程</span><br><span class="line">    int pid &#x3D; nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    ...</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>com_android_internal_os_Zygote.cpp</p>
<p>主要：fork创建新进程SystemServer，采用copy on write方式（为了高效先全部复制，等需要的时候在修改）另外， fork方法会有两次返回，分别返回子进程和父进程的pid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkSystemServer(</span><br><span class="line">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span><br><span class="line">        jlong effectiveCapabilities) &#123;</span><br><span class="line">  &#x2F;&#x2F; fork子进程，</span><br><span class="line">  pid_t pid &#x3D; ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities,effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,NULL, NULL);</span><br><span class="line">  ...</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span><br><span class="line">                                     jint debug_flags, jobjectArray javaRlimits,</span><br><span class="line">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span><br><span class="line">                                     jint mount_external,</span><br><span class="line">                                     jstring java_se_info, jstring java_se_name,</span><br><span class="line">                                     bool is_system_server, jintArray fdsToClose,</span><br><span class="line">                                     jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  pid_t pid &#x3D; fork(); &#x2F;&#x2F;!!! fork子进程 (COW 方式)</span><br><span class="line">  </span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;进入子进程，初始化设置等</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (pid &gt; 0) &#123; &#x2F;&#x2F;进入父进程，即zygote进程</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开始执行SystemServer进程fork后的ZygoteInit操作"><a href="#开始执行SystemServer进程fork后的ZygoteInit操作" class="headerlink" title="开始执行SystemServer进程fork后的ZygoteInit操作"></a>开始执行SystemServer进程fork后的ZygoteInit操作</h4><p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void handleSystemServerProcess(</span><br><span class="line">        ZygoteConnection.Arguments parsedArgs)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    &#x2F;&#x2F; 关闭父进程zygote复制而来的Socket</span><br><span class="line">    closeServerSocket(); </span><br><span class="line"></span><br><span class="line">    if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName); &#x2F;&#x2F;设置当前进程名为&quot;system_server&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String systemServerClasspath &#x3D; Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">    if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; 执行dex优化操作</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; invokeWith &#x3D; null</span><br><span class="line">        ClassLoader cl &#x3D; null;</span><br><span class="line">        if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">            创建类加载器，并赋予当前线程</span><br><span class="line">            cl &#x3D; new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; RuntimeInit 执行 zygoteInit初始化工作</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RuntimeInit.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">       throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">   ......</span><br><span class="line">   commonInit();</span><br><span class="line">   nativeZygoteInit();</span><br><span class="line">   applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置默认的未捕捉异常处理方法</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置市区，中国时区为&quot;Asia&#x2F;Shanghai&quot;</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置log配置</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span><br><span class="line">    String userAgent &#x3D; getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置socket的tag，用于网络流量统计</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123;</span><br><span class="line">   </span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp</span><br><span class="line">virtual void onZygoteInit()&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置虚拟机的内存利用率参数值为0.75 , 设置目标sdk</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args &#x3D; new Arguments(argv); &#x2F;&#x2F;解析参数</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用startClass的static方法 main()；args.startClass为”com.android.server.SystemServer</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line">        Method m;</span><br><span class="line">        try &#123;</span><br><span class="line">            m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int modifiers &#x3D; m.getModifiers();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ! 回到 ZygoteInit.main()方法中，直接进入catch语句（这样做好处是能清空栈帧，提高栈帧利用率，比较巧妙）</span><br><span class="line">        throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        startSystemServer(abiList, socketName);&#x2F;&#x2F;启动system_server</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;根据传递过来的参数，可知此处通过反射机制调用的是SystemServer.main()方法</span><br><span class="line">                mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">                ... </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="SystemServer进程开始执行SystemServer-main方法"><a href="#SystemServer进程开始执行SystemServer-main方法" class="headerlink" title="SystemServer进程开始执行SystemServer.main方法"></a>SystemServer进程开始执行SystemServer.main方法</h4><p>SystemServer.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   new SystemServer().run(); &#x2F;&#x2F;创建SystemServer对象，再调用对象的run()方法</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void run() &#123;       </span><br><span class="line">   &#x2F;&#x2F; 设置系统时间、设置默认语言、虚拟机库文件、虚拟机内存 等</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 当前线程作为mainLooper</span><br><span class="line">   Looper.prepareMainLooper(); </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 初始化系统上下文</span><br><span class="line">   createSystemContext();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建系统服务管理 用于创建和启动system service</span><br><span class="line">   mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">   LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 启动各种系统服务</span><br><span class="line">   try &#123;</span><br><span class="line">       startBootstrapServices(); &#x2F;&#x2F; 启动引导服务</span><br><span class="line">       startCoreServices();    &#x2F;&#x2F; 启动核心服务</span><br><span class="line">       startOtherServices();   &#x2F;&#x2F; 启动其它服务</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 开启loop循环</span><br><span class="line">   Looper.loop();</span><br><span class="line">   throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void createSystemContext() &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建主线程任务的管理和调度类 ActivityThread</span><br><span class="line">   ActivityThread activityThread &#x3D; ActivityThread.systemMain();</span><br><span class="line">   &#x2F;&#x2F; 会依次创建对象有ActivityThread，Instrumentation, ContextImpl，LoadedApk，Application</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依次启动引导服务、核心服务、其它服务"><a href="#依次启动引导服务、核心服务、其它服务" class="headerlink" title="依次启动引导服务、核心服务、其它服务"></a>依次启动引导服务、核心服务、其它服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    &#x2F;&#x2F;阻塞等待 Installer 建立socket通道</span><br><span class="line">    Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 ActivityManagerService</span><br><span class="line">    mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 PowerManagerService</span><br><span class="line">    mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 LightsService</span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 DisplayManagerService</span><br><span class="line">    mDisplayManagerService &#x3D; mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Phase100: 服务启动阶段100 [100、480、500、550、600、1000]</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 PackageManagerService</span><br><span class="line">    mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 UserManagerService，新建目录&#x2F;data&#x2F;user&#x2F;</span><br><span class="line">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置AMS</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动传感器服务</span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">    &#x2F;&#x2F;启动服务BatteryService，用于统计电池电量，需要LightService.</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务UsageStatsService，用于统计应用使用情况</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务WebViewUpdateService</span><br><span class="line">    mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mContentResolver &#x3D; context.getContentResolver(); &#x2F;&#x2F; resolver</span><br><span class="line">    mActivityManagerService.installSystemProviders(); &#x2F;&#x2F;provider</span><br><span class="line">    ActivityManagerNative.getDefault().showBootMessage(...); &#x2F;&#x2F;显示启动界面</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;phase480 和phase500  [100、480、500、550、600、1000]</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 准备好 window, power, package, display服务</span><br><span class="line">    wm.systemReady();</span><br><span class="line">    mPowerManagerService.systemReady(...);</span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    mDisplayManagerService.systemReady(...);</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; AMS ready 完成服务启动其它阶段 及Home启动等</span><br><span class="line">    mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F;phase550</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         &#x2F;&#x2F;phase600</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/08/01/HTTP%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/08/01/HTTP%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">HTTP缓存策略分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-01 21:25:12" itemprop="dateCreated datePublished" datetime="2019-08-01T21:25:12+08:00">2019-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:52:10" itemprop="dateModified" datetime="2020-02-07T00:52:10+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h3><p>HTTP缓存通常指浏览器缓存，基于HTTP中header字段实现<br>HTTP缓存分为强缓存和协商缓存，见下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-cce700528e23bc81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Cache-Control主要字段说明"><a href="#Cache-Control主要字段说明" class="headerlink" title="Cache-Control主要字段说明"></a>Cache-Control主要字段说明</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-2a26a690808fb292.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="缓存校验字段"><a href="#缓存校验字段" class="headerlink" title="缓存校验字段"></a>缓存校验字段</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-4656eec189b891ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="缓存字段对比"><a href="#缓存字段对比" class="headerlink" title="缓存字段对比"></a>缓存字段对比</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-0d9fb787867f2f04.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="HTTP缓存流程"><a href="#HTTP缓存流程" class="headerlink" title="HTTP缓存流程"></a>HTTP缓存流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-e9f7b43d56529039.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="为什么使用HTTP缓存"><a href="#为什么使用HTTP缓存" class="headerlink" title="为什么使用HTTP缓存"></a>为什么使用HTTP缓存</h3><p>终端缓存策略，可以缩短端到端的请求资源的距离，减少延迟，而且缓存重用，也能减少宽带流量，降低网络负荷。<br>最终用户体验和性能得到优化，避免无用资源请求浪费</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/05/16/Zygote%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/05/16/Zygote%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Zygote启动流程分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-16 15:16:04" itemprop="dateCreated datePublished" datetime="2019-05-16T15:16:04+08:00">2019-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:07:06" itemprop="dateModified" datetime="2020-02-07T01:07:06+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Zygote简介"><a href="#Zygote简介" class="headerlink" title="Zygote简介"></a>Zygote简介</h4><p>Zygote中文翻译为“受精卵”，正如其名，它主要用于孵化子进程。<br>Zygote是一个C/S模型，Zygote进程作为服务端，其他进程作为客户端向它发出“孵化”请求，而Zygote接收到这个请求后就“孵化”出一个新的进程。<br>此篇文章着重介绍 Zygote进程的创建和启动流程</p>
<h4 id="Zygote进程启动流程图"><a href="#Zygote进程启动流程图" class="headerlink" title="Zygote进程启动流程图"></a>Zygote进程启动流程图</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-310e2ec8e0685edb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="init进程main方法"><a href="#init进程main方法" class="headerlink" title="init进程main方法"></a>init进程main方法</h4><h5 id="system-core-init-init-c"><a href="#system-core-init-init-c" class="headerlink" title="/system/core/init/init.c"></a>/system/core/init/init.c</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">     int main(int argc, char **argv)&#123;      </span><br><span class="line">        ... &#x2F;&#x2F; 初始化 文件、属性服务等</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 解析 init.rc </span><br><span class="line">1077    init_parse_config_file(&quot;&#x2F;init.rc&quot;);</span><br><span class="line">1078    &#x2F;&#x2F; 执行 rc解析后的data （见 rc 语法）</span><br><span class="line">1079    action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);</span><br><span class="line">1081    queue_builtin_action(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);</span><br><span class="line">1082    queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">1083    queue_builtin_action(keychord_init_action, &quot;keychord_init&quot;);</span><br><span class="line">1084    queue_builtin_action(console_init_action, &quot;console_init&quot;);</span><br><span class="line">1087    action_for_each_trigger(&quot;init&quot;, action_add_queue_tail);</span><br><span class="line">1092    queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">1093    queue_builtin_action(property_service_init_action, &quot;property_service_init&quot;);</span><br><span class="line">1094    queue_builtin_action(signal_init_action, &quot;signal_init&quot;);</span><br><span class="line">1097    if (is_charger) &#123;</span><br><span class="line">1098        action_for_each_trigger(&quot;charger&quot;, action_add_queue_tail);</span><br><span class="line">1099    &#125; else &#123;</span><br><span class="line">1100        action_for_each_trigger(&quot;late-init&quot;, action_add_queue_tail);</span><br><span class="line">1101    &#125;</span><br><span class="line">1104    queue_builtin_action(queue_property_triggers_action, &quot;queue_property_triggers&quot;);</span><br><span class="line">1108    queue_builtin_action(bootchart_init_action, &quot;bootchart_init&quot;);</span><br><span class="line"></span><br><span class="line">1110    &#x2F;&#x2F; 无限循环，执行action、检查是否需要重启、处理系统属性变化、回收僵尸进程等</span><br><span class="line">1111    for(;;) &#123;</span><br><span class="line">            ......</span><br><span class="line">1173    &#125;</span><br><span class="line">1174</span><br><span class="line">1175    return 0;</span><br><span class="line">1176&#125;</span><br><span class="line">1177</span><br></pre></td></tr></table></figure>

<h4 id="rc配置文件"><a href="#rc配置文件" class="headerlink" title="rc配置文件"></a>rc配置文件</h4><h5 id="system-core-rootdir-init-rc"><a href="#system-core-rootdir-init-rc" class="headerlink" title="/system/core/rootdir/init.rc"></a>/system/core/rootdir/init.rc</h5><p>init.rc是一个配置文件，内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：<br>Action、Commands、Services、Options和Import</p>
<h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><p>init.c的main方法中通过触发器trigger执行，执行顺序依次为<br>early-init、init、late-init、boot/charger、property等</p>
<h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>init.c先解析rc文件将service添加到service链表中，然后有 Action配置在on XXX时机下触发启动服务<br>init生成的子进程，定义在rc文件，其中每一个service在启动时会通过fork方式生成子进程</p>
<h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><p>执行命令，例如：start <service_name>： 启动指定的服务</p>
<h5 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h5><p>是Service的可选项，例如 socket：创建名为/dev/soket/<name>的socket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">422  on nonencrypted  &#x2F;&#x2F; 执行启动 main服务</span><br><span class="line">423    class_start main</span><br><span class="line">424    class_start late_start</span><br><span class="line">...  </span><br><span class="line">     &#x2F;&#x2F; service 例子</span><br><span class="line">519  service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">520    class core</span><br><span class="line">521    user system</span><br><span class="line">522    group system</span><br><span class="line">523    critical</span><br><span class="line">524    onrestart restart healthd</span><br><span class="line">525    onrestart restart zygote</span><br><span class="line">526    onrestart restart media</span><br><span class="line">527    onrestart restart surfaceflinger</span><br><span class="line">528    onrestart restart drm</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="system-core-rootdir-init-zygote64-rc"><a href="#system-core-rootdir-init-zygote64-rc" class="headerlink" title="/system/core/rootdir/init.zygote64.rc"></a>/system/core/rootdir/init.zygote64.rc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">2    class main</span><br><span class="line">3    socket zygote stream 660 root system</span><br><span class="line">4    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">5    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">6    onrestart restart media</span><br><span class="line">7    onrestart restart netd</span><br></pre></td></tr></table></figure>

<h4 id="rc配置文件解析"><a href="#rc配置文件解析" class="headerlink" title="rc配置文件解析"></a>rc配置文件解析</h4><p>/system/core/init/init_parser.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">      &#x2F;&#x2F; 解析 rc文件</span><br><span class="line">404   int init_parse_config_file(const char *fn)&#123;</span><br><span class="line">409    &#x2F;&#x2F; 解析 rc文件数据</span><br><span class="line">410    parse_config(fn, data);</span><br><span class="line">412    ......</span><br><span class="line">413 &#125;</span><br><span class="line"></span><br><span class="line">347  static void parse_config(const char *fn, char *s)&#123;</span><br><span class="line">       ... &#x2F;&#x2F; 初始化变量等</span><br><span class="line">365    for (;;) &#123;</span><br><span class="line">366        switch (next_token(&amp;state)) &#123;</span><br><span class="line">367        ...</span><br><span class="line">370        case T_NEWLINE:</span><br><span class="line">371            state.line++;</span><br><span class="line">372            if (nargs) &#123;</span><br><span class="line">373                int kw &#x3D; lookup_keyword(args[0]);</span><br><span class="line">374                if (kw_is(kw, SECTION)) &#123;</span><br><span class="line">375                    state.parse_line(&amp;state, 0, 0); &#x2F;&#x2F; 解析一份配置的每一项</span><br><span class="line">376                    parse_new_section(&amp;state, kw, nargs, args); &#x2F;&#x2F; 解析一份配置</span><br><span class="line">377                &#125; else &#123;</span><br><span class="line">378                    state.parse_line(&amp;state, nargs, args);</span><br><span class="line">379                &#125;</span><br><span class="line">380                nargs &#x3D; 0;</span><br><span class="line">381            &#125;</span><br><span class="line">382            break;</span><br><span class="line">384         ...</span><br><span class="line">388        &#125;</span><br><span class="line">389    &#125;</span><br><span class="line">390     .....</span><br><span class="line">401    &#125;</span><br><span class="line">402&#125;</span><br><span class="line"></span><br><span class="line">      static void parse_new_section(struct parse_state *state, int kw,</span><br><span class="line">321                       int nargs, char **args)&#123;</span><br><span class="line">323    </span><br><span class="line">326    case K_service: &#x2F;&#x2F; 解析服务</span><br><span class="line">327        state-&gt;context &#x3D; parse_service(state, nargs, args);</span><br><span class="line">328        if (state-&gt;context) &#123;</span><br><span class="line">329            state-&gt;parse_line &#x3D; parse_line_service;</span><br><span class="line">330            return;</span><br><span class="line">331        &#125;</span><br><span class="line">332        break;</span><br><span class="line">333    case K_on: &#x2F;&#x2F; 解析 Action</span><br><span class="line">334        state-&gt;context &#x3D; parse_action(state, nargs, args);</span><br><span class="line">335        if (state-&gt;context) &#123;</span><br><span class="line">336            state-&gt;parse_line &#x3D; parse_line_action;</span><br><span class="line">337            return;</span><br><span class="line">338        &#125;</span><br><span class="line">339        break;</span><br><span class="line">340    ......</span><br><span class="line">345&#125;</span><br><span class="line">346</span><br><span class="line"></span><br><span class="line">616  static void *parse_service(struct parse_state *state, int nargs, char **args)&#123;</span><br><span class="line">       &#x2F;&#x2F; 创建service ， 并添加到 Service链表中</span><br><span class="line">640    svc-&gt;name &#x3D; args[1];</span><br><span class="line">641    svc-&gt;classname &#x3D; &quot;default&quot;;</span><br><span class="line">642    memcpy(svc-&gt;args, args + 2, sizeof(char*) * nargs);</span><br><span class="line">643    svc-&gt;args[nargs] &#x3D; 0;</span><br><span class="line">644    svc-&gt;nargs &#x3D; nargs;</span><br><span class="line">645    svc-&gt;onrestart.name &#x3D; &quot;onrestart&quot;;</span><br><span class="line">646    list_init(&amp;svc-&gt;onrestart.commands);</span><br><span class="line">647    list_add_tail(&amp;service_list, &amp;svc-&gt;slist);</span><br><span class="line">648    return svc;</span><br><span class="line">649 &#125;</span><br><span class="line">650</span><br></pre></td></tr></table></figure>

<h4 id="Zygote服务启动和进程创建"><a href="#Zygote服务启动和进程创建" class="headerlink" title="Zygote服务启动和进程创建"></a>Zygote服务启动和进程创建</h4><p>服务进程启动，7.0之前面向过程实现，之后面向对象实现<br>/system/core/init/builtins.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     int do_class_start(int nargs, char **args)&#123;</span><br><span class="line">221    service_for_each_class(args[1], service_start_if_not_disabled);</span><br><span class="line">222    return 0;</span><br><span class="line">223&#125;</span><br><span class="line"></span><br><span class="line">194 static void service_start_if_not_disabled(struct service *svc)&#123;</span><br><span class="line">196    if (!(svc-&gt;flags &amp; SVC_DISABLED)) &#123;</span><br><span class="line">197        service_start(svc, NULL); &#x2F;&#x2F; 启动service</span><br><span class="line">198    &#125; else &#123;</span><br><span class="line">199        svc-&gt;flags |&#x3D; SVC_DISABLED_START;</span><br><span class="line">200    &#125;</span><br><span class="line">201 &#125;</span><br></pre></td></tr></table></figure>
<p>/system/core/init/init.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    void service_start(struct service *svc, const char *dynamic_args) &#123;</span><br><span class="line">       .....</span><br><span class="line">251    pid &#x3D; fork();  &#x2F;&#x2F; fork 进程</span><br><span class="line">252</span><br><span class="line">253    if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; init 子进程</span><br><span class="line">254       if (!dynamic_args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过execve(svc-&gt;args[0], (char**)svc-&gt;args, (char**) ENV)，进入App_main.cpp的main()函数</span><br><span class="line">335            if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123;</span><br><span class="line">336                ERROR(&quot;cannot execve(&#39;%s&#39;): %s\n&quot;, svc-&gt;args[0], strerror(errno));</span><br><span class="line">337            &#125;</span><br><span class="line">338       &#125;</span><br><span class="line">356        _exit(127);</span><br><span class="line">357    &#125;</span><br><span class="line">358     ...</span><br><span class="line">359 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Zygote进程main方法"><a href="#Zygote进程main方法" class="headerlink" title="Zygote进程main方法"></a>Zygote进程main方法</h4><p>/frameworks/base/cmds/app_process/app_main.cpp<br>主要事情：创建一个AppRuntime，调用它的start函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">132 int main(int argc, const char* const argv[])&#123;</span><br><span class="line">       .....</span><br><span class="line">       &#x2F;&#x2F; 传递的参数 args 为 “-Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server”</span><br><span class="line">197    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); &#x2F;&#x2F; 初始一个 runtime</span><br><span class="line">       </span><br><span class="line">162    while (i &lt; argc) &#123;</span><br><span class="line">163        const char* arg &#x3D; argv[i++];</span><br><span class="line">164        if (!parentDir) &#123;</span><br><span class="line">165            parentDir &#x3D; arg;</span><br><span class="line">166        &#125; else if (strcmp(arg, &quot;--zygote&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">167            zygote &#x3D; true;   &#x2F;&#x2F; 标识启动zygote</span><br><span class="line">168            niceName &#x3D; &quot;zygote&quot;;  </span><br><span class="line">169        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">170            startSystemServer &#x3D; true;</span><br><span class="line">171        &#125; else if (strcmp(arg, &quot;--application&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">172            application &#x3D; true;</span><br><span class="line">173        &#125; else if (strncmp(arg, &quot;--nice-name&#x3D;&quot;, 12) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">174            niceName &#x3D; arg + 12;</span><br><span class="line">175        &#125; else &#123;</span><br><span class="line">176            className &#x3D; arg;</span><br><span class="line">177            break;</span><br><span class="line">178        &#125;</span><br><span class="line">179    &#125;</span><br><span class="line">180</span><br><span class="line">        ......</span><br><span class="line">187</span><br><span class="line">188    if (zygote) &#123; &#x2F;&#x2F; 调用AppRuntime启动ZygoteInit</span><br><span class="line">189        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,</span><br><span class="line">190                startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</span><br><span class="line">191    &#125; else if (className) &#123;</span><br><span class="line">196        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;,</span><br><span class="line">197                application ? &quot;application&quot; : &quot;tool&quot;);</span><br><span class="line">198    &#125; else &#123;</span><br><span class="line">202        return 10;</span><br><span class="line">203    &#125;</span><br><span class="line">204&#125;</span><br><span class="line">205</span><br></pre></td></tr></table></figure>

<h4 id="AndroidRuntime初始化及启动Zygote初始化"><a href="#AndroidRuntime初始化及启动Zygote初始化" class="headerlink" title="AndroidRuntime初始化及启动Zygote初始化"></a>AndroidRuntime初始化及启动Zygote初始化</h4><p>AndroidRuntime.cpp<br>主要事情：启动虚拟机、注册JNI方法，调用ZygoteInit的main函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">     void AndroidRuntime::start(const char* className, const char* options) &#123;</span><br><span class="line">        ......</span><br><span class="line">836</span><br><span class="line">837    &#x2F;* start the virtual machine 启动虚拟机 *&#x2F;</span><br><span class="line">838    JNIEnv* env; </span><br><span class="line">839    if (startVm(&amp;mJavaVM, &amp;env) !&#x3D; 0) &#123;</span><br><span class="line">840        return;</span><br><span class="line">841    &#125;</span><br><span class="line">842    onVmCreated(env);</span><br><span class="line">843</span><br><span class="line">844    &#x2F;*</span><br><span class="line">845     * Register android functions. JNI方法注册</span><br><span class="line">846     *&#x2F;</span><br><span class="line">847    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">848        ALOGE(&quot;Unable to register all android natives\n&quot;);</span><br><span class="line">849        return;</span><br><span class="line">850    &#125;</span><br><span class="line">        ......</span><br><span class="line">871</span><br><span class="line">        &#x2F;&#x2F; 将 &quot;com.android.internal.os.ZygoteInit&quot;转换为&quot;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit&quot;</span><br><span class="line">876    char* slashClassName &#x3D; toSlashClassName(className);</span><br><span class="line">877    jclass startClass &#x3D; env-&gt;FindClass(slashClassName);</span><br><span class="line">878    if (startClass &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">879       ......</span><br><span class="line">881    &#125; else &#123;</span><br><span class="line">882        jmethodID startMeth &#x3D; env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</span><br><span class="line">883            &quot;([Ljava&#x2F;lang&#x2F;String;)V&quot;);</span><br><span class="line">884        if (startMeth &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">885            ......</span><br><span class="line">887        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用ZygoteInit.main()方法</span><br><span class="line">888            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">889</span><br><span class="line">895    &#125;</span><br><span class="line">896   ......</span><br><span class="line">903&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZygoteInit的main方法"><a href="#ZygoteInit的main方法" class="headerlink" title="ZygoteInit的main方法"></a>ZygoteInit的main方法</h4><p>ZygoteInit.java<br>主要事情：创建Socket用来和AMS通讯、启动SystemServer、调用runSelectLoop进入循环等待唤醒并执行相应工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            RuntimeInit.enableDdms(); &#x2F;&#x2F; 开启DDMS功能</span><br><span class="line">            ......</span><br><span class="line">            &#x2F;&#x2F; 注册 ZygoteSocket 进程间通信</span><br><span class="line">            registerZygoteSocket(socketName);</span><br><span class="line">            &#x2F;&#x2F; 预加载 类和资源（fork 进程共享）</span><br><span class="line">            preload();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Do an initial gc to clean up after startup</span><br><span class="line">            gcAndFinalize();</span><br><span class="line">            &#x2F;&#x2F; 启动 SystemServer 此处会fork出服务进程</span><br><span class="line">            if (startSystemServer) &#123;</span><br><span class="line">                startSystemServer(abiList, socketName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 开启无限循环模式 处理进程消息</span><br><span class="line">            runSelectLoop(abiList);</span><br><span class="line">            &#x2F;&#x2F; 关闭 socket</span><br><span class="line">            closeServerSocket();</span><br><span class="line">        &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">            caller.run(); &#x2F;&#x2F; 子进程 System_Server抛异常后调用</span><br><span class="line">        &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</span><br><span class="line">            closeServerSocket();</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/04/09/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/04/09/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Android系统启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-09 09:55:10" itemprop="dateCreated datePublished" datetime="2019-04-09T09:55:10+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:51:47" itemprop="dateModified" datetime="2020-02-07T00:51:47+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Android启动流程"><a href="#Android启动流程" class="headerlink" title="Android启动流程"></a>Android启动流程</h3><ol>
<li><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote进程启动分析</a></li>
<li><a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">SystemServer启动分析</a></li>
<li><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">AMS启动分析</a></li>
<li><a href="https://www.jianshu.com/p/6df6ddac15d5" target="_blank" rel="noopener">Launcher启动流程分析</a></li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-b50171bddb4bb847.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>启动电源以及系统启动</p>
<ul>
<li>电源按下时引导芯片会从预定义地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行</li>
<li>BootLoader，引导执行程序。主要作用就是把操作系统拉起来运行</li>
</ul>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>内核启动，初始化各种软硬件环境，加载驱动程序，挂载根文件系统，并执行init程序，由此开启Android的世界</p>
<ul>
<li>swapper进程：又叫idle进程，系统初始化Kernel由无到有开创的第一个进程，用于初始化进程管理、内存管理，加载Binder Drive、Disply、Camera Driver等相关工作</li>
<li>kthreadd进程：Linux系统内核进程，所有内核进程鼻祖，会创建其它内核守护进程</li>
</ul>
<h3 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h3><h5 id="init进程主要流程"><a href="#init进程主要流程" class="headerlink" title="init进程主要流程"></a>init进程主要流程</h5><ul>
<li>创建和挂载启动所需的文件目录</li>
<li>初始化属性服务</li>
<li>处理子进程的终止(<strong>signal方式</strong>)<ul>
<li>Zygote进程异常终止的重启动</li>
<li>回收僵尸进程 </li>
</ul>
</li>
<li>fork出 logd 、 healthd 、 installd 、 adbd 等用户守护进程</li>
<li>启动属性服务<ul>
<li>启动servicemanager（binder服务大管家）、bootanim（开机动画）、mediaserver等重要服务</li>
<li>本地服务是指运行在C++层的系统守护进程</li>
</ul>
</li>
<li>解析init.rc配置文件并启动Zygote进程 <ul>
<li>解析 init.zygote.rc </li>
<li>启动 main 类型服务 </li>
<li>启动 zygote 服务 </li>
<li>创建 Zygote 进程 </li>
<li>创建 Zygote Socket </li>
</ul>
</li>
<li>进入无限循环，执行action、检查是否需要重启、处理系统属性变化、回收僵尸进程等</li>
</ul>
<h3 id="C-Framework层"><a href="#C-Framework层" class="headerlink" title="C++ Framework层"></a>C++ Framework层</h3><p>主要运行本地服务，即MediaServer进程，由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger、CameraService等服务</p>
<h3 id="Java-Framework层"><a href="#Java-Framework层" class="headerlink" title="Java Framework层"></a>Java Framework层</h3><h5 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h5><p><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote启动流程分析</a></p>
<ul>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；<br>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，这样当程序被fork处理后，应用的进程内已经包含了这些系统资源，大大节省了应用的启动时间。</li>
<li>调用startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>最后调用runSelectLoop()，进入监听和接收消息的循环，当接收到请求创建新进程请求时立即唤醒并执行相应工作。（采用高效的I/O多路复用机制，保证没有客户端连接请求或数据处理时休眠，否则相应客户端的请求）</li>
</ul>
<h5 id="System-Server"><a href="#System-Server" class="headerlink" title="System Server"></a>System Server</h5><p><a href="https://www.jianshu.com/p/4d02ac462733" target="_blank" rel="noopener">System Server启动流程分析</a></p>
<ul>
<li>SystemServer的启动<ul>
<li>初始化设置</li>
<li>调用createSystemContext()来创建系统上下文</li>
<li>创建SystemServiceManager</li>
<li>启动各种服务（引导服务、核心服务、其它服务）</li>
<li>进入Looper.loop循环    </li>
</ul>
</li>
<li>初始化系统上下文<ul>
<li>创建ActivityThread对象</li>
<li>创建SystemContext对象（ContextImpl） </li>
</ul>
</li>
<li>创建SystemServiceManager</li>
<li>启动各种服务<ul>
<li>startBootstrapServices()</li>
<li>startCoreServices()</li>
<li>startOtherServices()</li>
</ul>
</li>
</ul>
<h5 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h5><p>是Android中核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作<br><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener"><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">Android系统—ActivityManagerService启动流程</a>
</a></p>
<ul>
<li>创建AMS实例对象，创建Andoid Runtime，ActivityThread和Context对象；</li>
<li>启动AMS服务，创建ActivityManagerService.Lifecycle对象</li>
<li>setSystemProcess：注册AMS、meminfo、cpuinfo等服务到ServiceManager</li>
<li>启动SystemUIService，再调用一系列服务的systemReady()方法</li>
<li>AMS.startHomeActivityLocked，启动HomeAcitivity</li>
</ul>
<h3 id="App层"><a href="#App层" class="headerlink" title="App层"></a>App层</h3><p>Zygote进程孵化出的第一个应用进程是Launcher进程（桌面），它还会孵化出Browser进程（浏览器）、Phone进程（电话）等。我们每个创建的应用都是一个单独的进程。</p>
<ul>
<li>当我们点击应用图标启动应用时或者在应用内启动一个带有process标签的Activity时，都会触发创建新进程的请求，这种请求会先通过Binder</li>
<li>发送给system_server进程，也即是发送给ActivityManagerService进行处理。<br>system_server进程会调用Process.start()方法，会先收集uid、gid等参数，然后通过Socket方式发送给Zygote进程，请求创建新进程。</li>
<li>Zygote进程接收到创建新进程的请求后，调用ZygoteInit.main()方法进行runSelectLoop()循环体内，当有客户端连接时执行ZygoteConnection.runOnce()方法，最后fork生成新的应用进程。</li>
<li>新创建的进程会调用handleChildProc()方法，最后调用我们非常熟悉的ActivityThread.main()方法。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-3eb0e8834c129aeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/03/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/03/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">Java并发编程—线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-20 17:26:37" itemprop="dateCreated datePublished" datetime="2019-03-20T17:26:37+08:00">2019-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:43:08" itemprop="dateModified" datetime="2020-02-07T00:43:08+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的，合理使用线程有3个好处。</p>
<ol>
<li>降低资源消耗。通过重用已创建的线程来降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。通过已创建线程立即执行任务，减少了线程的创建时间</li>
<li>提高线程的可管理性。通过合理地使用线程池，从而实现统一分配、调优和监控等</li>
</ol>
<h3 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-bf3d2e726a5dd6d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15534290301842.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-d52f7d01a39f8a44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>ThreadPoolExecutor执行任务流程</strong></p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建线程来执行任务</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果BlockingQueue已满，则创建新的线程来处理任务</li>
<li>如果当前运行线程总数大于maximumPoolSize，任务将被拒绝执行。并调用RejectedExecutionHandler.rejectedExecution方法</li>
</ol>
<h3 id="线程池包结构"><a href="#线程池包结构" class="headerlink" title="线程池包结构"></a>线程池包结构</h3><p>线程池简要组成部分可以分三块，任务、任务执行者及工具类相关</p>
<ul>
<li>任务: Callable、Runnable、FutureTask</li>
<li>任务执行者：ThreadPoolExecutor、ScheduledThreadPoolExecutor</li>
<li>工具类：Executors</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-836ddd4f9b3c7f1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="ThreadPoolExecutor解析"><a href="#ThreadPoolExecutor解析" class="headerlink" title="ThreadPoolExecutor解析"></a>ThreadPoolExecutor解析</h3><p>Java线程池最核心的类即ThreadPoolExecutor，它是线程池的实现类。</p>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-ef17773e5dd66c5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul>
<li><p>WorkQueue: 任务阻塞队列，缓存将要执行的Runnable任务</p>
<ul>
<li>ArrayBlockingQueue：基于数组有界阻塞队列</li>
<li>LinkedBlockingQueue：基于链表阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列（读写须等待一并进行）</li>
<li>PriorityBlockingQueue：支持优先级的无界队列</li>
</ul>
</li>
<li><p>RejectedExecutionHandler：任务拒绝策略，默认AbortPolicy</p>
<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public ThreadPoolExecutor(</span><br><span class="line">     int corePoolSize,                   &#x2F;&#x2F; 核心线程数</span><br><span class="line">     int maximumPoolSize,                &#x2F;&#x2F; 最大线程数</span><br><span class="line">     long keepAliveTime,                 &#x2F;&#x2F; 非核心线程闲置回收时间</span><br><span class="line">     TimeUnit unit,                      &#x2F;&#x2F; 时间单位</span><br><span class="line">     BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 装载任务的阻塞队列                                              ThreadFactory threadFactory,             &#x2F;&#x2F; 线程创建工厂                        </span><br><span class="line">     RejectedExecutionHandler handler    &#x2F;&#x2F; 任务拒绝状态时处理策略</span><br><span class="line">     ) &#123; </span><br><span class="line">        &#x2F;&#x2F; ......                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 运行中</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 拒绝新任务</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 拒绝新任务且不处理剩余任务</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 所有线程停止，准备执行终止方法 </span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 已执行终止方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程状态 ctl值取低29位</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line"> &#x2F;&#x2F; 线程状态 ctl值取高3位</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">       int c &#x3D; ctl.get();</span><br><span class="line">       &#x2F;&#x2F; 首先，运行线程数是否小雨核心线程</span><br><span class="line">       if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           if (addWorker(command, true)) &#x2F;&#x2F; 创建核心线程</span><br><span class="line">               return;</span><br><span class="line">           c &#x3D; ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 其次，往队列中插入任务</span><br><span class="line">       if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           int recheck &#x3D; ctl.get();</span><br><span class="line">           if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">               addWorker(null, false);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 否则，创建非核心线程执行任务</span><br><span class="line">       else if (!addWorker(command, false))</span><br><span class="line">           reject(command); &#x2F;&#x2F; 如果上面都失败，则拒绝执行任务，调用handler</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="addWork"><a href="#addWork" class="headerlink" title="addWork()"></a>addWork()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 使用CAS机制轮训线程池的状态，如果处于SHTUTDOWN及以上状态则拒绝执行任务</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        boolean workerStarted &#x3D; false;</span><br><span class="line">        boolean workerAdded &#x3D; false;</span><br><span class="line">        Worker w &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            w &#x3D; new Worker(firstTask); &#x2F;&#x2F; 构建Worker（worker会创建thread）</span><br><span class="line">            final Thread t &#x3D; w.thread;</span><br><span class="line">            if (t !&#x3D; null) &#123;</span><br><span class="line">                final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    </span><br><span class="line">                    int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    if (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                        if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable</span><br><span class="line">                            throw new IllegalThreadStateException();</span><br><span class="line">                        workers.add(w); &#x2F;&#x2F; 新建woker线程加入集合保存</span><br><span class="line">                        int s &#x3D; workers.size();</span><br><span class="line">                        if (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize &#x3D; s;</span><br><span class="line">                        workerAdded &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                if (workerAdded) &#123;</span><br><span class="line">                    t.start(); &#x2F;&#x2F; 执行任务</span><br><span class="line">                    workerStarted &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Work类"><a href="#Work类" class="headerlink" title="Work类"></a>Work类</h5><p>TreadPoolExecutor内部类，Worker构造方法指定第一个要执行的任务，并通过线程工厂创建线程。<br>Worker为Runnable，可以执行run，即调用到外部类的runWorker方法<br>继承AbstractQueuedSynchronizer，执行每个任务前通过lock方法加锁，执行完后通过unlock释放锁，以防止运行中任务中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;</span><br><span class="line">        final Thread thread;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        </span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask &#x3D; firstTask; </span><br><span class="line">            this.thread &#x3D; getThreadFactory().newThread(this); &#x2F;&#x2F; 构造的时候创建线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="runWork（）"><a href="#runWork（）" class="headerlink" title="runWork（）"></a>runWork（）</h5><p>每一个Worker在getTask()成功之后都要获取Worker的锁之后运行，也就是说运行中的Worker不会中断。因为核心线程一般在空闲的时候会一直阻塞在获取Task上，也只有中断才可能导致其退出。这些阻塞着的Worker就是空闲的线程（当然，非核心线程阻塞之后也是空闲线程）。如果设置了keepAliveTime&gt;0，那非核心线程会在空闲状态下等待keepAliveTime之后销毁，直到最终的线程数量等于corePoolSize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">        Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">        Runnable task &#x3D; w.firstTask;</span><br><span class="line">        w.firstTask &#x3D; null;</span><br><span class="line">        w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">        boolean completedAbruptly &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        task.run(); &#x2F;&#x2F; 任务执行</span><br><span class="line">                    &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Error x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Throwable x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    task &#x3D; null;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly &#x3D; false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作</span><br><span class="line">            &#x2F;&#x2F;比如在corePoolSize跟maximumPoolSize之间的woker会进行回收</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="getTask（）"><a href="#getTask（）" class="headerlink" title="getTask（）"></a>getTask（）</h5><p>通过一个循环不断轮询任务队列有没有任务到来，首先判断线程池是否处于正常运行状态，根据超时配置有两种方法取出任务：<br>BlockingQueue.poll 阻塞指定的时间尝试获取任务，如果超过指定的时间还未获取到任务就返回null。<br>BlockingQueue.take 这种方法会在取到任务前一直阻塞。<br>keepAliveTime代表了线程池中的线程（即woker线程）的存活时间，如果到期则回收woker线程<br>FixedThreadPool使用的是take方法，所以会线程会一直阻塞等待任务。CachedThreadPool使用的是poll方法，也就是说CachedThreadPool中的线程如果在60秒内未获取到队列中的任务就会被终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c &#x3D; ctl.get();</span><br><span class="line">            int rs &#x3D; runStateOf(c);</span><br><span class="line">            ......</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Are workers subject to culling?</span><br><span class="line">            boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            &#x2F;&#x2F; 超时配置时间，通过不同方法取任务</span><br><span class="line">            try &#123;</span><br><span class="line">                Runnable r &#x3D; timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line"></span><br><span class="line">                if (r !&#x3D; null)</span><br><span class="line">                    return r;</span><br><span class="line">                timedOut &#x3D; true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">                timedOut &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Executors构建线程方法"><a href="#Executors构建线程方法" class="headerlink" title="Executors构建线程方法"></a>Executors构建线程方法</h3><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>定长线程池：<br>可控制线程最大并发数（同时执行的线程数）<br>超出的线程会在队列中等待</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>可缓存线程池：<br>线程数无限制<br>有空闲线程则复用空闲线程，若无空闲线程则新建线程<br>一定程序减少频繁创建/销毁线程，减少系统开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>单线程化的线程池：</p>
<p>有且仅有一个工作线程执行任务<br>所有任务按照指定顺序执行，即遵循队列的入队出队规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>支持定时以指定周期循环执行任务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/03/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/03/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/" class="post-title-link" itemprop="url">深入理解ThreadLocal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-16 10:32:59" itemprop="dateCreated datePublished" datetime="2019-03-16T10:32:59+08:00">2019-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:36:49" itemprop="dateModified" datetime="2020-02-07T00:36:49+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h3><blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p>
</blockquote>
<p>释义：<br>ThreadLocal提供线程本地实例。它与普通变量区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。<br>ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<h3 id="ThreadLocal解决什么问题？"><a href="#ThreadLocal解决什么问题？" class="headerlink" title="ThreadLocal解决什么问题？"></a>ThreadLocal解决什么问题？</h3><p>并发编程中常见需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。<br>常规思路：使用一个线程共享的Map&lt;Thread,T&gt;,通过map来获取对应线程变量的值。带来的问题是需要同步，效率比较低。<br>而ThreadLocal从另一个角度解决多线程并发的问题。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。<br>（空间换时间）</p>
<h3 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h3><h5 id="整体结构图"><a href="#整体结构图" class="headerlink" title="整体结构图"></a>整体结构图</h5><ul>
<li>Thread持有成员变量threadLocals（ThreadLocalMap）</li>
<li>ThreadLocalMap是一个映射表，内部实现一个数组，每一个元素位Entry</li>
<li>Entry为一个键值对，key为Thread，Value为任何对象</li>
</ul>
<p><img src="media/15527089073930.jpg" alt=""></p>
<h5 id="ThreadLocal解析"><a href="#ThreadLocal解析" class="headerlink" title="ThreadLocal解析"></a>ThreadLocal解析</h5><p>set和get方法通过线程对应ThreadLocalMap来管理实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">     Thread t &#x3D; Thread.currentThread(); &#x2F;&#x2F; 获取当前线程</span><br><span class="line">     ThreadLocalMap map &#x3D; getMap(t); &#x2F;&#x2F; 获取线程对应映射表</span><br><span class="line">     if (map !&#x3D; null) &#x2F;&#x2F; 设置KV</span><br><span class="line">         map.set(this, value);</span><br><span class="line">     else</span><br><span class="line">         createMap(t, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">      Thread t &#x3D; Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">      if (map !&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 获取映射表中当前ThreadLocal对应的Value</span><br><span class="line">          ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">          if (e !&#x3D; null) &#123;</span><br><span class="line">              @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">              T result &#x3D; (T)e.value;</span><br><span class="line">              return result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果Map还未初始化或者Map中没有找到Key，则设置一个初始值</span><br><span class="line">      return setInitialValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ThreadLocalMap解析"><a href="#ThreadLocalMap解析" class="headerlink" title="ThreadLocalMap解析"></a>ThreadLocalMap解析</h5><p><strong>成员变量和内部类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了处理非常大(指的是值)和长时间的用途，哈希表的Key使用了弱引用(WeakReferences)。</span><br><span class="line">&#x2F;&#x2F; 引用的队列(弱引用)不再被使用的时候，对应的过期的条目就能通过主动删除移出哈希表。</span><br><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Value为WeakReference持有</span><br><span class="line">       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               super(k);</span><br><span class="line">               value &#x3D; v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 初始化容量，必须是2的幂次方</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private static final int INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 哈希表，长度为2的幂次方</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private Entry[] table;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * The number of entries in the table.（Entry数目）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 记录下一次扩容阀值</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private int threshold; &#x2F;&#x2F; Default to 0</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * Set the resize threshold to maintain at worst a 2&#x2F;3 load factor.（设置下一次阀值，len的三分之二）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private void setThreshold(int len) &#123;</span><br><span class="line">           threshold &#x3D; len * 2 &#x2F; 3;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * Increment i modulo len.（以len为模增加i）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private static int nextIndex(int i, int len) &#123;</span><br><span class="line">           return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * Decrement i modulo len.（以len为模减少i）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private static int prevIndex(int i, int len) &#123;</span><br><span class="line">           return ((i - 1 &gt;&#x3D; 0) ? i - 1 : len - 1);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造ThreadLocal时候使用，对应ThreadLocal的实例方法void createMap(Thread t, T firstValue)</span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 哈希表默认容量为16</span><br><span class="line">    table &#x3D; new Entry[INITIAL_CAPACITY];</span><br><span class="line">    &#x2F;&#x2F; 计算第一个元素的哈希码 （黄金分割数 &amp;（容量-1））</span><br><span class="line">    int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] &#x3D; new Entry(firstKey, firstValue);</span><br><span class="line">    size &#x3D; 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造InheritableThreadLocal时候使用，基于父线程的ThreadLocalMap里面的内容进行提取放入新的ThreadLocalMap的哈希表中</span><br><span class="line">&#x2F;&#x2F; 对应ThreadLocal的静态方法static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap)</span><br><span class="line">private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    Entry[] parentTable &#x3D; parentMap.table;</span><br><span class="line">    int len &#x3D; parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table &#x3D; new Entry[len];</span><br><span class="line">    &#x2F;&#x2F; 基于父ThreadLocalMap的哈希表进行拷贝</span><br><span class="line">    for (Entry e : parentTable) &#123;</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key &#x3D; (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            if (key !&#x3D; null) &#123;</span><br><span class="line">                Object value &#x3D; key.childValue(e.value);</span><br><span class="line">                Entry c &#x3D; new Entry(key, value);</span><br><span class="line">                int h &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                while (table[h] !&#x3D; null)</span><br><span class="line">                    h &#x3D; nextIndex(h, len);</span><br><span class="line">                table[h] &#x3D; c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>set部分</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; We don&#39;t use a fast path as with get() because it is at</span><br><span class="line">           &#x2F;&#x2F; least as common to use set() to create new entries as</span><br><span class="line">           &#x2F;&#x2F; it is to replace existing ones, in which case, a fast</span><br><span class="line">           &#x2F;&#x2F; path would fail more often than not.</span><br><span class="line">           </span><br><span class="line">           Entry[] tab &#x3D; table;</span><br><span class="line">           int len &#x3D; tab.length;</span><br><span class="line">           int i &#x3D; key.threadLocalHashCode &amp; (len-1); &#x2F;&#x2F;取index值</span><br><span class="line">           &#x2F;&#x2F; nextIndex方法实现全遍历</span><br><span class="line">           for (Entry e &#x3D; tab[i];</span><br><span class="line">                e !&#x3D; null;</span><br><span class="line">                e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123; </span><br><span class="line">                </span><br><span class="line">               ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">               if (k &#x3D;&#x3D; key) &#123; &#x2F;&#x2F; 匹配则直接替换value</span><br><span class="line">                   e.value &#x3D; value;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               &#x2F;&#x2F; key为null，则替换key并赋值value</span><br><span class="line">               if (k &#x3D;&#x3D; null) &#123; </span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">           int sz &#x3D; ++size;</span><br><span class="line">           &#x2F;&#x2F; 追求效率的平衡，仅清理i到sz指引的回收value</span><br><span class="line">           if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">               rehash(); &#x2F;&#x2F; 重新hash</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">         private void rehash() &#123;</span><br><span class="line">           &#x2F;&#x2F; 清理一遍哈希表</span><br><span class="line">           expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 哈希表元素数目大雨 3&#x2F;4阀值，则扩容</span><br><span class="line">           if (size &gt;&#x3D; threshold - threshold &#x2F; 4)</span><br><span class="line">               resize();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   private void resize() &#123;</span><br><span class="line">           Entry[] oldTab &#x3D; table;</span><br><span class="line">           int oldLen &#x3D; oldTab.length;</span><br><span class="line">           int newLen &#x3D; oldLen * 2;</span><br><span class="line">           Entry[] newTab &#x3D; new Entry[newLen];</span><br><span class="line">           int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">           for (int j &#x3D; 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">               Entry e &#x3D; oldTab[j];</span><br><span class="line">               if (e !&#x3D; null) &#123;</span><br><span class="line">                   ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">                   if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       e.value &#x3D; null; &#x2F;&#x2F; Help the GC</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       int h &#x3D; k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                       while (newTab[h] !&#x3D; null)</span><br><span class="line">                           h &#x3D; nextIndex(h, newLen);</span><br><span class="line">                       newTab[h] &#x3D; e;</span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           setThreshold(newLen);</span><br><span class="line">           size &#x3D; count;</span><br><span class="line">           table &#x3D; newTab;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><strong>get部分</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">           int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">           Entry e &#x3D; table[i];</span><br><span class="line">           if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)</span><br><span class="line">               return e;</span><br><span class="line">           else  &#x2F;&#x2F; 注意这里，如果e为null或者Key对不上，会调用getEntryAfterMiss</span><br><span class="line">               return getEntryAfterMiss(key, i, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">           Entry[] tab &#x3D; table;</span><br><span class="line">           int len &#x3D; tab.length;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 这里会通过nextIndex尝试遍历整个哈希表，如果找到匹配的Key则返回Entry</span><br><span class="line">           &#x2F;&#x2F; 如果哈希表中存在Key &#x3D;&#x3D; null的情况，调用expungeStaleEntry进行清理</span><br><span class="line">           while (e !&#x3D; null) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">               if (k &#x3D;&#x3D; key)</span><br><span class="line">                   return e;</span><br><span class="line">               if (k &#x3D;&#x3D; null)</span><br><span class="line">                   expungeStaleEntry(i);</span><br><span class="line">               else</span><br><span class="line">                   i &#x3D; nextIndex(i, len);</span><br><span class="line">               e &#x3D; tab[i];</span><br><span class="line">           &#125;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ul>
<li>什么情况下ThreadLocal的使用会导致内存泄漏？<ul>
<li>通过源码分析可以知道，ThreadLocalMap存放的Value是弱引用，会自动GC。但是对应的强引用则只在调用get、set或者remove才可能被回收</li>
<li>例如：大量地(静态)初始化ThreadLocal实例，初始化之后不再调用get()、set()、remove()方法。</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><ul>
<li>JavaWeb中Session的实现</li>
<li>Android应用中的Looper创建管理</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://throwable.coding.me/2019/02/17/java-currency-threadlocal/#%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">ThreadLocal源码分析-黄金分割数的使用</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog/page/5/">5</a><a class="page-number" href="/blog/page/6/">6</a><a class="extend next" rel="next" href="/blog/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Afree</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Afree</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  


</body>
</html>
