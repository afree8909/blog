<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"afree8909.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":20},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Afree&#39;s blog">
<meta property="og:url" content="https://afree8909.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="Afree&#39;s blog">
<meta property="article:author" content="Afree">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://afree8909.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Afree's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Afree's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">保持好奇心，不畏边界，持续学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2020/01/10/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86-SMART%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/10/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86-SMART%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">目标管理-SMART原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 20:37:53" itemprop="dateCreated datePublished" datetime="2020-01-10T20:37:53+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:18:16" itemprop="dateModified" datetime="2020-02-07T01:18:16+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">方法论</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">思维模型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一图以蔽之"><a href="#一图以蔽之" class="headerlink" title="一图以蔽之"></a>一图以蔽之</h2><p><img src="https://upload-images.jianshu.io/upload_images/9696036-99645f5d4e58ed36.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul>
<li>提出者：彼得·德鲁克</li>
<li>出处：《管理的实践》</li>
<li>时间：1954年</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>促使工作更明确、更高效</li>
<li>提供了考核目标和考核标准</li>
<li>保证了考核公正、公开与公平</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>重视人的因素。<br>目标管理是一种参与的、民主的、自我控制的管理制度，也是一种把个人需求与组织目标结合起来的管理制度。在这一制度下，上级与下级的关系是平等、尊重、依赖、支持，下级在承诺目标和被授权之后是自觉、自主和自治的。</p>
</li>
<li><p>建立目标锁链与目标体系。<br>目标管理通过专门设计的过程，将组织的整体目标逐级分解，转换为各单位、各员工的分目标。从组织目标到经营单位目标，再到部门目标，最后到个人目标。在目标分解过程中，权、责、利三者已经明确，而且相互对称。这些目标方向一致，环环相扣，相互配合，形成协调统一的目标体系。只有每个人员完成了自己的分目标，整个企业的总目标才有完成的希望。</p>
</li>
<li><p>重视成果<br>目标管理以制定目标为起点，以目标完成情况的考核为终结。工作成果是评定目标完成程度的标准，也是人事考核和奖评的依据，成为评价管理工作绩效的唯一标志。至于完成目标的具体过程、途径和方法，上级并不过多干预。所以，在目标管理制度下，监督的成分很少，而控制目标实现的能力却很强。<br>“目标管理”的概念是管理专家彼得·德鲁克（Peter·Drucker）1954年在其名著《管理实践》中最先提出的，其后他又提出“目标管理和自我控制”的主张。德鲁克认为，并不是有了工作才有目标，而是相反，有了目标才能确定每个人的工作。所以“企业的使命和任务，必须转化为目标”，如果一个领域没有目标，这个领域的工作必然被忽视。因此管理者应该通过目标对下级进行管理，当组织最高层管理者确定了组织目标后，必须对其进行有效分解，转变成各个部门以及各个人的分目标，管理者根据分目标的完成情况对下级进行考核、评价和奖惩。</p>
</li>
</ul>
<h2 id="原则详解"><a href="#原则详解" class="headerlink" title="原则详解"></a>原则详解</h2><h3 id="1-Specific—明确性"><a href="#1-Specific—明确性" class="headerlink" title="1. Specific—明确性"></a>1. Specific—明确性</h3><p>所谓明确就是要用具体的语言清楚地说明要达成的行为标准。明确的目标几乎是所有成功团队的一致特点。很多团队不成功的重要原因之一就因为目标定的模棱两可，或没有将目标有效的传达给相关成员。</p>
<p><strong>示例</strong><br>目标——“增强客户意识”。这种对目标的描述就很不明确，因为增强客户意识有许多具体做法，如：减少客户投诉，过去客户投诉率是３％，现在把它减低到１．５％或者１％。提升服务的速度，使用规范礼貌的用语，采用规范的服务流程，也是增强客户意识的一个方面。</p>
<p>有这么多增强客户意识的做法，我们所说的“增强客户意识”到底指哪一块？不明确就没有办法评判、衡量。所以建议这样修改，比方说，我们将在月底前把前台收银的速度提升至正常的标准，这个正常的标准可能是两分钟，也可能是一分钟，或分时段来确定标准。</p>
<p><strong>实施要求</strong><br>目标设置要有项目、衡量标准、达成措施、完成期限以及资源要求，使考核人能够很清晰的看到部门或科室月计划要做哪些那些事情，计划完成到什么样的程度。
　　</p>
<h3 id="2-Measurable—衡量性"><a href="#2-Measurable—衡量性" class="headerlink" title="2. Measurable—衡量性"></a>2. Measurable—衡量性</h3><p>衡量性就是指目标应该是明确的，而不是模糊的。应该有一组明确的数据，作为衡量是否达成目标的依据。</p>
<p>如果制定的目标没有办法衡量，就无法判断这个目标是否实现。比如领导有一天问“这个目标离实现大概有多远？”团队成员的回答是“我们早实现了”。这就是领导和下属对团队目标所产生的一种分歧。原因就在于没有给他一个定量的可以衡量的分析数据。但并不是所有的目标可以衡量，有时也会有例外，比如说大方向性质的目标就难以衡量。</p>
<p>比方说，“为所有的老员工安排进一步的管理培训”。进一步是一个既不明确也不容易衡量的概念，到底指什么？是不是只要安排了这个培训，不管谁讲，也不管效果好坏都叫“进一步”？</p>
<p>改进一下：准确地说，在什么时间完成对所有老员工关于某个主题的培训，并且在这个课程结束后，学员的评分在８５分以上，低于８５分就认为效果不理想，高于８５分就是所期待的结果。这样目标变得可以</p>
<p><strong>实施要求</strong><br>目标的衡量标准遵循“能量化的量化，不能量化的质化”。使制定人与考核人有一个统一的、标准的、清晰的可度量的标尺，杜绝在目标设置中使用形容词等概念模糊、无法衡量的描述。对于目标的可衡量性应该首先从数量、质量、成本、时间、上级或客户的满意程度五个方面来进行，如果仍不能进行衡量，其次可考虑将目标细化，细化成分目标后再从以上五个方面衡量，如果仍不能衡量，还可以将完成目标的工作进行流程化，通过流程化使目标可衡量。</p>
<h3 id="3-Attainable—可实现性"><a href="#3-Attainable—可实现性" class="headerlink" title="3. Attainable—可实现性"></a>3. Attainable—可实现性</h3><p>目标是要可以让执行人实现、达到的，如果上司利用一些行政手段，利用权利性的影响力一厢情愿地把自己所制定的目标强压给下属，下属典型的反映是一种心理和行为上的抗拒：我可以接受，但是否完成这个目标，有没有最终的把握，这个可不好说。一旦有一天这个目标真完成不了的时候，下属有一百个理由可以推卸责任：你看我早就说了，这个目标肯定完成不了，但你坚持要压给我。</p>
<p>“控制式”的领导喜欢自己定目标，然后交给下属去完成，他们不在乎下属的意见和反映，这种做法越来越没有市场。今天员工的知识层次、学历、自己本身的素质，以及他们主张的个性张扬的程度都远远超出从前。因此，领导者应该更多的吸纳下属来参与目标制定的过程，即便是团队整体的</p>
<p>定目标成长，就先不要想达成的困难，不然热情还没点燃就先被畏惧给打消念头了。</p>
<p><strong>实施要求</strong><br>目标设置要坚持员工参与、上下左右沟通，使拟定的工作目标在组织及个人之间达成一致。既要使工作内容饱满，也要具有可达性。可以制定出跳起来“摘桃”的目标，不能制定出跳起来“摘星星”的目标。</p>
<h3 id="4-Relevant—相关性"><a href="#4-Relevant—相关性" class="headerlink" title="4. Relevant—相关性"></a>4. Relevant—相关性</h3><p>目标的相关性是指实现此目标与其他目标的关联情况。如果实现了这个目标，但对其他的目标完全不相关，或者相关度很低，那这个目标即使被达到了，意义也不是很大。</p>
<p>因为毕竟工作目标的设定，是要和岗位职责相关联的，不能跑题。比如一个前台，你让她学点英语以便接电话的时候用得上，这时候提升英语水平和前台接电话的服务质量有关联，即学英语这一目标与提高前台工作水准这一目标直接相关。若你让她去学习6sigma，就比较跑题了，因为前台学习6sigma这一目标与提高前台工作水准这一目标相关度很低。</p>
<h3 id="5-Time-bound—时限性"><a href="#5-Time-bound—时限性" class="headerlink" title="5. Time-bound—时限性"></a>5. Time-bound—时限性</h3><p>目标特性的时限性就是指目标是有时间限制的。例如，我将在2020年5月31日之前完成某事。5月31日就是一个确定的时间限制。没有时间限制的目标没有办法考核，或带来考核的不公。上下级之间对目标轻重缓急的认识程度不同，上司着急，但下面不知道。到头来上司可以暴跳如雷，而下属觉得委屈。这种没有明确的时间限定的方式也会带来考核的不公正，伤害工作关系，伤害下属的工作热情。</p>
<p><strong>实施要求</strong><br>目标设置要具有时间限制，根据工作任务的权重、事情的轻重缓急，拟定出完成目标项目的时间要求，定期检查项目的完成进度，及时掌握项目进展的变化情况，以方便对下属进行及时的工作指导，以及根据工作计划的异常情况变化及时地调整工作计划。</p>
<h2 id="相关变体"><a href="#相关变体" class="headerlink" title="相关变体"></a>相关变体</h2><p><strong>SMART（ER）</strong>所对应的单词在不同场合并不一致、有各种变体，下表就列出了一些变体：</p>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><p>Specific（明确）<br>Significant（重要）, Stretching（延伸）, Simple（简易）</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Measurable（可衡量）<br>Meaningful（有意义）, Motivational（激励）, Manageable（可管理）</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>Attainable（可达成）<br>Appropriate（适宜）, Achievable（可达成）, Agreed（同意）, Assignable（可分配）, Actionable（可行动）, Action-oriented（行动导向）, Ambitious（雄心）</p>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>Relevant（相关）<br>Realistic（实际）, Results/Results-focused/Results-oriented, Resourced（资源）, Rewarding（奖励）</p>
<h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>Time-bound（时限）<br>Time-oriented（时限）, Time framed（时限）, Timed（时限）, Time-based（基于时间）, Timeboxed（时限）, Timely（及时）, Time-Specific（明确时间）, Timetabled（时效）, Time limited（时限）, Trackable（可跟踪）, Tangible（明白）</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>Evaluate（评估）<br>Excitable（兴奋）, Ethical（伦理）</p>
<h3 id="R-1"><a href="#R-1" class="headerlink" title="R"></a>R</h3><p>Reevaluate（再评估）<br>Rewarded（奖励）, Reassess（再评估）, Revisit（再访）, Recorded（记录）</p>
<hr>
<p>参考：<a href="https://wiki.mbalib.com/wiki/SMART%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">SMART原则</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/30/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/30/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">《金字塔原理》学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-30 17:45:01" itemprop="dateCreated datePublished" datetime="2019-12-30T17:45:01+08:00">2019-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:18:03" itemprop="dateModified" datetime="2020-02-07T01:18:03+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">方法论</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">思维模型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>请问你工作过程中是否经常遇到？</p>
<ul>
<li>工作回报，Boss摇头又叹气：“请说重点！！！”</li>
<li>晋升答辩，评委们认为：“体现不出价值…”</li>
<li>分享沟通，听众表示：“一脸懵逼？？？”</li>
</ul>
<p><strong>世界上最遥远的距离，不是我没有说，而是我说了你却不明白</strong></p>
<p>坏消息：几乎大部分会同学命中上面的问题<br>好消息：《金字塔原理》这本书可以带给你一系列方法来解决上述问题</p>
<h2 id="为什么使用金字塔原理"><a href="#为什么使用金字塔原理" class="headerlink" title="为什么使用金字塔原理"></a>为什么使用金字塔原理</h2><p><strong>常见的偏见</strong></p>
<ul>
<li>我写不出“好”的文章，是因为我的文笔不够</li>
<li>我画不出“好”的架构图，是因为我没有找到好的软件，或者我不会很好地应用这个软件</li>
<li>我写不出“好”的ppt，是因为我的ppt模版不行</li>
<li>我读完这本书，全忘了，是因为这本书写的不好或者我记性不好</li>
</ul>
<p><strong>核心问题</strong></p>
<p>我们在写文章，或写PPT时，我们自己没有非常清晰的思路，没有梳理清楚自己的表达逻辑。我们表达思想时采用的逻辑顺序和读者的理解力发生了矛盾，我们的表达结构不是读者容易理解的结构。</p>
<p><strong>核心诉求</strong></p>
<ul>
<li>读者：一目了然（Don’t Make Me Think）</li>
<li>作者：想清楚（思考），说明白（表达）</li>
</ul>
<p><strong>金字塔原理能带给你的</strong></p>
<p>人类思维特征：大脑自动将信息归类分组，以便于理解和记忆。如果你所表达的内容结构，思路呈金字塔结构，由顶部开始逐渐向下展开，这样的思路不仅让自己，也让读者会更清晰，更易懂。</p>
<p>金字塔原理可以让你的输出</p>
<ul>
<li><strong>重点突出</strong>（避免啰嗦）：人通常都是没有耐心的，对未知也是有恐惧的。所以你的表达和文章一开始就得让对方知道你讲的到底是什么</li>
<li><strong>逻辑清晰</strong>（增加可读性）：能够看到明显因果关系和逻辑顺序，如时间顺序、空间顺序、程度顺序等</li>
<li><strong>主次分明</strong>（强化逻辑）：分清楚主要和次要，先主要后次要</li>
<li><strong>规范动作</strong>（减少耗时时间）：使用标准动作健身和使用非标准动作健身，花同样的时间，两者呈现的结果可能是千差万别；金字塔原理也是写作、思考、表达的规范性动作，在前期训练的过程，你会感觉很不舒适，但是一旦动作成型，那么你的写作、思考、表达的记忆性肌肉就炼成了，后期将会释放出力量。</li>
</ul>
<p><strong>图例</strong><br><img src="https://upload-images.jianshu.io/upload_images/9696036-5f23ae6141b04e5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="什么是金字塔原理"><a href="#什么是金字塔原理" class="headerlink" title="什么是金字塔原理"></a>什么是金字塔原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>金字塔原理是一种结构化思考、表达和解决问题的艺术</p>
<h3 id="金字塔原理的234"><a href="#金字塔原理的234" class="headerlink" title="金字塔原理的234"></a>金字塔原理的234</h3><h4 id="2个目标"><a href="#2个目标" class="headerlink" title="2个目标"></a>2个目标</h4><ul>
<li>想清楚：自下而上思考，总结概括</li>
<li>说明白：自上而下表达，结论先行</li>
</ul>
<h4 id="3种结构"><a href="#3种结构" class="headerlink" title="3种结构"></a>3种结构</h4><ol>
<li>序言：SCQA 抛出问题，吸引阅读</li>
<li>纵向：（问题-&gt;回答，论点-&gt;论据）文章中任意层次上的思想必须是其下一层思想的概括</li>
<li>横向：每组中的思想必须属于同一逻辑范畴且按逻辑顺序组织</li>
</ol>
<h4 id="4项原则"><a href="#4项原则" class="headerlink" title="4项原则"></a>4项原则</h4><ol>
<li>结论先行：每篇文章只有一个中心思想，并放在文章的最前面</li>
<li>以上统下：每一层次上的思想必须是对下一层次思想的总结</li>
<li>归类分组：每一组中的思想必须属于同一逻辑</li>
<li>逻辑递进：每一组中的思想必须按照逻辑顺序排列</li>
</ol>
<h2 id="怎么构建金字塔结构"><a href="#怎么构建金字塔结构" class="headerlink" title="怎么构建金字塔结构"></a>怎么构建金字塔结构</h2><p>主要在于如何熟练运用，对于一个事情，如何提炼中心点，层层剥离，分清主次，需要不断的思考与刻意练习。</p>
<h3 id="4大金句"><a href="#4大金句" class="headerlink" title="4大金句"></a>4大金句</h3><ul>
<li>自上而下表达，结论先行；</li>
<li>自下而上思考，总结概括；</li>
<li>纵向总结概括，横向归类分组；</li>
<li>序言讲故事，标题提炼思想精华；</li>
</ul>
<h3 id="自上而下法"><a href="#自上而下法" class="headerlink" title="自上而下法"></a>自上而下法</h3><p>确定主题、回答主要疑问，想好序言，提出中心思想和关键句要点，在关键句要点下展开讨论</p>
<ol>
<li>提出主题思想</li>
<li>设想主要疑问：想清楚要解决谁的什么问题</li>
<li>写序言：背景-冲突-疑问-回答。背景是问题产生的前提条件，冲突是背景中发生了哪些能使读者产生疑问的“冲突”，疑问是我们要解决的问题，回答就是主题思想。</li>
<li>进行疑问、回答式对话。从上一层思想到下一层思想。</li>
<li>对受众的新疑问，重复进行疑问/回答式对话。思想慢慢开展，层级慢慢丰富。</li>
</ol>
<h3 id="自下而上法"><a href="#自下而上法" class="headerlink" title="自下而上法"></a>自下而上法</h3><p>如果没有确定的主题思想，可以从关键句层次下手，自下而上的组织思想</p>
<ol>
<li>列出想表达的所有思想要点</li>
<li>找出各要点之间的逻辑关系</li>
<li>概括各组思想，得出结论</li>
<li>倒推出序言</li>
</ol>
<h3 id="序言结构"><a href="#序言结构" class="headerlink" title="序言结构"></a>序言结构</h3><p><strong>概念</strong>：交代故事发生的背景、环境，提出问题；根据已知信息，与后续将要回答问题间建立起某种关联</p>
<p><strong>作用</strong>：引起受众的兴趣</p>
<p><strong>关键</strong>：准确的界定问题</p>
<p><strong>SCQA序言设计方法</strong><br>S（情景）：介绍背景<br>C（冲突）：指出冲突<br>Q（疑问）：引发疑问<br>A（回答）：给出答案</p>
<h3 id="纵向结构"><a href="#纵向结构" class="headerlink" title="纵向结构"></a>纵向结构</h3><p>“问题-&gt;回答” 结构</p>
<ul>
<li>三类问题：What（是什么）、Why（为什么）、How（如何做）</li>
<li>设身处地站在受众角度设定问题</li>
<li>受众最关心的问题要放到关键位置</li>
</ul>
<h3 id="横向结构"><a href="#横向结构" class="headerlink" title="横向结构"></a>横向结构</h3><p>两个结构方法</p>
<ul>
<li>归纳结构<ul>
<li>时间顺序。在按照时间顺序组织的思想组中，按照采取行动的顺序（第一步、第二步、第三步 或 事前、事中、事后）依次表述达到某一结果必须采取的行动。</li>
<li>结构顺序。组织结构、空间结构等顺序中，分组后的各部分需要符合 MECE原则：不重不漏 </li>
<li>程度顺序。首要、次要等重要性顺序</li>
</ul>
</li>
<li>演绎结构<ul>
<li>标准式：大前提 -&gt; 小前提 -&gt; 结论</li>
<li>常见式：现象 -&gt; 原因 -&gt; 解决方案</li>
</ul>
</li>
</ul>
<h2 id="一图以蔽之"><a href="#一图以蔽之" class="headerlink" title="一图以蔽之"></a>一图以蔽之</h2><p><img src="https://upload-images.jianshu.io/upload_images/9696036-8362667c25ef0c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/28/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%A4%8D%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/28/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%A4%8D%E7%9B%98/" class="post-title-link" itemprop="url">如何做好复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-28 11:30:35" itemprop="dateCreated datePublished" datetime="2019-12-28T11:30:35+08:00">2019-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:17:37" itemprop="dateModified" datetime="2020-02-07T01:17:37+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">方法论</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%9F%BA%E6%9C%AC%E5%8A%9F/" itemprop="url" rel="index"><span itemprop="name">基本功</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是复盘"><a href="#什么是复盘" class="headerlink" title="什么是复盘"></a>什么是复盘</h2><h3 id="传统释义"><a href="#传统释义" class="headerlink" title="传统释义"></a>传统释义</h3><p>围棋术语，指下完一盘棋后，双方棋手把对弈过程重新摆一遍，看哪里下得好，哪里下得不好，哪些关键节点有不同甚至更好的下法，以检查对局中招法的优劣与得失，并从中寻找提高自己水平的方法。</p>
<h3 id="管理释义"><a href="#管理释义" class="headerlink" title="管理释义"></a>管理释义</h3><p>一句话概括：“做过的事情，再从头过一遍”<br>对于我们经历过的事情，“从头”指的是‘从目的“开始审视和思考，从中发现问题、分析原因、总结经验</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>考查“目标”和“结果”的Gap，根据差异，回顾、反思、探究、提升</p>
<h2 id="为什么要复盘"><a href="#为什么要复盘" class="headerlink" title="为什么要复盘"></a>为什么要复盘</h2><h3 id="对事"><a href="#对事" class="headerlink" title="对事"></a>对事</h3><p>战略上及时校准方向、调适路线<br>战术上攻克具体难题、及时总结方法、不断提升经营水平</p>
<h3 id="对人"><a href="#对人" class="headerlink" title="对人"></a>对人</h3><p>规避重复问题：分析问题，探索可能的解决方案以避免同样的错误再次发生<br>提升能力：积累经验，总结规律，并抽象成方法论</p>
<h3 id="核心价值"><a href="#核心价值" class="headerlink" title="核心价值"></a>核心价值</h3><p>巩固成功与改正错误</p>
<h2 id="什么时候复盘"><a href="#什么时候复盘" class="headerlink" title="什么时候复盘"></a>什么时候复盘</h2><h3 id="及时复盘"><a href="#及时复盘" class="headerlink" title="及时复盘"></a>及时复盘</h3><p>高风险和高阻塞等任务行动结束后，花很短的时间再过一次整个过程，及时制定改进方案并落实。</p>
<h3 id="阶段性复盘"><a href="#阶段性复盘" class="headerlink" title="阶段性复盘"></a>阶段性复盘</h3><p>大项目的执行过程中，阶段性复盘，思考原定的目标是什么，目前达成的结果是什么，阶段性地对目标或策略进行调整。</p>
<h3 id="全面复盘"><a href="#全面复盘" class="headerlink" title="全面复盘"></a>全面复盘</h3><p>在项目或战略结束后，全面总结目的、目标以及达成的结果，过程中哪些地方做得不好，哪些地方做得好，以及收获的经验教训和规律。</p>
<h2 id="如何复盘"><a href="#如何复盘" class="headerlink" title="如何复盘"></a>如何复盘</h2><h3 id="四步复盘法"><a href="#四步复盘法" class="headerlink" title="四步复盘法"></a>四步复盘法</h3><h4 id="1-回顾目标"><a href="#1-回顾目标" class="headerlink" title="1. 回顾目标"></a>1. 回顾目标</h4><p>回顾当初的目的或期望的结果是什么</p>
<p>抓手</p>
<ul>
<li>需求是如何从提出到立项的？</li>
<li>想要实现的目标和收益是什么？</li>
<li>最初的计划是怎样的？</li>
<li>预期的风险和应对措施是怎样的？</li>
</ul>
<p>注意点</p>
<ul>
<li>分清目的与目标的不同，正确的目的保证目标的方向；清晰而适配的目标能更好地分解和保障目的实现。</li>
<li>确定目的之外，最好能确定出可量化的目标或具有里程碑性质的标志。无量化或可考核的目标，很难保证目的实现，也难与结果对照评估。</li>
<li>事前所提目的、目标不清晰，复盘时追补清晰，便于本次对照，提高下次定目标的准确度。可参考SMART原则制定目标</li>
</ul>
<h4 id="2-评估结果"><a href="#2-评估结果" class="headerlink" title="2. 评估结果"></a>2. 评估结果</h4><p>对照原来设定的目标找出过程中的亮点和不足</p>
<p>抓手</p>
<ul>
<li>最初的目标和收益有没有实现？</li>
<li>最初制定的计划执行情况如何？（如进度计划、成本计划、资源计划等）       </li>
<li>预期风险是否发生？应对措施是否有效？</li>
<li>发生了哪些意料之外的事情？有何影响？</li>
</ul>
<p>注意点</p>
<ul>
<li>首先要与原定的目标相比较，客观分析意料外的重要亮点或不足。</li>
<li>亮点与不足同样重要，不能弱化亮点</li>
<li>多引入外部典型事实样本，让我们的结果评估视野更广阔、结论更客观。</li>
</ul>
<h4 id="3-分析原因"><a href="#3-分析原因" class="headerlink" title="3. 分析原因"></a>3. 分析原因</h4><p>寻找成功的关键原因和失败的根本原因</p>
<p>抓手</p>
<ul>
<li>叙述过程：实事求是的过程叙述，让复盘参与者知悉背景、对齐信息</li>
<li>自我剖析：自己对做过的事情进行反思和分析，看看有哪些问题，有哪些成绩，并试着去找出原因，发现规律。</li>
<li>众人设问：突破事件本身的局限，突破个人见识的局限。设问要多探索可能性，考察每一种可能性的条件，以及其边界。</li>
</ul>
<p>注意点</p>
<ul>
<li>成功时，主要看客观原因，多列举客观因素，精选自身真正的优势。</li>
<li>失败时，主要看主观原因。多从自身深挖原因，狠挑不足以补足短板</li>
</ul>
<h4 id="4-总结经验"><a href="#4-总结经验" class="headerlink" title="4. 总结经验"></a>4. 总结经验</h4><p>总结体会、体验、反思、规律，以及接下来的行动计划</p>
<p>抓手</p>
<ul>
<li>我们从过程中学到了什么新</li>
<li>如果有人要进行类似的项目，我会给到什么建议?</li>
<li>接下来我们该做些什么?需要实施哪些新举措？继续哪些动作？叫停哪些动作？</li>
</ul>
<p>注意点</p>
<ul>
<li><p>总结规律</p>
<ul>
<li><p>复盘结论的落脚点是否在偶发性的因素上？<br>当复盘的结论落脚在偶发性因素上，那一定是错误的。如果复盘没有进入到逻辑层面，没有经受住逻辑的验证，则这样的复盘结论，一定是不可信的。</p>
</li>
<li><p>复盘结论是指向人还是指向事？<br>复盘的结论如果是指向人，则很可能说明复盘没有真正到位。因为复盘得出的是规律性的认识，而人是具体的，各不相同。指向事，则复盘到规律的可能性更高。复盘的结论不是指向人，而是从事物的本质去理解分析，这是验证复盘结论是否可靠的标准之一。</p>
</li>
<li><p>复盘结论的得出，是否有过3次以上连续的 why 或者 why not 的追问？<br>如果次数不够，也很可能意味着复盘没有找到真正的原因。探寻问题背后的问题，找出答案之后的答案，这就是追问的目的。</p>
</li>
<li><p>是否是经过交叉验证得出的结论？<br>“孤证不能定案”是法律上的术语，用来比喻复盘得出的结论通过其他事情交叉验证，也可以为结论的有效性提供一定的保障。</p>
</li>
</ul>
</li>
<li><p>案例佐证<br>除了从因果关系上去验证规律外，为了验证规律的可信度，还应该用其他案例进行佐证。这是从规律的适用性出发的一次实验。案例佐证面临着案例选择的问题，所选的案例应该是同类型的、同行业的，不能选取跟所复盘的事件无关的案例。</p>
</li>
<li><p>归档复盘<br>复盘进行归档，这其实也是知识管理的一种。归档将复盘得到的认识知识化或者形成方法论，更加方便传播和查阅，这让没有参与复盘的人也能掌握复盘得出的规律和观念，让新人可以在自己的工作中进行学习和参考，少走弯路。</p>
</li>
</ul>
<h2 id="复盘模版"><a href="#复盘模版" class="headerlink" title="复盘模版"></a>复盘模版</h2><p><img src="https://upload-images.jianshu.io/upload_images/9696036-b088afab48869a76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="项目复盘示例"><a href="#项目复盘示例" class="headerlink" title="项目复盘示例"></a>项目复盘示例</h2><h3 id="项目目标复盘"><a href="#项目目标复盘" class="headerlink" title="项目目标复盘"></a>项目目标复盘</h3><h4 id="项目进度复盘"><a href="#项目进度复盘" class="headerlink" title="项目进度复盘"></a>项目进度复盘</h4><ul>
<li>是否按照原计划交付时间交付？</li>
<li>原计划的需求点实现了多少？哪些需求点没有按计划实现？每一个需求点延后原因分别是什么？</li>
<li>哪些里程碑有延迟，延迟原因是什么？</li>
</ul>
<h4 id="项目结果复盘"><a href="#项目结果复盘" class="headerlink" title="项目结果复盘"></a>项目结果复盘</h4><ul>
<li>项目中出现了哪些意外？为什么会出现这些意外？</li>
<li>用户对新增功能点的接受程度和项目规划中的是否一致？</li>
</ul>
<h3 id="需求阶段复盘"><a href="#需求阶段复盘" class="headerlink" title="需求阶段复盘"></a>需求阶段复盘</h3><h4 id="需求定义复盘："><a href="#需求定义复盘：" class="headerlink" title="需求定义复盘："></a>需求定义复盘：</h4><ul>
<li>是否提供完整的需求输出，包括：原型、MRD、PRD、UML等</li>
<li>设计师、交互师、开发人员分别对需求是否明确：如果出现需求不明确的情况，将会严重影响项目的进度和质量</li>
<li>是否对典型用户和使用场景有清晰的描述？</li>
</ul>
<h4 id="需求变更复盘"><a href="#需求变更复盘" class="headerlink" title="需求变更复盘"></a>需求变更复盘</h4><ul>
<li>需求变更次数：敏捷开发已经将需求变更的影响降到最低，但是较少的需求变更仍然是项目进展顺利的前提之一</li>
<li>哪些需求变更影响了项目实际进度</li>
<li>每次变更的原因：领导干预？前期考虑欠缺？需求无法实现？分析每一次的变更原因，可以在后期项目中进行合理的避免。</li>
<li>每个项目成员是否都清晰的知道每一次的变更：只有每位项目成员清楚的了解每次需求变更，并做好充分的沟通，才能保证项目的进度和质量。</li>
<li>项目成员是否能接收需求变更：这就要求每次需求变更，都要和相关人员做好沟通。</li>
</ul>
<h3 id="设计阶段复盘"><a href="#设计阶段复盘" class="headerlink" title="设计阶段复盘"></a>设计阶段复盘</h3><ul>
<li>是否确定视觉设计的最终审核人？</li>
<li>UI设计产出是否符合统一标准？</li>
<li>设计工作是否影响开发工作的进度？影响原因是什么？</li>
<li>产品设计工作在什么时候，由谁来完成的？</li>
</ul>
<h3 id="开发阶段复盘"><a href="#开发阶段复盘" class="headerlink" title="开发阶段复盘"></a>开发阶段复盘</h3><h4 id="工期评估复盘"><a href="#工期评估复盘" class="headerlink" title="工期评估复盘"></a>工期评估复盘</h4><ul>
<li>开发实施前，是否有充分的时间做工期预估：工期评估一方面是让项目成员能够对项目的整体进度有所准备，也是对项目需求进行详细梳理的过程。</li>
<li>工期预估与实际开发时间是否有差异，及差异原因分析</li>
</ul>
<h4 id="开发文档复盘"><a href="#开发文档复盘" class="headerlink" title="开发文档复盘"></a>开发文档复盘</h4><ul>
<li>是否有提供开发文档？</li>
<li>开发文档是否符合规范</li>
</ul>
<h4 id="突发状况复盘"><a href="#突发状况复盘" class="headerlink" title="突发状况复盘"></a>突发状况复盘</h4><ul>
<li>是否出现需求无法实现的状况？原因是什么？</li>
<li>是否出现团队成员变动情况？如何应对成员变动？后期如何避免？</li>
<li>是否出现功能模块与需求不符的情况？出现原因是什么？</li>
</ul>
<h4 id="Code-Review复盘"><a href="#Code-Review复盘" class="headerlink" title="Code Review复盘"></a>Code Review复盘</h4><ul>
<li>是如何进行的：包括如何分工，如何复查等。</li>
<li>Code Review结果是什么？</li>
<li>是否严格执行了代码规范？对不规范的代码如何处理？</li>
</ul>
<h3 id="测试阶段复盘"><a href="#测试阶段复盘" class="headerlink" title="测试阶段复盘"></a>测试阶段复盘</h3><h4 id="测试计划复盘"><a href="#测试计划复盘" class="headerlink" title="测试计划复盘"></a>测试计划复盘</h4><ul>
<li>是否有完整、准确的测试用例？</li>
<li>是否有一个测试计划？这样的计划是否有效？</li>
<li>团队是如何测试并跟踪产品开发效果的？</li>
</ul>
<h4 id="测试工具复盘"><a href="#测试工具复盘" class="headerlink" title="测试工具复盘"></a>测试工具复盘</h4><ul>
<li>使用了哪些测试工具来帮助测试？是否可以持续使用？</li>
<li>测试的时间、人力和软件/硬件资源是否足够?</li>
</ul>
<h4 id="测试结果复盘"><a href="#测试结果复盘" class="headerlink" title="测试结果复盘"></a>测试结果复盘</h4><ul>
<li>哪个功能模块产生的Bug最多，为什么？</li>
<li>哪些BUG出现回滚，原因是什么？</li>
</ul>
<h3 id="上线阶段复盘"><a href="#上线阶段复盘" class="headerlink" title="上线阶段复盘"></a>上线阶段复盘</h3><h4 id="验收复盘"><a href="#验收复盘" class="headerlink" title="验收复盘"></a>验收复盘</h4><ul>
<li>是否进行了正式的上线验收？</li>
<li>在正式发布的过程中是否有出现状况？后续如何避免？</li>
<li>上线前是否和运营、文案进行充分的沟通？</li>
<li>是否检查了数据埋点，数据埋点是否满足运营要求？</li>
</ul>
<h4 id="上线后效果复盘"><a href="#上线后效果复盘" class="headerlink" title="上线后效果复盘"></a>上线后效果复盘</h4><ul>
<li>在上线之后是否出现重大bug? 为什么测试阶段没有发现？</li>
<li>产品上线后的问题反馈渠道是否顺畅？</li>
<li>产品上线后收集到哪些问题反馈？都是什么类型？如何改进？</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/23/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/23/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Git常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-23 14:22:56" itemprop="dateCreated datePublished" datetime="2019-12-23T14:22:56+08:00">2019-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 00:57:08" itemprop="dateModified" datetime="2020-02-07T00:57:08+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/" itemprop="url" rel="index"><span itemprop="name">开发效率</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://upload-images.jianshu.io/upload_images/9696036-f719bd62f295b4fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="经典Git操作与对应区域图"></p>
<h2 id="Git库创建"><a href="#Git库创建" class="headerlink" title="Git库创建"></a>Git库创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 远程仓库克隆到本地</span><br><span class="line">git clone [ssh]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 本地构建仓库</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>以MAC系统，Git配置文件一般有两个配置文件，其作用域分别为全局级、仓库级</p>
<ol>
<li>全局级配置： ~/.gitconfig</li>
<li>仓库级配置： ${ProjectFile}/.git/.gitconfig</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看当前配置信息</span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置git用户信息</span><br><span class="line">git config [--local | --global] user.name &quot;[name]&quot;</span><br><span class="line">git config [--local | --global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>


<h2 id="Git分支相关"><a href="#Git分支相关" class="headerlink" title="Git分支相关"></a>Git分支相关</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 列出所有本地分支</span><br><span class="line">git branch </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有本地分支和远程分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出本地分支及其对应的远端分支，并附最新commit信息 （-v ）</span><br><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>

<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，指向指定commit</span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果本地有branch-name分支，则切换到该分支，如果没有切远程有branch-name分支，则直接以远程分支为基准创建branch-name本地分支</span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行本地分支 branch 追踪远端 remote-branch</span><br><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>

<h3 id="同步-amp-合并"><a href="#同步-amp-合并" class="headerlink" title="同步&amp;合并"></a>同步&amp;合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步远端变到本地</span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步远端变更，并与本地分支合并，可能有conflict</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并N个提交记录为一个</span><br><span class="line">git rebase -i HEAD~N</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 场景：个人分支 rebase 其它分支 ，（分支commit记录更清爽，相比merge操作少一个Merge commit）</span><br><span class="line">git rebase [branch]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并指定分支到当前分支</span><br><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>

<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 上传当前分支到跟踪的远端分支</span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传本地指定分支到远程仓库</span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">git push [remote] --force</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除本地分支</span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除远端分支</span><br><span class="line">git push origin --delete [branch-name]</span><br></pre></td></tr></table></figure>


<h2 id="Git提交相关"><a href="#Git提交相关" class="headerlink" title="Git提交相关"></a>Git提交相关</h2><h3 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示当前分支的提交历史</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示当前分支的最近几次提交</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>


<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 提交暂存区到本地仓库区</span><br><span class="line">git commit </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交快捷方式 带message</span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交到上一次commit，可变更message</span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将某个commit，合并到当前分支</span><br><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个提交，并对指定commit后的所有变更进行回滚</span><br><span class="line">git revert [commit]</span><br></pre></td></tr></table></figure>

<h2 id="Git文件相关"><a href="#Git文件相关" class="headerlink" title="Git文件相关"></a>Git文件相关</h2><h3 id="查看-2"><a href="#查看-2" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示变更的文件</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示暂存区和工作区的差异</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加指定文件到工作区</span><br><span class="line">git add [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加所有文件到工作区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除工作区指定文件</span><br><span class="line">git rm [file]</span><br></pre></td></tr></table></figure>

<h3 id="撤销-1"><a href="#撤销-1" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 恢复暂存区的所有文件到工作区</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将所有工作区文件 存储到stash区</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将stash 存储区最上面的一个，恢复到工作区</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有的标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个tag</span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定commit傻姑娘新建一个tag</span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除本地tag</span><br><span class="line">git tag -d [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除远程tag</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 推送指定tag</span><br><span class="line">git push [remote] [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以指定某个分支的tag处新建一个分支</span><br><span class="line">git checkout -b [branch][tag]</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-70673e2d55e85b18.gif?imageMogr2/auto-orient/strip" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/22/EventBus%203.1%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/22/EventBus%203.1%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">EventBus 3.1 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-22 11:50:11" itemprop="dateCreated datePublished" datetime="2019-12-22T11:50:11+08:00">2019-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:12:27" itemprop="dateModified" datetime="2020-02-07T01:12:27+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>基于V3.1.1<br><a href="http://greenrobot.org/eventbus/documentation/" target="_blank" rel="noopener">EventBus 官方地址</a><br><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus GitHub地址</a></p>
</blockquote>
<h3 id="EventBus-是什么"><a href="#EventBus-是什么" class="headerlink" title="EventBus 是什么"></a>EventBus 是什么</h3><p>概念：EventBus是一个Android事件发布/订阅框架<br>同类：Otto、RxBus<br>出品方：greenrobot</p>
<h3 id="EventBus-优缺点"><a href="#EventBus-优缺点" class="headerlink" title="EventBus 优缺点"></a>EventBus 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>通过消息总线形式，解耦发布者和订阅者，简化Android事件传递，从而代替Android传统的Intent、Handler、Broadcast方式或接口回调</li>
<li>支持注解配置消息<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4></li>
<li>消息事件满天飞，维护难</li>
<li>无延迟发送</li>
<li>不支持跨进程/App</li>
<li>Android生命周期无感知</li>
</ul>
<h3 id="EventBus-工作原理"><a href="#EventBus-工作原理" class="headerlink" title="EventBus 工作原理"></a>EventBus 工作原理</h3><h4 id="消息发布和订阅模型"><a href="#消息发布和订阅模型" class="headerlink" title="消息发布和订阅模型"></a>消息发布和订阅模型</h4><p>生产者：发布者发布消息<br>消费者：订阅者注册消息<br>调度中心： 执行消息的分发到位</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-dbdce0f49425368a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来源EventBus"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-c2e6b8e2a67958ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><p>主要就是两个切换，主线程切子线程，子线程切主线程<br>一个进程内通过Looper.getMainLooper可以顺利切换到主线程<br>子线程通过是通过主线程执行某个线程，自动切换，也可以借助ThreadLocal缓存对象来切换</p>
<p>参考：<a href="https://www.jianshu.com/p/75258d19a964" target="_blank" rel="noopener">Android线程消息机制</a></p>
<h3 id="EventBus-类图"><a href="#EventBus-类图" class="headerlink" title="EventBus 类图"></a>EventBus 类图</h3><ul>
<li>EventBus：核心类，代表了一个事件总线。实现发布-订阅模式。</li>
<li>SubscriberMethodFinder：寻找订阅者的订阅方法</li>
<li>FindState：寻找订阅方法过程中的缓存Buffer，目的内存复用</li>
<li>SubscriberMethod：订阅者的方法封装类</li>
<li>Subscription：订阅者对象的封装</li>
<li>ThreadMode：线程模型，用来标识不同线程执行消息</li>
<li>PostingThreadState：消息发布状态封装</li>
<li>Poster：不同线程消息发布器</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-4c00b6179c92cb4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="EventBus-订阅-发布时序图"><a href="#EventBus-订阅-发布时序图" class="headerlink" title="EventBus 订阅-发布时序图"></a>EventBus 订阅-发布时序图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-5905ca1a69e99644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="EventBus-订阅-发布流程图"><a href="#EventBus-订阅-发布流程图" class="headerlink" title="EventBus 订阅-发布流程图"></a>EventBus 订阅-发布流程图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-8648e4c75064762b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="订阅流程源码分析"><a href="#订阅流程源码分析" class="headerlink" title="订阅流程源码分析"></a>订阅流程源码分析</h3><p>EventBus.getDefault<br>获取EventBus单例，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 提供默认单例 EventBus</span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">   EventBus instance &#x3D; defaultInstance;</span><br><span class="line">   if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">       synchronized (EventBus.class) &#123;</span><br><span class="line">           instance &#x3D; EventBus.defaultInstance;</span><br><span class="line">           if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">               instance &#x3D; EventBus.defaultInstance &#x3D; new EventBus();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">   logger &#x3D; builder.getLogger();</span><br><span class="line">   &#x2F;&#x2F; &lt;订阅事件类型，订阅对象集合&gt;</span><br><span class="line">   subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; &lt;订阅者，订阅事件类型集合&gt;</span><br><span class="line">   typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; 粘性事件 map</span><br><span class="line">   stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; 主线程支持类</span><br><span class="line">   mainThreadSupport &#x3D; builder.getMainThreadSupport();</span><br><span class="line">   &#x2F;&#x2F; 主线程分发者</span><br><span class="line">   mainThreadPoster &#x3D; mainThreadSupport !&#x3D; null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">   &#x2F;&#x2F; 后天线程分发者</span><br><span class="line">   backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">   &#x2F;&#x2F; 异步现场分发者</span><br><span class="line">   asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">   indexCount &#x3D; builder.subscriberInfoIndexes !&#x3D; null ? builder.subscriberInfoIndexes.size() : 0;</span><br><span class="line">   &#x2F;&#x2F; 订阅方法寻找器</span><br><span class="line">   subscriberMethodFinder &#x3D; new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">           builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">   logSubscriberExceptions &#x3D; builder.logSubscriberExceptions;</span><br><span class="line">   logNoSubscriberMessages &#x3D; builder.logNoSubscriberMessages;</span><br><span class="line">   sendSubscriberExceptionEvent &#x3D; builder.sendSubscriberExceptionEvent;</span><br><span class="line">   sendNoSubscriberEvent &#x3D; builder.sendNoSubscriberEvent;</span><br><span class="line">   throwSubscriberException &#x3D; builder.throwSubscriberException;</span><br><span class="line">   &#x2F;&#x2F; 是否执行分发父类事件类型</span><br><span class="line">   eventInheritance &#x3D; builder.eventInheritance;</span><br><span class="line">   &#x2F;&#x2F; 线程执行器 </span><br><span class="line">   executorService &#x3D; builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.register</p>
<ol>
<li>获取订阅者Class</li>
<li>通过反射，获取Class的所有订阅方法集合</li>
<li>遍历订阅方法集合，存储两个Map，Map&lt;订阅事件类型，订阅对象集合&gt;， Map&lt;订阅者，订阅事件集合&gt;</li>
<li>如果订阅的是Stick事件类型，则直接寻找对应事件，然后分发到订阅方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 订阅对象的 Class</span><br><span class="line">   Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();</span><br><span class="line">   &#x2F;&#x2F;  通过注解反射拿到 订阅Class的订阅方法</span><br><span class="line">   List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注册 订阅</span><br><span class="line">           subscribe(subscriber, subscriberMethod);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubscriberMethodFinder.findSubscriberMethods</p>
<ol>
<li>先从内存缓存 Map&lt;订阅对象Class,订阅对象Class的订阅方法&gt; 找</li>
<li>然后通过反射方法获取订阅者Class的所有订阅方法</li>
<li>Map 存储</li>
<li>返回订阅者的订阅方法集合</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; 内存缓存 Map&lt;订阅对象Class,订阅对象Class的订阅方法&gt;</span><br><span class="line">   List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; METHOD_CACHE.get(subscriberClass);</span><br><span class="line">   if (subscriberMethods !&#x3D; null) &#123;</span><br><span class="line">       return subscriberMethods;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   if (ignoreGeneratedIndex) &#123;  &#x2F;&#x2F; 默认false</span><br><span class="line">       subscriberMethods &#x3D; findUsingReflection(subscriberClass);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 反射查找所有订阅方法</span><br><span class="line">       subscriberMethods &#x3D; findUsingInfo(subscriberClass);</span><br><span class="line">   &#125;</span><br><span class="line">   if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">       throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">               + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; map存储</span><br><span class="line">       METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">       return subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubscriberMethodFinder.findUsingInfo</p>
<ol>
<li>通过FIND_STATE_POOL构建FindState，用做找寻订阅方法时的缓存对象</li>
<li>执行反射寻找订阅者的订阅方法，存储到FindState中</li>
<li>循环遍历找订阅者的父类的订阅方法</li>
<li>返回订阅者的订阅方法集合，并释放FindState</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; FindState 在寻找订阅方法过程中 用于存储相关信息，为了内存复用，通过FIND_STATE_POOL维护了4个FindState来循环使用</span><br><span class="line">   FindState findState &#x3D; prepareFindState();</span><br><span class="line">   findState.initForSubscriber(subscriberClass);</span><br><span class="line">   while (findState.clazz !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取SubscriberInfo 包含订阅者Class、Methods等</span><br><span class="line">       findState.subscriberInfo &#x3D; getSubscriberInfo(findState);</span><br><span class="line">       </span><br><span class="line">       if (findState.subscriberInfo !&#x3D; null) &#123;</span><br><span class="line">            ... &#x2F;&#x2F; 如果有 ，直接遍历 设置methods数据</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行 反射获取订阅methods</span><br><span class="line">           findUsingReflectionInSingleClass(findState);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 父类Class，然后继续遍历找所有订阅方法</span><br><span class="line">       findState.moveToSuperclass();</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 返回订阅者的订阅方法集合，并释放FindState</span><br><span class="line">   return getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">   List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">   findState.recycle();</span><br><span class="line">   synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">       for (int i &#x3D; 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">           if (FIND_STATE_POOL[i] &#x3D;&#x3D; null) &#123;</span><br><span class="line">               FIND_STATE_POOL[i] &#x3D; findState;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubscriberMethodFinder.findUsingReflectionInSingleClass<br>遍历类中所有方法，寻找目标订阅方法，封装成SubscriberMethod存储到findState的subscriberMethods集合中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">   Method[] methods;</span><br><span class="line">   try &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取所有声明的方法</span><br><span class="line">       methods &#x3D; findState.clazz.getDeclaredMethods();</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 遍历方法</span><br><span class="line">   for (Method method : methods) &#123;</span><br><span class="line">       int modifiers &#x3D; method.getModifiers();</span><br><span class="line">       &#x2F;&#x2F; 找 public 方法</span><br><span class="line">       if ((modifiers &amp; Modifier.PUBLIC) !&#x3D; 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找参数为1的方法</span><br><span class="line">           Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">           if (parameterTypes.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找 含有 Subscribe注解的方法</span><br><span class="line">               Subscribe subscribeAnnotation &#x3D; method.getAnnotation(Subscribe.class);</span><br><span class="line">               if (subscribeAnnotation !&#x3D; null) &#123;</span><br><span class="line">                   Class&lt;?&gt; eventType &#x3D; parameterTypes[0];</span><br><span class="line">                   if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 添加 ThreadMode</span><br><span class="line">                       ThreadMode threadMode &#x3D; subscribeAnnotation.threadMode();</span><br><span class="line">                       &#x2F;&#x2F; findState 添加订阅的方法</span><br><span class="line">                       findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                               subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.subscribe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">    &#x2F;&#x2F; 事件类型 （订阅的事件）</span><br><span class="line">   Class&lt;?&gt; eventType &#x3D; subscriberMethod.eventType;</span><br><span class="line">   &#x2F;&#x2F; 构造 Subscription （封装订阅对象及对应方法）</span><br><span class="line">   Subscription newSubscription &#x3D; new Subscription(subscriber, subscriberMethod);</span><br><span class="line">   &#x2F;&#x2F; 针对eventType取对应的 CopyOnWriteArrayList【主要用来实现事件优先级接受】</span><br><span class="line">   CopyOnWriteArrayList&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);</span><br><span class="line">   if (subscriptions &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 没有，则创建 订阅集合</span><br><span class="line">       subscriptions &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">       &#x2F;&#x2F; 存储 &lt;订阅事件类型，订阅对象集合&gt;</span><br><span class="line">       subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   int size &#x3D; subscriptions.size();</span><br><span class="line">   &#x2F;&#x2F; 根据优先级添加 订阅对象</span><br><span class="line">   for (int i &#x3D; 0; i &lt;&#x3D; size; i++) &#123;</span><br><span class="line">       if (i &#x3D;&#x3D; size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">           subscriptions.add(i, newSubscription);</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 缓存 Map&lt;订阅者，订阅事件集合&gt;</span><br><span class="line"></span><br><span class="line">   List&lt;Class&lt;?&gt;&gt; subscribedEvents &#x3D; typesBySubscriber.get(subscriber);</span><br><span class="line">   if (subscribedEvents &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存储</span><br><span class="line">       subscribedEvents &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">       typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">   &#125;</span><br><span class="line">   subscribedEvents.add(eventType); &#x2F;&#x2F; 添加订阅事件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果订阅方法是 支持sticky事件,则直接执行分发sticky事件</span><br><span class="line">   if (subscriberMethod.sticky) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示是否分发订阅了响应事件类父类事件的方法</span><br><span class="line">       if (eventInheritance) &#123;</span><br><span class="line">           Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries &#x3D; stickyEvents.entrySet();</span><br><span class="line">           for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">               Class&lt;?&gt; candidateEventType &#x3D; entry.getKey();</span><br><span class="line">               if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                   Object stickyEvent &#x3D; entry.getValue();</span><br><span class="line">                   checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据事件类型，获取事件</span><br><span class="line">           Object stickyEvent &#x3D; stickyEvents.get(eventType);</span><br><span class="line">           &#x2F;&#x2F; 分发到订阅方法</span><br><span class="line">           checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发布流程源码分析"><a href="#发布流程源码分析" class="headerlink" title="发布流程源码分析"></a>发布流程源码分析</h4><p>EventBus.post</p>
<p>参考：<a href="https://www.jianshu.com/p/8a7fe7d592f8" target="_blank" rel="noopener">深入理解ThreadLocal</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过ThreadLocal&lt;PostingThreadState&gt; 获取当前现场的 PostingThreadState </span><br><span class="line">   PostingThreadState postingState &#x3D; currentPostingThreadState.get();</span><br><span class="line">   &#x2F;&#x2F; 通过List 存储 事件</span><br><span class="line">   List&lt;Object&gt; eventQueue &#x3D; postingState.eventQueue;</span><br><span class="line">   eventQueue.add(event);</span><br><span class="line">    &#x2F;&#x2F; 是否正在分发中，没有则开始分发</span><br><span class="line">   if (!postingState.isPosting) &#123;</span><br><span class="line">       postingState.isMainThread &#x3D; isMainThread(); &#x2F;&#x2F; 是否主线程</span><br><span class="line">       postingState.isPosting &#x3D; true; &#x2F;&#x2F; 标记为true</span><br><span class="line">       if (postingState.canceled) &#123;</span><br><span class="line">           throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环取事件，进行分发</span><br><span class="line">           while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 分发单个事件</span><br><span class="line">               postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 结束重置状态</span><br><span class="line">           postingState.isPosting &#x3D; false;</span><br><span class="line">           postingState.isMainThread &#x3D; false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.postSingleEvent<br>根据eventInheritance确认是否需要分发父类Class，最终执行postSingleEventForEventType 进行事件分发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">   Class&lt;?&gt; eventClass &#x3D; event.getClass();</span><br><span class="line">   boolean subscriptionFound &#x3D; false;</span><br><span class="line">   if (eventInheritance) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询事件对象的父类对象Class</span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; eventTypes &#x3D; lookupAllEventTypes(eventClass);</span><br><span class="line">       int countTypes &#x3D; eventTypes.size();</span><br><span class="line">       for (int h &#x3D; 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">           Class&lt;?&gt; clazz &#x3D; eventTypes.get(h);</span><br><span class="line">           subscriptionFound |&#x3D; postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       subscriptionFound &#x3D; postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.postSingleEventForEventType</p>
<ol>
<li>获取订阅对象集合</li>
<li>遍历订阅对象，执行事件分发</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 订阅对象集合</span><br><span class="line">   CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       subscriptions &#x3D; subscriptionsByEventType.get(eventClass);</span><br><span class="line">   &#125;</span><br><span class="line">   if (subscriptions !&#x3D; null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">       &#x2F;&#x2F; 遍历订阅对象集合 一个个分发</span><br><span class="line">       for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">           postingState.event &#x3D; event;</span><br><span class="line">           postingState.subscription &#x3D; subscription;</span><br><span class="line">           boolean aborted &#x3D; false;</span><br><span class="line">           try &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行分发</span><br><span class="line">               postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">               aborted &#x3D; postingState.canceled;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               postingState.event &#x3D; null;</span><br><span class="line">               postingState.subscription &#x3D; null;</span><br><span class="line">               postingState.canceled &#x3D; false;</span><br><span class="line">           &#125;</span><br><span class="line">           if (aborted) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.postToSubscription<br>根据不同的 ThreadMode 进行处理 </p>
<ol>
<li>执行线程与目标线程匹配，则直接反射执行订阅方法</li>
<li>不匹配，则先将事件添加到PendingPostQueue，然后通过ExecutorService执行Runnable</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据不同的 ThreadMode 进行处理 </span><br><span class="line">   switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">       case POSTING:</span><br><span class="line">           invokeSubscriber(subscription, event);</span><br><span class="line">           break;</span><br><span class="line">       case MAIN:</span><br><span class="line">           if (isMainThread) &#123;</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case MAIN_ORDERED:</span><br><span class="line">           if (mainThreadPoster !&#x3D; null) &#123;</span><br><span class="line">               mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; temporary: technically not correct as poster not decoupled from subscriber</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case BACKGROUND:</span><br><span class="line">           if (isMainThread) &#123;</span><br><span class="line">               backgroundPoster.enqueue(subscription, event);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case ASYNC:</span><br><span class="line">           asyncPoster.enqueue(subscription, event);</span><br><span class="line">           break;</span><br><span class="line">       default:</span><br><span class="line">           throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行订阅者的订阅方法</span><br><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">        &#x2F;&#x2F; 反射调用执行方法</span><br><span class="line">       subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">   &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">       handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">   &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BackgroundPoster<br>以BackgroundPoster为例，进行代码分析</p>
<ol>
<li>构建PendingPost，然后加入PendingPostQueue队列，接着调用线程执行器执行线程</li>
<li>线程执行，循环获取PendingPost，调用EventBus.invokeSubscriber反射执行订阅者的订阅方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final class BackgroundPoster implements Runnable, Poster &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 入队</span><br><span class="line">    public void enqueue(Subscription subscription, Object event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 订阅者和事件封装为一个 PendingPost</span><br><span class="line">        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            queue.enqueue(pendingPost); &#x2F;&#x2F; 入队</span><br><span class="line">            if (!executorRunning) &#123;</span><br><span class="line">                executorRunning &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F; 调用现场执行器，执行</span><br><span class="line">                eventBus.getExecutorService().execute(this); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    PendingPost pendingPost &#x3D; queue.poll(1000);</span><br><span class="line">                    轮训取 post，1s没有则停止执行</span><br><span class="line">                    if (pendingPost &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        synchronized (this) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Check again, this time in synchronized</span><br><span class="line">                            pendingPost &#x3D; queue.poll();</span><br><span class="line">                            if (pendingPost &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                executorRunning &#x3D; false;</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 最后执行eventBus的invokeSubscriber方法</span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-70673e2d55e85b18.gif?imageMogr2/auto-orient/strip" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/16/LeakCanary%202.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/16/LeakCanary%202.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">LeakCanary 2.0源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-16 14:48:07" itemprop="dateCreated datePublished" datetime="2019-12-16T14:48:07+08:00">2019-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:12:15" itemprop="dateModified" datetime="2020-02-07T01:12:15+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于LeakCanary 2.0源码分析<br><a href="https://square.github.io/leakcanary/" target="_blank" rel="noopener">LeakCanary - 官方地址</a><br><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary - GitHub代码地址</a></p>
</blockquote>
<h3 id="LeakCanary-是什么"><a href="#LeakCanary-是什么" class="headerlink" title="LeakCanary 是什么"></a>LeakCanary 是什么</h3><p>概念：LeakCanary是针对Android应用的一个内存泄漏监控三方库<br>能力：Activity、Fragment以及自主监控的任何对象<br>出品：Square</p>
<h3 id="LeakCanary-作用"><a href="#LeakCanary-作用" class="headerlink" title="LeakCanary 作用"></a>LeakCanary 作用</h3><p>基于对Android Framework层的认知，LeakCanary提供更精准的泄漏原因分析能力，从而帮助开发者快速减少OOM Crash问题</p>
<h3 id="LeakCanary-工作原理"><a href="#LeakCanary-工作原理" class="headerlink" title="LeakCanary 工作原理"></a>LeakCanary 工作原理</h3><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><h5 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h5><p>在Java运行环境下，内存泄漏是指某个程序错误导致应用长时间一直保留某个不在需要的对象，以至于它不能被回收，而它是会占用内存的，这就意味着内存泄漏了。持续累加，最终有可能导致发生内存溢出问题。<br>例如一个Activity执行完onDestroy方法后，它仍然被一个static变量强引用，从而阻止了Activity被GC回收，导致Activity发生内存泄漏</p>
<h5 id="怎么判断一个对象是否泄漏"><a href="#怎么判断一个对象是否泄漏" class="headerlink" title="怎么判断一个对象是否泄漏"></a>怎么判断一个对象是否泄漏</h5><p>从GC Roots出发进行遍历，强引用可到达对象，都是存活对象，不可达对象则为即将被回收的对象。如果那些存活对象本应该是要被回收的，那么这个对象就是发生了内存泄漏（见下图，引用一张图说明）<br>实际过程通常作法是针对核心对象Activity、Fragment进行监控分析</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-390ce78028460e86.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="如何开始监控"><a href="#如何开始监控" class="headerlink" title="如何开始监控"></a>如何开始监控</h4><p>LeakCanary通过实现四大组件中的ContentProvider，所以可以在App启动的时候执行到LeakCanary的AppWatcherInstaller.onCreate方法，从而完成<strong>0侵入</strong>实现注册监控流程</p>
<h4 id="监控什么对象以及如何监控到目标对象"><a href="#监控什么对象以及如何监控到目标对象" class="headerlink" title="监控什么对象以及如何监控到目标对象"></a>监控什么对象以及如何监控到目标对象</h4><p>Activity: 通过注册 Application.ActivityLifecycleCallbacks实现onActivityDestroyed执行回调，以监控需要被回收的Activity是否被回收<br>Fragment： 通过注册 FragmentManager.FragmentLifecycleCallbacks实现onFragmentViewDestroyed和onFragmentDestroyed回调，以监控需要被回收的Fragment或者View是否被回收</p>
<h4 id="如何确认目标对象泄漏"><a href="#如何确认目标对象泄漏" class="headerlink" title="如何确认目标对象泄漏"></a>如何确认目标对象泄漏</h4><ol>
<li>执行回收：目标对象如果在一个缓冲时间（5s）仍未被回收，我们通过手动执行GC，然后在确认其是否真的不能被回收</li>
<li>确认是否回收：JVM中，如果创建一个含有ReferenceQueue的WeakReference的A对象，这个WeakReference对应的A对象如果被回收了，则A会被自动加入到ReferenceQueue，所以我们可以通过维护一个ReferenceQueue，通过创建目标对象的含有ReferenceQueue的WeakReference，从而监听到目标对象是否被回收</li>
</ol>
<p>更多参考：<a href="https://www.jianshu.com/p/439a8f738153" target="_blank" rel="noopener">Reference和ReferenceQueue深入解读
</a></p>
<h4 id="如何分析目标对象泄漏的原因"><a href="#如何分析目标对象泄漏的原因" class="headerlink" title="如何分析目标对象泄漏的原因"></a>如何分析目标对象泄漏的原因</h4><p>泄漏原因即寻找泄漏路径</p>
<ol>
<li>通过Debug.dumpHprofData，dump一份hprof数据</li>
<li>读取hprof数据，整理出一份GcRoots对象索引</li>
<li>排序GcRoots对象，并构造一份ReferencePathNode树</li>
<li>BFS遍历，找到泄漏对象的最短路径节点</li>
<li>根据节点，生成泄漏路径</li>
</ol>
<h4 id="如何呈现目标对象泄漏的原因"><a href="#如何呈现目标对象泄漏的原因" class="headerlink" title="如何呈现目标对象泄漏的原因"></a>如何呈现目标对象泄漏的原因</h4><ol>
<li>生成一个HeapDumpScreen，呈现泄漏信息</li>
<li>发出通知</li>
</ol>
<h3 id="LeakCanary-2-0与1-x版本对比"><a href="#LeakCanary-2-0与1-x版本对比" class="headerlink" title="LeakCanary 2.0与1.x版本对比"></a>LeakCanary 2.0与1.x版本对比</h3><table>
<thead>
<tr>
<th>内容</th>
<th>2.0</th>
<th>1.0</th>
</tr>
</thead>
<tbody><tr>
<td>语言</td>
<td>kotlin</td>
<td>java</td>
</tr>
<tr>
<td>使用</td>
<td>仅需引入库，自动注册监控</td>
<td>除引入库，还需要手动执行install</td>
</tr>
<tr>
<td>内存分析</td>
<td>shark，基于Okio的自实现的轻巧内存分析库</td>
<td>haha三方库</td>
</tr>
<tr>
<td>其它</td>
<td>fragment，支持 androidx</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="LeakCanary-源码分析"><a href="#LeakCanary-源码分析" class="headerlink" title="LeakCanary 源码分析"></a>LeakCanary 源码分析</h3><h4 id="主要包的结构介绍"><a href="#主要包的结构介绍" class="headerlink" title="主要包的结构介绍"></a>主要包的结构介绍</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-7f35590ddeeb2d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="主要工作的时序图"><a href="#主要工作的时序图" class="headerlink" title="主要工作的时序图"></a>主要工作的时序图</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-3a291778423a85ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h4><h5 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h5><p>AppWatcherInstaller.onCreate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 继承 ContentProvider</span><br><span class="line">internal sealed class AppWatcherInstaller : ContentProvider() &#123;</span><br><span class="line">    &#x2F;&#x2F; App启动 执行 onCreate </span><br><span class="line">  override fun onCreate(): Boolean &#123;</span><br><span class="line">    val application &#x3D; context!!.applicationContext as Application</span><br><span class="line">    &#x2F;&#x2F; 注册启动（0 侵入）</span><br><span class="line">    InternalAppWatcher.install(application)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternalAppWatcher.install</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun install(application: Application) &#123;</span><br><span class="line">    InternalAppWatcher.application &#x3D; application</span><br><span class="line">    </span><br><span class="line">    val configProvider &#x3D; &#123; AppWatcher.config &#125;</span><br><span class="line">    &#x2F;&#x2F; Activity destroy方法监控注册</span><br><span class="line">    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    &#x2F;&#x2F; Fragment destroy方法监控注册</span><br><span class="line">    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    onAppWatcherInstalled(application)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityDestroyWatcher.install</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">internal class ActivityDestroyWatcher private constructor(</span><br><span class="line">  private val objectWatcher: ObjectWatcher,</span><br><span class="line">  private val configProvider: () -&gt; Config</span><br><span class="line">) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造 Application.ActivityLifecycleCallbacks</span><br><span class="line">  private val lifecycleCallbacks &#x3D;</span><br><span class="line">    object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">      override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">        if (configProvider().watchActivities) &#123;</span><br><span class="line">          objectWatcher.watch(activity, &quot;Activity received Activity#onDestroy() callback&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  companion object &#123;</span><br><span class="line">    fun install(</span><br><span class="line">      application: Application,</span><br><span class="line">      objectWatcher: ObjectWatcher,</span><br><span class="line">      configProvider: () -&gt; Config</span><br><span class="line">    ) &#123;</span><br><span class="line">      val activityDestroyWatcher &#x3D;</span><br><span class="line">        ActivityDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">      &#x2F;&#x2F; 注册 生命周期监听回调</span><br><span class="line">      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InternalLeakCanary.invoke</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 初始化相关类</span><br><span class="line">override fun invoke(application: Application) &#123;</span><br><span class="line">    this.application &#x3D; application</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 添加保留对象监听</span><br><span class="line">AppWatcher.objectWatcher.addOnObjectRetainedListener(this)</span><br><span class="line">    &#x2F;&#x2F; Android heap dumper类</span><br><span class="line">    val heapDumper &#x3D; AndroidHeapDumper(application, leakDirectoryProvider)</span><br><span class="line">    &#x2F;&#x2F; GC触发器</span><br><span class="line">    val gcTrigger &#x3D; GcTrigger.Default</span><br><span class="line">    </span><br><span class="line">    val configProvider &#x3D; &#123; LeakCanary.config &#125;</span><br><span class="line">    &#x2F;&#x2F; 相关线程 handler</span><br><span class="line">    val handlerThread &#x3D; HandlerThread(LEAK_CANARY_THREAD_NAME)</span><br><span class="line">    handlerThread.start()</span><br><span class="line">    val backgroundHandler &#x3D; Handler(handlerThread.looper)</span><br><span class="line">    &#x2F;&#x2F; Heap Dump 触发器</span><br><span class="line">    heapDumpTrigger &#x3D; HeapDumpTrigger(</span><br><span class="line">       application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,</span><br><span class="line">       configProvider</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="监控流程"><a href="#监控流程" class="headerlink" title="监控流程"></a>监控流程</h5><p>以Activity.onDestory为例<br>ActivityDestroyWatcher.lifecycleCallbacks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private val lifecycleCallbacks &#x3D;</span><br><span class="line">  object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">    override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">      if (configProvider().watchActivities) &#123;</span><br><span class="line">          &#x2F;&#x2F; 开始监控 销毁的activity</span><br><span class="line">        objectWatcher.watch(activity, &quot;Activity received Activity#onDestroy() callback&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ObjectWatcher.watch</span><br></pre></td></tr></table></figure>
<p>  @Synchronized fun watch(<br>    watchedObject: Any,<br>    description: String<br>  ) {<br>    // 移除已经回收的监听对象<br>    removeWeaklyReachableObjects()<br>    // 随机key<br>    val key = UUID.randomUUID()<br>        .toString()<br>    val watchUptimeMillis = clock.uptimeMillis()<br>    // 构造KeyedWeakReference 用来监听目标对象<br>    val reference =<br>      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)<br>    // 存储 key + reference<br>    watchedObjects[key] = reference<br>    checkRetainedExecutor.execute {<br>        // 执行 没有回收流程<br>      moveToRetained(key)<br>    }<br>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectWatcher.moveToRetained</span><br></pre></td></tr></table></figure>
<p>  @Synchronized private fun moveToRetained(key: String) {<br>    // 再次移除被回收的对象<br>    removeWeaklyReachableObjects()<br>    val retainedRef = watchedObjects[key]<br>    // 如果没有被回收 则开始执行对象未被回收流程<br>    if (retainedRef != null) {<br>      retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>      onObjectRetainedListeners.forEach { it.onObjectRetained() }<br>    }<br>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">HeapDumpTrigger</span><br></pre></td></tr></table></figure>
<p>  override fun onObjectRetained() {<br>    if (this::heapDumpTrigger.isInitialized) {<br>      heapDumpTrigger.onObjectRetained()<br>    }<br>  }</p>
<p>  fun onObjectRetained() {<br>    scheduleRetainedObjectCheck(“found new object retained”)<br>  }</p>
<p>  private fun scheduleRetainedObjectCheck(reason: String) {<br>    checkScheduled = true<br>    backgroundHandler.post {<br>      checkScheduled = false<br>      checkRetainedObjects(reason)<br>    }<br>  }</p>
<p>private fun checkRetainedObjects(reason: String) {<br>    val config = configProvider()<br>    // A tick will be rescheduled when this is turned back on.<br>    if (!config.dumpHeap) {<br>      SharkLog.d { “No checking for retained object: LeakCanary.Config.dumpHeap is false” }<br>      return<br>    }<br>    SharkLog.d { “Checking retained object because $reason” }</p>
<pre><code>var retainedReferenceCount = objectWatcher.retainedObjectCount
// 如果还有未被回收的目标对象，则出发GC，
if (retainedReferenceCount &gt; 0) {
  gcTrigger.runGc()
  retainedReferenceCount = objectWatcher.retainedObjectCount
}

if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return

// 触发GC后，对象仍未被回收，开始dump
dumpHeap(retainedReferenceCount, retry = true)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HeapDumpTrigger.dumpHeap</span><br></pre></td></tr></table></figure>
<p>  private fun dumpHeap(<br>    retainedReferenceCount: Int,<br>    retry: Boolean<br>  ) {<br>    // 储存Android 的资源id 及其对应的name<br>    saveResourceIdNamesToMemory()<br>    val heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    // dumpHeap 到file<br>    val heapDumpFile = heapDumper.dumpHeap()</p>
<pre><code>lastDisplayedRetainedObjectCount = 0
objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
// 启动service 开始dump分析
HeapAnalyzerService.runAnalysis(application, heapDumpFile)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AndroidHeapDumper.dumpHeap</span><br></pre></td></tr></table></figure>
<p> override fun dumpHeap(): File? {<br>    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null<br>    …<br>    // 调用Debug的dumpHprofData 到目标文件<br>    return Debug.dumpHprofData(heapDumpFile.absolutePath)<br>             heapDumpFile<br>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 分析流程</span><br><span class="line"></span><br><span class="line">HeapAnalyzerService.onHandleIntentInForeground</span><br></pre></td></tr></table></figure>
<p>  override fun onHandleIntentInForeground(intent: Intent?) {<br>    // 获取目标 heap dump file<br>     val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File<br>    // 构造 heap分析器<br>    val heapAnalyzer = HeapAnalyzer(this)<br>    // …<br>    // 执行分析流程<br>    val heapAnalysis =<br>      heapAnalyzer.analyze(<br>          heapDumpFile,<br>          config.referenceMatchers,<br>          config.computeRetainedHeapSize,<br>          config.objectInspectors,<br>          if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(<br>              ObjectInspectors.KEYED_WEAK_REFERENCE<br>          ),<br>          config.metatadaExtractor,<br>          proguardMappingReader?.readProguardMapping()<br>      )</p>
<pre><code>// 回调分析完成
config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HeapAnalyzer.analyze</span><br></pre></td></tr></table></figure>
<p>fun analyze(<br>    heapDumpFile: File,<br>    referenceMatchers: List<ReferenceMatcher> = emptyList(),<br>    computeRetainedHeapSize: Boolean = false,<br>    objectInspectors: List<ObjectInspector> = emptyList(),<br>    leakFinders: List<ObjectInspector> = objectInspectors,<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,<br>    proguardMapping: ProguardMapping? = null<br>  ): HeapAnalysis {<br>    val analysisStartNanoTime = System.nanoTime()</p>
<pre><code>try {
  listener.onAnalysisProgress(PARSING_HEAP_DUMP)
  // 读取 文件，然后执行分析
  Hprof.open(heapDumpFile)
      .use { hprof -&gt;
        // Hprof -&gt; graph 转换过程 目标获取GcRoots index
        val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)

        listener.onAnalysisProgress(EXTRACTING_METADATA)
        // 获取Android相关 metadata （如sdk版本、收集厂商等信息）
        val metadata = metadataExtractor.extractMetadata(graph)

        val findLeakInput = FindLeakInput(
            graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors
        )
        // 找泄漏最短路径
        val (applicationLeaks, libraryLeaks) = findLeakInput.findLeaks()
        listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
        // 返回分析成功结果
        return HeapAnalysisSuccess(
            heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime), metadata,
            applicationLeaks, libraryLeaks
        )
      }

}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HeapAnalyzer.findLeaks</span><br></pre></td></tr></table></figure>
<p>  private fun FindLeakInput.findLeaks(): Pair&lt;List<ApplicationLeak>, List<LibraryLeak>&gt; {<br>    // 找未被回收对象的 objectId<br>    val leakingInstanceObjectIds = findRetainedObjects()<br>    // 构造pathFinder对象<br>    val pathFinder = PathFinder(graph, listener, referenceMatchers)<br>    val pathFindingResults =<br>    // ⚠️ 找泄漏对象到GcRoots的最短路径<br>    pathFinder.findPathsFromGcRoots(leakingInstanceObjectIds, computeRetainedHeapSize)</p>
<p>   // 返回 泄漏路径<br>    return buildLeakTraces(pathFindingResults)<br>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PathFinder.findPatchsFromGcRoots</span><br></pre></td></tr></table></figure>
<p>  fun findPathsFromGcRoots(<br>    leakingObjectIds: Set<Long>,<br>    computeRetainedHeapSize: Boolean<br>  ): PathFindingResults {<br>    listener.onAnalysisProgress(FINDING_PATHS_TO_RETAINED_OBJECTS)</p>
<pre><code>val sizeOfObjectInstances = determineSizeOfObjectInstances(graph)

val state = State(leakingObjectIds, sizeOfObjectInstances, computeRetainedHeapSize)
// 执行 state。findPathsFromGcRoots
return state.findPathsFromGcRoots()</code></pre><p>  }</p>
<p>  private fun State.findPathsFromGcRoots(): PathFindingResults {<br>    // GcRoots 生成节点队列树<br>    enqueueGcRoots()</p>
<pre><code>val shortestPathsToLeakingObjects = mutableListOf&lt;ReferencePathNode&gt;()
visitingQueue@ while (queuesNotEmpty) {
  val node = poll() // 循环取node

    // 泄漏的节点，则添加到shortestPathsToLeakingObjects 直到，全部找完 
  if (node.objectId in leakingObjectIds) {
    shortestPathsToLeakingObjects.add(node)
    // Found all refs, stop searching (unless computing retained size)
    if (shortestPathsToLeakingObjects.size == leakingObjectIds.size) {
      if (computeRetainedHeapSize) {
        listener.onAnalysisProgress(FINDING_DOMINATORS)
      } else {
        break@visitingQueue
      }
    }
  }
}
return PathFindingResults(shortestPathsToLeakingObjects, dominatedObjectIds)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 呈现流程</span><br><span class="line"></span><br><span class="line">DefaultOnHeapAnalyzedListener.onHeapAnalyzed</span><br></pre></td></tr></table></figure>
<p>  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {<br>    // 写入 db<br>    val (id, groupProjections) = LeaksDbHelper(application)<br>        .writableDatabase.use { db -&gt;<br>      val id = HeapAnalysisTable.insert(db, heapAnalysis)<br>      id to LeakTable.retrieveHeapDumpLeaks(db, id)<br>    }</p>
<pre><code>// 生成 泄漏信息到屏幕展示
val (contentTitle, screenToShow) = when (heapAnalysis) {
  is HeapAnalysisFailure -&gt; application.getString(
      R.string.leak_canary_analysis_failed
  ) to HeapAnalysisFailureScreen(id)
  is HeapAnalysisSuccess -&gt; {
    var leakCount = 0
    var newLeakCount = 0
    var knownLeakCount = 0
    var libraryLeakCount = 0

    for ((_, projection) in groupProjections) {
      leakCount += projection.leakCount
      when {
        projection.isLibraryLeak -&gt; libraryLeakCount += projection.leakCount
        projection.isNew -&gt; newLeakCount += projection.leakCount
        else -&gt; knownLeakCount += projection.leakCount
      }
    }

    application.getString(
        R.string.leak_canary_analysis_success_notification, leakCount, newLeakCount,
        knownLeakCount, libraryLeakCount
    ) to HeapDumpScreen(id)
  }
}

val pendingIntent = LeakActivity.createPendingIntent(
    application, arrayListOf(HeapDumpsScreen(), screenToShow)
)

val contentText = application.getString(R.string.leak_canary_notification_message)
// 构建通知
Notifications.showNotification(
    application, contentTitle, contentText, pendingIntent,
    R.id.leak_canary_notification_analysis_result,
    LEAKCANARY_MAX
)</code></pre><p>  }</p>
<pre><code>


---
![](https://upload-images.jianshu.io/upload_images/9696036-70673e2d55e85b18.gif?imageMogr2/auto-orient/strip)

</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/08/Android%E7%B3%BB%E7%BB%9F_Surface%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/08/Android%E7%B3%BB%E7%BB%9F_Surface%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%EF%BC%89/" class="post-title-link" itemprop="url">Android系统_Surface渲染过程分析（软件绘制）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-08 13:06:37" itemprop="dateCreated datePublished" datetime="2019-12-08T13:06:37+08:00">2019-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:12:00" itemprop="dateModified" datetime="2020-02-07T01:12:00+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>基于API 23</p>
</blockquote>
<p>前篇：<a href="https://www.jianshu.com/p/956db9044cd8" target="_blank" rel="noopener">Android系统_Surface创建流程分析</a><br><img src="https://upload-images.jianshu.io/upload_images/9696036-b2bb93136eb953d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="申请Buffer"><a href="#申请Buffer" class="headerlink" title="申请Buffer"></a>申请Buffer</h3><h4 id="ViewRootImpl-draw"><a href="#ViewRootImpl-draw" class="headerlink" title="ViewRootImpl.draw"></a>ViewRootImpl.draw</h4><p>执行遍历 &gt; 执行Draw &gt; draw方法 &gt; 软件绘制流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void performTraversals() &#123;</span><br><span class="line">    ...</span><br><span class="line">    relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">    ...</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    ...         </span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    ...</span><br><span class="line">    performDraw();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void performDraw() &#123;</span><br><span class="line">    draw(fullRedrawNeeded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        &#x2F;&#x2F; 硬件加速 ，绘制绘制流程</span><br><span class="line">        if (mAttachInfo.mHardwareRenderer !&#x3D; null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">             ...</span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">           &#x2F;&#x2F; 软件绘制 流程</span><br><span class="line">            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewRootImpl-drawSoftware"><a href="#ViewRootImpl-drawSoftware" class="headerlink" title="ViewRootImpl.drawSoftware"></a>ViewRootImpl.drawSoftware</h4><p>主要三个步骤 申请Buffer、绘制、绘制完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo,...) &#123;</span><br><span class="line">    &#x2F;&#x2F; Draw with software renderer.</span><br><span class="line">    final Canvas canvas;</span><br><span class="line">    ...</span><br><span class="line">    canvas &#x3D; mSurface.lockCanvas(dirty);  &#x2F;&#x2F;申请Buffer</span><br><span class="line">    ...</span><br><span class="line">    mView.draw(canvas);  &#x2F;&#x2F;绘制</span><br><span class="line">    ...</span><br><span class="line">    mSurface.unlockCanvasAndPost(canvas);  &#x2F;&#x2F;绘制完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-lockCanvas"><a href="#Surface-lockCanvas" class="headerlink" title="Surface.lockCanvas"></a>Surface.lockCanvas</h4><p>执行JNI层的nativeLockCanvas，mNativeObject就是native层Surface指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Canvas lockCanvas(Rect inOutDirty)</span><br><span class="line">       throws Surface.OutOfResourcesException, IllegalArgumentException &#123;</span><br><span class="line">   synchronized (mLock) &#123;</span><br><span class="line">       checkNotReleasedLocked();</span><br><span class="line">       </span><br><span class="line">       mLockedObject &#x3D; nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">       return mCanvas;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="android-view-Surface-cpp"><a href="#android-view-Surface-cpp" class="headerlink" title="android_view_Surface.cpp"></a>android_view_Surface.cpp</h4><p>创建一个Rect对象，确定要重绘制的区域，执行Surface的lock方法来申请bugger，然后新建了一个SKBitmap，设置了内存地址，并把这个bitmap放入了Canvas中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static jlong nativeLockCanvas(JNIEnv* env, jclass clazz,jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123;</span><br><span class="line">    sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject)); &#x2F;&#x2F;转换指针</span><br><span class="line">    ...</span><br><span class="line">    Rect dirtyRect;</span><br><span class="line">    Rect* dirtyRectPtr &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    if (dirtyRectObj) &#123;</span><br><span class="line">        dirtyRect.left   &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">        dirtyRect.top    &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">        dirtyRect.right  &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">        dirtyRect.bottom &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">        dirtyRectPtr &#x3D; &amp;dirtyRect;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 申请内存Buffer</span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    status_t err &#x3D; surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    SkImageInfo info &#x3D; SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                     convertPixelFormat(outBuffer.format),</span><br><span class="line">                                     kPremul_SkAlphaType);               </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 新建一个SkBitmap 并进行一系列设置</span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    ssize_t bpr &#x3D; outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    bitmap.setInfo(info, bpr);</span><br><span class="line">    if (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123;</span><br><span class="line">        bitmap.setPixels(outBuffer.bits);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; be safe with an empty bitmap.</span><br><span class="line">        bitmap.setPixels(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 把创建的bitmap 设置到Canvas中</span><br><span class="line">    Canvas* nativeCanvas &#x3D; GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(bitma</span><br><span class="line">    if (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">                dirtyRect.right, dirtyRect.bottom);</span><br><span class="line">    </span><br><span class="line">    if (dirtyRectObj) &#123;</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Create another reference to the surface and return it.  This reference</span><br><span class="line">    &#x2F;&#x2F; should be passed to nativeUnlockCanvasAndPost in place of mNativeObject,</span><br><span class="line">    &#x2F;&#x2F; because the latter could be replaced while the surface is locked.</span><br><span class="line">    sp&lt;Surface&gt; lockedSurface(surface);</span><br><span class="line">    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    return (jlong) lockedSurface.get();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-cpp"><a href="#Surface-cpp" class="headerlink" title="Surface.cpp"></a>Surface.cpp</h4><p>通过dequeueBuffer获取一个ANativeWindowBuffer，之后构造一个GraphicBuffer，这个bugger用来传递绘制的元数据<br>BufferQueueProducer中dequeueBuffer，将分配的内存放到mSlots中，outSlot就是给应用进程mSlots的序号<br>BufferQueueProducer中requestBuffer，根据序号，从mSlots拿到buffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">status_t Surface::lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)&#123;</span><br><span class="line"></span><br><span class="line">    ANativeWindowBuffer* out; int fenceFd &#x3D; -1;</span><br><span class="line">    status_t err &#x3D; dequeueBuffer(&amp;out, &amp;fenceFd);  &#x2F;&#x2F;从 GraphicBufferProduce 中 拿出来一个 buffer </span><br><span class="line">    </span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));&#x2F;&#x2F;放到backBuffer中</span><br><span class="line">        const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height);</span><br><span class="line"> </span><br><span class="line">        .......</span><br><span class="line"> </span><br><span class="line">        void* vaddr;</span><br><span class="line">        status_t res &#x3D; backBuffer-&gt;lockAsync(&#x2F;&#x2F;把buffer的handle中的地址传到vaddr中</span><br><span class="line">                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">                newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line"> </span><br><span class="line">        if (res !&#x3D; 0) &#123;</span><br><span class="line">            err &#x3D; INVALID_OPERATION;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLockedBuffer &#x3D; backBuffer;</span><br><span class="line">            outBuffer-&gt;width  &#x3D; backBuffer-&gt;width;</span><br><span class="line">            outBuffer-&gt;height &#x3D; backBuffer-&gt;height;</span><br><span class="line">            outBuffer-&gt;stride &#x3D; backBuffer-&gt;stride;</span><br><span class="line">            outBuffer-&gt;format &#x3D; backBuffer-&gt;format;</span><br><span class="line">            outBuffer-&gt;bits   &#x3D; vaddr;&#x2F;&#x2F;buffer地址</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return err &#x2F;&#x2F; 返回GraphicBuffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    status_t result &#x3D; mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,</span><br><span class="line">                                                            reqFormat, reqUsage, &amp;mBufferAge,</span><br><span class="line">                                                            enableFrameTimestamps ? &amp;frameTimestamps</span><br><span class="line">                                                                                  : nullptr);</span><br><span class="line">                                                                                  </span><br><span class="line">                                                                        </span><br><span class="line">     if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        result &#x3D; mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);&#x2F;&#x2F;根据需要拿到buffer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line">    *buffer &#x3D; gbuf.get();</span><br><span class="line">    </span><br><span class="line">    return OK;                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="View绘制"><a href="#View绘制" class="headerlink" title="View绘制"></a>View绘制</h3><h4 id="View-draw"><a href="#View-draw" class="headerlink" title="View.draw"></a>View.draw</h4><p>执行<a href="https://www.jianshu.com/p/9b759b4a1aa5" target="_blank" rel="noopener">View的绘制流程</a><br>下面看常见的 canvas.drawRect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void drawRect(float left, float top, float right, float bottom, @NonNull Paint paint) &#123;</span><br><span class="line">   native_drawRect(mNativeCanvasWrapper, left, top, right, bottom, paint.getNativeInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="android-graphics-Canvas-cpp"><a href="#android-graphics-Canvas-cpp" class="headerlink" title="android_graphics_Canvas.cpp"></a>android_graphics_Canvas.cpp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void drawRect(JNIEnv* env, jobject, jlong canvasHandle, jfloat left, jfloat top,</span><br><span class="line">                     jfloat right, jfloat bottom, jlong paintHandle) &#123;</span><br><span class="line">    const Paint* paint &#x3D; reinterpret_cast&lt;Paint*&gt;(paintHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawRect(left, top, right, bottom, *paint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SkiaCanvas-drawRect"><a href="#SkiaCanvas-drawRect" class="headerlink" title="SkiaCanvas.drawRect"></a>SkiaCanvas.drawRect</h4><p>执行Skia库的绘制方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void SkiaCanvas::drawRect(float left, float top, float right, float bottom,</span><br><span class="line">        const SkPaint&amp; paint) &#123;</span><br><span class="line">    mCanvas-&gt;drawRectCoords(left, top, right, bottom, paint);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SkCanvas-drawRectCoords"><a href="#SkCanvas-drawRectCoords" class="headerlink" title="SkCanvas.drawRectCoords"></a>SkCanvas.drawRectCoords</h4><p>执行 到SkBitmap写入Buffer数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void SkCanvas::drawRectCoords(SkScalar left, SkScalar top,</span><br><span class="line">                              SkScalar right, SkScalar bottom,</span><br><span class="line">                              const SkPaint&amp; paint) &#123;</span><br><span class="line">    TRACE_EVENT0(&quot;disabled-by-default-skia&quot;, &quot;SkCanvas::drawRectCoords()&quot;);</span><br><span class="line">    SkRect  r;</span><br><span class="line"> </span><br><span class="line">    r.set(left, top, right, bottom);</span><br><span class="line">    this-&gt;drawRect(r, paint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SkCanvas::DrawRect(const SkDraw&amp; draw, const SkPaint&amp; paint,</span><br><span class="line">                        const SkRect&amp; r, SkScalar textSize) &#123;</span><br><span class="line">    if (paint.getStyle() &#x3D;&#x3D; SkPaint::kFill_Style) &#123;</span><br><span class="line">        &#x2F;&#x2F; fDevice 即SKBitmap ，从而实现将数据写入buffer</span><br><span class="line">        draw.fDevice-&gt;drawRect(draw, r, paint);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        SkPaint p(paint);</span><br><span class="line">        p.setStrokeWidth(SkScalarMul(textSize, paint.getStrokeWidth()));</span><br><span class="line">        draw.fDevice-&gt;drawRect(draw, r, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="View绘制完成后通知刷新"><a href="#View绘制完成后通知刷新" class="headerlink" title="View绘制完成后通知刷新"></a>View绘制完成后通知刷新</h3><h4 id="Surface-unlockCanvasAndPost-canvas"><a href="#Surface-unlockCanvasAndPost-canvas" class="headerlink" title="Surface.unlockCanvasAndPost(canvas)"></a>Surface.unlockCanvasAndPost(canvas)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void unlockCanvasAndPost(Canvas canvas) &#123;</span><br><span class="line">   synchronized (mLock) &#123;</span><br><span class="line">       checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">       if (mHwuiContext !&#x3D; null) &#123;</span><br><span class="line">           mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 走软件绘制流程</span><br><span class="line">           unlockSwCanvasAndPost(canvas);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="android-view-Surface-nativeUnlockCanvasAndPost"><a href="#android-view-Surface-nativeUnlockCanvasAndPost" class="headerlink" title="android_view.Surface.nativeUnlockCanvasAndPost"></a>android_view.Surface.nativeUnlockCanvasAndPost</h4><p>设置一个空的SkBitmap<br>然后执行Surface的unlockANdPost函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void unlockSwCanvasAndPost(Canvas canvas) &#123;</span><br><span class="line">   if (canvas !&#x3D; mCanvas) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;canvas object must be the same instance that &quot;</span><br><span class="line">               + &quot;was previously returned by lockCanvas&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   if (mNativeObject !&#x3D; mLockedObject) &#123;</span><br><span class="line">       Log.w(TAG, &quot;WARNING: Surface&#39;s mNativeObject (0x&quot; +</span><br><span class="line">               Long.toHexString(mNativeObject) + &quot;) !&#x3D; mLockedObject (0x&quot; +</span><br><span class="line">               Long.toHexString(mLockedObject) +&quot;)&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   if (mLockedObject &#x3D;&#x3D; 0) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Surface was not locked&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       nativeRelease(mLockedObject);</span><br><span class="line">       mLockedObject &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-cpp-unlockAndPost"><a href="#Surface-cpp-unlockAndPost" class="headerlink" title="Surface.cpp.unlockAndPost"></a>Surface.cpp.unlockAndPost</h4><p>解除buffer锁定，执行queueBuffer最后执行到GraphicBufferProducer的queueBuffer函数，将buffer清除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">status_t Surface::unlockAndPost()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    int fd &#x3D; -1;</span><br><span class="line">    status_t err &#x3D; mLockedBuffer-&gt;unlockAsync(&amp;fd);&#x2F;&#x2F;通过Gralloc模块，最后是操作的ioctl</span><br><span class="line">     </span><br><span class="line">    err &#x3D; queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"> </span><br><span class="line">    mPostedBuffer &#x3D; mLockedBuffer;</span><br><span class="line">    mLockedBuffer &#x3D; 0;</span><br><span class="line">    return err;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-queueBuffer"><a href="#Surface-queueBuffer" class="headerlink" title="Surface.queueBuffer"></a>Surface.queueBuffer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 获取Slot数组保存的buffer</span><br><span class="line">    int i &#x3D; getSlotFromBufferLocked(buffer); </span><br><span class="line">    ..</span><br><span class="line">    IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">    IGraphicBufferProducer::QueueBufferInput input(timestamp, isAutoTimestamp,</span><br><span class="line">            static_cast&lt;android_dataspace&gt;(mDataSpace), crop, mScalingMode,</span><br><span class="line">            mTransform ^ mStickyTransform, fence, mStickyTransform,</span><br><span class="line">            mEnableFrameTimestamps);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 插入buffer</span><br><span class="line">    status_t err &#x3D; mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output); </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 通知</span><br><span class="line">    mQueueBufferCondition.broadcast();</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mSlog集合为按照顺序保存GraphicBuffer的数组</span><br><span class="line">int Surface::getSlotFromBufferLocked(android_native_buffer_t* buffer) const &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; NUM_BUFFER_SLOTS; i++) &#123;</span><br><span class="line">        if (mSlots[i].buffer !&#x3D; NULL &amp;&amp; mSlots[i].buffer-&gt;handle &#x3D;&#x3D; buffer-&gt;handle) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BAD_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BufferQueueProducer-cpp-queueBuffer"><a href="#BufferQueueProducer-cpp-queueBuffer" class="headerlink" title="BufferQueueProducer.cpp.queueBuffer"></a>BufferQueueProducer.cpp.queueBuffer</h4><p>根据输入参数完善一个BufferItem，然后通知frameAvailabel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">status_t BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) &#123; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从input中获取一些列参数</span><br><span class="line">    input.deflate(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace,</span><br><span class="line">        &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform,</span><br><span class="line">        &amp;getFrameTimestamps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sp&lt;IConsumerListener&gt; frameAvailableListener;</span><br><span class="line">    sp&lt;IConsumerListener&gt; frameReplacedListener;</span><br><span class="line">    BufferItem item; &#x2F;&#x2F;一个待渲染的帧</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;item的一系列赋值操作</span><br><span class="line"></span><br><span class="line">    item.mAcquireCalled &#x3D; mSlots[slot].mAcquireCalled; </span><br><span class="line">    item.mGraphicBuffer &#x3D; mSlots[slot].mGraphicBuffer; &#x2F;&#x2F;根据slot获取GraphicBuffer。</span><br><span class="line">    item.mCrop &#x3D; crop;</span><br><span class="line">    item.mTransform &#x3D; transform &amp;</span><br><span class="line">            ~static_cast&lt;uint32_t&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);</span><br><span class="line">    item.mTransformToDisplayInverse &#x3D;</span><br><span class="line">            (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) !&#x3D; 0;</span><br><span class="line">    item.mScalingMode &#x3D; static_cast&lt;uint32_t&gt;(scalingMode);</span><br><span class="line">    item.mTimestamp &#x3D; requestedPresentTimestamp;</span><br><span class="line">    item.mIsAutoTimestamp &#x3D; isAutoTimestamp;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (frameAvailableListener !&#x3D; NULL) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item); &#x2F;&#x2F;item是一个frame，准备完毕，要通知外界</span><br><span class="line">    &#125; else if (frameReplacedListener !&#x3D; NULL) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addAndGetFrameTimestamps(&amp;newFrameEventsEntry,etFrameTimestamps ? &amp;output-&gt;frameTimestamps : nullptr);</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BufferLayer-cpp"><a href="#BufferLayer-cpp" class="headerlink" title="BufferLayer.cpp"></a>BufferLayer.cpp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void BufferLayer::onFrameAvailable(const BufferItem&amp; item) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SurfaceFlinger-cpp"><a href="#SurfaceFlinger-cpp" class="headerlink" title="SurfaceFlinger.cpp"></a>SurfaceFlinger.cpp</h4><p>执行SurfaceFlinger的invalidate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue-&gt;invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>————————————————————————————————————<br><strong>推荐阅读</strong>：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/01/Android%E7%B3%BB%E7%BB%9F_SurfaceFlinger%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/01/Android%E7%B3%BB%E7%BB%9F_SurfaceFlinger%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Android系统_SurfaceFlinger分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-01 21:27:16" itemprop="dateCreated datePublished" datetime="2019-12-01T21:27:16+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:11:49" itemprop="dateModified" datetime="2020-02-07T01:11:49+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>基于API 23</p>
</blockquote>
<p>SurfaceFlinger，合成抛射机，它在Android系统是一个独立的服务进程<br>它的作用是接受多个来源的图形显示数据，将他们合成，然后发送到显示设备。<br>它的工作内容主要包括合成的创建和管理、Vsync信号的处理<br>本文分析SurfaceFlinger的启动流程，和Vsync信号的处理流程<br><img src="https://upload-images.jianshu.io/upload_images/9696036-d486634011edd814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SurfaceFlinger的Vsync信号处理流程"></p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>SurfaceFlinger 进程是由 init 进程创建的，运行在独立的 SurfaceFlinger 进程中。init 进程读取 init.rc 文件启动 SurfaceFlinger。首先来看main方法</p>
<h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><ul>
<li>设定线程池上线4，并启动binder线程池</li>
<li>创建SF对象</li>
<li>初始化SF</li>
<li>执行SF的run方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int main(int, char**) &#123;</span><br><span class="line">    &#x2F;&#x2F;设定surfaceflinger进程的binder线程池个数上限为4，并启动binder线程池</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);</span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;实例化surfaceflinger</span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger &#x3D;  new SurfaceFlinger();</span><br><span class="line"></span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(0, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将服务注册到Service Manager</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 运行在当前线程</span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>继承BnSurfaceCompose<br>构造过程仅仅初始化了SurfaceFlinger的成员变量，同时调用了父类BnSurfaceComposer的构造函数。最后执行onFirstRef 走init方法来作一些初始化工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::SurfaceFlinger()</span><br><span class="line">    :   BnSurfaceComposer(),</span><br><span class="line">        mTransactionFlags(0),</span><br><span class="line">        mTransactionPending(false),</span><br><span class="line">        mAnimTransactionPending(false),</span><br><span class="line">        mLayersRemoved(false),</span><br><span class="line">        mRepaintEverything(0),</span><br><span class="line">        mRenderEngine(NULL),</span><br><span class="line">        mBootTime(systemTime()),</span><br><span class="line">        mVisibleRegionsDirty(false),</span><br><span class="line">        mHwWorkListDirty(false),</span><br><span class="line">        mAnimCompositionPending(false),</span><br><span class="line">        mDebugRegion(0),</span><br><span class="line">        mDebugDDMS(0),</span><br><span class="line">        mDebugDisableHWC(0),</span><br><span class="line">        mDebugDisableTransformHint(0),</span><br><span class="line">        mDebugInSwapBuffers(0),</span><br><span class="line">        mLastSwapBufferTime(0),</span><br><span class="line">        mDebugInTransaction(0),</span><br><span class="line">        mLastTransactionTime(0),</span><br><span class="line">        mBootFinished(false),</span><br><span class="line">        mForceFullDamage(false),</span><br><span class="line">        mPrimaryHWVsyncEnabled(false),</span><br><span class="line">        mHWVsyncAvailable(false),</span><br><span class="line">        mDaltonize(false),</span><br><span class="line">        mHasColorMatrix(false),</span><br><span class="line">        mHasPoweredOff(false),</span><br><span class="line">        mFrameBuckets(),</span><br><span class="line">        mTotalTime(0),</span><br><span class="line">        mLastSwapTime(0)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(&quot;SurfaceFlinger is starting&quot;);</span><br><span class="line">    char value[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">    property_get(&quot;ro.bq.gpu_to_cpu_unsupported&quot;, value, &quot;0&quot;);</span><br><span class="line">    mGpuToCpuSupported &#x3D; !atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(&quot;debug.sf.showupdates&quot;, value, &quot;0&quot;);</span><br><span class="line">    mDebugRegion &#x3D; atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(&quot;debug.sf.ddms&quot;, value, &quot;0&quot;);</span><br><span class="line">    mDebugDDMS &#x3D; atoi(value);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-onFirstRef"><a href="#SF-onFirstRef" class="headerlink" title="SF.onFirstRef"></a>SF.onFirstRef</h4><p>由于SurfaceFlinger继承于RefBase类，同时实现了RefBase的onFirstRef()方法，因此在第一次引用SurfaceFlinger对象时，onFirstRef()函数自动被调用。初始化MessageQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    mEventQueue.init(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>messageQueue对象的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">&#123;</span><br><span class="line">    mFlinger &#x3D; flinger;</span><br><span class="line">    mLooper &#x3D; new Looper(true);</span><br><span class="line">    mHandler &#x3D; new Handler(*this); </span><br><span class="line">&#125;</span><br><span class="line">class MessageQueue &#123;</span><br><span class="line">    class Handler : public MessageHandler &#123;</span><br><span class="line">        enum &#123;</span><br><span class="line">            eventMaskInvalidate     &#x3D; 0x1,</span><br><span class="line">            eventMaskRefresh        &#x3D; 0x2,</span><br><span class="line">            eventMaskTransaction    &#x3D; 0x4</span><br><span class="line">        &#125;;</span><br><span class="line">        MessageQueue&amp; mQueue;</span><br><span class="line">        int32_t mEventMask;</span><br><span class="line">    public:</span><br><span class="line">        Handler(MessageQueue&amp; queue) : mQueue(queue), mEventMask(0) &#123; &#125;</span><br><span class="line">        virtual void handleMessage(const Message&amp; message);</span><br><span class="line">        void dispatchRefresh();</span><br><span class="line">        void dispatchInvalidate();</span><br><span class="line">        void dispatchTransaction();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceFlinger-init"><a href="#SurfaceFlinger-init" class="headerlink" title="SurfaceFlinger.init"></a>SurfaceFlinger.init</h4><ul>
<li>初始化 EGL</li>
<li>创建 HWComposer</li>
<li>初始化非虚拟显示屏</li>
<li>启动 EventThread 线程</li>
<li>启动开机动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化EGL，作为默认的显示</span><br><span class="line">    mEGLDisplay &#x3D; eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化硬件composer对象</span><br><span class="line">    mHwc &#x3D; new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取RenderEngine引擎</span><br><span class="line">    mRenderEngine &#x3D; RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建的EGL上下文</span><br><span class="line">    mEGLContext &#x3D; mRenderEngine-&gt;getEGLContext();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化非虚拟显示屏</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        &#x2F;&#x2F;建立已连接的显示设备</span><br><span class="line">        if (mHwc-&gt;isConnected(i) || type&#x3D;&#x3D;DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            bool isSecure &#x3D; true;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token &#x3D; mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            &#x2F;&#x2F;创建BufferQueue的生产者和消费者</span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    new GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs &#x3D; new FramebufferSurface(*mHwc, i, consumer);</span><br><span class="line">            int32_t hwcId &#x3D; allocateHwcDisplayId(type);</span><br><span class="line">            &#x2F;&#x2F;创建显示设备</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw &#x3D; new DisplayDevice(this,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当应用和sf的vsync偏移量一致时，则只创建一个EventThread线程</span><br><span class="line">    if (vsyncPhaseOffsetNs !&#x3D; sfVsyncPhaseOffsetNs) &#123;</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;app&quot;);</span><br><span class="line">        mEventThread &#x3D; new EventThread(vsyncSrc);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, true, &quot;sf&quot;);</span><br><span class="line">        mSFEventThread &#x3D; new EventThread(sfVsyncSrc);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;创建DispSyncSource对象</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;sf-app&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建线程EventThread </span><br><span class="line">        mEventThread &#x3D; new EventThread(vsyncSrc);</span><br><span class="line">        &#x2F;&#x2F;设置EventThread </span><br><span class="line">        mEventQueue.setEventThread(mEventThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建EventControl</span><br><span class="line">    mEventControlThread &#x3D; new EventControlThread(this);</span><br><span class="line">    mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当不存在HWComposer时，则设置软件vsync</span><br><span class="line">    if (mHwc-&gt;initCheck() !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        mPrimaryDispSync.setPeriod(16666667);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化绘图状态</span><br><span class="line">    mDrawingState &#x3D; mCurrentState;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化显示设备</span><br><span class="line">    initializeDisplays();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动开机动画</span><br><span class="line">    startBootAnim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HWComposer构建"><a href="#HWComposer构建" class="headerlink" title="HWComposer构建"></a>HWComposer构建</h4><p>HWComposer代表着硬件显示设备，注册了VSYNC信号的回调。VSYNC信号本身是由显示驱动产生的， 在不支持硬件的VSYNC，则会创建“VSyncThread”线程来模拟定时VSYNC信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(</span><br><span class="line">        const sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(0), mHwc(0), mNumDisplays(1),</span><br><span class="line">      mCBContext(new cb_context),</span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(false)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    bool needVSyncThread &#x3D; true;</span><br><span class="line">    int fberr &#x3D; loadFbHalModule(); &#x2F;&#x2F;加载framebuffer的HAL层模块</span><br><span class="line">    loadHwcModule(); &#x2F;&#x2F;加载HWComposer模块</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记已分配的display ID</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;</span><br><span class="line">        mAllocatedDisplayIDs.markBit(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mHwc) &#123;</span><br><span class="line">        if (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            mCBContext-&gt;hwc &#x3D; this;</span><br><span class="line">            mCBContext-&gt;procs.invalidate &#x3D; &amp;hook_invalidate;</span><br><span class="line">            &#x2F;&#x2F;VSYNC信号的回调方法</span><br><span class="line">            mCBContext-&gt;procs.vsync &#x3D; &amp;hook_vsync;</span><br><span class="line">            if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                mCBContext-&gt;procs.hotplug &#x3D; &amp;hook_hotplug;</span><br><span class="line">            else</span><br><span class="line">                mCBContext-&gt;procs.hotplug &#x3D; NULL;</span><br><span class="line">            memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero));</span><br><span class="line">            &#x2F;&#x2F;注册回调函数</span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;进入此处，说明已成功打开硬件composer设备，则不再需要vsync线程</span><br><span class="line">        needVSyncThread &#x3D; false;</span><br><span class="line">        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (needVSyncThread) &#123;</span><br><span class="line">        &#x2F;&#x2F;不支持硬件的VSYNC，则会创建线程来模拟定时VSYNC信号</span><br><span class="line">        mVSyncThread &#x3D; new VSyncThread(*this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化显示设备"><a href="#初始化显示设备" class="headerlink" title="初始化显示设备"></a>初始化显示设备</h4><p>创建IGraphicBufferProducer和IGraphicBufferConsumer，以及FramebufferSurface，DisplayDevice对象。另外， 显示设备有3类：主设备，扩展设备，虚拟设备。其中前两个都是内置显示设备，故NUM_BUILTIN_DISPLAY_TYPES=2，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        &#x2F;&#x2F;建立已连接的显示设备</span><br><span class="line">        if (mHwc-&gt;isConnected(i) || type&#x3D;&#x3D;DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            bool isSecure &#x3D; true;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token &#x3D; mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            &#x2F;&#x2F;创建BufferQueue的生产者和消费者</span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    new GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs &#x3D; new FramebufferSurface(*mHwc, i, consumer);</span><br><span class="line">            int32_t hwcId &#x3D; allocateHwcDisplayId(type);</span><br><span class="line">            &#x2F;&#x2F;创建显示设备</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw &#x3D; new DisplayDevice(this,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EventThread构造方法"><a href="#EventThread构造方法" class="headerlink" title="EventThread构造方法"></a>EventThread构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(const sp&lt;VSyncSource&gt;&amp; src)</span><br><span class="line">    : mVSyncSource(src),</span><br><span class="line">      mUseSoftwareVSync(false),</span><br><span class="line">      mVsyncEnabled(false),</span><br><span class="line">      mDebugVsyncEnabled(false),</span><br><span class="line">      mVsyncHintSent(false) &#123;</span><br><span class="line"></span><br><span class="line">    for (int32_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        mVSyncEvent[i].header.type &#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        mVSyncEvent[i].header.id &#x3D; 0;</span><br><span class="line">        mVSyncEvent[i].header.timestamp &#x3D; 0;</span><br><span class="line">        mVSyncEvent[i].vsync.count &#x3D;  0;</span><br><span class="line">    &#125;</span><br><span class="line">    struct sigevent se;</span><br><span class="line">    se.sigev_notify &#x3D; SIGEV_THREAD;</span><br><span class="line">    se.sigev_value.sival_ptr &#x3D; this;</span><br><span class="line">    se.sigev_notify_function &#x3D; vsyncOffCallback;</span><br><span class="line">    se.sigev_notify_attributes &#x3D; NULL;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventThread::onFirstRef() &#123;</span><br><span class="line">    &#x2F;&#x2F;运行EventThread线程</span><br><span class="line">    run(&quot;EventThread&quot;, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ET-threadLoop"><a href="#ET-threadLoop" class="headerlink" title="ET.threadLoop"></a>ET.threadLoop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    &#x2F;&#x2F; 等待事件</span><br><span class="line">    signalConnections &#x3D; waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分发事件给所有的监听者</span><br><span class="line">    const size_t count &#x3D; signalConnections.size();</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;count ; i++) &#123;</span><br><span class="line">        const sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        &#x2F;&#x2F;传递事件【见小节3.10】</span><br><span class="line">        status_t err &#x3D; conn-&gt;postEvent(event);</span><br><span class="line">        if (err &#x3D;&#x3D; -EAGAIN || err &#x3D;&#x3D; -EWOULDBLOCK) &#123;</span><br><span class="line">            &#x2F;&#x2F;可能此时connection已满，则直接抛弃事件</span><br><span class="line">            ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;,</span><br><span class="line">                    event.header.type, conn.get());</span><br><span class="line">        &#125; else if (err &lt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;发生致命错误，则清理该连接</span><br><span class="line">            removeDisplayEventConnection(signalConnections[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ET-waitForEvent"><a href="#ET-waitForEvent" class="headerlink" title="ET.waitForEvent"></a>ET.waitForEvent</h4><p>EventThread线程，进入mCondition的wait()方法，等待唤醒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        bool eventPending &#x3D; false;</span><br><span class="line">        bool waitForVSync &#x3D; false;</span><br><span class="line"></span><br><span class="line">        size_t vsyncCount &#x3D; 0;</span><br><span class="line">        nsecs_t timestamp &#x3D; 0;</span><br><span class="line">        for (int32_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">            timestamp &#x3D; mVSyncEvent[i].header.timestamp;</span><br><span class="line">            if (timestamp) &#123;</span><br><span class="line">                *event &#x3D; mVSyncEvent[i];</span><br><span class="line">                mVSyncEvent[i].header.timestamp &#x3D; 0;</span><br><span class="line">                vsyncCount &#x3D; mVSyncEvent[i].vsync.count;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!timestamp) &#123;</span><br><span class="line">            &#x2F;&#x2F;没有vsync事件，则查看其它事件</span><br><span class="line">            eventPending &#x3D; !mPendingEvents.isEmpty();</span><br><span class="line">            if (eventPending) &#123;</span><br><span class="line">                &#x2F;&#x2F;存在其它事件可用于分发</span><br><span class="line">                *event &#x3D; mPendingEvents[0];</span><br><span class="line">                mPendingEvents.removeAt(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;查找正在等待事件的连接</span><br><span class="line">        size_t count &#x3D; mDisplayEventConnections.size();</span><br><span class="line">        for (size_t i&#x3D;0 ; i&lt;count ; i++) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection(mDisplayEventConnections[i].promote());</span><br><span class="line">            if (connection !&#x3D; NULL) &#123;</span><br><span class="line">                bool added &#x3D; false;</span><br><span class="line">                if (connection-&gt;count &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;需要vsync事件，由于至少存在一个连接正在等待vsync</span><br><span class="line">                    waitForVSync &#x3D; true;</span><br><span class="line">                    if (timestamp) &#123;</span><br><span class="line">                        if (connection-&gt;count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            connection-&gt;count &#x3D; -1;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added &#x3D; true;</span><br><span class="line">                        &#125; else if (connection-&gt;count &#x3D;&#x3D; 1 ||</span><br><span class="line">                                (vsyncCount % connection-&gt;count) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added &#x3D; true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    &#x2F;&#x2F;没有vsync事件需要处理(timestamp&#x3D;&#x3D;0),但存在pending消息</span><br><span class="line">                    signalConnections.add(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;该连接已死亡，则直接清理</span><br><span class="line">                mDisplayEventConnections.removeAt(i);</span><br><span class="line">                --i; --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            &#x2F;&#x2F;接收到VSYNC，但没有client需要它，则直接关闭VSYNC</span><br><span class="line">            disableVSyncLocked();</span><br><span class="line">        &#125; else if (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            &#x2F;&#x2F;至少存在一个client，则需要使能VSYNC</span><br><span class="line">            enableVSyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            if (waitForVSync) &#123;</span><br><span class="line">                bool softwareSync &#x3D; mUseSoftwareVSync;</span><br><span class="line">                nsecs_t timeout &#x3D; softwareSync ? ms2ns(16) : ms2ns(1000);</span><br><span class="line">                if (mCondition.waitRelative(mLock, timeout) &#x3D;&#x3D; TIMED_OUT) &#123;</span><br><span class="line">                    mVSyncEvent[0].header.type &#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[0].header.id &#x3D; DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[0].header.timestamp &#x3D; systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[0].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;不存在对vsync感兴趣的连接，即将要进入休眠</span><br><span class="line">                mCondition.wait(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (signalConnections.isEmpty());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;到此处，则保证存在timestamp以及连接</span><br><span class="line">    return signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MQ-setEvenetThread"><a href="#MQ-setEvenetThread" class="headerlink" title="MQ.setEvenetThread"></a>MQ.setEvenetThread</h4><p>设置EventThread，并监听BitTube<br>创建一个BitTube对象mEventTube<br>创建一个EventConnection</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void MessageQueue::setEventThread(const sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">&#123;</span><br><span class="line">    mEventThread &#x3D; eventThread;</span><br><span class="line">    &#x2F;&#x2F;创建连接</span><br><span class="line">    mEvents &#x3D; eventThread-&gt;createEventConnection();</span><br><span class="line">    &#x2F;&#x2F;获取BitTube对象</span><br><span class="line">    mEventTube &#x3D; mEvents-&gt;getDataChannel();</span><br><span class="line">    &#x2F;&#x2F;监听BitTube，一旦有数据到来则调用cb_eventReceiver()</span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, Looper::EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-run"><a href="#SF-run" class="headerlink" title="SF.run"></a>SF.run</h4><p>主线程进入waitMessage状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::run() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;不断循环地等待事件</span><br><span class="line">        waitForEvent();</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::waitForEvent() &#123;</span><br><span class="line">    mEventQueue.waitMessage(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MessageQueue::waitMessage() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">        int32_t ret &#x3D; mLooper-&gt;pollOnce(-1);</span><br><span class="line">        ...</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Vsync信号处理"><a href="#Vsync信号处理" class="headerlink" title="Vsync信号处理"></a>Vsync信号处理</h3><p>HWComposer对象创建过程，会注册一些回调方法，当硬件产生VSYNC信号时，则会回调hook_vsync()方法。</p>
<h4 id="HWComposer-hook-vsync"><a href="#HWComposer-hook-vsync" class="headerlink" title="HWComposer.hook_vsync"></a>HWComposer.hook_vsync</h4><p>hook 监听Vysnc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void HWComposer::hook_vsync(const struct hwc_procs* procs, int disp,</span><br><span class="line">        int64_t timestamp) &#123;</span><br><span class="line">    cb_context* ctx &#x3D; reinterpret_cast&lt;cb_context*&gt;(</span><br><span class="line">            const_cast&lt;hwc_procs_t*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp); 】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HWComposer-vsync"><a href="#HWComposer-vsync" class="headerlink" title="HWComposer.vsync"></a>HWComposer.vsync</h4><p>Vsync信号回调，执行SF的onVSyncReceived方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void HWComposer::vsync(int disp, int64_t timestamp) &#123;</span><br><span class="line">    if (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line">            if (timestamp &#x3D;&#x3D; mLastHwVSync[disp]) &#123;</span><br><span class="line">                return; &#x2F;&#x2F;忽略重复的VSYNC信号</span><br><span class="line">            &#125;</span><br><span class="line">            mLastHwVSync[disp] &#x3D; timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-onVSyncReceived"><a href="#SF-onVSyncReceived" class="headerlink" title="SF.onVSyncReceived"></a>SF.onVSyncReceived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::onVSyncReceived(int type, nsecs_t timestamp) &#123;</span><br><span class="line">    bool needsHwVsync &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        if (type &#x3D;&#x3D; 0 &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            &#x2F;&#x2F; 此处mPrimaryDispSync为DispSync类 kai是分析DispSync</span><br><span class="line">            needsHwVsync &#x3D; mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        disableHardwareVsync(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DispSync构建"><a href="#DispSync构建" class="headerlink" title="DispSync构建"></a>DispSync构建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DispSync::DispSync() :</span><br><span class="line">        mRefreshSkipCount(0),</span><br><span class="line">        mThread(new DispSyncThread()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 运行在DispSync线程</span><br><span class="line">    mThread-&gt;run(&quot;DispSync&quot;, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    reset();</span><br><span class="line">    beginResync();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DispSyncThread线程"><a href="#DispSyncThread线程" class="headerlink" title="DispSyncThread线程"></a>DispSyncThread线程</h4><p>线程”DispSync”停留在mCond的wait()过程，等待被唤醒<br>当收集到Vsync信号后开始回调onDispSyncEvent方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">virtual bool threadLoop() &#123;</span><br><span class="line">     status_t err;</span><br><span class="line">     nsecs_t now &#x3D; systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">     nsecs_t nextEventTime &#x3D; 0;</span><br><span class="line"></span><br><span class="line">     while (true) &#123;</span><br><span class="line">         Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">         nsecs_t targetTime &#x3D; 0;</span><br><span class="line">         &#123; &#x2F;&#x2F; Scope for lock</span><br><span class="line">             Mutex::Autolock lock(mMutex);</span><br><span class="line">             if (mStop) &#123;</span><br><span class="line">                 return false;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (mPeriod &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                 err &#x3D; mCond.wait(mMutex);</span><br><span class="line">                 continue;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             nextEventTime &#x3D; computeNextEventTimeLocked(now);</span><br><span class="line">             targetTime &#x3D; nextEventTime;</span><br><span class="line">             bool isWakeup &#x3D; false;</span><br><span class="line"></span><br><span class="line">             if (now &lt; targetTime) &#123;</span><br><span class="line">                 err &#x3D; mCond.waitRelative(mMutex, targetTime - now);</span><br><span class="line">                 if (err &#x3D;&#x3D; TIMED_OUT) &#123;</span><br><span class="line">                     isWakeup &#x3D; true;</span><br><span class="line">                 &#125; else if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">                     return false;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             now &#x3D; systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">             if (isWakeup) &#123;</span><br><span class="line">                 mWakeupLatency &#x3D; ((mWakeupLatency * 63) +</span><br><span class="line">                         (now - targetTime)) &#x2F; 64;</span><br><span class="line">                 if (mWakeupLatency &gt; 500000) &#123;</span><br><span class="line">                     mWakeupLatency &#x3D; 500000;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             &#x2F;&#x2F;收集vsync信号的所有回调方法</span><br><span class="line">             callbackInvocations &#x3D; gatherCallbackInvocationsLocked(now);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (callbackInvocations.size() &gt; 0) &#123;</span><br><span class="line">             &#x2F;&#x2F;回调所有对象的onDispSyncEvent方法</span><br><span class="line">             fireCallbackInvocations(callbackInvocations);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return false;</span><br><span class="line"> &#125;   </span><br><span class="line"> </span><br><span class="line">void fireCallbackInvocations(const Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行DSP 的接受方法</span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DispSyncSource-onDispSyncEvent"><a href="#DispSyncSource-onDispSyncEvent" class="headerlink" title="DispSyncSource.onDispSyncEvent"></a>DispSyncSource.onDispSyncEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">virtual void onDispSyncEvent(nsecs_t when) &#123;</span><br><span class="line">    sp&lt;VSyncSource::Callback&gt; callback;</span><br><span class="line">    &#123;</span><br><span class="line">       Mutex::Autolock lock(mCallbackMutex);</span><br><span class="line">       callback &#x3D; mCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callback !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行 EventThread接受Vsync方法</span><br><span class="line">      callback-&gt;onVSyncEvent(when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EventThread-onVsyncEvent"><a href="#EventThread-onVsyncEvent" class="headerlink" title="EventThread.onVsyncEvent"></a>EventThread.onVsyncEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void EventThread::onVSyncEvent(nsecs_t timestamp) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mVSyncEvent[0].header.type &#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">    mVSyncEvent[0].header.id &#x3D; 0;</span><br><span class="line">    mVSyncEvent[0].header.timestamp &#x3D; timestamp;</span><br><span class="line">    mVSyncEvent[0].vsync.count++;</span><br><span class="line">    mCondition.broadcast(); &#x2F;&#x2F;唤醒EventThread线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EventThread-postEvent"><a href="#EventThread-postEvent" class="headerlink" title="EventThread.postEvent"></a>EventThread.postEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">status_t EventThread::Connection::postEvent(</span><br><span class="line">        const DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    ssize_t size &#x3D; DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1);</span><br><span class="line">    return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DisplayEventReceiver-sendEvents"><a href="#DisplayEventReceiver-sendEvents" class="headerlink" title="DisplayEventReceiver.sendEvents"></a>DisplayEventReceiver.sendEvents</h4><p>MQ.setEvenetThread监听BitTube，此处调用BitTube来sendObjects。一旦收到数据，则调用MQ.cb_eventReceiver()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t DisplayEventReceiver::sendEvents(const sp&lt;BitTube&gt;&amp; dataChannel,</span><br><span class="line">        Event const* events, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    return BitTube::sendObjects(dataChannel, events, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MQ-cb-eventReceiver"><a href="#MQ-cb-eventReceiver" class="headerlink" title="MQ.cb_eventReceiver"></a>MQ.cb_eventReceiver</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123;</span><br><span class="line">    MessageQueue* queue &#x3D; reinterpret_cast&lt;MessageQueue *&gt;(data);</span><br><span class="line">    return queue-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MQ-eventReceiver"><a href="#MQ-eventReceiver" class="headerlink" title="MQ.eventReceiver"></a>MQ.eventReceiver</h4><p>接受事件，分发dispatchInvalidate、dispatchRefresh<br>消息接收，执行SF的onMessageReceived</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int MessageQueue::eventReceiver(int &#x2F;*fd*&#x2F;, int &#x2F;*events*&#x2F;) &#123;</span><br><span class="line">    ssize_t n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[8];</span><br><span class="line">    while ((n &#x3D; DisplayEventReceiver::getEvents(mEventTube, buffer, 8)) &gt; 0) &#123;</span><br><span class="line">        for (int i&#x3D;0 ; i&lt;n ; i++) &#123;</span><br><span class="line">            if (buffer[i].header.type &#x3D;&#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">#if INVALIDATE_ON_VSYNC</span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line">#else</span><br><span class="line">                mHandler-&gt;dispatchRefresh(); </span><br><span class="line">#endif</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 发送refresh</span><br><span class="line">void MessageQueue::Handler::dispatchRefresh() &#123;</span><br><span class="line">    if ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送消息，则进入handleMessage过程【</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::REFRESH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; MQ的消息接受处理</span><br><span class="line">void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123;</span><br><span class="line">    switch (message.what) &#123;</span><br><span class="line">        case INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">        case REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">        case TRANSACTION:</span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SF-onMessageReceived"><a href="#SF-onMessageReceived" class="headerlink" title="SF.onMessageReceived"></a>SF.onMessageReceived</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::onMessageReceived(int32_t what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    switch (what) &#123;</span><br><span class="line">        case MessageQueue::TRANSACTION: &#123;</span><br><span class="line">            handleMessageTransaction();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            bool refreshNeeded &#x3D; handleMessageTransaction();</span><br><span class="line">            refreshNeeded |&#x3D; handleMessageInvalidate(); </span><br><span class="line">            refreshNeeded |&#x3D; mRepaintEverything;</span><br><span class="line">            if (refreshNeeded) &#123;</span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh(); &#x2F;&#x2F; 执行refresh流程</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-handleMessageRefresh"><a href="#SF-handleMessageRefresh" class="headerlink" title="SF.handleMessageRefresh"></a>SF.handleMessageRefresh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    &#x2F;&#x2F; 处理显示设备与 layers 的改变</span><br><span class="line">    preComposition(); </span><br><span class="line">    &#x2F;&#x2F; 重建所有layer，根据z轴排序</span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    &#x2F;&#x2F; 更新 HWComposer涂层</span><br><span class="line">    setUpHWComposer();</span><br><span class="line">    doDebugFlashRegions();</span><br><span class="line">    &#x2F;&#x2F; 生成OpenGL 纹理图像</span><br><span class="line">    doComposition();</span><br><span class="line">    &#x2F;&#x2F; 将图像传递到物理屏幕</span><br><span class="line">    postComposition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a><br>参考：<br><a href="https://blog.csdn.net/freekiteyu/article/details/79483406" target="_blank" rel="noopener">一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系</a><br><a href="http://gityuan.com/2017/02/11/surface_flinger/" target="_blank" rel="noopener">SurfaceFlinger启动篇</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/12/01/Android%E7%B3%BB%E7%BB%9F_Choreographer%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/12/01/Android%E7%B3%BB%E7%BB%9F_Choreographer%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Android系统_Choreographer分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-01 11:11:30" itemprop="dateCreated datePublished" datetime="2019-12-01T11:11:30+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:11:36" itemprop="dateModified" datetime="2020-02-07T01:11:36+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>基于API 23w</p>
</blockquote>
<h3 id="图文概述"><a href="#图文概述" class="headerlink" title="图文概述"></a>图文概述</h3><p>Choreographer 编舞者。统一动画、输入和绘制时机<br>Choreographer 的作用，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，即 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，来控制每一帧绘制操作的时机</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-cfbb74160f4104d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-ef306f7cf547c798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Choreographer启动流程"><a href="#Choreographer启动流程" class="headerlink" title="Choreographer启动流程"></a>Choreographer启动流程</h3><p>Window添加流程中，当Activity启动执行onResume后，会执行到创建ViewRootImpt <a href="https://www.jianshu.com/p/6571fbdd1bcb" target="_blank" rel="noopener">Android系统_Window的创建和添加流程分析</a></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; VoewRootImpl 构造方法 会获取Choreographer实例</span><br><span class="line">    mChoreographer &#x3D; Choreographer.getInstance();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer构造"><a href="#Choreographer构造" class="headerlink" title="Choreographer构造"></a>Choreographer构造</h4><p>通过单例模式构建，这里是每一个线程有一个Choreographer对象，而这里的线程为应用进程的主线程</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> public static Choreographer getInstance() &#123;</span><br><span class="line">    return sThreadInstance.get(); &#x2F;&#x2F;单例模式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance &#x3D;</span><br><span class="line">    new ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    protected Choreographer initialValue() &#123;</span><br><span class="line">        Looper looper &#x3D; Looper.myLooper(); &#x2F;&#x2F;获取当前线程的Looper</span><br><span class="line">        if (looper &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The current thread must have a looper!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Choreographer(looper); 创建</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer构造方法"><a href="#Choreographer构造方法" class="headerlink" title="Choreographer构造方法"></a>Choreographer构造方法</h4><p> 初始化一个Looper和一个FrameHandler变量用来处理消息，另外创建了一个 FrameDisplayEventReceiver用来请求和接受Vysnc事件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> private Choreographer(Looper looper) &#123;</span><br><span class="line">    mLooper &#x3D; looper;</span><br><span class="line">    &#x2F;&#x2F;创建Handler对象</span><br><span class="line">    mHandler &#x3D; new FrameHandler(looper);</span><br><span class="line">    &#x2F;&#x2F;创建用于接收VSync信号的对象 （使用Vsync同步机制情况下创建）</span><br><span class="line">    mDisplayEventReceiver &#x3D; USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;</span><br><span class="line">    &#x2F;&#x2F;是指上一次帧绘制时间点</span><br><span class="line">    mLastFrameTimeNanos &#x3D; Long.MIN_VALUE;</span><br><span class="line">    &#x2F;&#x2F;帧间时长，默认16.7ms.</span><br><span class="line">    mFrameIntervalNanos &#x3D; (long)(1000000000 &#x2F; getRefreshRate());</span><br><span class="line">    &#x2F;&#x2F;创建回调对象</span><br><span class="line">    mCallbackQueues &#x3D; new CallbackQueue[CALLBACK_LAST + 1];</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] &#x3D; new CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建FrameHandler"><a href="#创建FrameHandler" class="headerlink" title="创建FrameHandler"></a>创建FrameHandler</h4><p> Choreographer 处理绘制的逻辑核心在 Choreographer.doFrame 函数中，doFrame 函数主要做三件事情，计算掉帧逻辑、记录帧绘制信息、<br>执行 CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_INSETS_ANIMATION、CALLBACK_TRAVERSAL、CALLBACK_COMMIT</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> private final class FrameHandler extends Handler &#123;</span><br><span class="line">    public FrameHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case MSG_DO_FRAME:</span><br><span class="line">                doFrame(System.nanoTime(), 0);</span><br><span class="line">                break;</span><br><span class="line">            case MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                break;</span><br><span class="line">            case MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建FrameDisplayEventReceiver"><a href="#创建FrameDisplayEventReceiver" class="headerlink" title="创建FrameDisplayEventReceiver"></a>创建FrameDisplayEventReceiver</h4><p>它继承DisPlayEvetReceiver，调用父类构造方法<br>另外FrameDisplayEventReceiver中三个比较重要的方法</p>
<ul>
<li>onVsync – Vsync 信号回调</li>
<li>run – 执行 doFrame</li>
<li>scheduleVsync – 请求 Vsync 信号</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123;</span><br><span class="line">            </span><br><span class="line">        public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123;</span><br><span class="line">         super(looper, vsyncSource);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        @Override</span><br><span class="line">        public void onVsync(long timestampNanos, long physicalDisplayId, int frame) &#123;</span><br><span class="line">           ......</span><br><span class="line">           mTimestampNanos &#x3D; timestampNanos;</span><br><span class="line">           mFrame &#x3D; frame;</span><br><span class="line">           Message msg &#x3D; Message.obtain(mHandler, this);</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, timestampNanos &#x2F; TimeUtils.NANOS_PER_MS);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">           mHavePendingVsync &#x3D; false;</span><br><span class="line">           doFrame(mTimestampNanos, mFrame);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        public void scheduleVsync() &#123;</span><br><span class="line">           ......  </span><br><span class="line">           nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DisplayEventReceiver构造"><a href="#DisplayEventReceiver构造" class="headerlink" title="DisplayEventReceiver构造"></a>DisplayEventReceiver构造</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public DisplayEventReceiver(Looper looper) &#123;</span><br><span class="line">    mMessageQueue &#x3D; looper.getQueue(); &#x2F;&#x2F;获取主线程的消息队列</span><br><span class="line">    &#x2F;&#x2F; 通过JNI执行native层初始化</span><br><span class="line">    mReceiverPtr &#x3D; nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="android-view-DisplayEventReceiver-cpp-初始化"><a href="#android-view-DisplayEventReceiver-cpp-初始化" class="headerlink" title="android_view_DisplayEventReceiver.cpp 初始化"></a>android_view_DisplayEventReceiver.cpp 初始化</h4><p> 创建NativeDisplayEventReceiver， 监听mReceiver的所获取的文件句柄，一旦有数据到来，则回调this(此处NativeDisplayEventReceiver)中所复写LooperCallback对象的 handleEvent</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj) &#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue &#x3D; android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;创建NativeDisplayEventReceiver</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver &#x3D; new NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    status_t status &#x3D; receiver-&gt;initialize();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取DisplayEventReceiver对象的引用</span><br><span class="line">    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NativeDisplayEventReceiver继承于LooperCallback对象，此处mReceiverWeakGlobal记录的是Java层 DisplayEventReceiver对象的全局引用</span><br><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)),</span><br><span class="line">        mMessageQueue(messageQueue), mWaitingForVsync(false) &#123;</span><br><span class="line">    ALOGV(&quot;receiver %p ~ Initializing display event receiver.&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t NativeDisplayEventReceiver::initialize() &#123;</span><br><span class="line">    &#x2F;&#x2F;mReceiver为DisplayEventReceiver类型</span><br><span class="line">    status_t result &#x3D; mReceiver.initCheck();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;监听mReceiver的所获取的文件句柄。</span><br><span class="line">    int rc &#x3D; mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT,</span><br><span class="line">            this, NULL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callback添加流程"><a href="#Callback添加流程" class="headerlink" title="Callback添加流程"></a>Callback添加流程</h3><p>Choreographer提供postCallback和postFrameCallback两种回调方式及对应的delay两种，其最终执行的内部postCallbackDelayedInternal方法</p>
<h4 id="Choreographer-postCallbackDelayedInternal"><a href="#Choreographer-postCallbackDelayedInternal" class="headerlink" title="Choreographer.postCallbackDelayedInternal"></a>Choreographer.postCallbackDelayedInternal</h4><p>创建Callback，然后添加到mCallbackQueues队列上，<br>然后根据是否立即执行，决定是发消息还是直接调用<br>最终执行scheduleFrameLocked方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void postCallbackDelayedInternal(int callbackType,</span><br><span class="line">       Object action, Object token, long delayMillis) &#123;</span><br><span class="line">   synchronized (mLock) &#123;</span><br><span class="line">       &#x2F;&#x2F;当前时间</span><br><span class="line">       final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">       &#x2F;&#x2F;回调执行时间，&#x3D;当前时间+delay时间</span><br><span class="line">       final long dueTime &#x3D; now + delayMillis;</span><br><span class="line">       &#x2F;&#x2F;添加到callback队列</span><br><span class="line">mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">       if (dueTime &lt;&#x3D; now) &#123;</span><br><span class="line">           scheduleFrameLocked(now); &#x2F;&#x2F; 立即执行</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; 发送消息执行</span><br><span class="line">           Message msg &#x3D; mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">           msg.arg1 &#x3D; callbackType;</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Choreographer-scheduleFrameLocked"><a href="#Choreographer-scheduleFrameLocked" class="headerlink" title="Choreographer.scheduleFrameLocked"></a>Choreographer.scheduleFrameLocked</h4><p>使用Vsync，按时间执行到scheduleVsyncLocked方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void scheduleFrameLocked(long now) &#123;</span><br><span class="line">   if (!mFrameScheduled) &#123;</span><br><span class="line">       mFrameScheduled &#x3D; true;</span><br><span class="line">       if (USE_VSYNC) &#123;</span><br><span class="line">           &#x2F;&#x2F; If running on the Looper thread, then schedule the vsync immediately,</span><br><span class="line">           &#x2F;&#x2F; otherwise post a message to schedule the vsync from the UI thread</span><br><span class="line">           &#x2F;&#x2F; as soon as possible.</span><br><span class="line">           if (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">               &#x2F;&#x2F; 请求Vsync信号，最终会调用到native层，natie层处理完成后出发onVsync信号接收回调流程</span><br><span class="line">               scheduleVsyncLocked();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; 发送消息，delay后执行此方法</span><br><span class="line">               Message msg &#x3D; mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">               msg.setAsynchronous(true);</span><br><span class="line">               mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有使用Vsync 则直接发送msg，然后调用doFrame</span><br><span class="line">           final long nextFrameTime &#x3D; Math.max(</span><br><span class="line">                   mLastFrameTimeNanos &#x2F; TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">          </span><br><span class="line">           Message msg &#x3D; mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-scheduleVsyncLocked"><a href="#Choreographer-scheduleVsyncLocked" class="headerlink" title="Choreographer.scheduleVsyncLocked"></a>Choreographer.scheduleVsyncLocked</h4><p>执行FrameDisplayEventReceiver.scheduleVsync<br>di层向SurfaceFlinger服务注册，即下一次Vsync事件会调用DisplayEventReceiver的disptachVsync方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void scheduleVsyncLocked() &#123;</span><br><span class="line">   mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void scheduleVsync() &#123;</span><br><span class="line">    nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Vsync回调流程"><a href="#Vsync回调流程" class="headerlink" title="Vsync回调流程"></a>Vsync回调流程</h3><p> 当vysnc信号由底层HWC触发后会执行android_view_DisplayEventReceiver的handleEvent方法。<br> JNI层接受HWC的Vysnc信号，过滤处理，分发到Java层DisplayEventReceiver</p>
<h4 id="android-view-DisplayEventReceiver-handleEvent"><a href="#android-view-DisplayEventReceiver-handleEvent" class="headerlink" title="android_view_DisplayEventReceiver.handleEvent"></a>android_view_DisplayEventReceiver.handleEvent</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int NativeDisplayEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    nsecs_t vsyncTimestamp;</span><br><span class="line">    int32_t vsyncDisplayId;</span><br><span class="line">    uint32_t vsyncCount;</span><br><span class="line">    &#x2F;&#x2F;清除所有的pending事件，只保留最后一次vsync</span><br><span class="line">    if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;分发Vsync</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历所有的事件，当有多个VSync事件到来，则只关注最近一次的事件</span><br><span class="line">bool NativeDisplayEventReceiver::processPendingEvents(</span><br><span class="line">        nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123;</span><br><span class="line">    bool gotVsync &#x3D; false;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    ssize_t n;</span><br><span class="line">    while ((n &#x3D; mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123;</span><br><span class="line">        for (ssize_t i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            const DisplayEventReceiver::Event&amp; ev &#x3D; buf[i];</span><br><span class="line">            switch (ev.header.type) &#123;</span><br><span class="line">            case DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                gotVsync &#x3D; true; &#x2F;&#x2F;获取VSync信号</span><br><span class="line">                *outTimestamp &#x3D; ev.header.timestamp;</span><br><span class="line">                *outId &#x3D; ev.header.id;</span><br><span class="line">                *outCount &#x3D; ev.vsync.count;</span><br><span class="line">                break;</span><br><span class="line">            case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return gotVsync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 分发Vsync ，DisplayEventReceiver进行接受</span><br><span class="line">void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123;</span><br><span class="line">    JNIEnv* env &#x3D; AndroidRuntime::getJNIEnv();</span><br><span class="line"></span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));</span><br><span class="line">    if (receiverObj.get()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 此处调用到Java层的DisplayEventReceiver对象的dispatchVsync()方法，执行进入Java层</span><br><span class="line">        env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, &quot;dispatchVsync&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FrameDisplayEventReceiver-onVsync"><a href="#FrameDisplayEventReceiver-onVsync" class="headerlink" title="FrameDisplayEventReceiver.onVsync"></a>FrameDisplayEventReceiver.onVsync</h4><p>Java层接受Vsync事件，通过Handler通信机制发送消息，后续执行到它自身的run方法，然后执行doFrame操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final class FrameDisplayEventReceiver extends DisplayEventReceiver</span><br><span class="line">        implements Runnable &#123;</span><br><span class="line">    private boolean mHavePendingVsync;</span><br><span class="line">    private long mTimestampNanos;</span><br><span class="line">    private int mFrame;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mHavePendingVsync &#x3D; false;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mTimestampNanos &#x3D; timestampNanos;</span><br><span class="line">        mFrame &#x3D; frame;</span><br><span class="line">        &#x2F;&#x2F;该消息的callback为当前对象FrameDisplayEventReceiver</span><br><span class="line">        Message msg &#x3D; Message.obtain(mHandler, this);</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">        &#x2F;&#x2F;此处mHandler为FrameHandler</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos &#x2F; TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-doFrame"><a href="#Choreographer-doFrame" class="headerlink" title="Choreographer.doFrame"></a>Choreographer.doFrame</h4><ul>
<li>先判断Vsync信号间隔时间和刷新时间是否符合</li>
<li>顺序执行4种时间对应的CallbackQueue队列中注册的回调函数<ol>
<li>CALLBACK_INPUT : 处理输入事件处理有关</li>
<li>CALLBACK_ANIMATION ： 处理 Animation 的处理有关</li>
<li>CALLBACK_INSETS_ANIMATION ： 处理 Insets Animation 的相关回调</li>
<li>CALLBACK_TRAVERSAL : 处理和 UI 等控件绘制有关</li>
<li>CALLBACK_COMMIT ： 处理 Commit 相关回调</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void doFrame(long frameTimeNanos, int frame) &#123;</span><br><span class="line">    final long startNanos;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; 每调用一次scheduleFrameLocked()，则mFrameScheduled&#x3D;true，能执行一次doFrame()操作，执行完doFrame()并设置mFrameScheduled&#x3D;false；</span><br><span class="line">        if (!mFrameScheduled) &#123;</span><br><span class="line">            return; &#x2F;&#x2F; mFrameScheduled&#x3D;false，则直接返回。</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;原本计划的绘帧时间点</span><br><span class="line">        long intendedFrameTimeNanos &#x3D; frameTimeNanos;        </span><br><span class="line">        &#x2F;&#x2F;起始时间</span><br><span class="line">        startNanos &#x3D; System.nanoTime();</span><br><span class="line">        &#x2F;&#x2F;计算消息发送与函数调用开始之间所花费的时间</span><br><span class="line">        final long jitterNanos &#x3D; startNanos - frameTimeNanos;</span><br><span class="line">        &#x2F;&#x2F;如果线程处理该消息的时间超过了屏幕刷新周期</span><br><span class="line">        if (jitterNanos &gt;&#x3D; mFrameIntervalNanos) &#123;</span><br><span class="line">            &#x2F;&#x2F; 计算函数调用期间所错过的帧数</span><br><span class="line">            final long skippedFrames &#x3D; jitterNanos &#x2F; mFrameIntervalNanos;</span><br><span class="line">            &#x2F;&#x2F;当掉帧个数超过30，则输出相应log</span><br><span class="line">            if (skippedFrames &gt;&#x3D; SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, &quot;Skipped &quot; + skippedFrames + &quot; frames!  &quot;</span><br><span class="line">                        + &quot;The application may be doing too much work on its main thread.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            final long lastFrameOffset &#x3D; jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            &#x2F;&#x2F;对齐帧的时间间隔</span><br><span class="line">            frameTimeNanos &#x3D; startNanos - lastFrameOffset; </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;此处frameTimeNanos是底层VSYNC信号到达的时间戳，如果frameTimeNanos小于一个屏幕刷新周期，则重新请求VSync信号</span><br><span class="line">        if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        mFrameScheduled &#x3D; false;</span><br><span class="line">        mLastFrameTimeNanos &#x3D; frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;Choreographer#doFrame&quot;);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        &#x2F;&#x2F;执行4种事件对应的回调方法</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;标记动画开始时间</span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-doCallbacks"><a href="#Choreographer-doCallbacks" class="headerlink" title="Choreographer.doCallbacks"></a>Choreographer.doCallbacks</h4><ul>
<li>从队列头mHead查找CallbackRecord对象，当队列头部的callbacks对象为空或者执行时间还没到达，则直接返回；</li>
<li>开始执行相应回调的run()方法；</li>
<li>回收callbacks，加入对象池mCallbackPool，就是说callback一旦执行完成，则会被回收。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void doCallbacks(int callbackType, long frameTimeNanos) &#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        final long now &#x3D; System.nanoTime();</span><br><span class="line">        &#x2F;&#x2F; 从队列查找相应类型的CallbackRecord对象</span><br><span class="line">        callbacks &#x3D; mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now &#x2F; TimeUtils.NANOS_PER_MS);</span><br><span class="line">        if (callbacks &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;  &#x2F;&#x2F;当队列为空，则直接返回</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning &#x3D; true;</span><br><span class="line"></span><br><span class="line">        if (callbackType &#x3D;&#x3D; Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            final long jitterNanos &#x3D; now - frameTimeNanos;</span><br><span class="line">            &#x2F;&#x2F;当commit类型回调执行的时间点超过2帧，则更新mLastFrameTimeNanos。</span><br><span class="line">            if (jitterNanos &gt;&#x3D; 2 * mFrameIntervalNanos) &#123;</span><br><span class="line">                final long lastFrameOffset &#x3D; jitterNanos % mFrameIntervalNanos</span><br><span class="line">                        + mFrameIntervalNanos;</span><br><span class="line">                frameTimeNanos &#x3D; now - lastFrameOffset;</span><br><span class="line">                mLastFrameTimeNanos &#x3D; frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (CallbackRecord c &#x3D; callbacks; c !&#x3D; null; c &#x3D; c.next) &#123;</span><br><span class="line">            c.run(frameTimeNanos); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          mCallbacksRunning &#x3D; false;</span><br><span class="line">          &#x2F;&#x2F;回收callbacks，加入对象池mCallbackPool</span><br><span class="line">          do &#123;</span><br><span class="line">              final CallbackRecord next &#x3D; callbacks.next;</span><br><span class="line">              recycleCallbackLocked(callbacks);</span><br><span class="line">              callbacks &#x3D; next;</span><br><span class="line">          &#125; while (callbacks !&#x3D; null);</span><br><span class="line">      &#125;</span><br><span class="line">      Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CallbackRecord-run"><a href="#CallbackRecord-run" class="headerlink" title="CallbackRecord.run"></a>CallbackRecord.run</h4><ul>
<li>当token的数据类型为FRAME_CALLBACK_TOKEN，则执行该对象的doFrame()方法;</li>
<li>当token为其他类型，则执行该对象的run()方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static final class CallbackRecord &#123;</span><br><span class="line">    public CallbackRecord next;</span><br><span class="line">    public long dueTime;</span><br><span class="line">    public Object action; &#x2F;&#x2F; Runnable或者 FrameCallback</span><br><span class="line">    public Object token;</span><br><span class="line"></span><br><span class="line">    public void run(long frameTimeNanos) &#123;</span><br><span class="line">        if (token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-CALLBACK-TRAVERSAL"><a href="#Choreographer-CALLBACK-TRAVERSAL" class="headerlink" title="Choreographer.CALLBACK_TRAVERSAL"></a>Choreographer.CALLBACK_TRAVERSAL</h4><p>这里主要分析Traversal类型，即View的绘制流程</p>
<ul>
<li>ViewRootImpl.scheduleTraversals , 添加callback</li>
<li>回调 TraversalRunnable.run 方法</li>
<li>开始View的绘制流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">    if (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;为了提高优先级，先 postSyncBarrier</span><br><span class="line">        mTraversalBarrier &#x3D; mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 真正开始执行 measure、layout、draw</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void doTraversal() &#123;</span><br><span class="line">    if (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 这里把 SyncBarrier remove</span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        &#x2F;&#x2F; 真正开始</span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void performTraversals() &#123;</span><br><span class="line">      &#x2F;&#x2F; measure 操作</span><br><span class="line">      if (focusChangedDueToTouchMode || mWidth !&#x3D; host.getMeasuredWidth() || mHeight !&#x3D; host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; layout 操作</span><br><span class="line">      if (didLayout) &#123;</span><br><span class="line">          performLayout(lp, mWidth, mHeight);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; draw 操作</span><br><span class="line">      if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">          performDraw();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a><br>参考<br><a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a><br><a href="http://gityuan.com/2017/02/25/choreographer" target="_blank" rel="noopener">Choreographer原理</a><br><a href="https://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="noopener">源码分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://afree8909.github.io/blog/2019/11/27/Android%E7%B3%BB%E7%BB%9F_%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%9301/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Afree">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Afree's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/11/27/Android%E7%B3%BB%E7%BB%9F_%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%9301/" class="post-title-link" itemprop="url">Android系统_图形系统总结01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-27 21:42:01" itemprop="dateCreated datePublished" datetime="2019-11-27T21:42:01+08:00">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-07 01:11:23" itemprop="dateModified" datetime="2020-02-07T01:11:23+08:00">2020-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文基于API23源码</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-d0a3e5312975989d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录"></p>
<h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><h4 id="Android系统启动流程介绍"><a href="#Android系统启动流程介绍" class="headerlink" title="Android系统启动流程介绍"></a>Android系统启动流程介绍</h4><p><a href="https://www.jianshu.com/p/4d02ac462733" target="_blank" rel="noopener">Android系统_启动流程分析</a><br><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Android系统_Zygote启动流程分析</a><br><a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">Android系统_SystemServer启动流程分析</a><br><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">Android系统_ActivityManagerService启动流程</a><br><a href="https://www.jianshu.com/p/c7fb582987ad" target="_blank" rel="noopener">Android系统_进程创建流程分析</a><br><a href="https://www.jianshu.com/p/6df6ddac15d5" target="_blank" rel="noopener">Android系统_Launcher启动流程分析</a></p>
<h4 id="Android图形系统重要流程介绍"><a href="#Android图形系统重要流程介绍" class="headerlink" title="Android图形系统重要流程介绍"></a>Android图形系统重要流程介绍</h4><p><a href="https://www.jianshu.com/p/66eb92cca405" target="_blank" rel="noopener">Android系统_View.MeasureSpec分析</a><br><a href="https://www.jianshu.com/p/e893950d6cb3" target="_blank" rel="noopener">Android系统_View_LinearLayout.measure分析</a><br><a href="https://www.jianshu.com/p/c7859e02cf25" target="_blank" rel="noopener">Android系统_View.measure解析</a><br><a href="https://www.jianshu.com/p/f36b54feb7c5" target="_blank" rel="noopener">Android系统_View.layout解析</a><br><a href="https://www.jianshu.com/p/9b759b4a1aa5" target="_blank" rel="noopener">Android系统_View.draw解析</a><br><a href="https://www.jianshu.com/p/052c635a8853" target="_blank" rel="noopener">Android系统_WindowManagerService分析</a><br><a href="https://www.jianshu.com/p/6571fbdd1bcb" target="_blank" rel="noopener">Android系统_Window的创建和添加流程分析</a><br><a href="https://www.jianshu.com/p/956db9044cd8" target="_blank" rel="noopener">Android系统_Surface相关创建过程分析</a><br><a href="https://www.jianshu.com/p/c247013616d0" target="_blank" rel="noopener">Android系统_Surface绘制流程分析</a><br><a href="https://www.jianshu.com/p/538df44171b1" target="_blank" rel="noopener">Android系统_Choreographer工作流程分析</a><br><a href="https://www.jianshu.com/p/23a722df662f" target="_blank" rel="noopener">Android系统_SurfaceFlinger源码分析01</a></p>
<h3 id="一图以蔽之"><a href="#一图以蔽之" class="headerlink" title="一图以蔽之"></a>一图以蔽之</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-a39cc7b496fd8297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Android系统启动流程图文总结"><a href="#Android系统启动流程图文总结" class="headerlink" title="Android系统启动流程图文总结"></a>Android系统启动流程图文总结</h3><h4 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-9bdd9830df6844aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="进程创建流程"><a href="#进程创建流程" class="headerlink" title="进程创建流程"></a>进程创建流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-b317f94b27701458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="WMS启动流程"><a href="#WMS启动流程" class="headerlink" title="WMS启动流程"></a>WMS启动流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-1a6efe3e69764146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Launcher启动时序图"><a href="#Launcher启动时序图" class="headerlink" title="Launcher启动时序图"></a>Launcher启动时序图</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-2ade1db25b50bc50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="App、AMS、WMS三者关系类图"><a href="#App、AMS、WMS三者关系类图" class="headerlink" title="App、AMS、WMS三者关系类图"></a>App、AMS、WMS三者关系类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-8ed645ddb7c0855e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Android图形绘制流程图文总结"><a href="#Android图形绘制流程图文总结" class="headerlink" title="Android图形绘制流程图文总结"></a>Android图形绘制流程图文总结</h3><h4 id="Window的创建和添加流程"><a href="#Window的创建和添加流程" class="headerlink" title="Window的创建和添加流程"></a>Window的创建和添加流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-b817d3db3ce31ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Surface的创建时序图"><a href="#Surface的创建时序图" class="headerlink" title="Surface的创建时序图"></a>Surface的创建时序图</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-af8ac6a690297127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Surface的绘制流程"><a href="#Surface的绘制流程" class="headerlink" title="Surface的绘制流程"></a>Surface的绘制流程</h4><p>surface的绘制时序图 （软件绘制流程、硬件绘制待后续补充）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-770103d0b6d79ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="View的measure、layout、draw三大流程"><a href="#View的measure、layout、draw三大流程" class="headerlink" title="View的measure、layout、draw三大流程"></a>View的measure、layout、draw三大流程</h4><h5 id="View-measure-流程"><a href="#View-measure-流程" class="headerlink" title="View.measure 流程"></a>View.measure 流程</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-101ad3306d8fb489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="View-MeasureSpec-说明"><a href="#View-MeasureSpec-说明" class="headerlink" title="View.MeasureSpec 说明"></a>View.MeasureSpec 说明</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-e3eac09a50090ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="View-layout-流程"><a href="#View-layout-流程" class="headerlink" title="View.layout 流程"></a>View.layout 流程</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-0ce23ae06edca160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="View-draw-流程"><a href="#View-draw-流程" class="headerlink" title="View.draw 流程"></a>View.draw 流程</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-0bfd5198cdefa19c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Android图形Vsync信号刷新原理总结"><a href="#Android图形Vsync信号刷新原理总结" class="headerlink" title="Android图形Vsync信号刷新原理总结"></a>Android图形Vsync信号刷新原理总结</h3><p>Android系统确保帧缓存刷新、图形合成、图形绘制一致的原理 ？<br>引用一张图<br><img src="https://upload-images.jianshu.io/upload_images/9696036-a74b5b74f6eb0c0b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Vsync信号流转流程图 （看完图相信就知道上面的疑问了）<br><img src="https://upload-images.jianshu.io/upload_images/9696036-f015cda5adaad776.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/6/">6</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Afree</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Afree</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  


</body>
</html>
