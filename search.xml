<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP缓存原理</title>
    <url>/blog/2020/02/07/HTTP%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h3><p>HTTP缓存通常指浏览器缓存，基于HTTP中header字段实现<br>HTTP缓存分为强缓存和协商缓存，见下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-cce700528e23bc81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Cache-Control主要字段说明"><a href="#Cache-Control主要字段说明" class="headerlink" title="Cache-Control主要字段说明"></a>Cache-Control主要字段说明</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-2a26a690808fb292.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="缓存校验字段"><a href="#缓存校验字段" class="headerlink" title="缓存校验字段"></a>缓存校验字段</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-4656eec189b891ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="缓存字段对比"><a href="#缓存字段对比" class="headerlink" title="缓存字段对比"></a>缓存字段对比</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-0d9fb787867f2f04.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="HTTP缓存流程"><a href="#HTTP缓存流程" class="headerlink" title="HTTP缓存流程"></a>HTTP缓存流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-e9f7b43d56529039.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="为什么使用HTTP缓存"><a href="#为什么使用HTTP缓存" class="headerlink" title="为什么使用HTTP缓存"></a>为什么使用HTTP缓存</h3><p>终端缓存策略，可以缩短端到端的请求资源的距离，减少延迟，而且缓存重用，也能减少宽带流量，降低网络负荷。<br>最终用户体验和性能得到优化，避免无用资源请求浪费</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令大全</title>
    <url>/blog/2020/02/07/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/9696036-f719bd62f295b4fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="经典Git操作与对应区域图"></p>
<h2 id="Git库创建"><a href="#Git库创建" class="headerlink" title="Git库创建"></a>Git库创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 远程仓库克隆到本地</span><br><span class="line">git clone [ssh]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 本地构建仓库</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>以MAC系统，Git配置文件一般有两个配置文件，其作用域分别为全局级、仓库级</p>
<ol>
<li>全局级配置： ~/.gitconfig</li>
<li>仓库级配置： ${ProjectFile}/.git/.gitconfig</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看当前配置信息</span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置git用户信息</span><br><span class="line">git config [--local | --global] user.name &quot;[name]&quot;</span><br><span class="line">git config [--local | --global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>


<h2 id="Git分支相关"><a href="#Git分支相关" class="headerlink" title="Git分支相关"></a>Git分支相关</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 列出所有本地分支</span><br><span class="line">git branch </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有本地分支和远程分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出本地分支及其对应的远端分支，并附最新commit信息 （-v ）</span><br><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>

<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，指向指定commit</span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果本地有branch-name分支，则切换到该分支，如果没有切远程有branch-name分支，则直接以远程分支为基准创建branch-name本地分支</span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行本地分支 branch 追踪远端 remote-branch</span><br><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>

<h3 id="同步-amp-合并"><a href="#同步-amp-合并" class="headerlink" title="同步&amp;合并"></a>同步&amp;合并</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步远端变到本地</span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步远端变更，并与本地分支合并，可能有conflict</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并N个提交记录为一个</span><br><span class="line">git rebase -i HEAD~N</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 场景：个人分支 rebase 其它分支 ，（分支commit记录更清爽，相比merge操作少一个Merge commit）</span><br><span class="line">git rebase [branch]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并指定分支到当前分支</span><br><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>

<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上传当前分支到跟踪的远端分支</span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传本地指定分支到远程仓库</span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">git push [remote] --force</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除本地分支</span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除远端分支</span><br><span class="line">git push origin --delete [branch-name]</span><br></pre></td></tr></table></figure>


<h2 id="Git提交相关"><a href="#Git提交相关" class="headerlink" title="Git提交相关"></a>Git提交相关</h2><h3 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示当前分支的提交历史</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示当前分支的最近几次提交</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>


<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 提交暂存区到本地仓库区</span><br><span class="line">git commit </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交快捷方式 带message</span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交到上一次commit，可变更message</span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将某个commit，合并到当前分支</span><br><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个提交，并对指定commit后的所有变更进行回滚</span><br><span class="line">git revert [commit]</span><br></pre></td></tr></table></figure>

<h2 id="Git文件相关"><a href="#Git文件相关" class="headerlink" title="Git文件相关"></a>Git文件相关</h2><h3 id="查看-2"><a href="#查看-2" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示变更的文件</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示暂存区和工作区的差异</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加指定文件到工作区</span><br><span class="line">git add [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加所有文件到工作区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除工作区指定文件</span><br><span class="line">git rm [file]</span><br></pre></td></tr></table></figure>

<h3 id="撤销-1"><a href="#撤销-1" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 恢复暂存区的所有文件到工作区</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将所有工作区文件 存储到stash区</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将stash 存储区最上面的一个，恢复到工作区</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有的标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个tag</span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定commit傻姑娘新建一个tag</span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除本地tag</span><br><span class="line">git tag -d [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除远程tag</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 推送指定tag</span><br><span class="line">git push [remote] [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以指定某个分支的tag处新建一个分支</span><br><span class="line">git checkout -b [branch][tag]</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-70673e2d55e85b18.gif?imageMogr2/auto-orient/strip" alt=""></p>
]]></content>
      <categories>
        <category>开发效率</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title> Mac下Charles使用教程</title>
    <url>/blog/2020/02/07/%20Mac%E4%B8%8BCharles%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>Charles是常用的截取网络封包的工具，Mac、Windows和linux下均可用</p>
<h5 id="能做什么？"><a href="#能做什么？" class="headerlink" title="能做什么？"></a>能做什么？</h5><ul>
<li>支持截取Http和Https（支持SSL代理）网络封包，</li>
<li>支持流量控制，可以模拟慢网、弱网等case</li>
<li>支持AJAX调试，可以自动格式化json或xml</li>
<li>支持重发网络请求，进行后端压测</li>
<li>支持网络请求和响应内容的mock修改</li>
</ul>
<h5 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h5><p>fiddler、tcpdump</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="http://upload-images.jianshu.io/upload_images/9696036-18c68b1c63bbda25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h5 id="Charles安装"><a href="#Charles安装" class="headerlink" title="Charles安装"></a>Charles安装</h5><h5 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h5><h6 id="设置charles为设置成系统代理"><a href="#设置charles为设置成系统代理" class="headerlink" title="设置charles为设置成系统代理"></a>设置charles为设置成系统代理</h6><p><img src="http://upload-images.jianshu.io/upload_images/9696036-37301ef7e2d3438d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="开启Charles的代理功能"><a href="#开启Charles的代理功能" class="headerlink" title="开启Charles的代理功能"></a>开启Charles的代理功能</h6><p><img src="http://upload-images.jianshu.io/upload_images/9696036-18643fd001f9b826.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="手机连Charles"><a href="#手机连Charles" class="headerlink" title="手机连Charles"></a>手机连Charles<br></h6><ul>
<li>Mac上查IP Address</li>
<li>手机Wifi连对应服务器+端口（8888）</li>
<li>第一次连接好后，Charles会弹出对应询问框（<strong>连上才会有</strong>），点击allow开始使用</li>
</ul>
<h5 id="Https截取配置"><a href="#Https截取配置" class="headerlink" title="Https截取配置"></a>Https截取配置</h5><p>给Mac安装证书，并信任证书<br>给手机安装证书（需要安装伪CA证书）<br><img src="http://upload-images.jianshu.io/upload_images/9696036-65d4c371e6b4171d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Charles设置SSL代理<br><img src="http://upload-images.jianshu.io/upload_images/9696036-1ae0ba56926f6128.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><h5 id="模拟弱网"><a href="#模拟弱网" class="headerlink" title="模拟弱网"></a>模拟弱网</h5><p><img src="http://upload-images.jianshu.io/upload_images/9696036-cabadbe1187d5bab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="修改请求或响应内容"><a href="#修改请求或响应内容" class="headerlink" title="修改请求或响应内容"></a>修改请求或响应内容</h5><ul>
<li>Breakpoint<br>&emsp;临时性网络内容修改<br><img src="http://upload-images.jianshu.io/upload_images/9696036-2190372ba3f82220.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<ul>
<li>Rewrite<br>&emsp;适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。主要可以对某些匹配请求的header、host、url、path、query param、response status、body进行rewrite</li>
<li>Repeat<br>&emsp;用作接口压力测试</li>
<li>Map<br>&emsp;MapRemote重定向，适用于不同服务器切换测试<br>&emsp;MapLocal重定向到本地数据，适用于本地修改及时查看数据响应</li>
<li>DNS Spoofing Setting<br>&emsp;适用于需要将<strong>域名</strong>打到<strong>ip地址</strong>的服务器上</li>
</ul>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p><img src="http://upload-images.jianshu.io/upload_images/9696036-4dd5d0c100489910.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="常见坑"><a href="#常见坑" class="headerlink" title="常见坑"></a>常见坑</h3><h5 id="Charles与翻墙软件冲突"><a href="#Charles与翻墙软件冲突" class="headerlink" title="Charles与翻墙软件冲突"></a>Charles与翻墙软件冲突</h5><h5 id="Charles设置MapLocal在Android中出现乱码"><a href="#Charles设置MapLocal在Android中出现乱码" class="headerlink" title="Charles设置MapLocal在Android中出现乱码"></a>Charles设置MapLocal在Android中出现乱码</h5><p>原因：MapLocal的Response的Headers中Content-Type值为text/plain,没有指定编码，Android的网络解析框架如果不支持的话则会出现乱码<br>解决：Tools-&gt;Rewrite-&gt;Rewrite Rule<br><img src="http://upload-images.jianshu.io/upload_images/9696036-a93a904173cbe565.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="Charles连接不上"><a href="#Charles连接不上" class="headerlink" title="Charles连接不上"></a>Charles连接不上</h5><p>其它配置正确情况下，请先用网线试下，是否可以连接成功，如果可以的话，基本确认是Mac的wifi网络对手机不可见，如果属于公司网络，联系公司内网进行设置，保证手机和Mac的网段一致</p>
]]></content>
      <categories>
        <category>开发效率</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/blog/2020/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/9696036-b89e727f8e21dc43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-959c5e557465806f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/blog/2020/02/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个类只有一个实例，该实例必须自行创建，并且向整个系统提供这个实例</p>
<h3 id="实现考虑因素"><a href="#实现考虑因素" class="headerlink" title="实现考虑因素"></a>实现考虑因素</h3><ul>
<li>唯一性<ul>
<li>是否防克隆</li>
<li>是否防反射</li>
<li>是否防序列化 </li>
</ul>
</li>
<li>性能<ul>
<li>是否需要懒加载 </li>
<li>是否防指令重排（双重锁方式问题） </li>
</ul>
</li>
</ul>
<h3 id="三种实现方式"><a href="#三种实现方式" class="headerlink" title="三种实现方式"></a>三种实现方式</h3><table>
<thead>
<tr>
<th>实现</th>
<th>懒加载</th>
<th>线程安全</th>
<th>防克隆</th>
<th>防反射</th>
<th>防序列化</th>
</tr>
</thead>
<tbody><tr>
<td>双重锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>枚举</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="双重锁方式（添加了防御功能）"><a href="#双重锁方式（添加了防御功能）" class="headerlink" title="双重锁方式（添加了防御功能）"></a>双重锁方式（添加了防御功能）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton implements Serializable, Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Singleton sSingleton; &#x2F;&#x2F; volatile防止指令重排</span><br><span class="line">    private static boolean sFlag &#x3D; true;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        if(sFlag)&#123; &#x2F;&#x2F; 防反射</span><br><span class="line">            sFlag &#x3D; false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw new RuntimeException(&quot;对象已经存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if (sSingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (sSingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    sSingleton &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return getSingleton(); &#x2F;&#x2F; 防序列化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return getSingleton(); &#x2F;&#x2F; 防克隆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Instance &#123;</span><br><span class="line">    private Instance() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Holder &#123;</span><br><span class="line">        &#x2F;&#x2F; 类加载机制保证懒加载，static&amp;final确保线程安全</span><br><span class="line">        private static final Instance INSTANCE &#x3D; new Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类方式"><a href="#枚举类方式" class="headerlink" title="枚举类方式"></a>枚举类方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Single &#123;</span><br><span class="line">    SINGLE;</span><br><span class="line">    public void whateverMethod()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本等价于(除enum的防反射、序列化、克隆等属性)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Single&#123;</span><br><span class="line">    public static final Single SINGLE &#x3D; new Single();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           Singleton singleton &#x3D; Singleton.getSingleton();</span><br><span class="line">           testCloneSingleton(singleton);</span><br><span class="line">           testReflectSingleton(singleton);</span><br><span class="line">           testSerializableSingleton(singleton);</span><br><span class="line"></span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void testCloneSingleton(Singleton singleton) throws CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">       boolean equals &#x3D; singleton.equals(Singleton.getSingleton().clone());</span><br><span class="line"></span><br><span class="line">       System.out.print(equals);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void testReflectSingleton(Singleton singleton) throws Exception &#123;</span><br><span class="line">       Constructor constructor &#x3D; Singleton.class.getDeclaredConstructor();</span><br><span class="line">       constructor.setAccessible(true);</span><br><span class="line">       constructor.newInstance();</span><br><span class="line"></span><br><span class="line">       boolean equals &#x3D; singleton.equals(constructor.newInstance(););</span><br><span class="line"></span><br><span class="line">       System.out.print(equals);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void testSerializableSingleton(Singleton singleton) throws Exception &#123;</span><br><span class="line">       String tempFile &#x3D; &quot;tempFile&quot;;</span><br><span class="line">       ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(tempFile));</span><br><span class="line">       oos.writeObject(getSingleton());</span><br><span class="line">       ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(new File(tempFile)));</span><br><span class="line"></span><br><span class="line">       boolean equals &#x3D; singleton.equals(objectInputStream.readObject());</span><br><span class="line"></span><br><span class="line">       System.out.print(equals);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中HashMap分析</title>
    <url>/blog/2020/02/07/Java8%E4%B8%ADHashMap%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Put方法流程图"><a href="#Put方法流程图" class="headerlink" title="Put方法流程图"></a>Put方法流程图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-d3f845741e8a5756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>高16bit不变，低16bit和高16bit做了一个异或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><ul>
<li>map中存储的KV数目</li>
<li>值为2的n次幂<ul>
<li>哈希表是通过除法散列法，取模会用到除法运算，效率很低，而HashMap通过 h&amp;（length－1）替代取模</li>
<li>length 为2的整数次幂，是为了使不同hash值发生碰撞概率小即更均匀散列</li>
<li>length 的值为100..0，length－1为011..1，相当于对取模，而且保证了hash可以奇偶都有</li>
</ul>
</li>
</ul>
<h4 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h4><ul>
<li>阀值，=容量*loadFactor（负载因子，默认0.75）</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><ul>
<li>hash与旧链表大小做 &amp; 运算，=0不变，=1移动到原位置+旧链表大小的位置<br><img src="http://upload-images.jianshu.io/upload_images/9696036-07f14b44d2fd625b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h3 id="线程是否安全"><a href="#线程是否安全" class="headerlink" title="线程是否安全"></a>线程是否安全</h3><ul>
<li>JDK1.7，扩容前后链表导致，转移过程中修改了原来链表中节点引用关系，可能导致死循环</li>
<li>JDK1.8，不会引起死循环，但put／get不一定同步</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程—线程池理解</title>
    <url>/blog/2020/02/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的，合理使用线程有3个好处。</p>
<ol>
<li>降低资源消耗。通过重用已创建的线程来降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。通过已创建线程立即执行任务，减少了线程的创建时间</li>
<li>提高线程的可管理性。通过合理地使用线程池，从而实现统一分配、调优和监控等</li>
</ol>
<h3 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/9696036-bf3d2e726a5dd6d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15534290301842.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-d52f7d01a39f8a44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>ThreadPoolExecutor执行任务流程</strong></p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建线程来执行任务</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果BlockingQueue已满，则创建新的线程来处理任务</li>
<li>如果当前运行线程总数大于maximumPoolSize，任务将被拒绝执行。并调用RejectedExecutionHandler.rejectedExecution方法</li>
</ol>
<h3 id="线程池包结构"><a href="#线程池包结构" class="headerlink" title="线程池包结构"></a>线程池包结构</h3><p>线程池简要组成部分可以分三块，任务、任务执行者及工具类相关</p>
<ul>
<li>任务: Callable、Runnable、FutureTask</li>
<li>任务执行者：ThreadPoolExecutor、ScheduledThreadPoolExecutor</li>
<li>工具类：Executors</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-836ddd4f9b3c7f1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="ThreadPoolExecutor解析"><a href="#ThreadPoolExecutor解析" class="headerlink" title="ThreadPoolExecutor解析"></a>ThreadPoolExecutor解析</h3><p>Java线程池最核心的类即ThreadPoolExecutor，它是线程池的实现类。</p>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-ef17773e5dd66c5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul>
<li><p>WorkQueue: 任务阻塞队列，缓存将要执行的Runnable任务</p>
<ul>
<li>ArrayBlockingQueue：基于数组有界阻塞队列</li>
<li>LinkedBlockingQueue：基于链表阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列（读写须等待一并进行）</li>
<li>PriorityBlockingQueue：支持优先级的无界队列</li>
</ul>
</li>
<li><p>RejectedExecutionHandler：任务拒绝策略，默认AbortPolicy</p>
<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public ThreadPoolExecutor(</span><br><span class="line">     int corePoolSize,                   &#x2F;&#x2F; 核心线程数</span><br><span class="line">     int maximumPoolSize,                &#x2F;&#x2F; 最大线程数</span><br><span class="line">     long keepAliveTime,                 &#x2F;&#x2F; 非核心线程闲置回收时间</span><br><span class="line">     TimeUnit unit,                      &#x2F;&#x2F; 时间单位</span><br><span class="line">     BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 装载任务的阻塞队列                                              ThreadFactory threadFactory,             &#x2F;&#x2F; 线程创建工厂                        </span><br><span class="line">     RejectedExecutionHandler handler    &#x2F;&#x2F; 任务拒绝状态时处理策略</span><br><span class="line">     ) &#123; </span><br><span class="line">        &#x2F;&#x2F; ......                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 运行中</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 拒绝新任务</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 拒绝新任务且不处理剩余任务</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 所有线程停止，准备执行终止方法 </span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 已执行终止方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程状态 ctl值取低29位</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line"> &#x2F;&#x2F; 线程状态 ctl值取高3位</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">       int c &#x3D; ctl.get();</span><br><span class="line">       &#x2F;&#x2F; 首先，运行线程数是否小雨核心线程</span><br><span class="line">       if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           if (addWorker(command, true)) &#x2F;&#x2F; 创建核心线程</span><br><span class="line">               return;</span><br><span class="line">           c &#x3D; ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 其次，往队列中插入任务</span><br><span class="line">       if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           int recheck &#x3D; ctl.get();</span><br><span class="line">           if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">               addWorker(null, false);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 否则，创建非核心线程执行任务</span><br><span class="line">       else if (!addWorker(command, false))</span><br><span class="line">           reject(command); &#x2F;&#x2F; 如果上面都失败，则拒绝执行任务，调用handler</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="addWork"><a href="#addWork" class="headerlink" title="addWork()"></a>addWork()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 使用CAS机制轮训线程池的状态，如果处于SHTUTDOWN及以上状态则拒绝执行任务</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        boolean workerStarted &#x3D; false;</span><br><span class="line">        boolean workerAdded &#x3D; false;</span><br><span class="line">        Worker w &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            w &#x3D; new Worker(firstTask); &#x2F;&#x2F; 构建Worker（worker会创建thread）</span><br><span class="line">            final Thread t &#x3D; w.thread;</span><br><span class="line">            if (t !&#x3D; null) &#123;</span><br><span class="line">                final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    </span><br><span class="line">                    int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    if (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                        if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable</span><br><span class="line">                            throw new IllegalThreadStateException();</span><br><span class="line">                        workers.add(w); &#x2F;&#x2F; 新建woker线程加入集合保存</span><br><span class="line">                        int s &#x3D; workers.size();</span><br><span class="line">                        if (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize &#x3D; s;</span><br><span class="line">                        workerAdded &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                if (workerAdded) &#123;</span><br><span class="line">                    t.start(); &#x2F;&#x2F; 执行任务</span><br><span class="line">                    workerStarted &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Work类"><a href="#Work类" class="headerlink" title="Work类"></a>Work类</h5><p>TreadPoolExecutor内部类，Worker构造方法指定第一个要执行的任务，并通过线程工厂创建线程。<br>Worker为Runnable，可以执行run，即调用到外部类的runWorker方法<br>继承AbstractQueuedSynchronizer，执行每个任务前通过lock方法加锁，执行完后通过unlock释放锁，以防止运行中任务中断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;</span><br><span class="line">        final Thread thread;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        </span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask &#x3D; firstTask; </span><br><span class="line">            this.thread &#x3D; getThreadFactory().newThread(this); &#x2F;&#x2F; 构造的时候创建线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="runWork（）"><a href="#runWork（）" class="headerlink" title="runWork（）"></a>runWork（）</h5><p>每一个Worker在getTask()成功之后都要获取Worker的锁之后运行，也就是说运行中的Worker不会中断。因为核心线程一般在空闲的时候会一直阻塞在获取Task上，也只有中断才可能导致其退出。这些阻塞着的Worker就是空闲的线程（当然，非核心线程阻塞之后也是空闲线程）。如果设置了keepAliveTime&gt;0，那非核心线程会在空闲状态下等待keepAliveTime之后销毁，直到最终的线程数量等于corePoolSize</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">        Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">        Runnable task &#x3D; w.firstTask;</span><br><span class="line">        w.firstTask &#x3D; null;</span><br><span class="line">        w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">        boolean completedAbruptly &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        task.run(); &#x2F;&#x2F; 任务执行</span><br><span class="line">                    &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Error x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Throwable x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    task &#x3D; null;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly &#x3D; false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作</span><br><span class="line">            &#x2F;&#x2F;比如在corePoolSize跟maximumPoolSize之间的woker会进行回收</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="getTask（）"><a href="#getTask（）" class="headerlink" title="getTask（）"></a>getTask（）</h5><p>通过一个循环不断轮询任务队列有没有任务到来，首先判断线程池是否处于正常运行状态，根据超时配置有两种方法取出任务：<br>BlockingQueue.poll 阻塞指定的时间尝试获取任务，如果超过指定的时间还未获取到任务就返回null。<br>BlockingQueue.take 这种方法会在取到任务前一直阻塞。<br>keepAliveTime代表了线程池中的线程（即woker线程）的存活时间，如果到期则回收woker线程<br>FixedThreadPool使用的是take方法，所以会线程会一直阻塞等待任务。CachedThreadPool使用的是poll方法，也就是说CachedThreadPool中的线程如果在60秒内未获取到队列中的任务就会被终止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c &#x3D; ctl.get();</span><br><span class="line">            int rs &#x3D; runStateOf(c);</span><br><span class="line">            ......</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Are workers subject to culling?</span><br><span class="line">            boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            &#x2F;&#x2F; 超时配置时间，通过不同方法取任务</span><br><span class="line">            try &#123;</span><br><span class="line">                Runnable r &#x3D; timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line"></span><br><span class="line">                if (r !&#x3D; null)</span><br><span class="line">                    return r;</span><br><span class="line">                timedOut &#x3D; true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">                timedOut &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Executors构建线程方法"><a href="#Executors构建线程方法" class="headerlink" title="Executors构建线程方法"></a>Executors构建线程方法</h3><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>定长线程池：<br>可控制线程最大并发数（同时执行的线程数）<br>超出的线程会在队列中等待</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>可缓存线程池：<br>线程数无限制<br>有空闲线程则复用空闲线程，若无空闲线程则新建线程<br>一定程序减少频繁创建/销毁线程，减少系统开销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>单线程化的线程池：</p>
<p>有且仅有一个工作线程执行任务<br>所有任务按照指定顺序执行，即遵循队列的入队出队规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>支持定时以指定周期循环执行任务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Reference子类源码解析</title>
    <url>/blog/2020/02/07/Reference%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="SoftReference和WeakReference"><a href="#SoftReference和WeakReference" class="headerlink" title="SoftReference和WeakReference"></a>SoftReference和WeakReference</h3><p>我们知道这两个类基本功能相似，区别在于当引用对象为空的时候，WeakRefreence对象会在GC回收的时候被回收，而SoftReference则需要更苛刻的条件</p>
<h4 id="SoftReference实现原理"><a href="#SoftReference实现原理" class="headerlink" title="SoftReference实现原理"></a>SoftReference实现原理</h4><p>总结：GC回收时计算 SoftReference存活时间与剩余内存换算得出的时间进行大小比较（内存剩余空间*设定系数仅过换算规则计算得出），如果大于测认为需要回收，反之亦然</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;memory&#x2F;referenceProcessor.cpp</span><br><span class="line">if (rt &#x3D;&#x3D; REF_SOFT) &#123;</span><br><span class="line">    &#x2F;&#x2F; 是否需要清除软引用</span><br><span class="line">    if (!_current_soft_ref_policy-&gt;should_clear_reference(obj, _soft_ref_timestamp_clock)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; should_clear_reference 实现如下</span><br><span class="line">bool LRUMaxHeapPolicy::should_clear_reference(oop p,</span><br><span class="line">                                             jlong timestamp_clock) &#123;</span><br><span class="line">  jlong interval &#x3D; timestamp_clock - java_lang_ref_SoftReference::timestamp(p);</span><br><span class="line">  assert(interval &gt;&#x3D; 0, &quot;Sanity check&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The interval will be zero if the ref was accessed since the last scavenge&#x2F;gc.</span><br><span class="line">  if(interval &lt;&#x3D; _max_interval) &#123; &#x2F;&#x2F; 与_max_interval比较</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Capture state (of-the-VM) information needed to evaluate the policy</span><br><span class="line">void LRUMaxHeapPolicy::setup() &#123;</span><br><span class="line">  size_t max_heap &#x3D; MaxHeapSize;</span><br><span class="line">  max_heap -&#x3D; Universe::get_heap_used_at_last_gc();</span><br><span class="line">  max_heap &#x2F;&#x3D; M;</span><br><span class="line"></span><br><span class="line">  _max_interval &#x3D; max_heap * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">  &#x2F;&#x2F; _max_interval 计算</span><br><span class="line">  assert(_max_interval &gt;&#x3D; 0,&quot;Sanity check&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SoftReference对象记录两个时间，目的就是为了GC判断是否需要清除</span><br><span class="line">public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 由JVM负责更新的，记录了上一次GC发生的时间。</span><br><span class="line">    static private long clock;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每次调用 get 方法都会更新，记录了当前Reference最后一次被访问的时间。</span><br><span class="line">    private long timestamp;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent) &#123;</span><br><span class="line">        super(referent);</span><br><span class="line">        this.timestamp &#x3D; clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">        this.timestamp &#x3D; clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 和super.get的逻辑最大的不同，就在于每次调用get都会把上次发生GC的时间，也就是</span><br><span class="line">    &#x2F;&#x2F; clock 更新到 timestamp 中去。</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        T o &#x3D; super.get();</span><br><span class="line">        if (o !&#x3D; null &amp;&amp; this.timestamp !&#x3D; clock)</span><br><span class="line">            this.timestamp &#x3D; clock;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PhantomReference和Cleaner"><a href="#PhantomReference和Cleaner" class="headerlink" title="PhantomReference和Cleaner"></a>PhantomReference和Cleaner</h3><ul>
<li>不能访问到referent</li>
<li>Cleaner继承PhantomReference，它们本质流程都是Reference流程，有GC标记，ReferenceHandler处理</li>
<li>Cleaner的clean方法由ReferenceHandler调用，最终到thunk线程进行自定义资源回收处理，以及自己的释放</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; get方法永远是null，所以无法获得referent</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Cleaner extends PhantomReference&lt;Object&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; Reference需要Queue，但Cleaner自己管理ref，所以虚构个无用Queue</span><br><span class="line">    private static final ReferenceQueue&lt;Object&gt; dummyQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 所有的cleaner都会被加到一个双向链表中去，确保回收前这些Cleaner都是存活的。</span><br><span class="line">    static private Cleaner first &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private Cleaner</span><br><span class="line">        next &#x3D; null,</span><br><span class="line">        prev &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造的时候把自己加到双向链表中去</span><br><span class="line">    private static synchronized Cleaner add(Cleaner cl) &#123;</span><br><span class="line">        if (first !&#x3D; null) &#123;</span><br><span class="line">            cl.next &#x3D; first;</span><br><span class="line">            first.prev &#x3D; cl;</span><br><span class="line">        &#125;</span><br><span class="line">        first &#x3D; cl;</span><br><span class="line">        return cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; clean方法会调用remove把当前的cleaner从链表中删除。</span><br><span class="line">    private static synchronized boolean remove(Cleaner cl) &#123;</span><br><span class="line">        &#x2F;&#x2F; If already removed, do nothing</span><br><span class="line">        if (cl.next &#x3D;&#x3D; cl)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update list</span><br><span class="line">        if (first &#x3D;&#x3D; cl) &#123;</span><br><span class="line">            if (cl.next !&#x3D; null)</span><br><span class="line">                first &#x3D; cl.next;</span><br><span class="line">            else</span><br><span class="line">                first &#x3D; cl.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cl.next !&#x3D; null)</span><br><span class="line">            cl.next.prev &#x3D; cl.prev;</span><br><span class="line">        if (cl.prev !&#x3D; null)</span><br><span class="line">            cl.prev.next &#x3D; cl.next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Indicate removal by pointing the cleaner to itself</span><br><span class="line">        cl.next &#x3D; cl;</span><br><span class="line">        cl.prev &#x3D; cl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用户自定义的一个Runnable对象，</span><br><span class="line">    private final Runnable thunk;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有有构造函数，保证了用户无法单独地使用new来创建Cleaner。</span><br><span class="line">    private Cleaner(Object referent, Runnable thunk) &#123;</span><br><span class="line">        super(referent, dummyQueue);</span><br><span class="line">        this.thunk &#x3D; thunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 所有的Cleaner都必须通过create方法进行创建。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Cleaner create(Object ob, Runnable thunk) &#123;</span><br><span class="line">        if (thunk &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        return add(new Cleaner(ob, thunk));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Reference Handler线程调用，来清理资源。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void clean() &#123;</span><br><span class="line">        if (!remove(this))</span><br><span class="line">            return;</span><br><span class="line">        try &#123;</span><br><span class="line">            thunk.run();</span><br><span class="line">        &#125; catch (final Throwable x) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        if (System.err !&#x3D; null)</span><br><span class="line">                            new Error(&quot;Cleaner terminated abnormally&quot;, x)</span><br><span class="line">                                .printStackTrace();</span><br><span class="line">                        System.exit(1);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FinalReference和Finalizer"><a href="#FinalReference和Finalizer" class="headerlink" title="FinalReference和Finalizer"></a>FinalReference和Finalizer</h3><ul>
<li>它本质流程依然与Reference类似</li>
<li>Finalizer的构造是通过标志由JVM构造（JVM构造的时候会判断finalize方法是否非空，最终会调用到register进行构造）</li>
<li>Finalizer加入的queue会被Finalizer线程进行处理</li>
<li>finalize方法只会调用一次，通过hasBeenFinalized这个tag保证</li>
<li>⚠️ finalize可以通过获取referent复活对象，其中存在很多安全隐患</li>
<li>⚠️ FinalizerThread为守护线程，优先级很低，很有可能抢占不到资源而导致资源无法回收</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Reference和ReferenceQueue深入解读</title>
    <url>/blog/2020/02/07/Reference%E5%92%8CReferenceQueue%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="为什么需要引用？"><a href="#为什么需要引用？" class="headerlink" title="为什么需要引用？"></a>为什么需要引用？</h3><p>我们知道在最早的JVM实现里，是使用“跟踪回收”算法从GC ROOTS出发，按照BFS或者DFS遍历所有可达对象，针对不不可达对象进行回收。但随着Java演进，暴露出一些不能覆盖的场景，例如：某些场景下使用方希望在回收具体对象的同时还能辅助回收这个对象绑定的一些资源（如socket、堆外内存等）、某些场景下希望使用堆内缓存尽可能缓存更多更久的数据但不OOM。基于此，JDK在1.2引入了Refreence及其子类来支持一些新特性和功能</p>
<h3 id="Reference介绍"><a href="#Reference介绍" class="headerlink" title="Reference介绍"></a>Reference介绍</h3><h5 id="Reference类图"><a href="#Reference类图" class="headerlink" title="Reference类图"></a>Reference类图</h5><p><img src="https://upload-images.jianshu.io/upload_images/9696036-fec84bdd662d2c10.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><strong>FinalReference</strong>，一种保底策略，因为GC只能管理自动内存资源而无法管理其它资源（如堆外内存、file handle、socket等），这些需要使用方手动对资源进行管理</li>
<li><strong>SoftReference</strong>，软引用，只有在堆内存不足时，垃圾回收器会回收对应引用。所以比较适合用来实现不是特别重要的缓存</li>
<li><strong>WeakReference</strong>，弱引用，每次垃圾回收都会回收其引用，一般在需要控制内存但又又想要尽量用到内存的场景下使用</li>
<li><strong>PhantomReference</strong>，虚引用，对引用无影响，只用于获取对象被回收的通知。和软引用以及弱引用不同的是幻影引用指向的对象没有其他强引用、软引用指向时不会自动被GC清理。</li>
</ul>
<p>⚠️ 因为默认的引用就是强引用，所以没有强引用的Reference实现类。<br>详情：<a href="https://www.jianshu.com/p/7ff38dfbb5a8" target="_blank" rel="noopener">Reference子类源码解析</a></p>
<h4 id="Reference生命周期"><a href="#Reference生命周期" class="headerlink" title="Reference生命周期"></a>Reference生命周期</h4><p>Referent被GC回收，则会根据是持有ReferenceQueue，而加入到对应到ReferenceQueue中，这样可以通过RQ来监听reference是否回收状态</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-78514b107996e4a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Reference运行结构"><a href="#Reference运行结构" class="headerlink" title="Reference运行结构"></a>Reference运行结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-0bd5881d52164f6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Reference源码"><a href="#Reference源码" class="headerlink" title="Reference源码"></a>Reference源码</h4><h6 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h6><ul>
<li>referent：  引用指向的对象</li>
<li>queue： ReferenceQueue，Reference构造的时候传入，其内部封装了单向链表的添加，删除和遍历等操作。用于Reference状态监听及管理</li>
<li>discovered：单向链表，由JVM维护</li>
<li>next：指向ReferenceQueue中下一个元素，ReferenceQueue链表指针</li>
<li>pending：discovered链表表头，在referent被回收后的reference<br>将有JVM标记，等待入队处理</li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ul>
<li>static代码块：构造ReferenceHandler线程，循环执行tryHandlePending方法</li>
<li>tryHandlePending：循环处理pending链表头，维护discovered链表，如果pending不为空，则进行插入ReferenceQueue进行后续操作。（这里如果是cleaner，则先进行clean操作）</li>
</ul>
<h6 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h6><ul>
<li>ReferenceHandler，线程实现类，run方法中循环调用Refreence的静态方法tryHandlePending</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于控制垃圾回收器操作与Pending状态的Reference入队操作不冲突执行的全局锁</span><br><span class="line">&#x2F;&#x2F; 垃圾回收器开始一轮垃圾回收前要获取此锁</span><br><span class="line">&#x2F;&#x2F; 所以所有占用这个锁的代码必须尽快完成，不能生成新对象，也不能调用用户代码</span><br><span class="line">static private class Lock &#123; &#125;;</span><br><span class="line">private static Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        super(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个线程一直执行</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Reference&lt;Object&gt; r;</span><br><span class="line">            &#x2F;&#x2F; 获取锁，避免与垃圾回收器同时操作</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断pending-Reference链表是否有数据</span><br><span class="line">                if (pending !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果有Pending Reference，从列表中取出</span><br><span class="line">                    r &#x3D; pending;</span><br><span class="line">                    pending &#x3D; r.discovered;</span><br><span class="line">                    r.discovered &#x3D; null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果没有Pending Reference，调用wait等待</span><br><span class="line">                    &#x2F;&#x2F; </span><br><span class="line">                    &#x2F;&#x2F; wait等待锁，是可能抛出OOME的，</span><br><span class="line">                    &#x2F;&#x2F; 因为可能发生InterruptedException异常，然后就需要实例化这个异常对象，</span><br><span class="line">                    &#x2F;&#x2F; 如果此时内存不足，就可能抛出OOME，所以这里需要捕获OutOfMemoryError，</span><br><span class="line">                    &#x2F;&#x2F; 避免因为OOME而导致ReferenceHandler进程静默退出</span><br><span class="line">                    try &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; catch (OutOfMemoryError x) &#123; &#125;</span><br><span class="line">                    &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Reference是Cleaner，调用其clean方法</span><br><span class="line">            &#x2F;&#x2F; 这与Cleaner机制有关系，不在此文的讨论访问</span><br><span class="line">            if (r instanceof Cleaner) &#123;</span><br><span class="line">                ((Cleaner)r).clean();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 把Reference添加到关联的ReferenceQueue中</span><br><span class="line">            &#x2F;&#x2F; 如果Reference构造时没有关联ReferenceQueue，会关联ReferenceQueue.NULL，这里就不会进行入队操作了</span><br><span class="line">            ReferenceQueue&lt;Object&gt; q &#x3D; r.queue;</span><br><span class="line">            if (q !&#x3D; ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReferenceQueue源码"><a href="#ReferenceQueue源码" class="headerlink" title="ReferenceQueue源码"></a>ReferenceQueue源码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReferenceQueue&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 单向链表</span><br><span class="line">    private volatile Reference&lt;? extends T&gt; head &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; </span><br><span class="line">    &#x2F;* Called only by Reference class *&#x2F;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">		&#x2F;&#x2F; 判断Reference是否需要入队</span><br><span class="line">        ReferenceQueue&lt;?&gt; queue &#x3D; r.queue;</span><br><span class="line">        if ((queue &#x3D;&#x3D; NULL) || (queue &#x3D;&#x3D; ENQUEUED)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        assert queue &#x3D;&#x3D; this;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Reference入队后，其queue变量设置为ENQUEUED</span><br><span class="line">        r.queue &#x3D; ENQUEUED;</span><br><span class="line">        &#x2F;&#x2F; Reference的next变量指向ReferenceQueue中下一个元素</span><br><span class="line">        r.next &#x3D; (head &#x3D;&#x3D; null) ? r : head;</span><br><span class="line">        head &#x3D; r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        if (r instanceof FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Reference&lt;? extends T&gt; poll() &#123;</span><br><span class="line">        &#x2F;&#x2F; 出队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Reference类解决的三个问题"><a href="#Reference类解决的三个问题" class="headerlink" title="Reference类解决的三个问题"></a>Reference类解决的三个问题</h3><ul>
<li>实现特定的引用类型，支持不同功能</li>
<li>使用者可以在对象被回收后得到通知</li>
<li>使用者可以自定义回收，进行非GC回收的资源释放</li>
</ul>
<p>参考<br><a href="https://coldwalker.com/2019/02//gc_intro/" target="_blank" rel="noopener">https://coldwalker.com/2019/02//gc_intro/</a><br><a href="https://github.com/zxiaofan/JDK/blob/master/JDK1.8/src/java/lang/ref/ReferenceQueue.java" target="_blank" rel="noopener">https://github.com/zxiaofan/JDK/blob/master/JDK1.8/src/java/lang/ref/ReferenceQueue.java</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存相关总结</title>
    <url>/blog/2020/02/07/JVM%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="JVM大体结构图"><a href="#JVM大体结构图" class="headerlink" title="JVM大体结构图"></a>JVM大体结构图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-10ef43c4b4f8a6eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><ul>
<li>线程隔离数据区<ul>
<li>程序计算器<ul>
<li>当前线程执行字节码的行号指示器</li>
<li>如分支、循环、跳转、异常处理、线程恢复等</li>
</ul>
</li>
<li>虚拟机栈<ul>
<li>栈帧存储区域，栈帧包含局部变量、操作数栈、动态链接、方法出口等</li>
<li>异常情况，StackOverflowError、OutOfMemoryError</li>
</ul>
</li>
<li>本地方法栈 <ul>
<li>JNI服务使用的栈，作用于本地方法（C/C++） </li>
</ul>
</li>
</ul>
</li>
<li>线程共享数据区<ul>
<li>Java堆<ul>
<li>存储对象实例</li>
<li>异常情况， OutOfMemoryError、内存泄漏</li>
</ul>
</li>
<li>方法区 <ul>
<li>存储加载的类信息、常量、静态变量、JIT编译后的代码等数据</li>
<li>异常情况，OutOfMemoryError</li>
<li>运行时常量池，字面量、符号引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象创建与回收过程"><a href="#对象创建与回收过程" class="headerlink" title="对象创建与回收过程"></a>对象创建与回收过程</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-a2f5045f5ab5eccb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="JVM垃圾收集算法"><a href="#JVM垃圾收集算法" class="headerlink" title="JVM垃圾收集算法"></a>JVM垃圾收集算法</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul>
<li>内存分成大小相等的两块，每次使用其中一块，回收的时候，把存活的对象复制到另一块，然后把这块内存整个清理掉</li>
<li>优点，回收效率提高、不存在碎片化</li>
<li>缺点，内存利用率低</li>
<li>解决，采用非对称法，eden:survivor = 8:1<br><img src="http://upload-images.jianshu.io/upload_images/9696036-c07b3961929e9872.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><ul>
<li>标记阶段，确定所有要回收的对象，做标记</li>
<li>清除阶段，将标记阶段确定的回收对象进行清除</li>
<li>优点，简单，最基础算法 </li>
<li>缺点，效率低，碎片化<br><img src="http://upload-images.jianshu.io/upload_images/9696036-af74e3fbdcf1e7ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><ul>
<li>把存活对象移动到内存的一端，然后直接回收边界以外的内存</li>
<li>场景,适合老年代存活对象较多的情况，减少内存复制量</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-2af17d66179a1ad3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-8457b2b3c2eae67d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Serial-SerialOld"><a href="#Serial-SerialOld" class="headerlink" title="Serial/SerialOld"></a>Serial/SerialOld</h4><ul>
<li>过程<ol>
<li>收集GC_ROOTS</li>
<li>对象可达性分析</li>
<li>标记垃圾对象</li>
<li>清理垃圾对象 </li>
</ol>
</li>
<li>优点，简单高效    </li>
<li>缺点，STW，服务停顿时间长 </li>
<li>场景，几百兆以内客户端程序<br><img src="http://upload-images.jianshu.io/upload_images/9696036-1f48e73d09b24f8b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="Parnew-Parallel-Scavenge-Parallel-Old"><a href="#Parnew-Parallel-Scavenge-Parallel-Old" class="headerlink" title="Parnew/Parallel Scavenge/Parallel Old"></a>Parnew/Parallel Scavenge/Parallel Old</h4><h5 id="Serial算法多线程版"><a href="#Serial算法多线程版" class="headerlink" title="Serial算法多线程版"></a>Serial算法多线程版</h5><ul>
<li>优点，多线程，回收速度快 </li>
<li>缺点，依然会暂停服务</li>
<li>场景，对响应时间要求不高的Server端</li>
</ul>
<p>ParNew与Parallel Scanvenge区别</p>
<ul>
<li>Parnew关注回收速度，多线程减少单词GC时间</li>
<li>Parallel Scanvenge关注吞吐量，减少GC时间占比<br><img src="http://upload-images.jianshu.io/upload_images/9696036-ba913709dfc65c9c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="CMS-Concurrent-Mark-Sweep-算法"><a href="#CMS-Concurrent-Mark-Sweep-算法" class="headerlink" title="CMS(Concurrent Mark Sweep)算法"></a>CMS(Concurrent Mark Sweep)算法</h4><ul>
<li>优点，并发，暂停时间短</li>
<li>缺点，耗CPU、GC时间长，GC提前，浮动垃圾，碎片化</li>
<li>场景，对响应时间敏感的Server服务，大部分线上服务应该是CMS<br><img src="http://upload-images.jianshu.io/upload_images/9696036-6c2a95b66e1b3040.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h4><ul>
<li>新一代垃圾回收算法</li>
<li>场景，大内存、高响应的服务端应用<br><img src="http://upload-images.jianshu.io/upload_images/9696036-9fd6fdd04512a592.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h3 id="JVM工具集"><a href="#JVM工具集" class="headerlink" title="JVM工具集"></a>JVM工具集</h3><h4 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h4><ul>
<li>查看当前用户java进程，类似于ps</li>
<li>-q 只输出LVMID(与PID一致)，省略主类的名称 </li>
<li>-m 输出启动时传递给主类main函数的参数</li>
<li>-l 输出主类的全名，如果是jar包，输出jar路径</li>
<li>-v 输出启动时的jvm参数</li>
</ul>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><ul>
<li>用于监视虚拟机各种运行状态信息，例如类装载、内存、垃圾收集、 jit编译等运行参数</li>
<li>-class 监视类装载、卸载数量、总空间以及装载所耗费时间等</li>
<li>-gc 监视java堆状况，包括eden区，survivor区，老年代，永久代的容量、已用 空间和 GC时间等信息</li>
<li>-gcnew 监视新生代GC状况</li>
<li>-gcold 监视老年代GC状况</li>
<li>-compiler 输出JIT编译器编译过的方法、耗时等信息</li>
</ul>
<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul>
<li>java内存映像工具，用于生成堆转储快照，即dump文件，结合JHAT、MAT或者VisualVM等软件 来分析java内存的详细使用情况，便于排查java内存问题</li>
<li>-dump 生成堆转储快照</li>
<li>-finalizerinfo 显示在等待执行finalize方法的对象</li>
<li>-heap 显示java堆详细信息，如使用的回收器、参数配置、分代状况等</li>
<li>-histo 显示堆中对象统计信息，包括类、实例数量、合计容量等</li>
<li>-permstat 以classloader为统计口径显示永久代内存状态</li>
<li>-F 强制生成堆转出快照</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://plumbr.io/handbook/what-is-garbage-collection" target="_blank" rel="noopener">https://plumbr.io/handbook/what-is-garbage-collection</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象生命周期</title>
    <url>/blog/2020/02/06/Java%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="Java对象生命周期图"><a href="#Java对象生命周期图" class="headerlink" title="Java对象生命周期图"></a>Java对象生命周期图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-0dd562d1863f77b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="创建阶段（Created）"><a href="#创建阶段（Created）" class="headerlink" title="创建阶段（Created）"></a>创建阶段（Created）</h3><ul>
<li>分配存储空间</li>
<li>开始构造对象</li>
<li>父类到子类依次初始化类变量</li>
<li>父类成员初始化，父类构造函数初始化</li>
<li>子类成员初始化，子类构造函数初始化</li>
</ul>
<h3 id="应用阶段（In-Use）"><a href="#应用阶段（In-Use）" class="headerlink" title="应用阶段（In Use）"></a>应用阶段（In Use）</h3><p>对象被一个或多个强引用持有，并且在作用域内</p>
<h3 id="不可见阶段（Invisible）"><a href="#不可见阶段（Invisible）" class="headerlink" title="不可见阶段（Invisible）"></a>不可见阶段（Invisible）</h3><p>其它区域已经不可以再引用它，本地变量超出了可见范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        Object a &#x3D; new Object();</span><br><span class="line">    &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    a.clone(); &#x2F;&#x2F; 该区域a不可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不可达阶段（Unreachable）"><a href="#不可达阶段（Unreachable）" class="headerlink" title="不可达阶段（Unreachable）"></a>不可达阶段（Unreachable）</h3><p>不再被任何强引用所持有</p>
<h3 id="收集阶段（Collected）"><a href="#收集阶段（Collected）" class="headerlink" title="收集阶段（Collected）"></a>收集阶段（Collected）</h3><p>对象不可达，并且垃圾回收器已经对该对象的内存空间重新分配做好准备时</p>
<h3 id="终结阶段（Finalized）"><a href="#终结阶段（Finalized）" class="headerlink" title="终结阶段（Finalized）"></a>终结阶段（Finalized）</h3><p>对象执行完finalize方法后，等待垃圾回收器对对象空间进行回收</p>
<h3 id="对象重新分配阶段（Deallocated）"><a href="#对象重新分配阶段（Deallocated）" class="headerlink" title="对象重新分配阶段（Deallocated）"></a>对象重新分配阶段（Deallocated）</h3><p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，此时称为对象空间重新分配阶段</p>
<h3 id="子父类代码执行顺序图"><a href="#子父类代码执行顺序图" class="headerlink" title="子父类代码执行顺序图"></a>子父类代码执行顺序图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-ad430f40c254dee1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/blog/2020/02/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h3 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>“通过一个类的全限定名来获取描述此类的二进制字节流。” ——实现这个动作的代码模块称为类加载器。</p>
<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><ul>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为 JVM 方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li>如果想维持双亲委派机制，则覆写findClass方法</li>
<li>如果想打破双亲委派机制，则覆写loadClass方法</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-bdec0871909f7e63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h5><ul>
<li><p>Java类库的隔离：不同应用程序使用不同的类加载器，可以实现Java类库的隔离。</p>
</li>
<li><p>Java类库的共享：通过Common类加载器和Shared类加载器可以实现Java类库的共享。</p>
</li>
<li><p>安全：服务器和应用程序有各自的类加载器加载Class文件。服务器的类库与应用程序的类库可以互相独立。</p>
</li>
<li><p>支持HotSwap（热替换）：JSP文件有独立的类加载器，服务器能通过替换JSP文件的类加载器来实现JSP的HotSwap功能。</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-6c2d2a58d8a20614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="Android类加载图"><a href="#Android类加载图" class="headerlink" title="Android类加载图"></a>Android类加载图</h3><h4 id="加载阶段-1"><a href="#加载阶段-1" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>通过一个dex文件或者apk文件的路径完成类的加载</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>BootClassLoader，主要用于加载系统的类，包括java和Android系统的类库</li>
<li>PathClassLoader，主要用于加载应用内中的类，路径是固定的，只能加载/data/app中的apk，无法指定dex路径</li>
<li>DexClassLoader，可任意加载.apk、zip或jar等，实现动态加载</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9696036-635865c5ccbce353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>类加载器相关应用，插件化、热补等</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类生命周期</title>
    <url>/blog/2020/02/06/Java%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="Java类生命周期图"><a href="#Java类生命周期图" class="headerlink" title="Java类生命周期图"></a>Java类生命周期图</h3><p> <img src="http://upload-images.jianshu.io/upload_images/9696036-fbfb4eb49ba287ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li>验证是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>
<li>包括文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li>类变量分配内存，并设为jvm默认的初始值</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>将常量池内的符号引用替换为直接引用的过程</li>
<li>主要针对类或接口、字段、类方法、接口方法四类符号引用进行解析</li>
<li>符号引用<ul>
<li>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中</li>
</ul>
</li>
<li>直接引用<ul>
<li>可以是直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化阶段是执行类构造器clinit方法的过程</li>
<li>clinit方法<ul>
<li>由编译器自动收集所有类变量（静态非final） 赋值操作和静态代码块语句合并产生</li>
<li>收集顺序由出现顺序决定，定义在前面的不能访问定义在后面的类变量</li>
<li>虚拟机保证父类clinit方法先于子类clinit方法执行</li>
<li>类或接口不一定都有clinit方法</li>
<li>虚拟机保证clinit方法在多线程环境下被正确的加锁和同步</li>
</ul>
</li>
<li>时机<ul>
<li>new、操作该类类变量、调用类方法</li>
<li>对类反射</li>
<li>子类初始化的时候，父类还没有初始化，则会先进行父类初始化</li>
<li>main函数对应的类</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>参考对象生命周期</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>jvm回收条件</p>
<ul>
<li>该类所有的实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>Class对象没有任何地方被引用，且无法在任何地方通过反射访问该类的方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>Android线程消息机制</title>
    <url>/blog/2020/02/06/Android%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android应用程序有主线程和子线程之分，其中主线程由AMS请求Zygote进程创建；而子线程则由主线程或者其它子线程创建。我们知道Android规定只能在主线程中执行与界面相关工作（严格意义是界面创建元素对应的线程），一旦我们在主线程执行的任务过重，就可能导致UI绘制无法及时完成，产生掉帧现象，或者更严重直接ANR。所以为了避霾类似问题，我们需要多线程技术方案，把那些复杂或者非重要的任务移到其它线程执行，来提升体验。<br>我们知道对于不定期的后台任务，一般有两种处理方式。第一种方式是每当条件满足的时，就创建一个子线程来执行一个不定期的后台任务，当这个不定期的任务执行完成之后，这个新创建子线程就随之推出。第二种方式是创建一个具有消息循环的子线程，每当条件满足时，就将一个不定期后台任务封装成一个消息发送到子线程的消息队列中去执行，而当条件不满足时，这个子线程就会因问它的消息队列为空而进入睡眠等待状态。虽然第一种方式创建的子线程不需要消息循环机制，但是频繁的创建和销毁子线程是有代价的，因此更倾向于第二种方式来执行那些不定期的后台任务。Android应用程序主线程和子线程都是具有消息循环机制的。<br>下面我们将从Android消息机制原理、Android线程消息循环模型和Android线程和线程池进行全面理解。</p>
<h3 id="Android消息机制"><a href="#Android消息机制" class="headerlink" title="Android消息机制"></a>Android消息机制</h3><p>Android的消息机制主要指Handler的运行机制及它附带的MessageQueue和Looper的工作过程。</p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p><strong>主要用途</strong></p>
<ol>
<li>在未来某个时间点处理 Messages 或者执行 Runnables</li>
<li>将任务切换到另一个线程执行</li>
</ol>
<p><strong>源码分析</strong><br>大致流程：构造Handler -&gt; 发送Runnable -&gt; 组合Message -&gt; Message入队 -&gt; Looper轮训Message执行任务 -&gt; 取Message对应Handler执行消息回调处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 字段</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Set this flag to true to detect anonymous, local or member classes</span><br><span class="line"> * that extend this Handler class and that are not static. These kind</span><br><span class="line"> * of classes can potentially create leaks.</span><br><span class="line"> * 非static的匿名内部类、局部变量或成员变量都将可能造成内存泄漏</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final boolean FIND_POTENTIAL_LEAKS &#x3D; false;</span><br><span class="line">final Looper mLooper; &#x2F;&#x2F; 持有对应Looper，获取对应queue</span><br><span class="line">final MessageQueue mQueue; &#x2F;&#x2F; 持有对应的消息队列，进行消息入队操作</span><br><span class="line">final Callback mCallback; &#x2F;&#x2F; hook，非null 优先回调处理消息</span><br><span class="line">final boolean mAsynchronous; &#x2F;&#x2F; 是否异步消息标识</span><br><span class="line">IMessenger mMessenger; &#x2F;&#x2F; 作用进程间通信</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数 Handler持有对应线程的Looper，同时持有对应Looper的MessageQueue</span><br><span class="line">public Handler() &#123;  ...  &#125;</span><br><span class="line">public Handler(Callback) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper,Callback) &#123;  ...  &#125;</span><br><span class="line">public Handler(boolean) &#123;  ...  &#125;</span><br><span class="line">public Handler(Callback,boolean) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper,Callback,boolean) &#123;  ...  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post方法，针对不同执行时间的Runnable的方法，最终Runnable转为Message，调用发消息方法插入队列</span><br><span class="line">public final boolean post(Runnable r)&#123; ... &#125;</span><br><span class="line">public final boolean postAtFrontOfQueuepo(Runnable r)&#123; ... &#125;</span><br><span class="line">public final boolean postAtTime(Runnable r,long uptimeMillis)&#123; ... &#125;</span><br><span class="line">public final boolean postAtTime(Runnable r,Object token,long uptimeMillis)&#123; ... &#125;</span><br><span class="line">public final boolean postDelayed(Runnable r,long delayMillis)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将runnable转为Message</span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;...&#125;</span><br><span class="line">private static Message getPostMessage(Runnable r, Object token) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  sendMessage方法，内部实现就是将Message入MessageQueue</span><br><span class="line">public final boolean sendMessage(Message msg)&#123; ... &#125;</span><br><span class="line">public final boolean sendEmptyMessage(int what)&#123; ... &#125;</span><br><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis)&#123; ... &#125;</span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; ... &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Message插入MessageQueue，</span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this; &#x2F;&#x2F; 指定Msg处理对象为当前Handler</span><br><span class="line">    if (mAsynchronous) &#123; &#x2F;&#x2F; 是否异步消息，即跳过屏障执行。</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis); &#x2F;&#x2F; 执行等待时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Looper轮训到执行任务消息时，便调用Message的target即此Handler的这个发送消息方法进行处理</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback !&#x3D; null) &#123; &#x2F;&#x2F; 优先尝试msg的callback回调</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback !&#x3D; null) &#123; &#x2F;&#x2F; Handler构造callBack</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg); &#x2F;&#x2F; 子类实现处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>数据结构主要包含一个int标识，一个long执行时间标识，一个Object数据传输对象，一个Bundle类型data存储对象，记录对应的Hanlder对象。<br>另外维护了一个默认50大小的单链表，用于Message创建，后续系统会回收Message</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个可以发送给 Handler 的消息，包含描述和任意数据对象。消息对象有两个额外的 int 字段和一个 object 字段，这可以满足大部分场景的需求了。</span><br><span class="line">&#x2F;&#x2F; 推荐通过Message.obtain()构建Message而不是直接new，里面维护了默认50大小的链表Message的sPool </span><br><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line">    public int what; &#x2F;&#x2F; 消息标识</span><br><span class="line">    public Object obj; &#x2F;&#x2F; 消息数据存储，用于非bundle传输</span><br><span class="line">    &#x2F;&#x2F; Flag标识（是否使用、是否异步消息）</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAG_IN_USE &#x3D; 1 &lt;&lt; 0;</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAG_ASYNCHRONOUS &#x3D; 1 &lt;&lt; 1;</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAGS_TO_CLEAR_ON_COPY_FROM &#x3D; FLAG_IN_USE;</span><br><span class="line">    &#x2F;*package*&#x2F; int flags;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*package*&#x2F; long when; &#x2F;&#x2F; 执行时间</span><br><span class="line">    &#x2F;*package*&#x2F; Bundle data; &#x2F;&#x2F; 非obj传输情况</span><br><span class="line">    &#x2F;*package*&#x2F; Handler target; &#x2F;&#x2F; 发送的Handler</span><br><span class="line">    &#x2F;*package*&#x2F; Runnable callback; &#x2F;</span><br><span class="line">    &#x2F;&#x2F; sometimes we store linked lists of these things</span><br><span class="line">    &#x2F;*package*&#x2F; Message next; &#x2F;&#x2F; Message单链表指向 </span><br><span class="line"></span><br><span class="line">    private static final Object sPoolSync &#x3D; new Object();</span><br><span class="line">    private static Message sPool; &#x2F;&#x2F; Message 链表池</span><br><span class="line">    private static int sPoolSize &#x3D; 0;</span><br><span class="line">    private static final int MAX_POOL_SIZE &#x3D; 50;</span><br><span class="line">    private static boolean gCheckRecycle &#x3D; true; &#x2F;&#x2F; 回收标识</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 各种Message构建方法 </span><br><span class="line">    public static Message obtain(Handler h, int what, int arg1, int arg2) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>通过ThreadLocal实现各线程持有自己的Looper<br>loop方法进行消息轮训，获取消息，调用目标Handler分发任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 扮演消息循环角色，从MessageQueue取消息，有就执行，无则阻塞等待</span><br><span class="line">public final class Looper &#123;</span><br><span class="line">    &#x2F;&#x2F; 重要字段</span><br><span class="line">    &#x2F;&#x2F; ThreadLocal缓存，实现各线程持有各自Looper对象。参考https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;8a7fe7d592f8</span><br><span class="line">    static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    private static Looper sMainLooper;  &#x2F;&#x2F; 持有主线程Looper，便于其它线程交互</span><br><span class="line"></span><br><span class="line">    final MessageQueue mQueue; &#x2F;&#x2F; Looper对应的MessageQueue</span><br><span class="line">    final Thread mThread; &#x2F;&#x2F; Looper对应当前线程</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数私有，必须通过prepare方法来构建</span><br><span class="line">    private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class="line">        mThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 构建Looper，通过ThreadLocal维护Looper（各线程对应一个Looper）</span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        &#x2F;&#x2F; 主线程消息轮训不允许退出，一直循环处理</span><br><span class="line">        &#x2F;&#x2F; 子线程消息轮训可以退出</span><br><span class="line">        if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 主线程构建Looper方法（ActivityThread调用）</span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper &#x3D; myLooper(); &#x2F;&#x2F; 此处缓存主线程Looper，便于后续与主线程的交互</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最重要的 loop 方法，消息轮训实现 （部分关键代码）</span><br><span class="line">    public static void loop() &#123;</span><br><span class="line">        final Looper me &#x3D; myLooper(); &#x2F;&#x2F; 获取当前线程对应的loop</span><br><span class="line">        final MessageQueue queue &#x3D; me.mQueue;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 循环去消息 （MessageQueue取过程可能阻塞）</span><br><span class="line">            Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block （参考MessageQueue next方法）</span><br><span class="line">            if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            msg.target.dispatchMessage(msg);&#x2F;&#x2F; 派发消息到对应Handler</span><br><span class="line">             </span><br><span class="line">            msg.recycleUnchecked(); &#x2F;&#x2F; 释放message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>重点关注 next取message 和 enqueueMessage插入message方法</p>
<blockquote>
<p>主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，详情见Android消息机制1-Handler(Java层)，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 基于Native JNI实现，重点看next和enqueueMessage方法</span><br><span class="line">public final class MessageQueue &#123;</span><br><span class="line"></span><br><span class="line">    private long mPtr; &#x2F;&#x2F; 保存Native层的MessageQueue的对象</span><br><span class="line"></span><br><span class="line">    Message mMessages; &#x2F;&#x2F; 即将执行的message（链表头部）</span><br><span class="line">    private final ArrayList&lt;IdleHandler&gt; mIdleHandlers &#x3D; new ArrayList&lt;IdleHandler&gt;(); &#x2F;&#x2F; 空闲handler列表（用于添加空闲任务）</span><br><span class="line">    private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">    private IdleHandler[] mPendingIdleHandlers; &#x2F;&#x2F; IdleHandler数组</span><br><span class="line">    private boolean mQuitting; &#x2F;&#x2F; 是否终止</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span><br><span class="line">    private boolean mBlocked; &#x2F;&#x2F; 表明next方法是否block 当调用JNI pollOnce方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The next barrier token.</span><br><span class="line">    &#x2F;&#x2F; Barriers are indicated by messages with a null target whose arg1 field carries the token.</span><br><span class="line">    private int mNextBarrierToken;</span><br><span class="line">    &#x2F;&#x2F; JNI 方法</span><br><span class="line">    private native static long nativeInit();</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed &#x3D; quitAllowed;</span><br><span class="line">        mPtr &#x3D; nativeInit(); &#x2F;&#x2F; 进行native层初始化</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点方法 ，获取下一个待处理任务 （部分重点代码）</span><br><span class="line">    Message next() &#123;</span><br><span class="line">        int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; 用于IdleHandler任务处理</span><br><span class="line">        int nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis); &#x2F;&#x2F;Native Looper的epoll</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">             </span><br><span class="line">                final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg &#x3D; null;</span><br><span class="line">                Message msg &#x3D; mMessages;</span><br><span class="line">                if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 处理无target的异步消息 （暂时忽略）</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg &#x3D; msg;</span><br><span class="line">                        msg &#x3D; msg.next;</span><br><span class="line">                    &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (msg !&#x3D; null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 标记下一次轮训时间</span><br><span class="line">                        nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        </span><br><span class="line">                        mBlocked &#x3D; false;</span><br><span class="line">                        if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                            prevMsg.next &#x3D; msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages &#x3D; msg.next; &#x2F;&#x2F; 记录下一个头部message</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next &#x3D; null;</span><br><span class="line">                        </span><br><span class="line">                        msg.markInUse(); &#x2F;&#x2F; 标记message状态</span><br><span class="line">                        return msg; &#x2F;&#x2F; 返回message</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                if (mQuitting) &#123; &#x2F;&#x2F; 终止</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 后面是 IdleHandler相关处理逻辑（暂时忽略）</span><br><span class="line">                ......</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点方法 ，Message入队 （部分重点代码）</span><br><span class="line">    boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            msg.markInUse(); &#x2F;&#x2F; </span><br><span class="line">            msg.when &#x3D; when;</span><br><span class="line">            Message p &#x3D; mMessages;</span><br><span class="line">            boolean needWake;</span><br><span class="line">            if (p &#x3D;&#x3D; null || when &#x3D;&#x3D; 0 || when &lt; p.when) &#123;</span><br><span class="line">                &#x2F;&#x2F; 立即执行任务，标记为head message。</span><br><span class="line">                msg.next &#x3D; p;</span><br><span class="line">                mMessages &#x3D; msg;</span><br><span class="line">                needWake &#x3D; mBlocked; &#x2F;&#x2F; 唤醒，如果处于blocked状态</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 考虑是否异步任务</span><br><span class="line">                needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                &#x2F;&#x2F; 根据执行时间先后，插入message链表队列</span><br><span class="line">                for (;;) &#123; </span><br><span class="line">                    prev &#x3D; p;</span><br><span class="line">                    p &#x3D; p.next;</span><br><span class="line">                    if (p &#x3D;&#x3D; null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next &#x3D; p; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next</span><br><span class="line">                prev.next &#x3D; msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 唤醒. 参考JNI方法</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JNI方法（参考）<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Native层</a></p>
<p>MessageQueue通过mPtr变量保存NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Looper.cpp</span><br><span class="line"></span><br><span class="line">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        result &#x3D; pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Looper::pollInner(int timeoutMillis) &#123;</span><br><span class="line">	...</span><br><span class="line">    &#x2F;&#x2F; Poll.</span><br><span class="line">    int result &#x3D; POLL_WAKE;</span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We are about to idle.</span><br><span class="line">    mIdling &#x3D; true;</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">	&#x2F;&#x2F;阻塞等待可以读取管道的通知</span><br><span class="line">    int eventCount &#x3D; epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No longer idling.</span><br><span class="line">    mIdling &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Acquire lock.</span><br><span class="line">    mLock.lock();</span><br><span class="line">	...</span><br><span class="line">    for (int i &#x3D; 0; i &lt; eventCount; i++) &#123;</span><br><span class="line">        int fd &#x3D; eventItems[i].data.fd;</span><br><span class="line">        uint32_t epollEvents &#x3D; eventItems[i].events;</span><br><span class="line">        if (fd &#x3D;&#x3D; mWakeReadPipeFd) &#123;</span><br><span class="line">            if (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();&#x2F;&#x2F; 关键代码方法</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Looper::awoken() &#123; &#x2F;&#x2F; 唤醒方法 （enqueueMessage方法调用）</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ awoken&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    char buffer[16];</span><br><span class="line">    ssize_t nRead;</span><br><span class="line">    do &#123;</span><br><span class="line">        nRead &#x3D; read(mWakeReadPipeFd, buffer, sizeof(buffer));&#x2F;&#x2F;可以看到读取了管道中的内容</span><br><span class="line">    &#125; while ((nRead &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EINTR) || nRead &#x3D;&#x3D; sizeof(buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Looper::wake() &#123; &#x2F;&#x2F; 最终调用到 native wake方法</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ wake&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ssize_t nWrite;</span><br><span class="line">    do &#123;</span><br><span class="line">        nWrite &#x3D; write(mWakeWritePipeFd, &quot;W&quot;, 1);&#x2F;&#x2F;进行了写操作</span><br><span class="line">    &#125; while (nWrite &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EINTR);</span><br><span class="line"></span><br><span class="line">    if (nWrite !&#x3D; 1) &#123;</span><br><span class="line">        if (errno !&#x3D; EAGAIN) &#123;</span><br><span class="line">            ALOGW(&quot;Could not write wake signal, errno&#x3D;%d&quot;, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Android线程消息循环模型"><a href="#Android线程消息循环模型" class="headerlink" title="Android线程消息循环模型"></a>Android线程消息循环模型</h3><h4 id="主线程消息循环模型"><a href="#主线程消息循环模型" class="headerlink" title="主线程消息循环模型"></a>主线程消息循环模型</h4><p>ActivityThread通过ApplicationThread和AMS进行进程间通讯，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，</p>
<p>system_server进程：<br>系统进程，包含了大量的系统服务。如图中ApplicationThreadProxy、ActivityManagerService，这两个服务都运行在system_server进程的不同线程中。另外ATP、AMS都是基于IBinder接口，属于binder线程，都是由binder底层驱动创建和销毁</p>
<p>App进程：<br>即应用程序，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作；另外每个App进程至少都有两个Binder线程，ApplicationThread和ActivityManagerProxy。</p>
<p>Binder<br>用于不同进程之间通信</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9696036-5f594a326e5a7d2e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程消息循环模型"></p>
<h4 id="主线程与子线程交互的消息循环模型"><a href="#主线程与子线程交互的消息循环模型" class="headerlink" title="主线程与子线程交互的消息循环模型"></a>主线程与子线程交互的消息循环模型</h4><p><img src="https://upload-images.jianshu.io/upload_images/9696036-cb9d80fde5fadfb6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程与子线程交互的消息循环模型.jpg"></p>
<h3 id="Android线程和线程池相关概念"><a href="#Android线程和线程池相关概念" class="headerlink" title="Android线程和线程池相关概念"></a>Android线程和线程池相关概念</h3><p>参考：<a href="[https://www.jianshu.com/p/d9e46d5a4af9](https://www.jianshu.com/p/d9e46d5a4af9">Java线程池理解</a></p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h5 id="Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？"><a href="#Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？" class="headerlink" title="Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？"></a>Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？</h5><p>见MessageQueue的next方法，涉及到Linux pipe/epoll机制，因为在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next ()中的nativePollOnce方法里，这是主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事物发生。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 </p>
<h5 id="主线程的消息循环机制是什么（死循环如何处理其它事务）？"><a href="#主线程的消息循环机制是什么（死循环如何处理其它事务）？" class="headerlink" title="主线程的消息循环机制是什么（死循环如何处理其它事务）？"></a>主线程的消息循环机制是什么（死循环如何处理其它事务）？</h5><p>参考前面的主线程消息模型图例</p>
<h5 id="ActivityThread-的动力是什么？（ActivityThread执行Looper的线程是什么）"><a href="#ActivityThread-的动力是什么？（ActivityThread执行Looper的线程是什么）" class="headerlink" title="ActivityThread 的动力是什么？（ActivityThread执行Looper的线程是什么）"></a>ActivityThread 的动力是什么？（ActivityThread执行Looper的线程是什么）</h5><p>ActivityThread通过main方法执行，也就是咱们的Runtime线程。该线程默认是不可quit的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  程序入口，runtime线程执行</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">       Looper.prepareMainLooper(); &#x2F;&#x2F; 将该线程对应Looper标记为MainLooper</span><br><span class="line"></span><br><span class="line">       ActivityThread thread &#x3D; new ActivityThread(); </span><br><span class="line">       thread.attach(false, startSeq);  &#x2F;&#x2F; 初始化ActivityThread</span><br><span class="line">       if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">           sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Looper.loop(); &#x2F;&#x2F; 循环</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="Handler-是如何能够线程切换，发送Message的？（线程间通讯）"><a href="#Handler-是如何能够线程切换，发送Message的？（线程间通讯）" class="headerlink" title="Handler 是如何能够线程切换，发送Message的？（线程间通讯）"></a>Handler 是如何能够线程切换，发送Message的？（线程间通讯）</h5><p>主线程到其它线程，只需要创建线程执行任务就可以。其它线程切回主线程，只需要拿到或者创建主线程Handler既可以发送消息切换回去</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义UUID-移动设备唯一标识</title>
    <url>/blog/2020/02/06/%E8%87%AA%E5%AE%9A%E4%B9%89UUID-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>希望自主生成用于所有移动业务上标识设备唯一性的标识符</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>业务支撑、日活和新增设备等数据统计、风控等</p>
<h3 id="uuid系统图"><a href="#uuid系统图" class="headerlink" title="uuid系统图"></a>uuid系统图</h3><p><img src="http://upload-images.jianshu.io/upload_images/9696036-3430540af001a4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="UUID生成"><a href="#UUID生成" class="headerlink" title="UUID生成"></a>UUID生成</h3><h4 id="移动端相关参数"><a href="#移动端相关参数" class="headerlink" title="移动端相关参数"></a>移动端相关参数</h4><h5 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h5><pre><code>IMEI

* International Mobile Equipment Identity，移动设备国际识别码，是手机的唯一识别号码。等价于DeviceId
* 仅支持具有通话功能的设备，例如平板没有
* 需要权限，并且在少数手机拿到的是不合法值
* 一定的重复率（约5%）

MAC Address

* 支持带有Wifi和蓝牙硬件的设备
* 需要权限

Sim Serial Number

* Sim卡序列号
* 对于CDMA设备，返回一个空值</code></pre><h5 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h5><pre><code>IDFA: 广告标志符,重置系统、还原广告会重新生成）
OpenUDID: 由OpenUDID的SDK包生成，该应用重置则会重新生成
keychain: 系统级存储，用于生成的标识存储
MACAddress和UDID:老版本兼容按需使用</code></pre><h4 id="uuid生成算法"><a href="#uuid生成算法" class="headerlink" title="uuid生成算法"></a>uuid生成算法</h4><p>相关参数：客户端类型、版本号、设备信息长度、设备信息内容（见上）、时间戳、设备信息类型、随机数<br>原则：生成uuid唯一，设备信息可反查，设备信息关联uuid，设备信息可校验等<br>算法：32位明文存储相关信息，AES64对称加密</p>
<h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><table>
<thead>
<tr>
<th>uuid</th>
<th>imei</th>
<th>mac</th>
<th>simid</th>
<th>idfa</th>
<th>keychainid</th>
<th>openudid</th>
<th>idfa</th>
<th align="left">udid</th>
<th align="left">Xxx</th>
</tr>
</thead>
</table>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>uuid没法保存<br>uuid合法性（去重、是否作弊）<br>兼容已有uuid<br>防止刷接口<br>防止伪造uuid</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>ID</tag>
      </tags>
  </entry>
</search>
