<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ReactNative 启动优化实践</title>
    <url>/blog/2020/05/02/ReactNative%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="RN-启动简介"><a href="#RN-启动简介" class="headerlink" title="RN 启动简介"></a>RN 启动简介</h3><p><a href="https://engineering.fb.com/android/dive-into-react-native-performance" target="_blank" rel="noopener">Dive into React Native performance</a><br>阐述了基于RN实现的页面各部分加载时间占比图<br><img src="/blog/" class="lazyload" data-src="https://engineering.fb.com/wp-content/uploads/2016/03/GEF5wQCX-cXZUeEAADQ_6S4AAAAAbj0JAAAB.jpg"  alt=""></p>
<p>页面加载流程图（引用）</p>
<p><img src="/blog/" class="lazyload" data-src="https://reactnative.dev/blog/assets/RNPerformanceStartup.png"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884224120287.jpg"  alt=""></p>
<p>从业务视角可以归纳为四个部分</p>
<ol>
<li>Bundle包准备：客户端Bundle包下载、解析等过程</li>
<li>初始化引擎：引擎准备，RN执行环境</li>
<li>加载Bundle：引擎加载JS代码</li>
<li>渲染Bundle：执行JS中runApplication()方法，开始渲染</li>
</ol>
<h3 id="RN-启动优化实践"><a href="#RN-启动优化实践" class="headerlink" title="RN 启动优化实践"></a>RN 启动优化实践</h3><h4 id="包生产"><a href="#包生产" class="headerlink" title="包生产"></a>包生产</h4><ul>
<li>分包<ul>
<li>分业务分包：页面维度单独成包，避免大文件包</li>
<li>分层分包：页面和组件拆分，便于复用，同时也减少了整体体积</li>
</ul>
</li>
<li>拆包<ul>
<li>一种方案，将一个包整体的index.js，拆分成一个入口+多个子模块，从而实现页面模块维度懒加载功能，减少页面首次加载时间，webpack和react loadable都有提供了切割能力</li>
<li>另一种方案，RAM bundles和内联引用<ul>
<li>RAM bundles：Indexed RAM Bundle和File RAM Bundle两种实现，将每个模块拆分为独立文件</li>
<li>内联引用（inline requires）：内联引用(require 代替 import)可以延迟模块或文件的加载，直到实际需要该文件。 </li>
</ul>
</li>
</ul>
</li>
<li>包大小优化<ul>
<li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">包大小分析工具</a>  </li>
<li>引入<a href="https://www.webpackjs.com/guides/tree-shaking/" target="_blank" rel="noopener">tree-shaking</a>将无用代码删除</li>
<li>静态资源压缩，重点图片</li>
</ul>
</li>
</ul>
<h4 id="包下载"><a href="#包下载" class="headerlink" title="包下载"></a>包下载</h4><ul>
<li>Bundle包缓存策略优化，减少下载时间<ul>
<li>核心或者重要页面直接预装</li>
<li>本地增量更新策略</li>
</ul>
</li>
<li>Bundle包下载策略优化，根据页面深度区分下载时机，实现延缓下载，减少首次并发下载任务量</li>
</ul>
<h4 id="包加载"><a href="#包加载" class="headerlink" title="包加载"></a>包加载</h4><ul>
<li>引擎池技术，默认空引擎+引擎复用，减少引擎池初始化时间</li>
</ul>
<h4 id="包渲染"><a href="#包渲染" class="headerlink" title="包渲染"></a>包渲染</h4><ul>
<li>数据层<ul>
<li>本地化数据优化，数据缓存、前一个页面数据带入后一个数据</li>
<li>数据请求异步加载，且尽可能提前请求，譬如执行js加载到内存</li>
</ul>
</li>
<li>模块层<ul>
<li>模块=页面一个个模块，对于复杂或者长的页面，简单理解可以是预先加载可见模块，然后在加载非可见模块。</li>
</ul>
</li>
<li>组件层<ul>
<li>减少重复渲染，例如Immutablejs、唯一Kye、慎用setState</li>
<li>React布局和渲染的一些基本常识</li>
<li>实践过程中，最难点也是比较常见的场景就是，复杂且条目多的长列表实现，FlatList可以满足一般场景，但是有两个缺陷，<ul>
<li>白屏问题是因为异步渲染导致的。cell先创建了一个等高空白容器，然后整个cell的viewTree异步渲染完成后再添加到空白容器内。所以快速滑动的时候，由于异步任务堆积，导致无法快速展现出现白屏。</li>
<li>FlatList数据条目多时容易产生崩溃。这是因为FlatList中Cell之间的viewTree并没有真实复用，随着滚动渲染出来的viewTree越来越多，内存开销过大容易出现OOM</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>参考：<br><a href="http://blog.poetries.top/2019/10/02/rn-start-progress/" target="_blank" rel="noopener">React Native之启动流程</a><br><a href="https://juejin.im/post/5a4dc842518825698e7279a9" target="_blank" rel="noopener">Tree-Shaking性能优化实践 - 原理篇</a><br><a href="https://reactnative.cn/docs/performance/#%E6%8B%86%E5%8C%85ram-bundles%E5%92%8C%E5%86%85%E8%81%94%E5%BC%95%E7%94%A8" target="_blank" rel="noopener">ReactNative 性能</a></p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>RN，性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative 介绍</title>
    <url>/blog/2020/04/30/ReactNative%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="ReactNative-发展历史"><a href="#ReactNative-发展历史" class="headerlink" title="ReactNative 发展历史"></a>ReactNative 发展历史</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>React Native 想法来源于2013年的 Facebook 内部黑客马拉松（hackathon）<br><a href="https://engineering.fb.com/android/react-native-bringing-modern-web-techniques-to-mobile/" target="_blank" rel="noopener">React Native: A year in review</a></p>
<blockquote>
<p>In the beginning: React Native’s roots<br>In the essence of Facebook’s hacker culture, React Native started as a hackathon project in the summer of 2013. Similar to React, React Native seemed like a boldly unconventional idea. It wasn’t clear this would actually work. How was touch negotiation between JS and native ScrollViews going to work? What about performance, and what about debugging? None of these challenges stopped the engineers from focusing and pushing forward.</p>
</blockquote>
<p><a href="https://engineering.fb.com/android/react-native-bringing-modern-web-techniques-to-mobile/" target="_blank" rel="noopener">React Native: Bringing modern web techniques to mobile</a></p>
<p>随着React的快速发展，Facebook越发感受到 React 以及 Web 技术的优势，同时Native在““Move fast” 这一块的糟糕表现，所以就引发了将Web先进技术引进Native的开发，</p>
<ul>
<li>快速开发（Rapid development velocity）：刷新浏览器即可生效，不必等待重新编译 App</li>
<li>快速迭代（Rapid iteration cycle）：Web 一天两版，产品迭代周期更短</li>
<li>快速反馈（Immediate testing feedback）：Web 发布立即触达用户，A/B test 等实验结果立等可取，产品演进更快</li>
</ul>
<p>为了实现这个目标，FaceBook尝试过三种方案</p>
<ol>
<li>Using WebViews ，通过Native提供容器，使用Web进行开发。这样能全面利用Web的开发经验并且具备WEB技术的一样可扩展性，但最终渲染性能并不理想，而且因为全部是Web技术开发也没有沉淀很好的Native技术</li>
<li>Porting React to native，把React移植到native实现，15年推出了iOS <a href="https://github.com/facebook/componentkit" target="_blank" rel="noopener">componentkit</a> 以及在17年推出了Android <a href="https://github.com/facebook/litho" target="_blank" rel="noopener">Litho</a> 。实现了很多React的特性，例如可预测性UI、声明式。但没有实现提升效率的初衷，仍然需要重新编译。另外需要进行双端适配。而且Web React的生态建设也不能直接复用。</li>
<li>Scripting native，通过 JavaScript 调用 Native API。既能拥有 Web 开发的快速迭代能力，还不局限于 Web 技术，同时也没有脱离 JavaScript 生态，似乎是个完美的方案，然而实践并没有那么简单。主要是Native环境和JS环境来回通信，过多的通信承载以及引起的UI线程阻塞都会带来性能损害。 但最终幸运的是React整体的技术模型仍然可以向着正确的方向演进</li>
</ol>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><h4 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h4><ul>
<li><p>February 18, 2015 : <a href="https://reactjs.org/blog/2015/02/18/react-conf-roundup-2015.html" target="_blank" rel="noopener">React.js Conf Round-up 2015</a>，首次揭幕FaceBook内部使用技术ReactNative</p>
<blockquote>
<p>unveil three new technologies that we’ve been using internally at Facebook for some time: GraphQL, Relay, and React Native.</p>
</blockquote>
</li>
<li><p>March 26, 2015： <a href="https://about.fb.com/news/2015/03/f8-2015-new-open-source-tools-for-mobile-developers/" target="_blank" rel="noopener">F8 2015: New Open Source Tools for Mobile Developers</a>，首次发布并开源ReactNative</p>
<blockquote>
<p>React Native is a framework for native environments that allows developers to build first-class iOS and Android user interfaces with no browser/WebView involved</p>
</blockquote>
</li>
<li><p>MAR 26, 2015: <a href="https://engineering.fb.com/android/react-native-bringing-modern-web-techniques-to-mobile/" target="_blank" rel="noopener">React Native: Bringing modern web techniques to mobile</a>，发布第一篇官方介绍，此时仅支持 iOS</p>
</li>
<li><p>SEP 14, 2015：<a href="https://engineering.fb.com/developer-tools/react-native-for-android-how-we-built-the-first-cross-platform-react-native-app/" target="_blank" rel="noopener">React Native for Android: How we built the first cross-platform React Native app</a>，宣布 React Native 支持 Android 了，文章中提到两个大的认知，1是iOS和Android独立开发并不可取，最终两端基于一个公共库进行开发；2是初始阶段由于双端未充分的测试带来的成本要高于开发成本，不过这些偶发的问题在不断的技术抹平差异后带来了稳定性的提高</p>
</li>
</ul>
<h4 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h4><ul>
<li>March 24, 2016：<a href="https://reactnative.dev/blog/2016/03/24/introducing-hot-reloading" target="_blank" rel="noopener">Introducing Hot Reloading</a>，热加载介绍，实现了变更实施可见</li>
<li>MAR 28, 2016：<a href="https://engineering.fb.com/android/dive-into-react-native-performance/" target="_blank" rel="noopener">Dive into React Native performance</a>，全面提升性能<ul>
<li>Cleanup Require/Babel helpers (high impact): 清楚无用引用</li>
<li>Avoid copying and decoding strings when loading the bundle (medium impact): 加载bundle避免复制和解码</li>
<li>Stripping DEV-only modules (low impact): 支持Dev模块，减少体积从而提升JS转换效率</li>
<li>Generate event descriptions on the server (low impact): Data后移，减少客户端处理数据操作</li>
<li>Lazy requires (low impact): 按需加载模块</li>
<li>Relay incremental cache read (high impact): 提神缓存读取效率</li>
<li>De-batching bridge calls, batch Relay calls (high impact): 批处理桥交互操作</li>
<li>Early UI flushing (low impact): UI刷新批处理</li>
<li>Lazy native modules loading (low impact): 懒加载Native模块</li>
<li>Lazy touch bindings on text components (low impact): 懒加载组件</li>
<li>Defer popular events query (medium impact): 延期处理屏幕事件</li>
</ul>
</li>
<li>APRIL 13, 2016 ：<a href="https://blogs.windows.com/windowsdeveloper/2016/04/13/react-native-on-the-universal-windows-platform/" target="_blank" rel="noopener">React Native on the Universal Windows Platform</a>，Windows平台实现</li>
<li>APR 142016：<a href="https://www.tizen.org/blogs/srsaul/2016/samsung-committed-bringing-react-native-tizen" target="_blank" rel="noopener">Samsung Committed to Bringing React Native to Tizen：进入三星物联网生态（Tizen 系统）</a>进入三星物联网生态（Tizen 系统）</li>
<li>August 19, 2016：<a href="https://reactnative.dev/blog/2016/08/19/right-to-left-support-for-react-native-apps" target="_blank" rel="noopener">Making an App RTL-ready</a>，支持RTL布局</li>
<li>October 25, 2016：<a href="https://reactnative.dev/blog/2016/10/25/0.36-headless-js-the-keyboard-api-and-more" target="_blank" rel="noopener">0.36: Headless JS, the Keyboard API, &amp; more</a>，发布0.36版本，Headless支持后台任务、键盘操作等</li>
<li>November 8, 2016：<a href="https://reactnative.dev/blog/2016/11/08/introducing-button-yarn-and-a-public-roadmap" target="_blank" rel="noopener">Introducing Button, Faster Installs with Yarn, and a Public Roadmap</a>，发布0.37版本，支持Button组件，支持Yarn</li>
</ul>
<h4 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h4><ul>
<li>February 14, 2017：<a href="https://reactnative.dev/blog/2017/02/14/using-native-driver-for-animated" target="_blank" rel="noopener">Using Native Driver for Animated</a>，支持Native驱动动画，早期动画实现在JS线程中，这容易因JS线程Block造成动画的跳帧。</li>
<li>March 13, 2017：<a href="https://reactnative.dev/blog/2017/03/13/better-list-views" target="_blank" rel="noopener">Better List Views in React Native</a>，提供FlatList和SectionList更好的支持列表实现。同时也提到了一些注意事项，譬如非屏幕部分是异步渲染，所以在快速滑动的时候可能会引起白屏。</li>
<li>March 13, 2017：<a href="https://reactnative.dev/blog/2017/03/13/introducing-create-react-native-app" target="_blank" rel="noopener">Introducing Create React Native App</a>，推出官方脚手架支持App创建</li>
<li>August 7, 2017：<a href="https://reactnative.dev/blog/2017/08/07/react-native-performance-in-marketplace" target="_blank" rel="noopener">React Native Performance in Marketplace</a>，介绍 Facebook 在其 React Native 主应用（Marketplace）上的性能优化实践，后续计划优化编译时的性能优化探索，如Prepack，期望大幅削减 React Native core 的初始化耗时<br><img src="/blog/" class="lazyload" data-src="https://reactnative.dev/blog/assets/RNPerformanceStartup.png"  alt=""></li>
</ul>
<h4 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h4><ul>
<li>January 18, 2018：<a href="https://reactnative.dev/blog/2018/01/18/implementing-twitters-app-loading-animation-in-react-native" target="_blank" rel="noopener">Implementing Twitter’s App Loading Animation in React Native</a>，Twitter动画的一些实践，并且在动画方面有一些成果，Fade、Scale、Hide</li>
<li>March 22, 2018：<a href="https://reactnative.dev/blog/2018/03/22/building-input-accessory-view-for-react-native" target="_blank" rel="noopener">Building <InputAccessoryView> For React Native</a>，支持 InputAccessoryView组件</li>
<li>May 7, 2018：<a href="https://reactnative.dev/blog/2018/05/07/using-typescript-with-react-native" target="_blank" rel="noopener">Using TypeScript with React Native</a>，支持TS语言</li>
<li>June 14, 2018：<a href="https://reactnative.dev/blog/2018/06/14/state-of-react-native-2018" target="_blank" rel="noopener">State of React Native 2018</a>，介绍团队正在对整体架构进行重构升级，旨在使得框架更加轻量和更加监控，主要聚焦三个方面 <ol>
<li>针对高优先级的更新可以在任何线程同步调用JS线程，以及取代每次UI更新需要经历三层线程模型，使得JS线程可以根据。</li>
<li>合并异步渲染以及简化异步数据处理</li>
<li>轻量化桥实现，JS和Native之间桥交互性能更高效</li>
</ol>
</li>
<li>July 4, 2018：<a href="https://reactnative.dev/blog/2018/07/04/releasing-react-native-056" target="_blank" rel="noopener">Releasing 0.56</a>，发布 0.56，升级 Babel、Android SDK、Xcode、Flow 等依赖版本</li>
<li>November 1, 2018：<a href="https://reactnative.dev/blog/2018/11/01/oss-roadmap" target="_blank" rel="noopener">Open Source Roadmap</a>，计划精简核心模块，并开源 Facebook 内部的一些基建</li>
<li>January 7, 2019: <a href="https://reactnative.dev/blog/2019/01/07/state-of-react-native-community" target="_blank" rel="noopener">The State of the React Native Community in 2018</a>，说明2018计划更好地支持 Native &amp; React Native 混合 App，核心团队启动了架构升级计划（Fabric），包括重构线程模型、支持 React async rendering 能力、简化 React Native core 等大改。</li>
</ul>
<h4 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h4><ul>
<li><p>March 12, 2019：<a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059" target="_blank" rel="noopener">Releasing React Native 0.59</a>，发布0.59</p>
<ul>
<li>Hooks支持</li>
<li>JSC更新，和性能提升，以及Android 64位支持</li>
<li>inline requires支持，更快app启动性能</li>
<li>Lean core is underway，核心模块精简计划持续进行</li>
<li>CLI improvements</li>
</ul>
</li>
<li><p>March 31, 2019：<a href="https://www.facebook.com/FacebookforDevelopers/videos/mobile-innovation-with-react-native-componentkit-and-litho/440768533157155/" target="_blank" rel="noopener">Mobile Innovation with React Native, ComponentKit, and Litho</a>，分享 Facebook 的移动技术栈（React Native + ComponentKit 和 Litho）</p>
</li>
<li><p>July 17, 2019：<a href="https://reactnative.dev/blog/2019/07/17/hermes" target="_blank" rel="noopener">Meet Hermes, a new JavaScript Engine optimized for React Native</a> Hermes 引擎发布，Hermes: An open source JavaScript engine optimized for mobile apps, starting with React Native</p>
</li>
<li><p>July 3, 2019：<a href="https://reactnative.dev/blog/2019/07/03/version-60" target="_blank" rel="noopener">Announcing React Native 0.60</a>，0.60发布，聚焦一些辅助功能提升，AndroidX支持、Native模块自动链接、Helper更新等</p>
</li>
<li><p>September 18, 2019：<a href="https://reactnative.dev/blog/2019/09/18/version-0.61" target="_blank" rel="noopener">Announcing React Native 0.61 with Fast Refresh</a>，新概念“Fast Flush”，更可靠和更高效的本地更新渲染能力</p>
</li>
</ul>
<h4 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h4><ul>
<li>March 26, 2020：<a href="https://reactnative.dev/blog/2020/03/26/version-0.62" target="_blank" rel="noopener">Announcing React Native 0.62 with Flipper</a>，发布0.62，提供Flipper，更友好的支持Debug调试</li>
</ul>
<h2 id="ReactNative-运行原理"><a href="#ReactNative-运行原理" class="headerlink" title="ReactNative 运行原理"></a>ReactNative 运行原理</h2><h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>整体由React、JavaScript、Bridge、Native四层组成，Native负责UI更新及交互处理，JavaScript调用Native能力实现业务功能，Bridge则为两者之间提供通信桥梁</p>
<ul>
<li>最上层提供类 React 支持，运行在JavaScriptCore提供的 JavaScript 运行时环境中</li>
<li>Bridge 层将 JavaScript 与 Native 环境连接起来，JSON用来传递UI更新信息，Shadow Tree 用来定义 UI 效果及交互功能，Native Modules 提供 Native 功能（比如蓝牙），二者之间通过 JSON 消息相互通信<ul>
<li>异步（asynchronous）：不依赖于同步通信</li>
<li>可序列化（serializable）：保证一切 UI 操作都能序列化成 JSON 并转换回来</li>
<li>批处理（batched）：对 Native 调用进行排队，批量处理</li>
</ul>
</li>
<li></li>
</ul>
<p><strong>系统分层</strong><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884342848646.jpg"  alt=""></p>
<p><strong>系统结构（Android）（引用）</strong><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884342941914.jpg"  alt=""></p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>React Native 中主要有3种线程</p>
<ul>
<li>UI Thread：Android/iOS（或其它平台）应用中的主线程</li>
<li>Shadow Thread：进行布局计算和构造 UI 界面的线程</li>
<li>JS Thread：React或其它JavaScript 代码都在这个线程执行</li>
</ul>
<p>此外，还有一类 Native Modules 线程，不同的 Native Module 可以运行在不同的线程中<a href="http://chain-react-bridging.surge.sh/dist/96efedea67e784036f946c487a06cdc9.png" target="_blank" rel="noopener">http://chain-react-bridging.surge.sh/dist/96efedea67e784036f946c487a06cdc9.png</a></p>
<p><strong>线程工作流程</strong><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884343045589.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="https://engineering.fb.com/wp-content/uploads/2016/03/GCefvQD26BsmvqsAAFRTmREAAAAAbj0JAAAB.jpg"  alt=""></p>
<p><strong>线程交互流程</strong></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884343191889.jpg"  alt=""></p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><ul>
<li>启动RN App</li>
<li>加载JavaScript VM、JavaScript Bundle、NativeModule</li>
<li>执行JavaScript bundle</li>
<li>native调用、shadow tree创建、布局、NativeView创建</li>
<li>View渲染</li>
</ul>
<p><strong>整体启动流程</strong><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884343256657.jpg"  alt=""></p>
<p><strong>官方启动时间模块划分</strong><br><img src="/blog/" class="lazyload" data-src="https://reactnative.dev/blog/assets/RNPerformanceStartup.png"  alt=""></p>
<h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><p><strong>事件传递</strong></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884061536946.jpg"  alt=""></p>
<p><strong>首次渲染</strong></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/blog/rn_render_old_.gif"  alt=""></p>
<p><strong>更新渲染</strong></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/blog/rn_render_update_old.gif"  alt=""></p>
<h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><p>2018 年 6 月启动了架构升级计划 Fabric，重构线程模型并简化 React Native Core，以更好地支持 Native &amp; React Native 混合 App</p>
<p>以前架构问题：</p>
<ul>
<li>异步：无法将 JavaScript 逻辑直接与许多需要同步的 Native API 集成</li>
<li>同步桥支持差：在官方代码注释中提到，同步桥存在严重的性能问题，并且会引入线程BUG</li>
<li>通信性能瓶颈：JS与Native通信采用消息队列的方式，传输过程中需要将要传递的消息序列化为JSON。当传输数据量变大时，桥上会出现拥塞</li>
</ul>
<p>改进方向</p>
<h4 id="React-层"><a href="#React-层" class="headerlink" title="React 层"></a>React 层</h4><p>提供 CodeGen 工具来保证消息通信的类型安全，以解决 JavaScript 与 Native 通信中被广为诟病的 Bridge API 数据类型问题</p>
<h4 id="JavaScript-层"><a href="#JavaScript-层" class="headerlink" title="JavaScript 层"></a>JavaScript 层</h4><p>上层 JavaScript 代码需要一个运行时环境，在 React Native 中这个环境是 JSC（JavaScriptCore）。不同于之前直接将 JavaScript 代码输入给 JSC，新的架构中引入了一层 JSI（JavaScript Interface），作为 JSC 之上的抽象，用来屏蔽 JavaScript 引擎的差异，允许换用不同的 JavaScript 引擎（如Hermes）</p>
<h4 id="Bridge-层"><a href="#Bridge-层" class="headerlink" title="Bridge 层"></a>Bridge 层</h4><p>划分成 Fabric 和 TurboModules 两部分，分别负责 UI 管理与 Native 模块    </p>
<p><strong>Fabric</strong> 期望以更现代化的方式去实现 React Native 的渲染层，简化之前渲染流程中复杂跨线程交互（React -&gt; Native -&gt; Shadow Tree -&gt; Native UI）。具体的，直接在 C++层创建 JavaScript 与 Native 共享的 Shadow Tree，并通过 JSI 层将 UI 操作接口暴露给 JavaScript，允许 JavaScript 直接控制高优先级的 UI 操作，甚至允许同步调用（应对列表快速滚动、页面切换、手势处理等场景）</p>
<p><strong>TurboModules</strong> 之前所有 Native Modules（无论是否需要用到）都要在应用启动时进行初始化，因为 Native 不知道 JavaScript 将会调用哪些功能模块。而新的TurboModules 允许按需加载 Native 模块，并在模块初始化之后直接持有其引用，不再依靠消息通信来调用模块功能。因此，应用的启动时间也会有所提升</p>
<h4 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h4><p>精简核心模块，将非核心部分拆分出去作为社区模块独立更新维护，理论上 React Native 应该是通用的，对平台无感知，这是能够支持Web、Windows等不同平台的关键<br>虽然 Native 不在 React Native 的掌控中，无法垂直地深入优化，但可以进行横向的精简，将非核心的部分代码拆分出去作为社区模块，如 AsyncStorage、ImageStore、MaskedViewIOS、NetInfo 等等。一方面缩减包体积，另一方面也有利于这些模块的独立更新维护</p>
<p><img src="/blog/" class="lazyload" data-src="media/15883438221773.jpg"  alt=""></p>
<hr>
<p>参考<br><a href="https://github.com/react-native-community/releases/blob/master/CHANGELOG.md" target="_blank" rel="noopener">CHANGELOG</a><br><a href="https://formidable.com/blog/2019/react-codegen-part-1/" target="_blank" rel="noopener">The New React Native Architecture Explained</a><br><a href="https://www.youtube.com/watch?v=0MlT74erp60" target="_blank" rel="noopener">React.js Conf 2016 - Tadeu Zagallo - Optimising React Native: Tools and Tips</a><br><a href="https://tadeuzagallo.com/blog/react-native-bridge/" target="_blank" rel="noopener">Bridging in React Native</a><br><a href="https://www.slideshare.net/axemclion/react-native-fabric-review20180725/1" target="_blank" rel="noopener">React Native - Fabric review-2018-07-25</a><br><a href="https://www.freecodecamp.org/news/how-react-native-constructs-app-layouts-and-how-fabric-is-about-to-change-it-dd4cb510d055/" target="_blank" rel="noopener">How React Native constructs app layouts (and how Fabric is about to change it)</a><br><a href="http://www.ayqy.net/blog/react-native-architecture-overview/" target="_blank" rel="noopener">React Native</a><br><a href="https://github.com/sucese/react-native/tree/master/doc" target="_blank" rel="noopener">ReactNative源码篇</a></p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title>Litho粗读</title>
    <url>/blog/2020/04/29/Litho%E7%B2%97%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="Litho-是什么"><a href="#Litho-是什么" class="headerlink" title="Litho 是什么"></a>Litho 是什么</h3><p><a href="https://fblitho.com/" target="_blank" rel="noopener">Litho官网</a><br>Litho是Facebook推出的一套高效构建Android UI的声明式框架，主要目的是提升RecyclerView复杂列表的滑动性能和降低内存占用。</p>
<p><strong>声明式组件</strong><br>允许用户使用声明式的API（注解）来构建符合Flexbox规范的布局。</p>
<p><strong>异步布局</strong><br>支持组件挂载，异步线程执行measure和layout操作，UI线程完成绘制工作</p>
<p><strong>扁平化布局</strong><br>Litho使用Yoga来完成组件布局的测量和计算，而且支持将View转换成Drawable渲染，降低了View层级，实现了布局的扁平化</p>
<p><strong>细粒度组件复用</strong><br>支持Text、Image或者Video细粒度组件的复用，尤其在多ItemType的列表中有显著性能提升</p>
<h3 id="Litho特性原理粗析"><a href="#Litho特性原理粗析" class="headerlink" title="Litho特性原理粗析"></a>Litho特性原理粗析</h3><h4 id="声明式组件"><a href="#声明式组件" class="headerlink" title="声明式组件"></a>声明式组件</h4><p>Litho采用声明式的API来定义UI组件，组件通过一组不可变的属性来描述UI。这种组件化的思想灵感来源于React，实践过ReactNative或React都深有体会。不过声明式组件也有弊端，开发者不能直接预览布局编写，从而影响开发效率。</p>
<h4 id="异步布局"><a href="#异步布局" class="headerlink" title="异步布局"></a>异步布局</h4><p>Android系统在绘制时为了防止页面错乱，页面所有View的测量（Measure）、布局（Layout）以及绘制（Draw）都是在UI线程中完成的。当页面UI非常复杂、视图层级较深时，难免Measure和Layout的时间会过长，从而导致页面渲染时候丢帧出现卡顿情况。<br>Litho鉴于此，提出了异步布局思想，最终实现了控件维度下异步线程完成measure和layout操作，在主线程完成draw操作。</p>
<p>首先，我们了解下 Android原生为什么不支持异步布局呢？</p>
<ol>
<li>Android 视图是有状态和可变的。例如，TextView 必须跟踪它正在显示的文本，同时暴露一个允许开发人员对文本进行改变的 setText（）方法。这意味着如果 Android UI 框架决定把布局计算之类的操作放在在辅助线程中执行，则必须解决用户从另一个线程调用 setText（）并同时在布局计算发生时改变当前文本的问题。</li>
<li>提前异步布局就意味着要提前创建好接下来要用到的一个或者多个条目的视图，而Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，大大增加内存占用。</li>
</ol>
<p>Litho的对策是怎样的呢 ？</p>
<ol>
<li>Litho设计的组件的属性是不可变的，所以对于一个组件来说，它的布局计算结果是唯一且不变的。这样就不存在多线程问题</li>
<li>Litho组件只包含视图属性，仅负责计算布局，将绘制工作丢给父布局组件来完成。这样的拆分使得提前创建多个组件及子线程完成布局并不会带来太多的性能问题</li>
</ol>
<h5 id="Litho-布局绘制流程"><a href="#Litho-布局绘制流程" class="headerlink" title="Litho 布局绘制流程"></a>Litho 布局绘制流程</h5><p>View onMeasure时，在LayoutState中的clollectResults() 递归调用了nodeTree中的结点，最终调用yoga来计算结点的位置，目标就算是把所有的节点最终绘制到一个View中，降低View的层级。</p>
<p>View onLayout时，在MountState中，对所有的Component进行Mount调用，准备好需要绘制的具体内容，以待绘制调用。</p>
<p>​​同时Litho引入了缓存机制，可以提前在异步线程中进行measure和layout的操作，这样在绘制过程中只需要draw就可以了，理论提升效率35%（FaceBook宣传）<br>​​</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/blog/20200429204925.png"  alt=""></p>
<h4 id="扁平化的视图"><a href="#扁平化的视图" class="headerlink" title="扁平化的视图"></a>扁平化的视图</h4><p>使用Litho布局，我们可以得到一个极致扁平的视图效果。它可以减少渲染时的递归调用，加快渲染速度。</p>
<p>下面是同一个视图在Android和Litho实现下的视图层级效果对比。可以看到，同样的样式，使用Litho实现的布局要比使用Android原生实现的布局更加扁平。<br><img src="/blog/" class="lazyload" data-src="https://fblitho.com/static/images/not-flat.png"  alt=""><br><img src="/blog/" class="lazyload" data-src="https://fblitho.com/static/images/flat.png"  alt=""></p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><ol>
<li>使用了Yoga来进行布局计算，Yoga会将Flexbox的相对布局转成绝对布局。经过Yoga处理后的布局没有了原来的布局层级，变成了只有一层。虽然不能解决过度绘制的问题，但是可以有效地减少渲染时的递归调用。</li>
<li>前面介绍过Litho的视图渲染由绘制单元来完成，绘制单元可以是View或者更加轻量的Drawable，Litho自己实现了一系列挂载Drawable的基本视图组件。通过使用Drawable可以减少内存占用，同时相比于View，Android无法检查出Drawable的视图层级，这样可以使视图效果看起来更加扁平。</li>
</ol>
<p>虽然平坦的视图结构对内存使用和绘图时间有重要的好处，但它们并非万能的灵丹妙药。Litho 有一个非常通用的系统来自动“ unflatten（堆叠起来） ” 已挂载组件的层次结构，当使用 Android View 里一些不可或缺的功能，如触摸事件的处理，无障碍功能，或限制失效等。例如，如果要在示例中启用单击图像或文本，则框架会自动将它们包装在视图中。</p>
<h4 id="细粒度组件回收"><a href="#细粒度组件回收" class="headerlink" title="细粒度组件回收"></a>细粒度组件回收</h4><p>Litho中的所有组件都可以被回收，并在任何位置进行复用。这种细粒度的复用方式可以极大地提高内存使用率，尤其适用于多Item类型的复杂列表，内存优化非常明显。</p>
<p>RecyclerView 支持显示多样内容。为此，它根据视图的类型将视图保存在不同的缓冲池中。虽然这个概念在简单的情况下工作得很好，但是对于具有许多不同视图类型的 UI 来说，它可能会出现问题。在包含许多视图类型的场景中，在滚动事件之后进入窗口的视图更有可能是 RecyclerView 第一次显示的视图。如果发生这种情况，RecyclerView 必须分配一个新的视图。发生分配的 16ms 时间槽内 RecyclerView 也必须同时对即将显示的视图执行绑定、测量和布局操作</p>
<p>Litho 提供更具扩展性和高效率的回收系统，同时我们希望从 API 中消除视图类型的复杂性。 Litho 布局的表示与在屏幕上渲染布局的 View 和Drawable 完全脱节。这意味着，当我们需要在屏幕上放置一个新的 RecyclerView 视图时，我们已经知道该项目的内容以及它相对于其余 UI 的位置。 这使 Litho 完全摆脱 View 类型的概念。在 RecyclerView 滚动时，我们可以递增地使用文本或图像等构建块，而不是重新使用表示RecyclerView中项目的整个 View。 这对于传统的 Android 视图来说是不可能的，因为布局计算在完整的视图树上运行，并且当我们知道所有视图在一行中的位置时，所有视图都已经被实例化了。</p>
<h5 id="组件回收代码粗析"><a href="#组件回收代码粗析" class="headerlink" title="组件回收代码粗析"></a>组件回收代码粗析</h5><p>InternalNode：由Component+（View）NodeInfo转化得到的表示布局信息的节点<br>DiffNode：InternalNode的轻量级表示形式，用于在两个布局树的计算之间缓存测量结果，如果不需要更新，那么直接复用DiffNode即可<br>MountSpec：对应的Component包含纯粹的View或者Drawable，比如TextSpec，ImageSpec<br>LayoutSpec：对应的Component类似于ViewGroup，内部组织管理了很多子Component，比如CardSpec，SpinnerSpec</p>
<p>什么条件复用DiffNode至InternalNode ？</p>
<ol>
<li>两个节点的类型不会产生冲突</li>
<li>两个节点的所有子节点类型不会产生冲突</li>
<li>不需要更新Component，这通过每个自定义的Component都会重写的isEquivalentTo()方法判断</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 当InternalNode和DiffNode都含有同一种Component类型或者都不含有Component时返回true</span><br><span class="line">private static boolean hostIsCompatible(InternalNode node, DiffNode diffNode) &#123;</span><br><span class="line">  if (diffNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return isSameComponentType(node.getTailComponent(), diffNode.getComponent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void applyDiffNodeToUnchangedNodes(InternalNode layoutNode, DiffNode diffNode) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    final boolean isTreeRoot &#x3D; layoutNode.getParent() &#x3D;&#x3D; null;</span><br><span class="line">    if (isLayoutSpecWithSizeSpec(layoutNode.getTailComponent()) &amp;&amp; !isTreeRoot) &#123;</span><br><span class="line">      layoutNode.setDiffNode(diffNode);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复用条件1：两个节点包含的Component类型必须相同</span><br><span class="line">    if (!hostIsCompatible(layoutNode, diffNode)) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 将DiffNode绑定到InternalNode中</span><br><span class="line">    layoutNode.setDiffNode(diffNode);</span><br><span class="line"></span><br><span class="line">    final int layoutCount &#x3D; layoutNode.getChildCount();</span><br><span class="line">    final int diffCount &#x3D; diffNode.getChildCount();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 复用条件2：对两个节点的所有子节点做递归判断，他们的类型也必须兼容</span><br><span class="line">    if (layoutCount !&#x3D; 0 &amp;&amp; diffCount !&#x3D; 0) &#123;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; layoutCount &amp;&amp; i &lt; diffCount; i++) &#123;</span><br><span class="line">        applyDiffNodeToUnchangedNodes(layoutNode.getChildAt(i), diffNode.getChildAt(i));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#125; else if (!shouldComponentUpdate(layoutNode, diffNode)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果不需要更新Component（根据每个Component都会重写的isEquivalentTo()方法判断），将DiffNode应用到InternalNode中的叶子节点（比如MountSpec）</span><br><span class="line">      applyDiffNodeToLayoutNode(layoutNode, diffNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 如果我们有一个cachedLayout，那么onPrepare和onMeasure之前就已经被调用了</span><br><span class="line">public @Nullable ConcurrentHashMap&lt;Long, InternalNode&gt; mThreadIdToLastMeasuredLayout;</span><br><span class="line"></span><br><span class="line">static InternalNode resolveNestedTree(</span><br><span class="line">    ComponentContext context, InternalNode holder, int widthSpec, int heightSpec) &#123;</span><br><span class="line">	......</span><br><span class="line">    &#x2F;&#x2F; 检查是否有缓存可以使用</span><br><span class="line">    final InternalNode cachedLayout &#x3D;</span><br><span class="line">        consumeCachedLayout(component, holder, widthSpec, heightSpec);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>参考<br><a href="https://mp.weixin.qq.com/s/RS7O7prvkCvKyxkK3YQxtA?utm_source=androidweekly.io&utm_medium=website" target="_blank" rel="noopener">Litho的使用及原理剖析</a><br><a href="https://fujianyi.gitbook.io/litho/" target="_blank" rel="noopener">LithoGitBook</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Litho</tag>
      </tags>
  </entry>
  <entry>
    <title>RececlerView 源码分析</title>
    <url>/blog/2020/04/27/RececlerView%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>本文基于 V7-25.3.1</p>
</blockquote>
<h2 id="图文总结"><a href="#图文总结" class="headerlink" title="图文总结"></a>图文总结</h2><h3 id="RecyclerView优点"><a href="#RecyclerView优点" class="headerlink" title="RecyclerView优点"></a>RecyclerView优点</h3><ul>
<li>更好的灵活配置能力，在LayoutManager（布局）、Adapter（数据适配）和动画的兼容上都更优雅</li>
<li>缓存能力增强，离屏缓存相对较优，另增加了一层缓存池缓存</li>
<li>支持局部刷新，对于一些交互处理多的情况下，会带来更好的性能</li>
</ul>
<h3 id="RecyclerView类图"><a href="#RecyclerView类图" class="headerlink" title="RecyclerView类图"></a>RecyclerView类图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/20200429123125.png"  alt=""></p>
<h3 id="RecyclerView绘制流程图"><a href="#RecyclerView绘制流程图" class="headerlink" title="RecyclerView绘制流程图"></a>RecyclerView绘制流程图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884348092958.png"  alt=""></p>
<h3 id="RecyclerView滑动流程图"><a href="#RecyclerView滑动流程图" class="headerlink" title="RecyclerView滑动流程图"></a>RecyclerView滑动流程图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884348202362.png"  alt=""></p>
<h3 id="RecyclerView缓存介绍图"><a href="#RecyclerView缓存介绍图" class="headerlink" title="RecyclerView缓存介绍图"></a>RecyclerView缓存介绍图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884348287378.png"  alt=""></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><h3 id="RecyclerView使用方法分分析"><a href="#RecyclerView使用方法分分析" class="headerlink" title="RecyclerView使用方法分分析"></a>RecyclerView使用方法分分析</h3><h4 id="RecyclerView-构造方法"><a href="#RecyclerView-构造方法" class="headerlink" title="RecyclerView 构造方法"></a>RecyclerView 构造方法</h4><ul>
<li>进行View相关配置属性设置，触摸范围、滑动速度等</li>
<li>设置Item动画监听器</li>
<li>初始化AdapterManager，创建AdapterHelper（负责Adapter里的数据集发生变化时的预处理操作）</li>
<li>初始化ChildHelper（负责管理和访问 RecyclerView 的子视图）</li>
<li>如果配置了LayoutManager 则通过反射方法创建它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</span><br><span class="line">       super(context, attrs, defStyle);</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; View配置相关属性设置</span><br><span class="line">       final ViewConfiguration vc &#x3D; ViewConfiguration.get(context);</span><br><span class="line">       mTouchSlop &#x3D; vc.getScaledTouchSlop();</span><br><span class="line">       mMinFlingVelocity &#x3D; vc.getScaledMinimumFlingVelocity();</span><br><span class="line">       mMaxFlingVelocity &#x3D; vc.getScaledMaximumFlingVelocity();</span><br><span class="line">       setWillNotDraw(getOverScrollMode() &#x3D;&#x3D; View.OVER_SCROLL_NEVER);</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 设置Item动画监听器</span><br><span class="line">       mItemAnimator.setListener(mItemAnimatorListener);</span><br><span class="line">       &#x2F;&#x2F; 设置 AdapterManager</span><br><span class="line">       initAdapterManager();</span><br><span class="line">       &#x2F;&#x2F; 设置 ChildrenHelper </span><br><span class="line">       initChildrenHelper();</span><br><span class="line">       &#x2F;&#x2F; 硬件加速相关属性设置</span><br><span class="line">       if (ViewCompat.getImportantForAccessibility(this)</span><br><span class="line">               &#x3D;&#x3D; ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">           ViewCompat.setImportantForAccessibility(this,</span><br><span class="line">                   ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">       &#125;</span><br><span class="line">       mAccessibilityManager &#x3D; (AccessibilityManager) getContext()</span><br><span class="line">               .getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class="line">       setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 如果attrs指定了LayoutManager，则创建LayoutManager</span><br><span class="line">       boolean nestedScrollingEnabled &#x3D; true;</span><br><span class="line">       </span><br><span class="line">       if (attrs !&#x3D; null) &#123;</span><br><span class="line">           int defStyleRes &#x3D; 0;</span><br><span class="line">           TypedArray a &#x3D; context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,</span><br><span class="line">                   defStyle, defStyleRes);</span><br><span class="line">           String layoutManagerName &#x3D; a.getString(R.styleable.RecyclerView_layoutManager);</span><br><span class="line">           int descendantFocusability &#x3D; a.getInt(</span><br><span class="line">                   R.styleable.RecyclerView_android_descendantFocusability, -1);</span><br><span class="line">           if (descendantFocusability &#x3D;&#x3D; -1) &#123;</span><br><span class="line">               setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">           &#125;</span><br><span class="line">           a.recycle();</span><br><span class="line">           &#x2F;&#x2F; 反射方法创建 LayoutManager</span><br><span class="line">           createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);</span><br><span class="line"></span><br><span class="line">           if (Build.VERSION.SDK_INT &gt;&#x3D; 21) &#123;</span><br><span class="line">               &#x2F;&#x2F; SDK &gt;&#x3D;21下 ，nestedScrollingEnabled状态支持变更</span><br><span class="line">               a &#x3D; context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,</span><br><span class="line">                       defStyle, defStyleRes);</span><br><span class="line">               nestedScrollingEnabled &#x3D; a.getBoolean(0, true);</span><br><span class="line">               a.recycle();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 重置nestedScrollingEnabled状态 SDK 21以下默认true</span><br><span class="line">       setNestedScrollingEnabled(nestedScrollingEnabled);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="setLayoutManager"><a href="#setLayoutManager" class="headerlink" title="setLayoutManager"></a>setLayoutManager</h4><ul>
<li>处理重新设置一个新的LayoutManager的一些逻辑</li>
<li>设置this给到LayoutManager，并如果attach了则执行LayoutManger的attach分发实践</li>
<li>跟新缓存大小，并请求重新布局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setLayoutManager(LayoutManager layout) &#123;</span><br><span class="line">        if (layout &#x3D;&#x3D; mLayout) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        stopScroll();</span><br><span class="line">        &#x2F;&#x2F; 设置新的layout情况下的一些处理逻辑</span><br><span class="line">        ... </span><br><span class="line">        </span><br><span class="line">        mChildHelper.removeAllViewsUnfiltered();</span><br><span class="line">        mLayout &#x3D; layout;</span><br><span class="line">        if (layout !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; layout只能绑定一个mRecyclerView </span><br><span class="line">            if (layout.mRecyclerView !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +</span><br><span class="line">                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置this引用给LayoutManager</span><br><span class="line">            mLayout.setRecyclerView(this);</span><br><span class="line">            if (mIsAttached) &#123;</span><br><span class="line">                &#x2F;&#x2F; 分发attach事件</span><br><span class="line">                mLayout.dispatchAttachedToWindow(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 重新更新缓存大小 及请求重新布局</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="setAdapter"><a href="#setAdapter" class="headerlink" title="setAdapter"></a>setAdapter</h4><ul>
<li>接触frozen状态</li>
<li>设置新的Adapter，并触发一系列监听事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setAdapter(Adapter adapter) &#123;</span><br><span class="line">   &#x2F;&#x2F; 解除frozen状态</span><br><span class="line">   setLayoutFrozen(false);</span><br><span class="line">   &#x2F;&#x2F; 替换到当前Adapter，并触发监听</span><br><span class="line">   setAdapterInternal(adapter, false, true);</span><br><span class="line">   requestLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,</span><br><span class="line">            boolean removeAndRecycleViews) &#123;</span><br><span class="line">        &#x2F;&#x2F; 旧Adapter进行解绑数据监听 和 RecyclerView的引用</span><br><span class="line">        if (mAdapter !&#x3D; null) &#123;</span><br><span class="line">            mAdapter.unregisterAdapterDataObserver(mObserver);</span><br><span class="line">            mAdapter.onDetachedFromRecyclerView(this);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!compatibleWithPrevious || removeAndRecycleViews) &#123;</span><br><span class="line">            removeAndRecycleViews(); &#x2F;&#x2F; 移除缓存的View</span><br><span class="line">        &#125;</span><br><span class="line">        mAdapterHelper.reset();</span><br><span class="line">        final Adapter oldAdapter &#x3D; mAdapter;</span><br><span class="line">        mAdapter &#x3D; adapter;</span><br><span class="line">        if (adapter !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 处理新设置的Adapter的关联监听和RecyclerView</span><br><span class="line">            adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">            adapter.onAttachedToRecyclerView(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通知LayoutManager Adapter变更</span><br><span class="line">        if (mLayout !&#x3D; null) &#123;</span><br><span class="line">            mLayout.onAdapterChanged(oldAdapter, mAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 触发Recycler Adapter变更事件</span><br><span class="line">        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</span><br><span class="line">        &#x2F;&#x2F; 状态置为 mStructureChanged </span><br><span class="line">        mState.mStructureChanged &#x3D; true;</span><br><span class="line">        markKnownViewsInvalid();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecyclerView绘制方法分析"><a href="#RecyclerView绘制方法分析" class="headerlink" title="RecyclerView绘制方法分析"></a>RecyclerView绘制方法分析</h3><h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><ul>
<li>未赋值layoutManager情况下，走默认measure，结果是无展示</li>
<li>系统提供的LayoutManager默认AutoMeasure。执行LayoutManger的onMeasure方法</li>
<li>如果未指定确定宽高的尺寸规格，则会进行布局，继而获得子View的大小。此过程可能执行两次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</span><br><span class="line">   if (mLayout &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 无LayoutManger</span><br><span class="line">       defaultOnMeasure(widthSpec, heightSpec); </span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; Android提供的三个LayoutManger，都是AutoMeasure</span><br><span class="line">   if (mLayout.mAutoMeasure) &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取测量规格</span><br><span class="line">       final int widthMode &#x3D; MeasureSpec.getMode(widthSpec);</span><br><span class="line">       final int heightMode &#x3D; MeasureSpec.getMode(heightSpec);</span><br><span class="line">       final boolean skipMeasure &#x3D; widthMode &#x3D;&#x3D; MeasureSpec.EXACTLY</span><br><span class="line">               &amp;&amp; heightMode &#x3D;&#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">       &#x2F;&#x2F; 执行LayoutManager的onMeasure方法</span><br><span class="line">       mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">       </span><br><span class="line">       if (skipMeasure || mAdapter &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 如果测量规格不确定 且设置了Adapter，则先执行一次layout</span><br><span class="line">       if (mState.mLayoutStep &#x3D;&#x3D; State.STEP_START) &#123;</span><br><span class="line">           dispatchLayoutStep1();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 设置测量规格</span><br><span class="line">       mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">       mState.mIsMeasuring &#x3D; true;</span><br><span class="line">       dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 设置 获取到子View的宽高</span><br><span class="line">       mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;二次测量，宽高不确定情况下</span><br><span class="line">       if (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">           mLayout.setMeasureSpecs(</span><br><span class="line">                   MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                   MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">           mState.mIsMeasuring &#x3D; true;</span><br><span class="line">           dispatchLayoutStep2();</span><br><span class="line">           &#x2F;&#x2F; now we can get the width and height from the children.</span><br><span class="line">           mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RecyclerView-onLayout"><a href="#RecyclerView-onLayout" class="headerlink" title="RecyclerView.onLayout"></a>RecyclerView.onLayout</h4><ul>
<li>执行DispatchLayout方法</li>
<li>根据不同State状态，分别执行Step1、Step2、Step3方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">   TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">   dispatchLayout();</span><br><span class="line">   TraceCompat.endSection();</span><br><span class="line">   mFirstLayoutComplete &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">    void dispatchLayout() &#123;</span><br><span class="line">        mState.mIsMeasuring &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 如果State状态是 State.STEP_START 则执行 Step1 和Step2</span><br><span class="line">        if (mState.mLayoutStep &#x3D;&#x3D; State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() !&#x3D; getWidth() </span><br><span class="line">            &#x2F;&#x2F; 直接执行 step2</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 执行Step3 ，主要保存一些View信息和动画执行</span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="dispatchLayoutStep1"><a href="#dispatchLayoutStep1" class="headerlink" title="dispatchLayoutStep1"></a>dispatchLayoutStep1</h4><ul>
<li>第一步layout方法</li>
<li>处理adapter变更</li>
<li>确定需要执行的动画</li>
<li>针对当前的Views进行信息缓存</li>
<li>如有必要，则进行预布局并缓存信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void dispatchLayoutStep1() &#123;</span><br><span class="line">   &#x2F;&#x2F;  State状态断言 </span><br><span class="line">   mState.assertLayoutStep(State.STEP_START);</span><br><span class="line">   mState.mIsMeasuring &#x3D; false;</span><br><span class="line">   &#x2F;&#x2F; 是否过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1</span><br><span class="line">   eatRequestLayout();</span><br><span class="line">   &#x2F;&#x2F; 清楚 ViewInfo 所有状态和其存在的数据</span><br><span class="line">   mViewInfoStore.clear();</span><br><span class="line">   &#x2F;&#x2F; 执行进入 layout或者scroll行为标志</span><br><span class="line">   onEnterLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 执行Adapter变更及计算那些需要执行的动画</span><br><span class="line">   processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">   &#x2F;&#x2F; 存储焦点信息</span><br><span class="line">   saveFocusInfo();</span><br><span class="line">   &#x2F;&#x2F; state状态信息设置</span><br><span class="line">   mState.mTrackOldChangeHolders &#x3D; mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;</span><br><span class="line">   mItemsAddedOrRemoved &#x3D; mItemsChanged &#x3D; false;</span><br><span class="line">   mState.mInPreLayout &#x3D; mState.mRunPredictiveAnimations;</span><br><span class="line">   mState.mItemCount &#x3D; mAdapter.getItemCount();</span><br><span class="line">   &#x2F;&#x2F; 寻找 layout过程中position的最大和最小值</span><br><span class="line">   findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</span><br><span class="line">   </span><br><span class="line">   if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">       ...  </span><br><span class="line">       int count &#x3D; mChildHelper.getChildCount();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; count; ++i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历VieHolder</span><br><span class="line">           final ViewHolder holder &#x3D; getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">           if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 创建 ItemHolderInfo</span><br><span class="line">           final ItemHolderInfo animationInfo &#x3D; mItemAnimator</span><br><span class="line">                   .recordPreLayoutInformation(mState, holder,</span><br><span class="line">                           ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</span><br><span class="line">                           holder.getUnmodifiedPayloads());</span><br><span class="line">           &#x2F;&#x2F; mViewInfoStore存储 holder及其对应animation信息</span><br><span class="line">           mViewInfoStore.addToPreLayout(holder, animationInfo);</span><br><span class="line">           if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</span><br><span class="line">               &#x2F;&#x2F; 如果holder确定要更新，就把它添加到 oldChangeHolders 集合中</span><br><span class="line">               mViewInfoStore.addToOldChangeHolders(key, holder);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">   if (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">      ... &#x2F;&#x2F; 运行预布局</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 执行退出 layout或者scroll行为标志</span><br><span class="line">   onExitLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 对应 mEatRequestLayout -1</span><br><span class="line">   resumeRequestLayout(false);</span><br><span class="line">   &#x2F;&#x2F; 状态进入 State.STEP_LAYOUT</span><br><span class="line">   mState.mLayoutStep &#x3D; State.STEP_LAYOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void processAdapterUpdatesAndSetAnimationFlags() &#123;</span><br><span class="line">   if (predictiveItemAnimationsEnabled()) &#123;</span><br><span class="line">       mAdapterHelper.preProcess(); &#x2F;&#x2F; 预处理</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">   &#125;</span><br><span class="line">   boolean animationTypeSupported &#x3D; mItemsAddedOrRemoved || mItemsChanged;</span><br><span class="line">   &#x2F;&#x2F; 计算 mRunSimpleAnimations 和 mRunPredictiveAnimations</span><br><span class="line">   &#x2F;&#x2F; mDataSetHasChangedAfterLayout 数据是否变化</span><br><span class="line">   mState.mRunSimpleAnimations &#x3D; mFirstLayoutComplete</span><br><span class="line">           &amp;&amp; mItemAnimator !&#x3D; null</span><br><span class="line">           &amp;&amp; (mDataSetHasChangedAfterLayout</span><br><span class="line">           || animationTypeSupported</span><br><span class="line">           || mLayout.mRequestedSimpleAnimations)</span><br><span class="line">           &amp;&amp; (!mDataSetHasChangedAfterLayout</span><br><span class="line">           || mAdapter.hasStableIds());</span><br><span class="line">   mState.mRunPredictiveAnimations &#x3D; mState.mRunSimpleAnimations</span><br><span class="line">           &amp;&amp; animationTypeSupported</span><br><span class="line">           &amp;&amp; !mDataSetHasChangedAfterLayout</span><br><span class="line">           &amp;&amp; predictiveItemAnimationsEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchLayoutStep2"><a href="#dispatchLayoutStep2" class="headerlink" title="dispatchLayoutStep2"></a>dispatchLayoutStep2</h4><ul>
<li>执行最终的View布局操作，该过程由LayoutManager完成</li>
<li>该方法可能会被多次执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void dispatchLayoutStep2() &#123;</span><br><span class="line">   &#x2F;&#x2F; 过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1。对应resumeRequestLayout方法进行消费</span><br><span class="line">   eatRequestLayout();</span><br><span class="line">   &#x2F;&#x2F; 对应 onExitLayoutOrScroll</span><br><span class="line">   onEnterLayoutOrScroll();</span><br><span class="line">   mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">   &#x2F;&#x2F; 跳过预处理过程，一次性执行完所有的update</span><br><span class="line">   mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">   mState.mItemCount &#x3D; mAdapter.getItemCount(); &#x2F;&#x2F; 赋值 itemCOunt</span><br><span class="line">   mState.mDeletedInvisibleItemCountSincePreviousLayout &#x3D; 0; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   mState.mInPreLayout &#x3D; false;</span><br><span class="line">   &#x2F;&#x2F; 执行 layout （执行 LayoutManager 布局）</span><br><span class="line">   mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">   mState.mStructureChanged &#x3D; false;</span><br><span class="line">   mPendingSavedState &#x3D; null;</span><br><span class="line">   mState.mRunSimpleAnimations &#x3D; mState.mRunSimpleAnimations &amp;&amp; mItemAnimator !&#x3D; null;</span><br><span class="line">   &#x2F;&#x2F; State状态进入 State.STEP_ANIMATIONS</span><br><span class="line">   mState.mLayoutStep &#x3D; State.STEP_ANIMATIONS;</span><br><span class="line">   &#x2F;&#x2F; 对应 onExitLayoutOrScroll</span><br><span class="line">   onExitLayoutOrScroll();</span><br><span class="line">   &#x2F;&#x2F; 对应eatRequestLayout方法</span><br><span class="line">   resumeRequestLayout(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchLayoutStep3"><a href="#dispatchLayoutStep3" class="headerlink" title="dispatchLayoutStep3"></a>dispatchLayoutStep3</h4><p>layout过程最后一步，执行相关动画和一些清理事项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void dispatchLayoutStep3() &#123;</span><br><span class="line">   ...</span><br><span class="line">   if (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">       &#x2F;&#x2F; 执行相关动画</span><br><span class="line">       ... </span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 一些清理动作   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h4><p>主要涉及Item装饰的绘制和动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void draw(Canvas c) &#123;</span><br><span class="line">   super.draw(c);</span><br><span class="line"></span><br><span class="line">   final int count &#x3D; mItemDecorations.size();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">       mItemDecorations.get(i).onDrawOver(c, this, mState);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   boolean needsInvalidate &#x3D; false;</span><br><span class="line">   ...</span><br><span class="line">   if (!needsInvalidate &amp;&amp; mItemAnimator !&#x3D; null &amp;&amp; mItemDecorations.size() &gt; 0 &amp;&amp;</span><br><span class="line">           mItemAnimator.isRunning()) &#123;</span><br><span class="line">       needsInvalidate &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (needsInvalidate) &#123;</span><br><span class="line">       ViewCompat.postInvalidateOnAnimation(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void onDraw(Canvas c) &#123;</span><br><span class="line">   super.onDraw(c);</span><br><span class="line"></span><br><span class="line">   final int count &#x3D; mItemDecorations.size();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">       mItemDecorations.get(i).onDraw(c, this, mState);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinearLayoutManager-填充子View过程"><a href="#LinearLayoutManager-填充子View过程" class="headerlink" title="LinearLayoutManager 填充子View过程"></a>LinearLayoutManager 填充子View过程</h3><h4 id="LinearLayoutManager-onLayoutChildren"><a href="#LinearLayoutManager-onLayoutChildren" class="headerlink" title="LinearLayoutManager.onLayoutChildren"></a>LinearLayoutManager.onLayoutChildren</h4><ul>
<li>Child布局执行核心方法</li>
<li>布局方式，通过确定锚点，首先以锚点为基准上到下布局，在以锚点为基准从下往上布局。如果还有空间，继续从上到下布局。最后确认整个间隙是正确的。（反向布局及横向反之则可）</li>
<li>该方法为LayoutManager布局核心执行方法，Child的测量和添加工作在fill这个重要方法执行，接下来会阐述 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">    </span><br><span class="line">       &#x2F;&#x2F; 确定是否需要反向布局</span><br><span class="line">       &#x2F;&#x2F; 确定锚点及偏移量 (1. 优先焦点child 2. 如果是反向布局，则找recycler里面最最接近尾部的child 3. 如果是正向，则找最接近头部的child)</span><br><span class="line">       &#x2F;&#x2F; 计算额外的偏移量（RecyclerView padding） </span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 锚点准备ready        </span><br><span class="line">       onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">       &#x2F;&#x2F; 临时 detach和回收当前的view 第一次 measure 的时候不会产生效果，因为此时 RecyclerView 还没有子 View。 而在第二第三次 layout 时，它会把子 View 从 RecyclerView 中 remove 或 detach ，并缓存子 View，以便之后重新 add 回来或 attach 回来，避免重复加载相同的子 View</span><br><span class="line">       detachAndScrapAttachedViews(recycler); </span><br><span class="line">       mLayoutState.mInfinite &#x3D; resolveIsInfinite(); </span><br><span class="line">       mLayoutState.mIsPreLayout &#x3D; state.isPreLayout();</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 开始填充view</span><br><span class="line">       if (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">          ... &#x2F;&#x2F; 反向填充</span><br><span class="line">       &#125; else &#123; &#x2F;&#x2F; 正向填充</span><br><span class="line">           &#x2F;&#x2F; （基于锚点位置先 由上到下||由左到右）更新锚点信息</span><br><span class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">           mLayoutState.mExtra &#x3D; extraForEnd; &#x2F;&#x2F; 额外的尾部偏移量</span><br><span class="line">           &#x2F;&#x2F; 开始填充 View布局主要方法</span><br><span class="line">           fill(recycler, mLayoutState, state, false);</span><br><span class="line">           &#x2F;&#x2F; 尾部位移</span><br><span class="line">           endOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           final int lastElement &#x3D; mLayoutState.mCurrentPosition;</span><br><span class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">               extraForStart +&#x3D; mLayoutState.mAvailable;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; （基于锚点位置 由下到上||由右到左）更新锚点信息</span><br><span class="line">           updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">           mLayoutState.mExtra &#x3D; extraForStart;</span><br><span class="line">           mLayoutState.mCurrentPosition +&#x3D; mLayoutState.mItemDirection;</span><br><span class="line">           &#x2F;&#x2F; 二次填充</span><br><span class="line">           fill(recycler, mLayoutState, state, false);</span><br><span class="line">           startOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           &#x2F;&#x2F; 仍有可用空间</span><br><span class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</span><br><span class="line">               extraForEnd &#x3D; mLayoutState.mAvailable;</span><br><span class="line">               &#x2F;&#x2F; 继续 （基于锚点位置先 由上到下||由左到右）更新信息并填充View</span><br><span class="line">               updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">               mLayoutState.mExtra &#x3D; extraForEnd;</span><br><span class="line">               fill(recycler, mLayoutState, state, false);</span><br><span class="line">               endOffset &#x3D; mLayoutState.mOffset;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       &#x2F;&#x2F; 有滑动位置导致的gap间隙修复处理</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 预布局动画处理</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-fill"><a href="#LinearLayoutManager-fill" class="headerlink" title="LinearLayoutManager.fill"></a>LinearLayoutManager.fill</h4><ul>
<li>如果是滑动流程，则根据情况进行回收流程</li>
<li>LayoutState中部分成员变量含义，mOffset：填充起始坐标，mCurrentPosition：填充起始数据的position，mAvailable：本次滑动可填充的距离，mScrollingOffset：滑动过的总量循环依次加载子View</li>
<li>确定可布局大小，直至布局大小消费完成</li>
<li>加载子View在 layoutChunk 中执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</span><br><span class="line">            </span><br><span class="line">   &#x2F;&#x2F; 可布局的位移</span><br><span class="line">   final int start &#x3D; layoutState.mAvailable;</span><br><span class="line">   &#x2F;&#x2F; 滑动偏移的情况下</span><br><span class="line">   if (layoutState.mScrollingOffset !&#x3D; LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">       if (layoutState.mAvailable &lt; 0) &#123;</span><br><span class="line">           layoutState.mScrollingOffset +&#x3D; layoutState.mAvailable;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 执行回收流程</span><br><span class="line">       recycleByLayoutState(recycler, layoutState);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 余量大小</span><br><span class="line">   int remainingSpace &#x3D; layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">   &#x2F;&#x2F; 每次布局结果中间记录 方便运算  </span><br><span class="line">   LayoutChunkResult layoutChunkResult &#x3D; mLayoutChunkResult;</span><br><span class="line">   while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">       layoutChunkResult.resetInternal();</span><br><span class="line">       &#x2F;&#x2F; 加载子View</span><br><span class="line">       layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line"></span><br><span class="line">       if (layoutChunkResult.mFinished) &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       layoutState.mOffset +&#x3D; layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">       &#x2F;&#x2F; 计算布局使用过的大小值</span><br><span class="line">       if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList !&#x3D; null</span><br><span class="line">               || !state.isPreLayout()) &#123;</span><br><span class="line">           layoutState.mAvailable -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">           remainingSpace -&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">       &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果当前正在滚动屏幕</span><br><span class="line">       if (layoutState.mScrollingOffset !&#x3D; LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">           layoutState.mScrollingOffset +&#x3D; layoutChunkResult.mConsumed;</span><br><span class="line">           if (layoutState.mAvailable &lt; 0) &#123;</span><br><span class="line">               layoutState.mScrollingOffset +&#x3D; layoutState.mAvailable;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 把移出屏幕的 View 缓存到 mCachedViews 里面</span><br><span class="line">           recycleByLayoutState(recycler, layoutState);</span><br><span class="line">       &#125;</span><br><span class="line">       if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-layoutChunk"><a href="#LinearLayoutManager-layoutChunk" class="headerlink" title="LinearLayoutManager.layoutChunk"></a>LinearLayoutManager.layoutChunk</h4><ul>
<li>通过layoutState.next(recycler)获取目标布局View</li>
<li>获取目标View完毕后，进行含装饰的Margin计算，并执行布局</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,</span><br><span class="line">            LayoutState layoutState, LayoutChunkResult result) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取下一个布局View （核心方法）</span><br><span class="line">        View view &#x3D; layoutState.next(recycler);</span><br><span class="line">        </span><br><span class="line">        LayoutParams params &#x3D; (LayoutParams) view.getLayoutParams();</span><br><span class="line">        if (layoutState.mScrapList &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 除非特殊指定，否则mScrapList为null</span><br><span class="line">            &#x2F;&#x2F; 执行 addView </span><br><span class="line">            if (mShouldReverseLayout &#x3D;&#x3D; (layoutState.mLayoutDirection</span><br><span class="line">                    &#x3D;&#x3D; LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 添加到末尾</span><br><span class="line">                addView(view); </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addView(view, 0); &#x2F;&#x2F; 添加到第一个位置</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...      </span><br><span class="line">        &#125;</span><br><span class="line">        measureChildWithMargins(view, 0, 0); &#x2F;&#x2F; 测量子View的Margins</span><br><span class="line">        &#x2F;&#x2F; 计算 含装饰的Margin值的大小</span><br><span class="line">        result.mConsumed &#x3D; mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">        int left, top, right, bottom;</span><br><span class="line">        &#x2F;&#x2F; 计算 r、l、t、b的值</span><br><span class="line">        if (mOrientation &#x3D;&#x3D; VERTICAL) &#123;</span><br><span class="line">            if (isLayoutRTL()) &#123;</span><br><span class="line">                right &#x3D; getWidth() - getPaddingRight();</span><br><span class="line">                left &#x3D; right - mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left &#x3D; getPaddingLeft();</span><br><span class="line">                right &#x3D; left + mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">            &#125;</span><br><span class="line">            if (layoutState.mLayoutDirection &#x3D;&#x3D; LayoutState.LAYOUT_START) &#123;</span><br><span class="line">                bottom &#x3D; layoutState.mOffset;</span><br><span class="line">                top &#x3D; layoutState.mOffset - result.mConsumed;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                top &#x3D; layoutState.mOffset;</span><br><span class="line">                bottom &#x3D; layoutState.mOffset + result.mConsumed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 对View进行布局</span><br><span class="line">        layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">        &#x2F;&#x2F; 部分状态改变 </span><br><span class="line">        if (params.isItemRemoved() || params.isItemChanged()) &#123;</span><br><span class="line">            result.mIgnoreConsumed &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        result.mFocusable &#x3D; view.hasFocusable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager-next"><a href="#LinearLayoutManager-next" class="headerlink" title="LinearLayoutManager.next"></a>LinearLayoutManager.next</h4><p>通过RecyclerView.Recycler获取对应Pos的View</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View next(RecyclerView.Recycler recycler) &#123;</span><br><span class="line">  if (mScrapList !&#x3D; null) &#123; &#x2F;&#x2F; 除非定制View，不然为null</span><br><span class="line">      return nextViewFromScrapList();</span><br><span class="line">  &#125;</span><br><span class="line">  通过RecyclerView.Recycler 获取目标position对应的View </span><br><span class="line">  final View view &#x3D; recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">  mCurrentPosition +&#x3D; mItemDirection; &#x2F;&#x2F; 当前pos 增加</span><br><span class="line">  return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Recycler获取VH的缓存和创建过程"><a href="#Recycler获取VH的缓存和创建过程" class="headerlink" title="Recycler获取VH的缓存和创建过程"></a>Recycler获取VH的缓存和创建过程</h3><h4 id="Recycler-getViewForPosition"><a href="#Recycler-getViewForPosition" class="headerlink" title="Recycler.getViewForPosition"></a>Recycler.getViewForPosition</h4><p>根据Pos获取View方法，最终执行tryGetViewHolderForPositionByDeadline获取View</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public View getViewForPosition(int position) &#123;</span><br><span class="line">  return getViewForPosition(position, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">  return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Recycler-tryGetViewHolderForPositionByDeadline"><a href="#Recycler-tryGetViewHolderForPositionByDeadline" class="headerlink" title="Recycler.tryGetViewHolderForPositionByDeadline"></a>Recycler.tryGetViewHolderForPositionByDeadline</h4><ul>
<li>获取ViewHolder方法</li>
<li>如果是预布局，线通过ChangeScrap中获取</li>
<li>第一次尝试获取VH，依次从Scrap、Hidden、Cache中获取VH</li>
<li>第二次尝试获取VH，针对具有StableId的Adapter，根据id依次从Scrap和Cache获取</li>
<li>第三次尝试从自定义缓存中获取VH</li>
<li>第四次尝试从Recycler获取VH</li>
<li>最后直接创建VH</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">  </span><br><span class="line">  boolean fromScrapOrHiddenOrCache &#x3D; false;</span><br><span class="line">  ViewHolder holder &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 0) 如果是预布局， 从mChangedScrap中获取 </span><br><span class="line">  if (mState.isPreLayout()) &#123;</span><br><span class="line">      holder &#x3D; getChangedScrapViewForPosition(position);</span><br><span class="line">      fromScrapOrHiddenOrCache &#x3D; holder !&#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 1) 第一次尝试获取，依次从Scrap、Hidden、Cache中获取VH</span><br><span class="line">  if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 依次从Scrap、Hidden、Cache中获取VH</span><br><span class="line">      holder &#x3D; getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">      ... </span><br><span class="line">  &#125;</span><br><span class="line">  if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">      final int type &#x3D; mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">      &#x2F;&#x2F; 2) 第二次尝试获取，当Adapter具备StableIds情况</span><br><span class="line">      if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">          holder &#x3D; getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                  type, dryRun);</span><br><span class="line">          if (holder !&#x3D; null) &#123;</span><br><span class="line">              &#x2F;&#x2F; update position</span><br><span class="line">              holder.mPosition &#x3D; offsetPosition;</span><br><span class="line">              fromScrapOrHiddenOrCache &#x3D; true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 3) 第三次尝试从 自定义缓存获取</span><br><span class="line">      if (holder &#x3D;&#x3D; null &amp;&amp; mViewCacheExtension !&#x3D; null) &#123;</span><br><span class="line">                   final View view &#x3D; mViewCacheExtension</span><br><span class="line">                  .getViewForPositionAndType(this, position, type);</span><br><span class="line">          if (view !&#x3D; null) &#123;</span><br><span class="line">              holder &#x3D; getChildViewHolder(view);</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 4) 第四次尝试 从 RecyclerPool中获取</span><br><span class="line">      if (holder &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; fallback to pool</span><br><span class="line">          holder &#x3D; getRecycledViewPool().getRecycledView(type);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 5) 开始创建</span><br><span class="line">      if (holder &#x3D;&#x3D; null) &#123;</span><br><span class="line">          long start &#x3D; getNanoTime();</span><br><span class="line">          &#x2F;&#x2F; 创建VH</span><br><span class="line">          holder &#x3D; mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">          ... </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">       boolean bound &#x3D; false;</span><br><span class="line">       if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">           holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">       &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 为bind过，执行bind方法</span><br><span class="line">           final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">           bound &#x3D; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        private boolean tryBindViewHolderByDeadline(ViewHolder holder, int offsetPosition,</span><br><span class="line">                int position, long deadlineNs) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 执行Adapter bindViewHolder方法</span><br><span class="line">            mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">            ...</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="00-从ChangeScrap获取"><a href="#00-从ChangeScrap获取" class="headerlink" title="00 从ChangeScrap获取"></a>00 从ChangeScrap获取</h4><p>针对的是预布局状态，从mChangedScrap中获取目标ViewHolder<br>ScrapView：View仍然attach在其父RecyclerView上且可以被重复绑定数据及重复使用。将View标记为Scrap过程中分为两大类mAttachedScrap 和 mChangedScrap。<br>mAttachedScrap：VH有ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID这两个Flag，或者VH是没有被更新过的，或者是可以被重新更新的VH。<br>其它则是mChangedScrap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ViewHolder getChangedScrapViewForPosition(int position) &#123;</span><br><span class="line">  &#x2F;&#x2F; 必须是预布局状态，取mChangedScrap中的ViewHolder</span><br><span class="line">  final int changedScrapSize;</span><br><span class="line">  if (mChangedScrap &#x3D;&#x3D; null || (changedScrapSize &#x3D; mChangedScrap.size()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 通过position获取</span><br><span class="line">  for (int i &#x3D; 0; i &lt; changedScrapSize; i++) &#123;</span><br><span class="line">      final ViewHolder holder &#x3D; mChangedScrap.get(i);</span><br><span class="line">      if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position) &#123;</span><br><span class="line">          holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">          return holder;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果Adapter是固定id，尝试从Adapter获取</span><br><span class="line">  if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">      final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">      if (offsetPosition &gt; 0 &amp;&amp; offsetPosition &lt; mAdapter.getItemCount()) &#123;</span><br><span class="line">          final long id &#x3D; mAdapter.getItemId(offsetPosition);</span><br><span class="line">          for (int i &#x3D; 0; i &lt; changedScrapSize; i++) &#123;</span><br><span class="line">              final ViewHolder holder &#x3D; mChangedScrap.get(i);</span><br><span class="line">              if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getItemId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">                  holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">                  return holder;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mark an attached view as scrap.</span><br><span class="line">void scrapView(View view) &#123;</span><br><span class="line">       final ViewHolder holder &#x3D; getChildViewHolderInt(view);</span><br><span class="line">       if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">               || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">           holder.setScrapContainer(this, false);</span><br><span class="line">           mAttachedScrap.add(holder);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           if (mChangedScrap &#x3D;&#x3D; null) &#123;</span><br><span class="line">               mChangedScrap &#x3D; new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">           &#125;</span><br><span class="line">           holder.setScrapContainer(this, true);</span><br><span class="line">           mChangedScrap.add(holder);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="第一次尝试获取VH（AttachScrap、Hidden、CacheView）"><a href="#第一次尝试获取VH（AttachScrap、Hidden、CacheView）" class="headerlink" title="第一次尝试获取VH（AttachScrap、Hidden、CacheView）"></a>第一次尝试获取VH（AttachScrap、Hidden、CacheView）</h4><ul>
<li>先从 mAttachedScrap中获取VH</li>
<li>从隐藏且未移出的View中获取 View</li>
<li>从一级缓存CacheView中获取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">       final int scrapCount &#x3D; mAttachedScrap.size();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 先从 mAttachedScrap中获取VH</span><br><span class="line">       for (int i &#x3D; 0; i &lt; scrapCount; i++) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mAttachedScrap.get(i);</span><br><span class="line">           &#x2F;&#x2F; 验证VH是否可用，若可用，则直接返回该VH</span><br><span class="line">           if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position</span><br><span class="line">                   &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;</span><br><span class="line">               holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">               return holder;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; dryRun 传递是false（代表VH在scrap、cache中可以被Removed）</span><br><span class="line">       if (!dryRun) &#123;</span><br><span class="line">           &#x2F;&#x2F; 从隐藏且未移出的View中获取 View</span><br><span class="line">           View view &#x3D; mChildHelper.findHiddenNonRemovedView(position);</span><br><span class="line">           if (view !&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; View可用，则进行可视、detach、scrap缓存</span><br><span class="line">               final ViewHolder vh &#x3D; getChildViewHolderInt(view);</span><br><span class="line">               mChildHelper.unhide(view);</span><br><span class="line">               int layoutIndex &#x3D; mChildHelper.indexOfChild(view);</span><br><span class="line">               mChildHelper.detachViewFromParent(layoutIndex);</span><br><span class="line">               scrapView(view);</span><br><span class="line">               vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP</span><br><span class="line">                       | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">               return vh;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 从第一级缓存View中获取</span><br><span class="line">       final int cacheSize &#x3D; mCachedViews.size();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; cacheSize; i++) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mCachedViews.get(i);</span><br><span class="line">           &#x2F;&#x2F; VH是有效的</span><br><span class="line">           if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() &#x3D;&#x3D; position) &#123;</span><br><span class="line">               if (!dryRun) &#123;</span><br><span class="line">                   mCachedViews.remove(i); &#x2F;&#x2F; 移出获取的cache</span><br><span class="line">               &#125;</span><br><span class="line">               return holder; &#x2F;&#x2F; 返回VH</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二次尝试获取VH（Adapter有稳定id情况）"><a href="#第二次尝试获取VH（Adapter有稳定id情况）" class="headerlink" title="第二次尝试获取VH（Adapter有稳定id情况）"></a>第二次尝试获取VH（Adapter有稳定id情况）</h4><ul>
<li>Adapter配置的id是稳定的，稳定指数据集变化的时候，对于同一数据对应的id是唯一的</li>
<li>先尝试从Scrap获取VH，非dryRun下，将未命中的从Scrap中移出，并加入到Cache或Pool缓存</li>
<li>在尝试从Cache获取VH，将未命中的从Cache中移出，并加入到Pool缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) &#123;</span><br><span class="line">       &#x2F;&#x2F; 从AttachedScrap中 尝试获取VH</span><br><span class="line">       final int count &#x3D; mAttachedScrap.size();</span><br><span class="line">       for (int i &#x3D; count - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mAttachedScrap.get(i);</span><br><span class="line">           &#x2F;&#x2F; id 相等 且 holder 非Scrap返回</span><br><span class="line">           if (holder.getItemId() &#x3D;&#x3D; id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">               if (type &#x3D;&#x3D; holder.getItemViewType()) &#123;</span><br><span class="line">                   holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</span><br><span class="line">                   if (holder.isRemoved()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 从事</span><br><span class="line">                       if (!mState.isPreLayout()) &#123;</span><br><span class="line">                           holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE</span><br><span class="line">                                   | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return holder;</span><br><span class="line">               &#125; else if (!dryRun) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 从AttachedScrap移除</span><br><span class="line">                   mAttachedScrap.remove(i);</span><br><span class="line">                   removeDetachedView(holder.itemView, false);</span><br><span class="line">                   &#x2F;&#x2F; 回收加入至 cache 或者 pool</span><br><span class="line">                   quickRecycleScrapView(holder.itemView);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 从CacheView中尝试获取</span><br><span class="line">       final int cacheSize &#x3D; mCachedViews.size();</span><br><span class="line">       for (int i &#x3D; cacheSize - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">           final ViewHolder holder &#x3D; mCachedViews.get(i);</span><br><span class="line">           if (holder.getItemId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">               if (type &#x3D;&#x3D; holder.getItemViewType()) &#123;</span><br><span class="line">                   if (!dryRun) &#123;</span><br><span class="line">                       mCachedViews.remove(i); &#x2F;&#x2F; 从Cache中移出</span><br><span class="line">                   &#125;</span><br><span class="line">                   return holder;</span><br><span class="line">               &#125; else if (!dryRun) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 从Cache中移出，放到pool中</span><br><span class="line">                   recycleCachedViewAt(i);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecyclerView滑动机制分析"><a href="#RecyclerView滑动机制分析" class="headerlink" title="RecyclerView滑动机制分析"></a>RecyclerView滑动机制分析</h3><p>根据View事件机制可以直接来看onTouchEvent方法。<br>重点查看move事件。move事件执行了scrollByInternal方法。该方法最后会执行LayoutManager的Scroll方法，以LinearLayoutManager为例，它的ScrollBy方法最终执行到fill方法。也就是上文提到的ItemView填充方法，滑动过程中会不断执行获取对应位置的ViewHolder，然后进行View的展示。从而实现RecyclerView的滑动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent e) &#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   switch (action) &#123;</span><br><span class="line">       case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">          ...</span><br><span class="line">       case MotionEventCompat.ACTION_POINTER_DOWN: </span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_MOVE: &#123; &#x2F;&#x2F; 触摸时间-move</span><br><span class="line">           ...</span><br><span class="line">           if (mScrollState &#x3D;&#x3D; SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">               mLastTouchX &#x3D; x - mScrollOffset[0];</span><br><span class="line">               mLastTouchY &#x3D; y - mScrollOffset[1];</span><br><span class="line">                &#x2F;&#x2F; 执行内部滑动方法</span><br><span class="line">               if (scrollByInternal(</span><br><span class="line">                       canScrollHorizontally ? dx : 0,</span><br><span class="line">                       canScrollVertically ? dy : 0,</span><br><span class="line">                       vtev)) &#123;</span><br><span class="line">                   getParent().requestDisallowInterceptTouchEvent(true);</span><br><span class="line">               &#125;</span><br><span class="line">               ...           &#125;</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEventCompat.ACTION_POINTER_UP: &#123;</span><br><span class="line">           onPointerUp(e);</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_UP: &#123; &#x2F;&#x2F; 触摸事件-up</span><br><span class="line">           &#x2F;&#x2F; 执行 fling方法 ，主要做一些item和scroller动画等操作</span><br><span class="line">           if (!((xvel !&#x3D; 0 || yvel !&#x3D; 0) &amp;&amp; fling((int) xvel, (int) yvel))) &#123;</span><br><span class="line">               setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">           &#125;</span><br><span class="line">           resetTouch();</span><br><span class="line">       &#125; break;</span><br><span class="line"></span><br><span class="line">       case MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">           cancelTouch();</span><br><span class="line">       &#125; break;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scrollByInternal"><a href="#scrollByInternal" class="headerlink" title="scrollByInternal"></a>scrollByInternal</h4><ul>
<li>内部Scroll执行方法，此处会执行LayoutManager的Scroll方法</li>
<li>其它处罚Nested、OnScroll等事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">boolean scrollByInternal(int x, int y, MotionEvent ev) &#123;</span><br><span class="line">   int unconsumedX &#x3D; 0, unconsumedY &#x3D; 0;</span><br><span class="line">   int consumedX &#x3D; 0, consumedY &#x3D; 0;</span><br><span class="line"></span><br><span class="line">   consumePendingUpdateOperations();</span><br><span class="line">   if (mAdapter !&#x3D; null) &#123;</span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">       if (x !&#x3D; 0) &#123;</span><br><span class="line">           consumedX &#x3D; mLayout.scrollHorizontallyBy(x, mRecycler, mState);</span><br><span class="line">           unconsumedX &#x3D; x - consumedX;</span><br><span class="line">       &#125;</span><br><span class="line">       if (y !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; LinearLayout 竖向布局为例，走LayoutManager滑动放啊放</span><br><span class="line">           consumedY &#x3D; mLayout.scrollVerticallyBy(y, mRecycler, mState);</span><br><span class="line">           unconsumedY &#x3D; y - consumedY;</span><br><span class="line">       &#125;</span><br><span class="line">       TraceCompat.endSection();</span><br><span class="line">       repositionShadowingViews();</span><br><span class="line">       onExitLayoutOrScroll();</span><br><span class="line">       resumeRequestLayout(false);</span><br><span class="line">   &#125;</span><br><span class="line">   if (!mItemDecorations.isEmpty()) &#123;</span><br><span class="line">       invalidate();</span><br><span class="line">   &#125;</span><br><span class="line">    &#x2F;&#x2F; 分发 NestedScroll事件</span><br><span class="line">   if (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">   if (consumedX !&#x3D; 0 || consumedY !&#x3D; 0) &#123;</span><br><span class="line">       dispatchOnScrolled(consumedX, consumedY); &#x2F;&#x2F; 分发onScrolled事件</span><br><span class="line">   &#125;</span><br><span class="line">   if (!awakenScrollBars()) &#123;</span><br><span class="line">       invalidate();</span><br><span class="line">   &#125;</span><br><span class="line">   return consumedX !&#x3D; 0 || consumedY !&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager执行滑动处理"><a href="#LinearLayoutManager执行滑动处理" class="headerlink" title="LinearLayoutManager执行滑动处理"></a>LinearLayoutManager执行滑动处理</h4><ul>
<li>执行scrollBy方法</li>
<li>scrollBy方法最终走到 fill方法（上面提到的填充子View方法）</li>
<li>该方法则会进行 ItemView的填充。从而完成Recycler滑动时，View的重新创建或者重新绑定一系列过程</li>
<li>平移整个View的child，实现滑动效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,</span><br><span class="line">       RecyclerView.State state) &#123;</span><br><span class="line">   if (mOrientation &#x3D;&#x3D; HORIZONTAL) &#123;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   return scrollBy(dy, recycler, state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</span><br><span class="line">   ...</span><br><span class="line">   mLayoutState.mRecycle &#x3D; true;</span><br><span class="line">   ensureLayoutState();</span><br><span class="line">   final int layoutDirection &#x3D; dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">   final int absDy &#x3D; Math.abs(dy);</span><br><span class="line">   &#x2F;&#x2F; 更新LayoutState，布局方向和偏移值。目的是让LayoutManager知道从开始还是末尾进行回收和填充</span><br><span class="line">   updateLayoutState(layoutDirection, absDy, true, state);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 执行 LinearLayout的fill 方法</span><br><span class="line">   final int consumed &#x3D; mLayoutState.mScrollingOffset</span><br><span class="line">           + fill(recycler, mLayoutState, state, false);</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 平移整个view的child</span><br><span class="line">   mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">   </span><br><span class="line">   return scrolled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 执行回收流程</span><br><span class="line">    recycleByLayoutState(recycler, layoutState);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 执行填充流程（参考上面layoutChunk方法）</span><br><span class="line">    layoutChunk(recycler, state, layoutState,layoutChunkResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayoutManager回收流程"><a href="#LinearLayoutManager回收流程" class="headerlink" title="LinearLayoutManager回收流程"></a>LinearLayoutManager回收流程</h4><ul>
<li>根据不同的布局方向进行不同方向的回收。以Start为例介绍</li>
<li>计算位移limit值，根据limit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123;</span><br><span class="line">   &#x2F;&#x2F; 假设是 初始方向布局，则开始末尾View回收。反之亦然</span><br><span class="line">   if (layoutState.mLayoutDirection &#x3D;&#x3D; LayoutState.LAYOUT_START) &#123;</span><br><span class="line">       recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) &#123;</span><br><span class="line">   final int limit &#x3D; dt;</span><br><span class="line">   final int childCount &#x3D; getChildCount();</span><br><span class="line">   if (mShouldReverseLayout) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; childCount; i++) &#123;</span><br><span class="line">           View child &#x3D; getChildAt(i);</span><br><span class="line">           &#x2F;&#x2F; 遍历child，当超过限制大小时候，开始回收</span><br><span class="line">           if (mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">                   || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">               recycleChildren(recycler, 0, i); &#x2F;&#x2F; 执行Children回收流程</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) &#123;</span><br><span class="line">   if (endIndex &gt; startIndex) &#123;</span><br><span class="line">       for (int i &#x3D; endIndex - 1; i &gt;&#x3D; startIndex; i--) &#123;</span><br><span class="line">           removeAndRecycleViewAt(i, recycler); &#x2F;&#x2F; 执行RecyclerView的移出和回收方法</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       for (int i &#x3D; startIndex; i &gt; endIndex; i--) &#123;</span><br><span class="line">           removeAndRecycleViewAt(i, recycler);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RecyclerView-removeAndRecycleViewAt"><a href="#RecyclerView-removeAndRecycleViewAt" class="headerlink" title="RecyclerView.removeAndRecycleViewAt"></a>RecyclerView.removeAndRecycleViewAt</h4><ul>
<li>移出和回收View方法</li>
<li>执行ChildHelper的移出View方法。内部Bucket移出和回掉CallBack进行View移出</li>
<li>执行Recycler回收方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void removeAndRecycleViewAt(int index, Recycler recycler) &#123;</span><br><span class="line">  final View view &#x3D; getChildAt(index); &#x2F;&#x2F; 获取目标View</span><br><span class="line">  removeViewAt(index); &#x2F;&#x2F; 执行ChildHelper移出</span><br><span class="line">  recycler.recycleView(view); &#x2F;&#x2F; 回收View</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeViewAt(int index) &#123;</span><br><span class="line">  final View child &#x3D; getChildAt(index); </span><br><span class="line">  if (child !&#x3D; null) &#123;</span><br><span class="line">      mChildHelper.removeViewAt(index); &#x2F;&#x2F; 执行ChildHelper移出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void recycleView(View view) &#123;</span><br><span class="line">  ViewHolder holder &#x3D; getChildViewHolderInt(view); &#x2F;&#x2F; 获取VH</span><br><span class="line">  &#x2F;&#x2F; ViewHolder 回收前，需要完全detach、且不是Scrap</span><br><span class="line">  if (holder.isTmpDetached()) &#123;</span><br><span class="line">      removeDetachedView(view, false); </span><br><span class="line">  &#125;</span><br><span class="line">  if (holder.isScrap()) &#123;</span><br><span class="line">      holder.unScrap();</span><br><span class="line">  &#125; else if (holder.wasReturnedFromScrap())&#123;</span><br><span class="line">      holder.clearReturnedFromScrapFlag();</span><br><span class="line">  &#125;</span><br><span class="line">  recycleViewHolderInternal(holder); &#x2F;&#x2F; 执行回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="RecyclerView-recycleViewHolderInternal"><a href="#RecyclerView-recycleViewHolderInternal" class="headerlink" title="RecyclerView.recycleViewHolderInternal"></a>RecyclerView.recycleViewHolderInternal</h4><ul>
<li>内部缓存VH方法</li>
<li>如果CacheView满了，则移出一个Cache到Pool中</li>
<li>将目标VH缓存到Cache末尾</li>
<li>如果没有Cache成功，则直接缓存到Pool中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> void recycleViewHolderInternal(ViewHolder holder) &#123;  </span><br><span class="line">      if (mViewCacheMax &gt; 0</span><br><span class="line">              &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">              | ViewHolder.FLAG_REMOVED</span><br><span class="line">              | ViewHolder.FLAG_UPDATE</span><br><span class="line">              | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</span><br><span class="line">          &#x2F;&#x2F; Cache缓存个数超了，则直接回收CacheView到RecyclerPool</span><br><span class="line">          int cachedViewSize &#x3D; mCachedViews.size();</span><br><span class="line">          if (cachedViewSize &gt;&#x3D; mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</span><br><span class="line">              recycleCachedViewAt(0);</span><br><span class="line">              cachedViewSize--;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          int targetCacheIndex &#x3D; cachedViewSize;</span><br><span class="line">          &#x2F;&#x2F; 将VH缓存到CacheView中</span><br><span class="line">          mCachedViews.add(targetCacheIndex, holder);</span><br><span class="line">          cached &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果未CacheView缓存，则直接缓存RecyclerViewPool中</span><br><span class="line">      if (!cached) &#123;</span><br><span class="line">          addViewHolderToRecycledViewPool(holder, true);</span><br><span class="line">          recycled &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="局部刷新"><a href="#局部刷新" class="headerlink" title="局部刷新"></a>局部刷新</h3><h4 id="Adapter数据操作对外API"><a href="#Adapter数据操作对外API" class="headerlink" title="Adapter数据操作对外API"></a>Adapter数据操作对外API</h4><p>RecyclerView.Adapter提供局部数据变化通知方法，然后执行到RecyclerViewDataObserver对应的各种数据操作方法上。</p>
<h4 id="RecyclerViewDataObserver"><a href="#RecyclerViewDataObserver" class="headerlink" title="RecyclerViewDataObserver"></a>RecyclerViewDataObserver</h4><ul>
<li>通过mAdapterHelper进行数据变化处理操作</li>
<li>然后触发更新处理</li>
<li>下面介绍下 ItemChanged操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void onItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onItemRangeInserted(int positionStart, int itemCount) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onItemRangeRemoved(int positionStart, int itemCount) &#123;</span><br><span class="line">    assertNotInLayoutOrScroll(null);</span><br><span class="line">    if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) &#123;</span><br><span class="line">        triggerUpdateProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AdapterHelper-onItemRangeChanged"><a href="#AdapterHelper-onItemRangeChanged" class="headerlink" title="AdapterHelper.onItemRangeChanged"></a>AdapterHelper.onItemRangeChanged</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean onItemRangeChanged(int positionStart, int itemCount, Object payload) &#123;</span><br><span class="line">   &#x2F;&#x2F; 添加一个更新操作 ，标志为update、记录pos、item相关信息</span><br><span class="line">   mPendingUpdates.add(obtainUpdateOp(UpdateOp.UPDATE, positionStart, itemCount, payload));</span><br><span class="line">   mExistingUpdateTypes |&#x3D; UpdateOp.UPDATE;</span><br><span class="line">   &#x2F;&#x2F; 如果只有一个待处理操作则为true，true则执行后续更新处理。如果是多个，则会忽略，因为在第一次出发后，就会集中处理</span><br><span class="line">   return mPendingUpdates.size() &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RecyclerViewDataObserver-triggerUpdateProcessor"><a href="#RecyclerViewDataObserver-triggerUpdateProcessor" class="headerlink" title="RecyclerViewDataObserver.triggerUpdateProcessor"></a>RecyclerViewDataObserver.triggerUpdateProcessor</h4><ol>
<li>当RecyclerView有固定大小，且已经Attached了。则走Runnable更新</li>
<li>否则直接走requestLayout方式更新，即重新走绘制流程 onMeasure、onLayout等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void triggerUpdateProcessor() &#123;</span><br><span class="line">  if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) &#123;</span><br><span class="line">      &#x2F;&#x2F; RecyclerView有固定大小的时候 会执行mUpdateChildViewsRunnable 来处理更新</span><br><span class="line">      ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 直接走 requestLayout方式来处理</span><br><span class="line">      mAdapterUpdateDuringMeasure &#x3D; true;</span><br><span class="line">      requestLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="triggerUpdateProcessor下requestLayout"><a href="#triggerUpdateProcessor下requestLayout" class="headerlink" title="triggerUpdateProcessor下requestLayout"></a>triggerUpdateProcessor下requestLayout</h4><p>requestLayout下 onMeasure -&gt; dispatchLayout -&gt; dispatchLayoutStep2 -&gt; layoutChildren -&gt; fill -&gt; layoutChunk -&gt; next -&gt; tryGetViewHolderForPositionByDeadline<br>最终对Item进行重新绑定 实现局部刷新逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ViewHolder tryGetViewHolderForPositionByDeadline(int position,</span><br><span class="line">                boolean dryRun, long deadlineNs) &#123;</span><br><span class="line">                </span><br><span class="line">           if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">                holder.mPreLayoutPosition &#x3D; position;</span><br><span class="line">            &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行数据变化的Holder的重新bind，从而实现局部刷新              </span><br><span class="line">                final int offsetPosition &#x3D; mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                bound &#x3D; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="triggerUpdateProcessor下mUpdateChildViewsRunnable"><a href="#triggerUpdateProcessor下mUpdateChildViewsRunnable" class="headerlink" title="triggerUpdateProcessor下mUpdateChildViewsRunnable"></a>triggerUpdateProcessor下mUpdateChildViewsRunnable</h4><p>当RecyclerView有固定大小时，则不需要Measure，直接走dispatchLayout方法进行刷新操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Runnable mUpdateChildViewsRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 消费 等待执行的操作 </span><br><span class="line">        consumePendingUpdateOperations();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumePendingUpdateOperations() &#123;</span><br><span class="line">        </span><br><span class="line">      if (mAdapterHelper.hasAnyUpdateTypes(AdapterHelper.UpdateOp.UPDATE) &amp;&amp; !mAdapterHelper</span><br><span class="line">           .hasAnyUpdateTypes(AdapterHelper.UpdateOp.ADD | AdapterHelper.UpdateOp.REMOVE</span><br><span class="line">                   | AdapterHelper.UpdateOp.MOVE)) &#123;</span><br><span class="line">        &#x2F;&#x2F; update 情况下 逻辑</span><br><span class="line">       </span><br><span class="line">       eatRequestLayout();</span><br><span class="line">       onEnterLayoutOrScroll();</span><br><span class="line">       &#x2F;&#x2F; 数据预处理 </span><br><span class="line">       mAdapterHelper.preProcess();</span><br><span class="line">       if (!mLayoutRequestEaten) &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行 dispatchLayout 进行局部刷新处理</span><br><span class="line">           if (hasUpdatedView()) &#123;</span><br><span class="line">               dispatchLayout();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; no need to layout, clean state</span><br><span class="line">               mAdapterHelper.consumePostponedUpdates();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125; else if (mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">       &#x2F;&#x2F; add、remove等操作，直接执行dispatchLayout</span><br><span class="line">       dispatchLayout();</span><br><span class="line">       TraceCompat.endSection();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>RececlerView</tag>
      </tags>
  </entry>
  <entry>
    <title>Git主流分支模型</title>
    <url>/blog/2020/04/27/Git%E4%B8%BB%E6%B5%81%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>分支模型的抉择可以概括为围绕 <strong>持续集成</strong> 和 <strong>特性隔离</strong> 两个特征进行博弈。</p>
<h3 id="分支模型对比结论"><a href="#分支模型对比结论" class="headerlink" title="分支模型对比结论"></a>分支模型对比结论</h3><h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p><a href="https://trunkbaseddevelopment.com/alternative-branching-models/index.html#modern-claimed-high-throughput-branching-models" target="_blank" rel="noopener">TBD说明</a></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884345933675.jpg"  alt=""></p>
<h4 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a>使用分析</h4><table>
<thead>
<tr>
<th>分支模型</th>
<th>主干数</th>
<th>特性分支数</th>
<th>集成频率</th>
<th>多版本并行开发</th>
<th>需求中途撤销</th>
<th>打包方式</th>
</tr>
</thead>
<tbody><tr>
<td>Git Flow</td>
<td>2</td>
<td>5类</td>
<td>特性分支完成后一起集成</td>
<td>特性分支</td>
<td>合并前：删除特性分支 合并后：手动剔除代码</td>
<td>开发分支和发布分支分别打包</td>
</tr>
<tr>
<td>Aone FLow</td>
<td>1</td>
<td>3类</td>
<td>指定特性分支频繁集成</td>
<td>特性分支且控制合并时间</td>
<td>删除特性分支重新集成</td>
<td>发布分支分别打包</td>
</tr>
<tr>
<td>GitHub Flow</td>
<td>1</td>
<td>1类</td>
<td>特性分支立即集成</td>
<td>特性分支</td>
<td>手工剔除代码</td>
<td>特性分支打包</td>
</tr>
<tr>
<td>TBD</td>
<td>1</td>
<td>1类</td>
<td>所有提交立即集成</td>
<td>特性开关</td>
<td>手工剔除代码</td>
<td>一次打包多次部署</td>
</tr>
</tbody></table>
<h3 id="分支模型详细分析"><a href="#分支模型详细分析" class="headerlink" title="分支模型详细分析"></a>分支模型详细分析</h3><h4 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h4><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">详情参考</a></p>
<h5 id="分支情况"><a href="#分支情况" class="headerlink" title="分支情况"></a>分支情况</h5><ul>
<li>主干分支（长期）<ul>
<li>主分支：master</li>
<li>开发分支：develop</li>
</ul>
</li>
<li>特性分支（短期）<ul>
<li>功能分支：feature</li>
<li>预发分支：release</li>
<li>补丁分支：hotfix</li>
</ul>
</li>
</ul>
<h5 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h5><ul>
<li>开发&amp;发布<ul>
<li>develop分支创建feature分支</li>
<li>feature开发、测试完提pr到develop分支</li>
<li>code review 和合并进develop</li>
<li>等待各个feature合并到develop</li>
<li>develop创建release分支并进行测试</li>
<li>release 开始发布，进行bug fix 且需要合并回develop</li>
<li>release 发布完成，merge到master和develop</li>
</ul>
</li>
<li>修复<ul>
<li>通过tag创建对应hotfix进行修复，然后合并回develop和master</li>
</ul>
</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884346291576.png"  alt=""></p>
<h4 id="GitHubFlow"><a href="#GitHubFlow" class="headerlink" title="GitHubFlow"></a>GitHubFlow</h4><p><a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">详情参考</a></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884346745153.jpg"  alt=""></p>
<h5 id="分支情况-1"><a href="#分支情况-1" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master<br>特性分支：feature</p>
<h5 id="玩法-1"><a href="#玩法-1" class="headerlink" title="玩法"></a>玩法</h5><p>开发：主分支创建feature分支进行开发、PR、Review、发布完成后，建立PR回master<br>修复：特性分支未合入master前特性分支修复，合入后针对tag单开分支修复并合入主干分支</p>
<p>它有一个变种版本，更好的支持多环境和多版本 ，可以参考 <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" target="_blank" rel="noopener">GitLab Flow</a></p>
<h4 id="TBD"><a href="#TBD" class="headerlink" title="TBD"></a>TBD</h4><p><a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">详情参考</a><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884346820323.png"  alt=""></p>
<h5 id="分支情况-2"><a href="#分支情况-2" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master</p>
<h5 id="玩法-2"><a href="#玩法-2" class="headerlink" title="玩法"></a>玩法</h5><p>开发：所有团队成员都在单个主干分支上进行开发，<br>符合约定后commit到主干分支。也可创建短周期分支进行开发rebase主干分支后提交PR</p>
<p>发布：优先Tag，Tag不能满足则创建发布分支</p>
<p>修复：主干分支修复，cherry pick到发布分支，新tag与发布</p>
<p>其它辅助方案策略</p>
<ul>
<li>如何避免引入未完成feature？ feature toggle（功能开关）</li>
<li>如果重构？ BBA（抽象分支）</li>
</ul>
<h4 id="AoneFlow"><a href="#AoneFlow" class="headerlink" title="AoneFlow"></a>AoneFlow</h4><p><a href="https://mp.weixin.qq.com/sJsBX3UPgZL_HUOTCIopr_A" target="_blank" rel="noopener">详情参考</a><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884346905034.png"  alt=""><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884346974000.png"  alt=""><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884347033922.png"  alt=""></p>
<h5 id="分支情况-3"><a href="#分支情况-3" class="headerlink" title="分支情况"></a>分支情况</h5><p>主干分支：master<br>特性分支：feature、release</p>
<h5 id="玩法-3"><a href="#玩法-3" class="headerlink" title="玩法"></a>玩法</h5><ul>
<li>开始工作前，从主干创建特性分支。</li>
<li>通过合并特性分支，形成发布分支。</li>
<li>发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。</li>
</ul>
]]></content>
      <categories>
        <category>开发效率</category>
      </categories>
      <tags>
        <tag>软件开发模式</tag>
      </tags>
  </entry>
  <entry>
    <title>项目立项</title>
    <url>/blog/2020/03/15/%E9%A1%B9%E7%9B%AE%E7%AB%8B%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="立项模版"><a href="#立项模版" class="headerlink" title="立项模版"></a>立项模版</h2><h3 id="项目基本信息"><a href="#项目基本信息" class="headerlink" title="项目基本信息"></a>项目基本信息</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>项目名称</td>
<td></td>
<td>项目负责人</td>
<td></td>
</tr>
<tr>
<td>项目类型</td>
<td></td>
<td>项目规模</td>
<td></td>
</tr>
<tr>
<td>项目发起方</td>
<td></td>
<td>项目成本收益方</td>
<td></td>
</tr>
<tr>
<td>开始日期</td>
<td></td>
<td>计划结束日期</td>
<td></td>
</tr>
</tbody></table>
<h3 id="项目背景（为什么要做）"><a href="#项目背景（为什么要做）" class="headerlink" title="项目背景（为什么要做）"></a>项目背景（为什么要做）</h3><p>有需求，深入理解用户的根本需求，鉴别真伪需求</p>
<ul>
<li>现状<ul>
<li>内部：开发方的短期、长期发展战略；开发方的当前实力</li>
<li>外部：业务需求及行业发展趋势；技术状况及发展趋势</li>
</ul>
</li>
<li>需求<ul>
<li>谁有需求 ？以客户为中心；消费者第一、商家第二、员工第三。</li>
<li>什么需求 ？需求有真伪；要看透本质 。</li>
</ul>
</li>
</ul>
<h3 id="项目概括（做什么）"><a href="#项目概括（做什么）" class="headerlink" title="项目概括（做什么）"></a>项目概括（做什么）</h3><h4 id="项目定义及价值-（解决什么问题）"><a href="#项目定义及价值-（解决什么问题）" class="headerlink" title="项目定义及价值 （解决什么问题）"></a>项目定义及价值 （解决什么问题）</h4><p>用简练的语言说明本项目“是什么”，“什么用途”，</p>
<ul>
<li>方向包括公司战略、服务体验部OKR、收入增长、成本节约、客户满意度提高、转人工率下降等。</li>
<li>说明产品市场定位、目标客户、项目价值</li>
<li>项目价值可以从短期价值和长期价值两个维度来分析</li>
</ul>
<h4 id="项目主要功能和特色-（主要功能特色）"><a href="#项目主要功能和特色-（主要功能特色）" class="headerlink" title="项目主要功能和特色 （主要功能特色）"></a>项目主要功能和特色 （主要功能特色）</h4><ul>
<li>给出项目的主要功能列表（Feature List）。</li>
<li>说明本项目的特色。</li>
</ul>
<h4 id="项目范围（做什么和不做什么）"><a href="#项目范围（做什么和不做什么）" class="headerlink" title="项目范围（做什么和不做什么）"></a>项目范围（做什么和不做什么）</h4><ul>
<li>说明本项目“适用的领域”和“不适用的领域”。</li>
<li>说明本项目“应当包含的内容”和“不包含的内容”。</li>
</ul>
<h3 id="项目目标-（定什么目标）"><a href="#项目目标-（定什么目标）" class="headerlink" title="项目目标 （定什么目标）"></a>项目目标 （定什么目标）</h3><ul>
<li>制定项目目标（定性、粗定量、细定量）</li>
<li>符合SMART原则 <a href="https://www.jianshu.com/p/6fd6a7e1a1ef" target="_blank" rel="noopener">SMART</a></li>
</ul>
<h3 id="项目技术方案（怎么做）"><a href="#项目技术方案（怎么做）" class="headerlink" title="项目技术方案（怎么做）"></a>项目技术方案（怎么做）</h3><ul>
<li>需求调研准备<ul>
<li>BRD（Bussiness Requirement Document） 商业需求文档</li>
<li>MRD（Market Requirement Document）市场需求文档</li>
<li>PRD（Product Requirement Document）产品需求文档</li>
</ul>
</li>
<li>系统架构<ul>
<li>服务/系统全景图</li>
<li>业务流程图</li>
<li>场景功能图 </li>
</ul>
</li>
</ul>
<h3 id="项目可行性分析-（是否可行）"><a href="#项目可行性分析-（是否可行）" class="headerlink" title="项目可行性分析 （是否可行）"></a>项目可行性分析 （是否可行）</h3><ul>
<li>市场机会分析、市场规模、市场发展趋势</li>
<li>竞品分析/份额、盈利模式、场景及用户分析、收益预估</li>
<li>运营、推广、营销、策略以及计划</li>
<li>也可包括技术可行性分析等</li>
</ul>
<h3 id="项目规划及里程碑-达成目标路径"><a href="#项目规划及里程碑-达成目标路径" class="headerlink" title="项目规划及里程碑 (达成目标路径)"></a>项目规划及里程碑 (达成目标路径)</h3><p>里程碑如何设置？做事的计划是什么？优先级是什么？</p>
<p>Roadmap主要内容：时间周期、阶段目标、主要事项、路标（里程碑时间点）<br>分阶段说明在什么时间周期里，达到什么阶段目标，完成什么主要事项，并设定里程碑时间点</p>
<p>eg: 列出项目立项、立项评审、需求评审、技术评审、研发、提测、上线、结项各个节点的时间</p>
<h3 id="项目目标评估（怎么评估）"><a href="#项目目标评估（怎么评估）" class="headerlink" title="项目目标评估（怎么评估）"></a>项目目标评估（怎么评估）</h3><p>怎么评估做得好还是没做好？<br>定义合理的指标比实现该指标更难。结果导向。</p>
<h3 id="项目资源、预算（所需资源）"><a href="#项目资源、预算（所需资源）" class="headerlink" title="项目资源、预算（所需资源）"></a>项目资源、预算（所需资源）</h3><ul>
<li>项目资源，包括人力资源、营销成本、花费等</li>
<li>计算项目预算</li>
<li>项目ROI</li>
</ul>
<h3 id="项目风险及挑战"><a href="#项目风险及挑战" class="headerlink" title="项目风险及挑战"></a>项目风险及挑战</h3><p>风险说明，及对应风险减轻/应急措施的建议或方案</p>
<h2 id="PRFAQ"><a href="#PRFAQ" class="headerlink" title="PRFAQ"></a>PRFAQ</h2><ol>
<li><p>该项目用户是谁？<br> 用户list。</p>
</li>
<li><p>该项目解决了哪些问题？</p>
<p> 直接描述问题本身（无法实现什么，缺少什么功能），而不是阐述解决问题的方法或结果（提供了什么功能，具备了什么能力）。</p>
</li>
<li><p>该项目系统的改进点有哪些？量化收益是多少？<br> 结合上述问题以及现状，描述系统在各方面的改进点，以及为公司/部门带来的好处。</p>
</li>
<li><p>为什么要现在启动项目？如果现在不做会怎么样？<br> 描述现在启动的必要性和紧急性。</p>
</li>
<li><p>该项目的核心价值或特点是什么？<br> 高屋建瓴地标榜系统的核心价值、定位和能力，描述系统最为关键和独特的亮点。</p>
</li>
<li><p>在什么场景下可以使用该项目？<br> 列举一些主要的、具体的使用场景。</p>
</li>
<li><p>该项目有哪些业界对标？<br> 竞对怎么做、优劣势对比分析等，业界/公司内/BG内。对比完后要能够指导实践。</p>
</li>
<li><p>该项目是不是重复造轮子？<br> 如果可能联想到公司的同类产品，需要简要论证是或者不是。</p>
</li>
<li><p>该项目和其它项目的区别是什么？</p>
<ol>
<li>业界知名产品，我们要对标 </li>
<li>一个开源的版本，而该项目是对它的演进</li>
<li>公司内部解决类似问题的产品。</li>
</ol>
</li>
<li><p>该项目采用什么样的架构？主要考虑了哪些因素？这些因素是如何做权衡的？<br>概括系统所采用的架构模型和架构原则。描述系统架构所考虑的各个因素，以及它们的主次/取舍关系。可以在附录中附上技术架构图。</p>
</li>
<li><p>该项目会依赖哪些系统的什么能力？<br>描述系统底层依赖了哪些系统的能力，便于读者更好地理解系统架构层次，以及哪些能力是直接复用的。</p>
</li>
<li><p>该项目的性能标准有哪些？<br>描述系统的指标，包括响应时间、延迟等。</p>
</li>
<li><p>该项目的系统质量有哪些指标可以评估？这些指标期望达到什么标准？<br>描述系统的质量指标及目标。如可用性、线下bug率、故障数等。</p>
</li>
<li><p>该项目是否会有安全问题或挑战？如果有，如何解决？<br>考虑域名安全、权限问题、数据安全、防刷、反爬虫等方面，描述系统的安全风险及应对措施。</p>
</li>
<li><p>有哪些指标可以评估系统是否已达到了预期的安全性？这些指标期望达到什么标准？<br>安全测试、安全描述、安全相关的case/故障数等。</p>
</li>
<li><p>与现状对比，该项目系统在效率层面是否有所改善？如果有，有哪些指标可以体现？<br>描述系统在效率层面的改善目标及评估指标，如研发成本（人日节省）、机器资源等。</p>
</li>
<li><p>该项目有哪些业务衡量指标？<br>一张各方面业务指标的表格，需要量化指标以及相应的衡量方法。</p>
</li>
<li><p>该项目的里程碑有哪些？<br>列举系统的里程碑规划，为利益相关方和用户建立预期。</p>
</li>
<li><p>建设和推广该系统的成本是什么？<br>人力投入、时间成本、机器成本、财务预算等。</p>
</li>
<li><p>该项目在建设和推广的过程中，可能会遇到哪些挑战？哪些业务场景会面临最大的问题？如何解决？<br>考虑落地过程中，来自不同团队和业务方的实际挑战和困难。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>方法论</category>
        <category>基本功</category>
      </categories>
      <tags>
        <tag>复盘</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp 4源码（7）— 总结</title>
    <url>/blog/2020/01/30/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%887%EF%BC%89%E2%80%94%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>本文基于OkHttp 4.3.1源码分析 Okio 2.4.3源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a><br><a href="https://square.github.io/okio/" target="_blank" rel="noopener">Okio - 官方地址</a><br><a href="https://github.com/square/okio" target="_blank" rel="noopener">Okio - GitHub代码地址</a></p>
</blockquote>
<h2 id="OkHttp-介绍"><a href="#OkHttp-介绍" class="headerlink" title="OkHttp 介绍"></a>OkHttp 介绍</h2><h3 id="OkHttp-是什么"><a href="#OkHttp-是什么" class="headerlink" title="OkHttp 是什么"></a>OkHttp 是什么</h3><p>超文本传输协议（HTTP）是一个用于传输超媒体或者数据的应用层协议。高效应用HTTP可以获得更快的传输速度以及更节省的流量<br>OkHttp来源Square公司，它是针对HTTP进行高效封装的一套网络库</p>
<h3 id="Okio-优点"><a href="#Okio-优点" class="headerlink" title="Okio 优点"></a>Okio 优点</h3><h4 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h4><ul>
<li>支持HTTP/2</li>
<li>连接池技术，避免频繁的请求连接和断开 （非HTTP2情况下）</li>
<li>支持GZIP压缩</li>
<li>缓存支持，避免重复请求</li>
</ul>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ul>
<li>连接重试，支持多IP重试，支持IPV4和IPV6隧道连接</li>
<li>支持TLS特性</li>
<li>请求和响应Api简洁明了，支持同步和异步请求</li>
</ul>
<h2 id="OkHttp-图文总结"><a href="#OkHttp-图文总结" class="headerlink" title="OkHttp 图文总结"></a>OkHttp 图文总结</h2><p><a href="https://www.jianshu.com/p/ff836d3cacd1" target="_blank" rel="noopener">OkHttp 4源码（1）— OkHttp初始化和请求构造分析</a><br><a href="https://www.jianshu.com/p/0c830962c6e3" target="_blank" rel="noopener">OkHttp 4源码（2）— 拦截器机制分析</a><br><a href="https://www.jianshu.com/p/2eafcd161dd9" target="_blank" rel="noopener">OkHttp 4源码（3）— 缓存机制分析</a><br><a href="https://www.jianshu.com/p/be6d09f2656b" target="_blank" rel="noopener">OkHttp 4源码（4）— 连接机制分析</a><br><a href="https://www.jianshu.com/p/097b1904f580" target="_blank" rel="noopener">OkHttp 4源码（5）— 请求和响应 I/O操作</a><br><a href="https://www.jianshu.com/p/7b7ba4333c5e" target="_blank" rel="noopener">OkHttp 4源码（6）— Okio源码解析</a></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349070330.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349198291.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349359474.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349399526.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349603597.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349768181.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349822059.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349902121.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349963397.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884350013241.jpg"  alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp 4源码（6）—Okio分析.</title>
    <url>/blog/2020/01/19/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%886%EF%BC%89%E2%80%94Okio%E5%88%86%E6%9E%90./</url>
    <content><![CDATA[<blockquote>
<p>本文基于Okio 2.4.3源码分析<br><a href="https://square.github.io/okio/" target="_blank" rel="noopener">Okio - 官方地址</a><br><a href="https://github.com/square/okio" target="_blank" rel="noopener">Okio - GitHub代码地址</a></p>
</blockquote>
<h2 id="Okio-介绍"><a href="#Okio-介绍" class="headerlink" title="Okio 介绍"></a>Okio 介绍</h2><h3 id="Okio是什么"><a href="#Okio是什么" class="headerlink" title="Okio是什么"></a>Okio是什么</h3><p>Okio来源Square公司，它是对java.io和java.nio的进一步封装实现，使得更容易处理、访问、缓存数据。它最初是作为OkHttp网络库的组件</p>
<h3 id="Okio-特点"><a href="#Okio-特点" class="headerlink" title="Okio 特点"></a>Okio 特点</h3><h4 id="Buffer-and-ByteString"><a href="#Buffer-and-ByteString" class="headerlink" title="Buffer and ByteString"></a>Buffer and ByteString</h4><p>目标：更好的CPU和Memory综合表现</p>
<ul>
<li>Buffer：通过双向链表的Segment缓存结构，当从一个Buffer转移数据到另一个Buffer的时候，提供重新分配拥有权达到无需拷贝，相比一次深拷贝，效率大大增加。</li>
<li>ByteString：Encode UTF-8 String到byteString过程会缓存原string，Decode过程中则可以直接使用</li>
</ul>
<h4 id="Source-and-Sink"><a href="#Source-and-Sink" class="headerlink" title="Source and Sink"></a>Source and Sink</h4><ul>
<li>支持超时机制</li>
<li>非常轻便，便于实现、使用、测试</li>
</ul>
<h3 id="Okio-图文概括"><a href="#Okio-图文概括" class="headerlink" title="Okio 图文概括"></a>Okio 图文概括</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884351494519.png"  alt=""><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884351613228.png"  alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="测试代码示例"><a href="#测试代码示例" class="headerlink" title="测试代码示例"></a>测试代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class OkioTest &#123;</span><br><span class="line">  @Rule public TemporaryFolder temporaryFolder &#x3D; new TemporaryFolder();</span><br><span class="line"></span><br><span class="line">  @Test public void readWriteFile() throws Exception &#123;</span><br><span class="line">    File file &#x3D; temporaryFolder.newFile();</span><br><span class="line">    &#x2F;&#x2F; 写</span><br><span class="line">    BufferedSink sink &#x3D; Okio.buffer(Okio.sink(file));</span><br><span class="line">    sink.writeUtf8(&quot;Hello, java.io file!&quot;);</span><br><span class="line">    sink.close();</span><br><span class="line">    assertTrue(file.exists());</span><br><span class="line">    assertEquals(20, file.length());</span><br><span class="line">    &#x2F;&#x2F; 读</span><br><span class="line">    BufferedSource source &#x3D; Okio.buffer(Okio.source(file));</span><br><span class="line">    assertEquals(&quot;Hello, java.io file!&quot;, source.readUtf8());</span><br><span class="line">    source.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据写入-Sink"><a href="#数据写入-Sink" class="headerlink" title="数据写入 Sink"></a>数据写入 Sink</h3><ul>
<li>实现类：OutputStreamSink</li>
<li>实现原理：依旧是借助OutputStream进行写入操作</li>
<li>写入流程<ol>
<li>超时判断</li>
<li>根据入参的所需写入数据大小，循环写入数据</li>
<li>取Buffer中第一个Segment，计算可读取的数据，写入到目标输出流中</li>
<li>每次循环写入的数据大小=min（剩余要写入数据大小，此次循环取到的Segment中的可读取数据大小），直至完成目标数据大小的写入</li>
<li>每次写入完毕，对Segment进行移除和回收</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回一个Sink</span><br><span class="line">fun File.sink(append: Boolean &#x3D; false): Sink &#x3D; FileOutputStream(this, append).sink()</span><br><span class="line"></span><br><span class="line">fun OutputStream.sink(): Sink &#x3D; OutputStreamSink(this, Timeout())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sink实现类</span><br><span class="line">private class OutputStreamSink(</span><br><span class="line">  private val out: OutputStream, &#x2F;&#x2F; java底层输出流</span><br><span class="line">  private val timeout: Timeout &#x2F;&#x2F; 超时机制</span><br><span class="line">) : Sink &#123;</span><br><span class="line">  &#x2F;&#x2F;  buffer写入到输出流</span><br><span class="line">  override fun write(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">    checkOffsetAndCount(source.size, 0, byteCount)</span><br><span class="line">    var remaining &#x3D; byteCount</span><br><span class="line">    &#x2F;&#x2F; 循环读取 所需读取数据大小</span><br><span class="line">    while (remaining &gt; 0) &#123;</span><br><span class="line">      timeout.throwIfReached() &#x2F;&#x2F; 是否超时</span><br><span class="line">      &#x2F;&#x2F; Buffer的缓存数据是由 Segment双向链表数据结构缓存</span><br><span class="line">      &#x2F;&#x2F; 取Buffer的第一个Segment（缓存片段）</span><br><span class="line">      val head &#x3D; source.head!!</span><br><span class="line">      &#x2F;&#x2F; segment中limit-pos即数据大小，这里取两者最小的那个数据大小</span><br><span class="line">      val toCopy &#x3D; minOf(remaining, head.limit - head.pos).toInt()</span><br><span class="line">      &#x2F;&#x2F; 将目标读取数据 写入到 OutputStream中</span><br><span class="line">      out.write(head.data, head.pos, toCopy)</span><br><span class="line">      &#x2F;&#x2F; segment 读指针迁移 写入数据大小</span><br><span class="line">      head.pos +&#x3D; toCopy</span><br><span class="line">      &#x2F;&#x2F; 读取数据大小减少 写入数据大小</span><br><span class="line">      remaining -&#x3D; toCopy</span><br><span class="line">      &#x2F;&#x2F; source即buffer中数据大小减少 写入数据大小</span><br><span class="line">      source.size -&#x3D; toCopy</span><br><span class="line">      &#x2F;&#x2F; 如果读数据指针等于写数据指针，证明segment无有效数据，则脸表移除该Segment，并执行Segment回收方法</span><br><span class="line">      if (head.pos &#x3D;&#x3D; head.limit) &#123;</span><br><span class="line">        source.head &#x3D; head.pop()</span><br><span class="line">        SegmentPool.recycle(head)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; flush 执行OutputStream的flush方法</span><br><span class="line">  override fun flush() &#x3D; out.flush()</span><br><span class="line">  &#x2F;&#x2F; close 执行OutputStream的close方法</span><br><span class="line">  override fun close() &#x3D; out.close()</span><br><span class="line">  &#x2F;&#x2F; 超时机制</span><br><span class="line">  override fun timeout() &#x3D; timeout</span><br><span class="line"></span><br><span class="line">  override fun toString() &#x3D; &quot;sink($out)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据读取-Source"><a href="#数据读取-Source" class="headerlink" title="数据读取 Source"></a>数据读取 Source</h3><ul>
<li>实现类：InputStreamSource</li>
<li>实现原理：依旧是借助InputStream进行写入操作</li>
<li>读取流程<ol>
<li>超时判断，目标读取数据大小合法判断</li>
<li>获取Buffer的尾部Segment，并计算该Segment可写入的数据最大值 ，与目标读取数据大小值进行比较，取其中小的一个</li>
<li>读取数据到Buffer中</li>
<li>返回读取数据大小</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回File的一个Source</span><br><span class="line">fun File.source(): Source &#x3D; inputStream().source()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建InputStreamSource作为Source返回</span><br><span class="line">fun InputStream.source(): Source &#x3D; InputStreamSource(this, Timeout())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; InputStreamSource实现类</span><br><span class="line">private class InputStreamSource(</span><br><span class="line">  private val input: InputStream,</span><br><span class="line">  private val timeout: Timeout</span><br><span class="line">) : Source &#123;</span><br><span class="line">  &#x2F;&#x2F; 核心read方法实现</span><br><span class="line">  override fun read(sink: Buffer, byteCount: Long): Long &#123;</span><br><span class="line">    if (byteCount &#x3D;&#x3D; 0L) return 0</span><br><span class="line">    require(byteCount &gt;&#x3D; 0) &#123; &quot;byteCount &lt; 0: $byteCount&quot; &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 是否超时</span><br><span class="line">      timeout.throwIfReached()</span><br><span class="line">      &#x2F;&#x2F; 获取一个可写入数据的 Segment</span><br><span class="line">      val tail &#x3D; sink.writableSegment(1)</span><br><span class="line">      &#x2F;&#x2F; 最大可写入到Buffer中的大小（一个Segment数据最大大小 减去 该Segment已经写入的数据大小）</span><br><span class="line">      val maxToCopy &#x3D; minOf(byteCount, Segment.SIZE - tail.limit).toInt()</span><br><span class="line">      &#x2F;&#x2F; 从目标读取流中 ，读取制定大小数据到Segment中</span><br><span class="line">      val bytesRead &#x3D; input.read(tail.data, tail.limit, maxToCopy)</span><br><span class="line">      &#x2F;&#x2F; 读取大小-1异常情况处理</span><br><span class="line">      if (bytesRead &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        if (tail.pos &#x3D;&#x3D; tail.limit) &#123;</span><br><span class="line">          &#x2F;&#x2F; 没有数据，移除Segment并回收</span><br><span class="line">          sink.head &#x3D; tail.pop()</span><br><span class="line">          SegmentPool.recycle(tail)</span><br><span class="line">        &#125;</span><br><span class="line">        return -1</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Segment的limit增加读取的数据大小</span><br><span class="line">      tail.limit +&#x3D; bytesRead</span><br><span class="line">      &#x2F;&#x2F; buffer数据大小增加 读取的数据大小</span><br><span class="line">      sink.size +&#x3D; bytesRead</span><br><span class="line">      &#x2F;&#x2F; 返回本次读取数据的大小</span><br><span class="line">      return bytesRead.toLong() </span><br><span class="line">    &#125; catch (e: AssertionError) &#123;</span><br><span class="line">      if (e.isAndroidGetsocknameError) throw IOException(e)</span><br><span class="line">      throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun close() &#x3D; input.close()</span><br><span class="line"></span><br><span class="line">  override fun timeout() &#x3D; timeout</span><br><span class="line"></span><br><span class="line">  override fun toString() &#x3D; &quot;source($input)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据缓存-Buffer"><a href="#数据缓存-Buffer" class="headerlink" title="数据缓存 Buffer"></a>数据缓存 Buffer</h3><h4 id="写入缓存"><a href="#写入缓存" class="headerlink" title="写入缓存"></a>写入缓存</h4><h5 id="BufferedSink-接口"><a href="#BufferedSink-接口" class="headerlink" title="BufferedSink 接口"></a>BufferedSink 接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actual interface BufferedSink : Sink, WritableByteChannel &#123;</span><br><span class="line">  &#x2F;&#x2F; Buffer</span><br><span class="line">  actual val buffer: Buffer</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 write方法</span><br><span class="line">  actual fun writeXXX(...): BufferedSink</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将Buffer中数据写入到Sink中</span><br><span class="line">  actual fun emitCompleteSegments(): BufferedSink</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RealBufferedSink-实现类"><a href="#RealBufferedSink-实现类" class="headerlink" title="RealBufferedSink 实现类"></a>RealBufferedSink 实现类</h5><ul>
<li>BufferedSink实现类，含有两个重要成员Sink和Buffer</li>
<li>接口方法基本上都经过 internal/RealBufferedSink一层封装，方法实现皆借助Buffer进行写入操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal actual class RealBufferedSink actual constructor(</span><br><span class="line">  @JvmField actual val sink: Sink &#x2F;&#x2F; 目标写入Sink</span><br><span class="line">) : BufferedSink &#123;</span><br><span class="line"></span><br><span class="line">  @JvmField val bufferField &#x3D; Buffer() &#x2F;&#x2F; 创建Buffer，buffer逻辑实现核心类</span><br><span class="line"></span><br><span class="line">  @JvmField actual var closed: Boolean &#x3D; false &#x2F;&#x2F; 是否关闭</span><br><span class="line"></span><br><span class="line">  @Suppress(&quot;OVERRIDE_BY_INLINE&quot;) &#x2F;&#x2F; 重载父类buffer getter方法</span><br><span class="line">   override val buffer: Buffer</span><br><span class="line">    inline get() &#x3D; bufferField</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 write方法 。实现逻辑都是通过internal&#x2F;RealBufferSink进行实现，里面都是通过Buffer进行写操作</span><br><span class="line">  override fun writeAll(source: Source) &#x3D; commonWriteAll(source)</span><br><span class="line">  override fun write(source: Source, byteCount: Long): BufferedSink &#x3D; commonWrite(source, byteCount)</span><br><span class="line">  override fun writeByte(b: Int) &#x3D; commonWriteByte(b)</span><br><span class="line">  override fun writeShort(s: Int) &#x3D; commonWriteShort(s)</span><br><span class="line">  override fun writeShortLe(s: Int) &#x3D; commonWriteShortLe(s)</span><br><span class="line">  override fun writeInt(i: Int) &#x3D; commonWriteInt(i)</span><br><span class="line">  override fun writeIntLe(i: Int) &#x3D; commonWriteIntLe(i)</span><br><span class="line">  override fun writeLong(v: Long) &#x3D; commonWriteLong(v)</span><br><span class="line">  override fun writeLongLe(v: Long) &#x3D; commonWriteLongLe(v)</span><br><span class="line">  override fun writeDecimalLong(v: Long) &#x3D; commonWriteDecimalLong(v)</span><br><span class="line">  override fun writeHexadecimalUnsignedLong(v: Long) &#x3D; commonWriteHexadecimalUnsignedLong(v)</span><br><span class="line">  override fun emitCompleteSegments() &#x3D; commonEmitCompleteSegments()</span><br><span class="line">  override fun emit() &#x3D; commonEmit()</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取缓存"><a href="#读取缓存" class="headerlink" title="读取缓存"></a>读取缓存</h4><h5 id="BufferedSource-接口"><a href="#BufferedSource-接口" class="headerlink" title="BufferedSource 接口"></a>BufferedSource 接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actual interface BufferedSource : Source, ReadableByteChannel &#123;</span><br><span class="line">  &#x2F;&#x2F; Buffer</span><br><span class="line">  actual val buffer: Buffer</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 read方法</span><br><span class="line">  actual fun readXXX(...): XXX</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RealBufferedSource-实现类"><a href="#RealBufferedSource-实现类" class="headerlink" title="RealBufferedSource 实现类"></a>RealBufferedSource 实现类</h5><ul>
<li>BufferedSource实现类，含有两个重要成员Source和Buffer</li>
<li>接口方法基本上都经过 internal/RealBufferedSource一层封装，方法实现皆借助Buffer进行读取操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal actual class RealBufferedSource actual constructor(</span><br><span class="line">  @JvmField actual val source: Source</span><br><span class="line">) : BufferedSource &#123;</span><br><span class="line">  @JvmField val bufferField &#x3D; Buffer() &#x2F;&#x2F; 创建一个Buffer</span><br><span class="line">  @JvmField actual var closed: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  @Suppress(&quot;OVERRIDE_BY_INLINE&quot;) &#x2F;&#x2F; 重载父类buffer getter方法</span><br><span class="line">  override val buffer: Buffer</span><br><span class="line">    inline get() &#x3D; bufferField</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 一系列 read方法 。实现逻辑都是通过internal&#x2F;RealBufferSource进行实现，里面都是通过Buffer进行写操作</span><br><span class="line">  override fun readByte(): Byte &#x3D; commonReadByte()</span><br><span class="line">  override fun readByteString(): ByteString &#x3D; commonReadByteString()</span><br><span class="line">  override fun readByteString(byteCount: Long): ByteString &#x3D; commonReadByteString(byteCount)</span><br><span class="line">  override fun readFully(sink: Buffer, byteCount: Long): Unit &#x3D; commonReadFully(sink, byteCount)</span><br><span class="line">  override fun readAll(sink: Sink): Long &#x3D; commonReadAll(sink)</span><br><span class="line">  override fun readUtf8(): String &#x3D; commonReadUtf8()</span><br><span class="line">  override fun readUtf8(byteCount: Long): String &#x3D; commonReadUtf8(byteCount)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存实现类-Buffer"><a href="#缓存实现类-Buffer" class="headerlink" title="缓存实现类 Buffer"></a>缓存实现类 Buffer</h4><p>缓存逻辑实现核心类，对RealBufferedSource和RealBufferedSink中暴露的Api进行了实现，重点看下Buffer的读写方法，其核心设计原则就是兼顾CPU（时间）和Memory（空间）</p>
<ul>
<li>每一个Buffer中，包含Segment双向链表结构，进行缓存数据存储，多个固定的Segment有助于避免内存的申请和回收，减少内存片段</li>
<li>Buffer既充当了缓存写入角色，又充当了缓存读取角色，更有利于实现buffer平滑实现一次拷贝</li>
<li>读Buffer数据转移到写Buffer，1. 如果写Buffer可以容纳，则直接拷贝存储；2.如果写Buffer不可以容纳，则通过split方法在来一个Segment进行存储</li>
</ul>
<p>Buffer、Segment、SegmentPool巧妙的设计，兼顾了CPU和Memory的平衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal inline fun Buffer.commonRead(sink: Buffer, byteCount: Long): Long &#123;</span><br><span class="line">  var byteCount &#x3D; byteCount</span><br><span class="line">  require(byteCount &gt;&#x3D; 0) &#123; &quot;byteCount &lt; 0: $byteCount&quot; &#125;</span><br><span class="line"></span><br><span class="line">  if (size &#x3D;&#x3D; 0L) return -1L</span><br><span class="line">  if (byteCount &gt; size) byteCount &#x3D; size</span><br><span class="line">  &#x2F;&#x2F; 执行 Buffer的write方法</span><br><span class="line">  sink.write(this, byteCount)</span><br><span class="line">  return byteCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal inline fun Buffer.commonWrite(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">  var byteCount &#x3D; byteCount &#x2F;&#x2F; 写入大小</span><br><span class="line">  &#x2F;&#x2F; 逻辑判断</span><br><span class="line">  require(source !&#x3D;&#x3D; this) &#123; &quot;source &#x3D;&#x3D; this&quot; &#125;</span><br><span class="line">  checkOffsetAndCount(source.size, 0, byteCount)</span><br><span class="line"></span><br><span class="line">  while (byteCount &gt; 0L) &#123;</span><br><span class="line">    &#x2F;&#x2F; source对应的Segment数据大小是否 大于 目标写入大小，大于则只写入一部分数据</span><br><span class="line">    if (byteCount &lt; source.head!!.limit - source.head!!.pos) &#123;</span><br><span class="line">      &#x2F;&#x2F; 取尾部Segment</span><br><span class="line">      val tail &#x3D; if (head !&#x3D; null) head!!.prev else null</span><br><span class="line">      &#x2F;&#x2F; 尾部不为空，且拥有数据写入权 且 拥有足够写入的空间</span><br><span class="line">      if (tail !&#x3D; null &amp;&amp; tail.owner &amp;&amp;</span><br><span class="line">        byteCount + tail.limit - (if (tail.shared) 0 else tail.pos) &lt;&#x3D; Segment.SIZE) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将读取Buffer的数据写入到 本Buffer的尾部Segment中</span><br><span class="line">        &#x2F;&#x2F; writeTo方法 可能是深拷贝或者是浅拷贝，后面有分析</span><br><span class="line">        source.head!!.writeTo(tail, byteCount.toInt())</span><br><span class="line">        &#x2F;&#x2F; 重置source的size 和本Buffer的size</span><br><span class="line">        source.size -&#x3D; byteCount</span><br><span class="line">        size +&#x3D; byteCount</span><br><span class="line">        return</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 装不下读取的数据，则需要新的Segment来写入 ，新的segement可能通过shareCopy或者SegemntPool来（见Segment分析）</span><br><span class="line">        source.head &#x3D; source.head!!.split(byteCount.toInt())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Remove the source&#39;s head segment and append it to our tail.</span><br><span class="line">    &#x2F;&#x2F; source对应Buffer中的head Segment数据读取完毕，对Buffer中的Segment进行移除</span><br><span class="line">    val segmentToMove &#x3D; source.head</span><br><span class="line">    val movedByteCount &#x3D; (segmentToMove!!.limit - segmentToMove.pos).toLong()</span><br><span class="line">    source.head &#x3D; segmentToMove.pop()</span><br><span class="line">    &#x2F;&#x2F; 移除后，因为它有可能含有共享的数据（见Segment），所以将其加入本Buffer的tail</span><br><span class="line">    &#x2F;&#x2F; 从而巧妙实现 Buffer 读写的复用</span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; head为空，直接赋值head</span><br><span class="line">      head &#x3D; segmentToMove</span><br><span class="line">      segmentToMove.prev &#x3D; segmentToMove</span><br><span class="line">      segmentToMove.next &#x3D; segmentToMove.prev</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; head不为空，赋值到尾部</span><br><span class="line">      var tail &#x3D; head!!.prev</span><br><span class="line">      tail &#x3D; tail!!.push(segmentToMove)</span><br><span class="line">      &#x2F;&#x2F; 新的tail加入，确认是否需要压缩</span><br><span class="line">      tail.compact()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 重置source大小，和本Buffer的size大小</span><br><span class="line">    source.size -&#x3D; movedByteCount</span><br><span class="line">    size +&#x3D; movedByteCount</span><br><span class="line">    byteCount -&#x3D; movedByteCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存数据片段-Segment"><a href="#缓存数据片段-Segment" class="headerlink" title="缓存数据片段 Segment"></a>缓存数据片段 Segment</h3><p>Buffer数据存储片段，目标数据都存储在Segment中的data字段中，Segment双向链表结构，提供pop、push进行Segment的增加和移除。split和compact对Segment进行拆分和合并，shareCopy为共享数据提供一次拷贝便利等</p>
<h4 id="共享机制"><a href="#共享机制" class="headerlink" title="共享机制"></a>共享机制</h4><p>两个字段（shared、owner）和两个方法（sharedCopy、unsharedCopy）来实现<br>浅拷贝的应用会直接减少一次I/O操作，大大提高I/O效率</p>
<ul>
<li>shared：代表该Segment的数据是否共享</li>
<li>owner：代表该Segment是否拥有对数据的写入权利</li>
<li>sharedCopy：data浅拷贝，共享复制的Segment中的data数据，其中owner为false（即拷贝的Segment只能读不能写）</li>
<li>unsharedCopy：data深拷贝，完全复制一个Segment</li>
</ul>
<h4 id="拆分与合并"><a href="#拆分与合并" class="headerlink" title="拆分与合并"></a>拆分与合并</h4><p>为了Segment的回收，以及更加合理化存储数据，提供两个方法</p>
<ul>
<li>compact：合并，如果本Segment与前一个Segment两者数据可以合为一个，则可以通过compact方法合并为一个Segment，然后回收本Segment</li>
<li>split：分割，当存储的数据大于当前Segment的容量时，则需要一个新的Segment，此时会有两种情况，1.如果数据量大于1024则浅拷贝一个Segment来装数据，如果不是，则直接深拷贝数据创建一个新的Segment</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal class Segment &#123;</span><br><span class="line">  &#x2F;&#x2F; 缓存的数据</span><br><span class="line">  @JvmField val data: ByteArray</span><br><span class="line"></span><br><span class="line">  &#x2F;** 读取数据的指针  *&#x2F;</span><br><span class="line">  @JvmField var pos: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">  &#x2F;** 写入数据的的指针 *&#x2F;</span><br><span class="line">  @JvmField var limit: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">  &#x2F;** 数据是否共享  *&#x2F;</span><br><span class="line">  @JvmField var shared: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;** limit扩展字段，数据是否属于当前的Segment，true即可以写入 *&#x2F;</span><br><span class="line">  @JvmField var owner: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;** 链表数据结构的next字段 *&#x2F;</span><br><span class="line">  @JvmField var next: Segment? &#x3D; null</span><br><span class="line"></span><br><span class="line">  &#x2F;** 链表数据结构的prev字段  *&#x2F;</span><br><span class="line">  @JvmField var prev: Segment? &#x3D; null</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.data &#x3D; ByteArray(SIZE)</span><br><span class="line">    this.owner &#x3D; true</span><br><span class="line">    this.shared &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(data: ByteArray, pos: Int, limit: Int, shared: Boolean, owner: Boolean) &#123;</span><br><span class="line">    this.data &#x3D; data</span><br><span class="line">    this.pos &#x3D; pos</span><br><span class="line">    this.limit &#x3D; limit</span><br><span class="line">    this.shared &#x3D; shared</span><br><span class="line">    this.owner &#x3D; owner</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; data浅拷贝，创建一个共享的Segment，owner为false</span><br><span class="line">  fun sharedCopy(): Segment &#123;</span><br><span class="line">    shared &#x3D; true</span><br><span class="line">    return Segment(data, pos, limit, true, false)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; data深拷贝，创建一个非共享的Segment，</span><br><span class="line">  fun unsharedCopy() &#x3D; Segment(data.copyOf(), pos, limit, false, true)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 移除本Segment对象</span><br><span class="line">  fun pop(): Segment? &#123;</span><br><span class="line">    val result &#x3D; if (next !&#x3D;&#x3D; this) next else null</span><br><span class="line">    prev!!.next &#x3D; next</span><br><span class="line">    next!!.prev &#x3D; prev</span><br><span class="line">    next &#x3D; null</span><br><span class="line">    prev &#x3D; null</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 添加一个segment到链表中</span><br><span class="line">  fun push(segment: Segment): Segment &#123;</span><br><span class="line">    segment.prev &#x3D; this</span><br><span class="line">    segment.next &#x3D; next</span><br><span class="line">    next!!.prev &#x3D; segment</span><br><span class="line">    next &#x3D; segment</span><br><span class="line">    return segment</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 分割为两个Segment，数据起始点分别为 &#96;[pos..pos+byteCount)&#96;、&#96;[pos+byteCount..limit)&#96;</span><br><span class="line">  fun split(byteCount: Int): Segment &#123;</span><br><span class="line">    require(byteCount &gt; 0 &amp;&amp; byteCount &lt;&#x3D; limit - pos) &#123; &quot;byteCount out of range&quot; &#125;</span><br><span class="line">    val prefix: Segment</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1\. 尽量减少二次拷贝；2\. 共享拷贝在一定大小才执行，避免过多的短小的Segment</span><br><span class="line">    if (byteCount &gt;&#x3D; SHARE_MINIMUM) &#123;</span><br><span class="line">      prefix &#x3D; sharedCopy() &#x2F;&#x2F; 共享拷贝</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      prefix &#x3D; SegmentPool.take() &#x2F;&#x2F; 直接拷贝</span><br><span class="line">      data.copyInto(prefix.data, startIndex &#x3D; pos, endIndex &#x3D; pos + byteCount)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; prefix赋值 limit pos</span><br><span class="line">    prefix.limit &#x3D; prefix.pos + byteCount</span><br><span class="line">    pos +&#x3D; byteCount</span><br><span class="line">    prev!!.push(prefix)</span><br><span class="line">    return prefix</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 合并压缩</span><br><span class="line">  fun compact() &#123;</span><br><span class="line">    check(prev !&#x3D;&#x3D; this) &#123; &quot;cannot compact&quot; &#125;</span><br><span class="line">    if (!prev!!.owner) return </span><br><span class="line">    &#x2F;&#x2F; 本Segment数据大小</span><br><span class="line">    val byteCount &#x3D; limit - pos</span><br><span class="line">    &#x2F;&#x2F; 前一个Segment剩余可写入空间大小</span><br><span class="line">    val availableByteCount &#x3D; SIZE - prev!!.limit + if (prev!!.shared) 0 else prev!!.pos</span><br><span class="line">    if (byteCount &gt; availableByteCount) return     </span><br><span class="line">    &#x2F;&#x2F; 如果有足够的空间，则将本Segment数据写入到前一个Segment</span><br><span class="line">    writeTo(prev!!, byteCount)</span><br><span class="line">    &#x2F;&#x2F; pop，然后执行回收</span><br><span class="line">    pop()</span><br><span class="line">    SegmentPool.recycle(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 将数据写入到buffer的segment中 *&#x2F;</span><br><span class="line">  fun writeTo(sink: Segment, byteCount: Int) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只有owner为true才能写入数据</span><br><span class="line">    check(sink.owner) &#123; &quot;only owner can write&quot; &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果被写入的sink limit+byteCount大于了最大值，则需要先充值下pos和limit</span><br><span class="line">    if (sink.limit + byteCount &gt; SIZE) &#123;</span><br><span class="line">      if (sink.shared) throw IllegalArgumentException()</span><br><span class="line">      &#x2F;&#x2F; 如果所有空闲都容纳不下 ，则抛出异常</span><br><span class="line">      if (sink.limit + byteCount - sink.pos &gt; SIZE) throw IllegalArgumentException()</span><br><span class="line">      &#x2F;&#x2F; 将被写入的segment中的数据复制到 [ 0,limit-pos)</span><br><span class="line">      sink.data.copyInto(sink.data, startIndex &#x3D; sink.pos, endIndex &#x3D; sink.limit)</span><br><span class="line">      &#x2F;&#x2F; 重置 pos和limit</span><br><span class="line">      sink.limit -&#x3D; sink.pos</span><br><span class="line">      sink.pos &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将本Segment的data复制到sink的data中，偏移大小为limit，起点为pos</span><br><span class="line">    data.copyInto(sink.data, destinationOffset &#x3D; sink.limit, startIndex &#x3D; pos,</span><br><span class="line">        endIndex &#x3D; pos + byteCount)</span><br><span class="line">    sink.limit +&#x3D; byteCount</span><br><span class="line">    pos +&#x3D; byteCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  companion object &#123;</span><br><span class="line">    &#x2F;** Segment 大小 bytes  *&#x2F;</span><br><span class="line">    const val SIZE &#x3D; 8192</span><br><span class="line"></span><br><span class="line">    &#x2F;** 共享数据大小  *&#x2F;</span><br><span class="line">    const val SHARE_MINIMUM &#x3D; 1024</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存片段池-SegmentPool"><a href="#缓存片段池-SegmentPool" class="headerlink" title="缓存片段池 SegmentPool"></a>缓存片段池 SegmentPool</h3><ul>
<li>大小：64 * 1024 Kib，一个Segment大小8192，相当于8个Segment</li>
<li>结构：单链表结构，提供take（取）和recycle（存）Segment方法，且线程安全</li>
<li>作用：防止已申请的资源被回收，增加资源的重复利用，提高效率，减少GC,避免内存抖动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal object SegmentPool &#123;</span><br><span class="line">  &#x2F;&#x2F; 缓存Segment池总大小 </span><br><span class="line">  const val MAX_SIZE &#x3D; 64 * 1024L &#x2F;&#x2F; 64 KiB.</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单链表next指针</span><br><span class="line">  var next: Segment? &#x3D; null</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; segment缓存池使用大小</span><br><span class="line">  var byteCount &#x3D; 0L</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 取 segment方法  （线程安全） </span><br><span class="line">  fun take(): Segment &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      &#x2F;&#x2F; 先从链表中获取</span><br><span class="line">      next?.let &#123; result -&gt;</span><br><span class="line">        &#x2F;&#x2F; 将缓存池next指针后移到下一个next</span><br><span class="line">        next &#x3D; result.next </span><br><span class="line">        &#x2F;&#x2F; 目标segment中next指引为null</span><br><span class="line">        result.next &#x3D; null</span><br><span class="line">        &#x2F;&#x2F; 总大小 减去</span><br><span class="line">        byteCount -&#x3D; Segment.SIZE</span><br><span class="line">        return result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Segment() &#x2F;&#x2F; 创建一个新的segment</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 存（回收） segment方法</span><br><span class="line">  fun recycle(segment: Segment) &#123;</span><br><span class="line">    require(segment.next &#x3D;&#x3D; null &amp;&amp; segment.prev &#x3D;&#x3D; null)</span><br><span class="line">    if (segment.shared) return &#x2F;&#x2F; 共用segment，不可回收使用</span><br><span class="line"></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      &#x2F;&#x2F; 目前segment池大小已经满了，不在回收</span><br><span class="line">      if (byteCount + Segment.SIZE &gt; MAX_SIZE) return &#x2F;&#x2F; Pool is full.</span><br><span class="line">      &#x2F;&#x2F; 回收目标segment，增加大小、更换next指引、重置segment</span><br><span class="line">      byteCount +&#x3D; Segment.SIZE</span><br><span class="line">      segment.next &#x3D; next</span><br><span class="line">      segment.limit &#x3D; 0</span><br><span class="line">      segment.pos &#x3D; segment.limit</span><br><span class="line">      next &#x3D; segment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/c988d0416020" target="_blank" rel="noopener">下一篇 OkHttp 4源码（7）— 总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp 4源码（5）—请求写入和响应读取</title>
    <url>/blog/2020/01/16/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%885%EF%BC%89%E2%80%94%E8%AF%B7%E6%B1%82%E5%86%99%E5%85%A5%E5%92%8C%E5%93%8D%E5%BA%94%E8%AF%BB%E5%8F%96/</url>
    <content><![CDATA[<blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884363770335.jpg"  alt=""></p>
<p>IO流程图<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349902121.jpg"  alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><h4 id="CallServerInterceptor-intercept"><a href="#CallServerInterceptor-intercept" class="headerlink" title="CallServerInterceptor.intercept"></a>CallServerInterceptor.intercept</h4><p>整体可以划分6个步骤，根据不同协议执行实现逻辑区分Http1.x和Http2</p>
<ol>
<li>写请求头</li>
<li>创建请求体</li>
<li>写请求体</li>
<li>完成请求写入</li>
<li>读取响应头</li>
<li>返回响应结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line">    &#x2F;&#x2F; 写入请求头</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 针对支持body的请求，且body不为空的情况进行请求体写入</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 对 “100-continue” 进行处理</span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; 写入请求体</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest() &#x2F;&#x2F; 写入请求</span><br><span class="line">    &#125;</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 读取响应头，写入到创建的ResponseBuilder</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建响应</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; 响应码为100的情况下，再次读取响应头，重新构建response</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 读取响应头结束</span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; webSocket &amp; 101情况下，返回一个empty的reponse</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 输入响应体，创建响应</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... &#x2F;&#x2F; check</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="写请求头"><a href="#写请求头" class="headerlink" title="写请求头"></a>写请求头</h3><h4 id="Exchange-writeRequestHeaders"><a href="#Exchange-writeRequestHeaders" class="headerlink" title="Exchange.writeRequestHeaders"></a>Exchange.writeRequestHeaders</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    eventListener.requestHeadersStart(call)</span><br><span class="line">    codec.writeRequestHeaders(request) &#x2F;&#x2F; 调用codec执行写headers</span><br><span class="line">    eventListener.requestHeadersEnd(call, request)</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建请求体"><a href="#创建请求体" class="headerlink" title="创建请求体"></a>创建请求体</h3><h4 id="Exchange-createRequestBody"><a href="#Exchange-createRequestBody" class="headerlink" title="Exchange.createRequestBody"></a>Exchange.createRequestBody</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun createRequestBody(request: Request, duplex: Boolean): Sink &#123;</span><br><span class="line">  this.isDuplex &#x3D; duplex</span><br><span class="line">  val contentLength &#x3D; request.body!!.contentLength()</span><br><span class="line">  eventListener.requestBodyStart(call)</span><br><span class="line">  &#x2F;&#x2F; 执行编码器创建请求体</span><br><span class="line">  val rawRequestBody &#x3D; codec.createRequestBody(request, contentLength)</span><br><span class="line">  return RequestBodySink(rawRequestBody, contentLength)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写请求体"><a href="#写请求体" class="headerlink" title="写请求体"></a>写请求体</h3><h4 id="RequestBodySink-write"><a href="#RequestBodySink-write" class="headerlink" title="RequestBodySink.write"></a>RequestBodySink.write</h4><p>根据创建的RequestBodySink进行写入操作<br>Http/1.x ，newKnownLengthSink或者newChunkedSink</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun write(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">  check(!closed) &#123; &quot;closed&quot; &#125;</span><br><span class="line">  if (contentLength !&#x3D; -1L &amp;&amp; bytesReceived + byteCount &gt; contentLength) &#123;</span><br><span class="line">    throw ProtocolException(</span><br><span class="line">        &quot;expected $contentLength bytes but received $&#123;bytesReceived + byteCount&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行写入操作 </span><br><span class="line">    super.write(source, byteCount) </span><br><span class="line">    this.bytesReceived +&#x3D; byteCount</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    throw complete(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成请求写入"><a href="#完成请求写入" class="headerlink" title="完成请求写入"></a>完成请求写入</h3><h4 id="Exchange-finishRequest"><a href="#Exchange-finishRequest" class="headerlink" title="Exchange.finishRequest"></a>Exchange.finishRequest</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun finishRequest() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    codec.finishRequest() &#x2F;&#x2F; 执行请求写入</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    eventListener.requestFailed(call, e)</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    throw e</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取响应头"><a href="#读取响应头" class="headerlink" title="读取响应头"></a>读取响应头</h3><h4 id="Exchange-readResponseHeaders"><a href="#Exchange-readResponseHeaders" class="headerlink" title="Exchange.readResponseHeaders"></a>Exchange.readResponseHeaders</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun readResponseHeaders(expectContinue: Boolean): Response.Builder? &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    val result &#x3D; codec.readResponseHeaders(expectContinue)</span><br><span class="line">    result?.initExchange(this)</span><br><span class="line">    return result</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    eventListener.responseFailed(call, e)</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    throw e</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取响应体"><a href="#读取响应体" class="headerlink" title="读取响应体"></a>读取响应体</h3><h4 id="Exchange-openResponseBody"><a href="#Exchange-openResponseBody" class="headerlink" title="Exchange.openResponseBody"></a>Exchange.openResponseBody</h4><p>创建响应体封装实例，含有响应体的读取流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun openResponseBody(response: Response): ResponseBody &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据类型</span><br><span class="line">    val contentType &#x3D; response.header(&quot;Content-Type&quot;)</span><br><span class="line">    &#x2F;&#x2F; 数据大小</span><br><span class="line">    val contentLength &#x3D; codec.reportedContentLength(response)</span><br><span class="line">    &#x2F;&#x2F; 编码器创建读取原生流</span><br><span class="line">    val rawSource &#x3D; codec.openResponseBodySource(response)</span><br><span class="line">    &#x2F;&#x2F; 创建响应体的Source</span><br><span class="line">    val source &#x3D; ResponseBodySource(rawSource, contentLength)</span><br><span class="line">    return RealResponseBody(contentType, contentLength, source.buffer())</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    eventListener.responseFailed(call, e)</span><br><span class="line">    trackFailure(e)</span><br><span class="line">    throw e</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTP1-x对应实现"><a href="#HTTP1-x对应实现" class="headerlink" title="HTTP1.x对应实现"></a>HTTP1.x对应实现</h3><h4 id="Http1ExchangeCodec-writeRequestHeaders"><a href="#Http1ExchangeCodec-writeRequestHeaders" class="headerlink" title="Http1ExchangeCodec.writeRequestHeaders"></a>Http1ExchangeCodec.writeRequestHeaders</h4><p>创建RequestLine，执行写入headers方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取RequestLine实例，进行request输入</span><br><span class="line">  val requestLine &#x3D; RequestLine.get(</span><br><span class="line">      request, realConnection!!.route().proxy.type())</span><br><span class="line">  &#x2F;&#x2F; 写入headers</span><br><span class="line">  writeRequest(request.headers, requestLine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-writeRequest"><a href="#Http1ExchangeCodec-writeRequest" class="headerlink" title="Http1ExchangeCodec.writeRequest"></a>Http1ExchangeCodec.writeRequest</h4><p>通过Okio的Sink实例 写入headers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun writeRequest(headers: Headers, requestLine: String) &#123;</span><br><span class="line">  check(state &#x3D;&#x3D; STATE_IDLE) &#123; &quot;state: $state&quot; &#125;</span><br><span class="line">  sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;)</span><br><span class="line">  &#x2F;&#x2F; 写入headers</span><br><span class="line">  for (i in 0 until headers.size) &#123;</span><br><span class="line">    sink.writeUtf8(headers.name(i))</span><br><span class="line">        .writeUtf8(&quot;: &quot;)</span><br><span class="line">        .writeUtf8(headers.value(i))</span><br><span class="line">        .writeUtf8(&quot;\r\n&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  sink.writeUtf8(&quot;\r\n&quot;)</span><br><span class="line">  state &#x3D; STATE_OPEN_REQUEST_BODY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-createRequestBody"><a href="#Http1ExchangeCodec-createRequestBody" class="headerlink" title="Http1ExchangeCodec.createRequestBody"></a>Http1ExchangeCodec.createRequestBody</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun createRequestBody(request: Request, contentLength: Long): Sink &#123;</span><br><span class="line">  return when &#123;</span><br><span class="line">    request.body !&#x3D; null &amp;&amp; request.body.isDuplex() -&gt; throw ProtocolException(</span><br><span class="line">        &quot;Duplex connections are not supported for HTTP&#x2F;1&quot;)</span><br><span class="line">    request.isChunked() -&gt; newChunkedSink() &#x2F;&#x2F;  创建未知大小的SInk</span><br><span class="line">    contentLength !&#x3D; -1L -&gt; newKnownLengthSink() &#x2F;&#x2F; 创建已知大小的Sink</span><br><span class="line">    else -&gt; &#x2F;&#x2F; Stream a request body of a known length.</span><br><span class="line">      throw IllegalStateException(</span><br><span class="line">          &quot;Cannot stream a request body without chunked encoding or a known content length!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-finishRequest"><a href="#Http1ExchangeCodec-finishRequest" class="headerlink" title="Http1ExchangeCodec.finishRequest"></a>Http1ExchangeCodec.finishRequest</h4><p>请求写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun finishRequest() &#123;</span><br><span class="line">  sink.flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http1ExchangeCodec-readResponseHeaders"><a href="#Http1ExchangeCodec-readResponseHeaders" class="headerlink" title="Http1ExchangeCodec.readResponseHeaders"></a>Http1ExchangeCodec.readResponseHeaders</h4><ul>
<li>读取响应头信息，根据StatusLine解析协议类型、响应码、Message</li>
<li>构建ResponseBuilder接受响应头信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? &#123;</span><br><span class="line">    check(state &#x3D;&#x3D; STATE_OPEN_REQUEST_BODY || state &#x3D;&#x3D; STATE_READ_RESPONSE_HEADERS) &#123;</span><br><span class="line">      &quot;state: $state&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 读取statusLine，响应状态信息</span><br><span class="line">      val statusLine &#x3D; StatusLine.parse(readHeaderLine())</span><br><span class="line">      &#x2F;&#x2F; 创建 Response，赋值status信息和header信息</span><br><span class="line">      val responseBuilder &#x3D; Response.Builder()</span><br><span class="line">          .protocol(statusLine.protocol)</span><br><span class="line">          .code(statusLine.code)</span><br><span class="line">          .message(statusLine.message)</span><br><span class="line">          .headers(readHeaders())</span><br><span class="line">      &#x2F;&#x2F; 返回responseBuilder</span><br><span class="line">      return when &#123;</span><br><span class="line">        expectContinue &amp;&amp; statusLine.code &#x3D;&#x3D; HTTP_CONTINUE -&gt; &#123;</span><br><span class="line">          null</span><br><span class="line">        &#125;</span><br><span class="line">        statusLine.code &#x3D;&#x3D; HTTP_CONTINUE -&gt; &#123;</span><br><span class="line">          state &#x3D; STATE_READ_RESPONSE_HEADERS</span><br><span class="line">          responseBuilder</span><br><span class="line">        &#125;</span><br><span class="line">        else -&gt; &#123;</span><br><span class="line">          state &#x3D; STATE_OPEN_RESPONSE_BODY</span><br><span class="line">          responseBuilder</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e: EOFException) &#123;</span><br><span class="line">        ...</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http1ExchangeCodec-openResponseBodySource"><a href="#Http1ExchangeCodec-openResponseBodySource" class="headerlink" title="Http1ExchangeCodec.openResponseBodySource"></a>Http1ExchangeCodec.openResponseBodySource</h4><p>根据响应体chunked特性和大小是否已知创建不同的Source流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun openResponseBodySource(response: Response): Source &#123;</span><br><span class="line">  return when &#123;</span><br><span class="line">    !response.promisesBody() -&gt; newFixedLengthSource(0) &#x2F;&#x2F; 固定长度Source</span><br><span class="line">    response.isChunked() -&gt; newChunkedSource(response.request.url) &#x2F;&#x2F; ChunkedSource</span><br><span class="line">    else -&gt; &#123;</span><br><span class="line">      val contentLength &#x3D; response.headersContentLength()</span><br><span class="line">      if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">        newFixedLengthSource(contentLength)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        newUnknownLengthSource() &#x2F;&#x2F; 未知长度Source</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTP2对应实现"><a href="#HTTP2对应实现" class="headerlink" title="HTTP2对应实现"></a>HTTP2对应实现</h3><h4 id="Http2ExchangeCodec-writeRequestHeaders"><a href="#Http2ExchangeCodec-writeRequestHeaders" class="headerlink" title="Http2ExchangeCodec.writeRequestHeaders"></a>Http2ExchangeCodec.writeRequestHeaders</h4><p>创建RequestLine，执行写入headers方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">  if (stream !&#x3D; null) return</span><br><span class="line"></span><br><span class="line">  val hasRequestBody &#x3D; request.body !&#x3D; null</span><br><span class="line">  &#x2F;&#x2F; 将request中的Headers 转换为一个含有Header的List集合</span><br><span class="line">  val requestHeaders &#x3D; http2HeadersList(request) </span><br><span class="line">  &#x2F;&#x2F; 创建 本地发起的双向流 （过程会写入header）</span><br><span class="line">  stream &#x3D; connection.newStream(requestHeaders, hasRequestBody)</span><br><span class="line">  </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http2ExchangeCodec-newStream"><a href="#Http2ExchangeCodec-newStream" class="headerlink" title="Http2ExchangeCodec.newStream"></a>Http2ExchangeCodec.newStream</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun newStream(</span><br><span class="line">   associatedStreamId: Int,</span><br><span class="line">   requestHeaders: List&lt;Header&gt;,</span><br><span class="line">   out: Boolean</span><br><span class="line"> ): Http2Stream &#123;</span><br><span class="line">   val outFinished &#x3D; !out</span><br><span class="line">   val inFinished &#x3D; false</span><br><span class="line">   val flushHeaders: Boolean</span><br><span class="line">   val stream: Http2Stream</span><br><span class="line">   val streamId: Int</span><br><span class="line"></span><br><span class="line">   synchronized(writer) &#123;</span><br><span class="line">     synchronized(this) &#123;</span><br><span class="line">       if (nextStreamId &gt; Int.MAX_VALUE &#x2F; 2) &#123;</span><br><span class="line">         shutdown(REFUSED_STREAM)</span><br><span class="line">       &#125;</span><br><span class="line">       if (isShutdown) &#123;</span><br><span class="line">         throw ConnectionShutdownException()</span><br><span class="line">       &#125;</span><br><span class="line">       streamId &#x3D; nextStreamId</span><br><span class="line">       nextStreamId +&#x3D; 2</span><br><span class="line">       &#x2F;&#x2F; 创建Http2Stream</span><br><span class="line">       stream &#x3D; Http2Stream(streamId, this, outFinished, inFinished, null)</span><br><span class="line">       </span><br><span class="line">       flushHeaders &#x3D; !out ||</span><br><span class="line">           writeBytesTotal &gt;&#x3D; writeBytesMaximum ||</span><br><span class="line">           stream.writeBytesTotal &gt;&#x3D; stream.writeBytesMaximum</span><br><span class="line">       if (stream.isOpen) &#123;</span><br><span class="line">         streams[streamId] &#x3D; stream</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if (associatedStreamId &#x3D;&#x3D; 0) &#123; </span><br><span class="line">       &#x2F;&#x2F; 写入headers</span><br><span class="line">       writer.headers(outFinished, streamId, requestHeaders)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       require(!client) &#123; &quot;client streams shouldn&#39;t have associated stream IDs&quot; &#125;</span><br><span class="line">       &#x2F;&#x2F; HTTP&#x2F;2 has a PUSH_PROMISE frame.</span><br><span class="line">       writer.pushPromise(associatedStreamId, streamId, requestHeaders)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (flushHeaders) &#123;</span><br><span class="line">     writer.flush()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return stream</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Writer-headers"><a href="#Http2Writer-headers" class="headerlink" title="Http2Writer.headers"></a>Http2Writer.headers</h4><ul>
<li>HPACK加密数据</li>
<li>写入帧头数据</li>
<li>写入加密过的Header数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun headers(</span><br><span class="line">  outFinished: Boolean,</span><br><span class="line">  streamId: Int,</span><br><span class="line">  headerBlock: List&lt;Header&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  if (closed) throw IOException(&quot;closed&quot;)</span><br><span class="line">  &#x2F;&#x2F; 通过Hpack进行headers 的HPACK加密</span><br><span class="line">  hpackWriter.writeHeaders(headerBlock)</span><br><span class="line"></span><br><span class="line">  val byteCount &#x3D; hpackBuffer.size</span><br><span class="line">  val length &#x3D; minOf(maxFrameSize.toLong(), byteCount)</span><br><span class="line">  var flags &#x3D; if (byteCount &#x3D;&#x3D; length) FLAG_END_HEADERS else 0</span><br><span class="line">  if (outFinished) flags &#x3D; flags or FLAG_END_STREAM</span><br><span class="line">  &#x2F;&#x2F; 写入帧头</span><br><span class="line">  frameHeader(</span><br><span class="line">      streamId &#x3D; streamId,</span><br><span class="line">      length &#x3D; length.toInt(),</span><br><span class="line">      type &#x3D; TYPE_HEADERS,</span><br><span class="line">      flags &#x3D; flags</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 写入加密过的header数据</span><br><span class="line">  sink.write(hpackBuffer, length)</span><br><span class="line"></span><br><span class="line">  if (byteCount &gt; length) writeContinuationFrames(streamId, byteCount - length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Http2ExchangeCodec-createRequestBody"><a href="#Http2ExchangeCodec-createRequestBody" class="headerlink" title="Http2ExchangeCodec.createRequestBody"></a>Http2ExchangeCodec.createRequestBody</h4><p>返回一个 FramingSink 对象 ，RequestBodySink.writeTo(bufferedRequestBody)最后会调用其成员变量delegate即sink对象的write方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun createRequestBody(request: Request, contentLength: Long): Sink &#123;</span><br><span class="line">  return stream!!.getSink() &#x2F;&#x2F; FramingSink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FramingSink-write"><a href="#FramingSink-write" class="headerlink" title="FramingSink.write"></a>FramingSink.write</h4><p>写入帧数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun write(source: Buffer, byteCount: Long) &#123;</span><br><span class="line">  this@Http2Stream.assertThreadDoesntHoldLock()</span><br><span class="line">  &#x2F;&#x2F; buffer写入source数据</span><br><span class="line">  sendBuffer.write(source, byteCount)</span><br><span class="line">  while (sendBuffer.size &gt;&#x3D; EMIT_BUFFER_SIZE) &#123;</span><br><span class="line">    emitFrame(false) &#x2F;&#x2F; 当buffer数据大于EMIT_BUFFER_SIZE 则执行发送frame数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FramingSink-emitFrame"><a href="#FramingSink-emitFrame" class="headerlink" title="FramingSink.emitFrame"></a>FramingSink.emitFrame</h4><blockquote>
<p>Emit a single data frame to the connection. The frame’s size be limited by this stream’s write window. This method will block until the write window is nonempty.</p>
</blockquote>
<p>往连接中写入Frame数据，当写入的数据超过了写入的最大值就阻塞直到唤起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun emitFrame(outFinishedOnLastFrame: Boolean) &#123;</span><br><span class="line">  val toWrite: Long</span><br><span class="line">  val outFinished: Boolean</span><br><span class="line">  synchronized(this@Http2Stream) &#123;</span><br><span class="line">    writeTimeout.enter()</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 当写入的总数据大小 大于 最大写入值的时候 阻塞</span><br><span class="line">      while (writeBytesTotal &gt;&#x3D; writeBytesMaximum &amp;&amp;</span><br><span class="line">          !finished &amp;&amp;</span><br><span class="line">          !closed &amp;&amp;</span><br><span class="line">          errorCode &#x3D;&#x3D; null) &#123;</span><br><span class="line">        waitForIo() &#x2F;&#x2F; 阻塞直到 接受  WINDOW_UPDATE </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      writeTimeout.exitAndThrowIfTimedOut()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkOutNotClosed() &#x2F;&#x2F; </span><br><span class="line">    toWrite &#x3D; minOf(writeBytesMaximum - writeBytesTotal, sendBuffer.size)</span><br><span class="line">    writeBytesTotal +&#x3D; toWrite</span><br><span class="line">    outFinished &#x3D; outFinishedOnLastFrame &amp;&amp; toWrite &#x3D;&#x3D; sendBuffer.size &amp;&amp; errorCode &#x3D;&#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  writeTimeout.enter()</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 写入数据</span><br><span class="line">    connection.writeData(id, outFinished, sendBuffer, toWrite)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    writeTimeout.exitAndThrowIfTimedOut()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Connection-writeData"><a href="#Http2Connection-writeData" class="headerlink" title="Http2Connection.writeData"></a>Http2Connection.writeData</h4><p>连接写入数据，当写入的数据超过了写入的最大值就阻塞直到唤起<br>writeBytesMaximum = 16384（每个帧限制大小）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun writeData(</span><br><span class="line">    streamId: Int,</span><br><span class="line">    outFinished: Boolean,</span><br><span class="line">    buffer: Buffer?,</span><br><span class="line">    byteCount: Long</span><br><span class="line">  ) &#123;</span><br><span class="line">    var byteCount &#x3D; byteCount</span><br><span class="line">    while (byteCount &gt; 0L) &#123;</span><br><span class="line">      var toWrite: Int</span><br><span class="line">      synchronized(this@Http2Connection) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        </span><br><span class="line">          while (writeBytesTotal &gt;&#x3D; writeBytesMaximum) &#123; &#x2F;&#x2F; 待写入数据超了</span><br><span class="line">            if (!streams.containsKey(streamId)) &#123;</span><br><span class="line">              throw IOException(&quot;stream closed&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            this@Http2Connection.wait() &#x2F;&#x2F; 阻塞</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">          Thread.currentThread().interrupt() &#x2F;&#x2F; Retain interrupted status.</span><br><span class="line">          throw InterruptedIOException()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        toWrite &#x3D; minOf(byteCount, writeBytesMaximum - writeBytesTotal).toInt()</span><br><span class="line">        toWrite &#x3D; minOf(toWrite, writer.maxDataLength())</span><br><span class="line">        writeBytesTotal +&#x3D; toWrite.toLong()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      byteCount -&#x3D; toWrite.toLong()</span><br><span class="line">      &#x2F;&#x2F;写入数据 </span><br><span class="line">      writer.data(outFinished &amp;&amp; byteCount &#x3D;&#x3D; 0L, streamId, buffer, toWrite)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http2Write-data"><a href="#Http2Write-data" class="headerlink" title="Http2Write.data"></a>Http2Write.data</h4><p>数据帧的写入执行方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun data(outFinished: Boolean, streamId: Int, source: Buffer?, byteCount: Int) &#123;</span><br><span class="line">  if (closed) throw IOException(&quot;closed&quot;)</span><br><span class="line">  var flags &#x3D; FLAG_NONE</span><br><span class="line">  if (outFinished) flags &#x3D; flags or FLAG_END_STREAM</span><br><span class="line">  &#x2F;&#x2F; 帧数据写入</span><br><span class="line">  dataFrame(streamId, flags, source, byteCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">fun dataFrame(streamId: Int, flags: Int, buffer: Buffer?, byteCount: Int) &#123;</span><br><span class="line">  &#x2F;&#x2F; 写入帧头</span><br><span class="line">  frameHeader(</span><br><span class="line">      streamId &#x3D; streamId,</span><br><span class="line">      length &#x3D; byteCount,</span><br><span class="line">      type &#x3D; TYPE_DATA,</span><br><span class="line">      flags &#x3D; flags</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 写入数据</span><br><span class="line">  if (byteCount &gt; 0) &#123;</span><br><span class="line">    sink.write(buffer!!, byteCount.toLong())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Http2ExchangeCodec-readResponseHeaders"><a href="#Http2ExchangeCodec-readResponseHeaders" class="headerlink" title="Http2ExchangeCodec.readResponseHeaders"></a>Http2ExchangeCodec.readResponseHeaders</h4><ul>
<li>阻塞等待获取Headers数据 </li>
<li>获取Headers数据，转换为Response中headers，以及其它响应头信息，创建ResponseBuilder</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? &#123;</span><br><span class="line">  val headers &#x3D; stream!!.takeHeaders() &#x2F;&#x2F; 取headers</span><br><span class="line">  val responseBuilder &#x3D; readHttp2HeadersList(headers, protocol) &#x2F;&#x2F; 读取到headers集合并创建建响应Buidler</span><br><span class="line">  return if (expectContinue &amp;&amp; responseBuilder.code &#x3D;&#x3D; HTTP_CONTINUE) &#123;</span><br><span class="line">    null</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    responseBuilder</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Stream-takeHeaders"><a href="#Http2Stream-takeHeaders" class="headerlink" title="Http2Stream.takeHeaders"></a>Http2Stream.takeHeaders</h4><p>阻塞等待headers数据，在拿到headers后，返回数据<br>headers数据在receiveHeaders方法中会添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun takeHeaders(): Headers &#123;</span><br><span class="line">  readTimeout.enter()</span><br><span class="line">  try &#123;</span><br><span class="line">    while (headersQueue.isEmpty() &amp;&amp; errorCode &#x3D;&#x3D; null) &#123;</span><br><span class="line">      waitForIo() &#x2F;&#x2F; 如果为空，则阻塞等待 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    readTimeout.exitAndThrowIfTimedOut()</span><br><span class="line">  &#125;</span><br><span class="line">  if (headersQueue.isNotEmpty()) &#123;</span><br><span class="line">    return headersQueue.removeFirst() &#x2F;&#x2F;取headers 返回</span><br><span class="line">  &#125;</span><br><span class="line">  throw errorException ?: StreamResetException(errorCode!!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Stream-receiveHeaders"><a href="#Http2Stream-receiveHeaders" class="headerlink" title="Http2Stream.receiveHeaders"></a>Http2Stream.receiveHeaders</h4><p>从数据源接受header后，存储到headers队列中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun receiveHeaders(headers: Headers, inFinished: Boolean) &#123;</span><br><span class="line">  this@Http2Stream.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  val open: Boolean</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    if (!hasResponseHeaders || !inFinished) &#123;</span><br><span class="line">      hasResponseHeaders &#x3D; true</span><br><span class="line">      headersQueue +&#x3D; headers &#x2F;&#x2F; 加入headers</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.source.trailers &#x3D; headers</span><br><span class="line">    &#125;</span><br><span class="line">    if (inFinished) &#123;</span><br><span class="line">      this.source.finished &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">    open &#x3D; isOpen</span><br><span class="line">    notifyAll() </span><br><span class="line">  &#125;</span><br><span class="line">  if (!open) &#123;</span><br><span class="line">    connection.removeStream(id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReaderRunnable-run"><a href="#ReaderRunnable-run" class="headerlink" title="ReaderRunnable.run"></a>ReaderRunnable.run</h4><p>在Http2Connection.start的时候，最后会执行一个此线程方法<br>当读取完preface之后，就一直循环读取下一个帧数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun run() &#123;</span><br><span class="line">  var connectionErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">  var streamErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">  var errorException: IOException? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    reader.readConnectionPreface(this) </span><br><span class="line">    &#x2F;&#x2F; 循环读取帧数据</span><br><span class="line">    while (reader.nextFrame(false, this)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    connectionErrorCode &#x3D; ErrorCode.NO_ERROR</span><br><span class="line">    streamErrorCode &#x3D; ErrorCode.CANCEL</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http2Reader-nextFrame"><a href="#Http2Reader-nextFrame" class="headerlink" title="Http2Reader.nextFrame"></a>Http2Reader.nextFrame</h4><p>读取响应数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun nextFrame(requireSettings: Boolean, handler: Handler): Boolean &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    source.require(9) &#x2F;&#x2F; Frame header size.</span><br><span class="line">  &#125; catch (e: EOFException) &#123;</span><br><span class="line">    return false &#x2F;&#x2F; This might be a normal socket close.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val length &#x3D; source.readMedium()</span><br><span class="line">  if (length &gt; INITIAL_MAX_FRAME_SIZE) &#123;</span><br><span class="line">    throw IOException(&quot;FRAME_SIZE_ERROR: $length&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  val type &#x3D; source.readByte() and 0xff</span><br><span class="line">  if (requireSettings &amp;&amp; type !&#x3D; TYPE_SETTINGS) &#123;</span><br><span class="line">    throw IOException(&quot;Expected a SETTINGS frame but was $type&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  val flags &#x3D; source.readByte() and 0xff</span><br><span class="line">  val streamId &#x3D; source.readInt() and 0x7fffffff &#x2F;&#x2F; Ignore reserved bit.</span><br><span class="line">  if (logger.isLoggable(FINE)) logger.fine(frameLog(true, streamId, length, type, flags))</span><br><span class="line">  &#x2F;&#x2F; 读取不同类型数据</span><br><span class="line">  when (type) &#123;</span><br><span class="line">    TYPE_DATA -&gt; readData(handler, length, flags, streamId)</span><br><span class="line">    TYPE_HEADERS -&gt; readHeaders(handler, length, flags, streamId)</span><br><span class="line">    TYPE_PRIORITY -&gt; readPriority(handler, length, flags, streamId)</span><br><span class="line">    TYPE_RST_STREAM -&gt; readRstStream(handler, length, flags, streamId)</span><br><span class="line">    TYPE_SETTINGS -&gt; readSettings(handler, length, flags, streamId)</span><br><span class="line">    TYPE_PUSH_PROMISE -&gt; readPushPromise(handler, length, flags, streamId)</span><br><span class="line">    TYPE_PING -&gt; readPing(handler, length, flags, streamId)</span><br><span class="line">    TYPE_GOAWAY -&gt; readGoAway(handler, length, flags, streamId)</span><br><span class="line">    TYPE_WINDOW_UPDATE -&gt; readWindowUpdate(handler, length, flags, streamId)</span><br><span class="line">    else -&gt; source.skip(length.toLong()) &#x2F;&#x2F; Implementations MUST discard frames of unknown types.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### FramingSource.read</span><br></pre></td></tr></table></figure>
<p>override fun read(sink: Buffer, byteCount: Long): Long {<br>      require(byteCount &gt;= 0L) { “byteCount &lt; 0: $byteCount” }</p>
<pre><code>  while (true) {
    var tryAgain = false
    var readBytesDelivered = -1L
    var errorExceptionToDeliver: IOException? = null

    // 1. Decide what to do in a synchronized block.

    synchronized(this@Http2Stream) {
      readTimeout.enter()
      try {
        if (errorCode != null) {
          // Prepare to deliver an error.
          errorExceptionToDeliver = errorException ?: StreamResetException(errorCode!!)
        }

        if (closed) {
          throw IOException(&quot;stream closed&quot;)
        } else if (readBuffer.size &gt; 0L) {
          // Prepare to read bytes. Start by moving them to the caller&apos;s buffer.
          readBytesDelivered = readBuffer.read(sink, minOf(byteCount, readBuffer.size))
          readBytesTotal += readBytesDelivered

          val unacknowledgedBytesRead = readBytesTotal - readBytesAcknowledged
          if (errorExceptionToDeliver == null &amp;&amp;
              unacknowledgedBytesRead &gt;= connection.okHttpSettings.initialWindowSize / 2) {
            // Flow control: notify the peer that we&apos;re ready for more data! Only send a
            // WINDOW_UPDATE if the stream isn&apos;t in error.
            connection.writeWindowUpdateLater(id, unacknowledgedBytesRead)
            readBytesAcknowledged = readBytesTotal
          }
        } else if (!finished &amp;&amp; errorExceptionToDeliver == null) {
          // Nothing to do. Wait until that changes then try again.
          waitForIo()
          tryAgain = true
        }
      } finally {
        readTimeout.exitAndThrowIfTimedOut()
      }
    }

    // 2. Do it outside of the synchronized block and timeout.

    if (tryAgain) {
      continue
    }

    if (readBytesDelivered != -1L) {
      // Update connection.unacknowledgedBytesRead outside the synchronized block.
      updateConnectionFlowControl(readBytesDelivered)
      return readBytesDelivered
    }

    ...

    return -1L // This source is exhausted.
  }
}</code></pre><pre><code>[下一篇 OkHttp 4源码（6）— Okio源码解析](https://www.jianshu.com/p/7b7ba4333c5e)

</code></pre>]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp 4源码（4）—连接机制分析</title>
    <url>/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%884%EF%BC%89%E2%80%94%E8%BF%9E%E6%8E%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884353600040.png"  alt=""></p>
<p>连接时序图<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349768181.jpg"  alt=""></p>
<p>HTTP不同协议连接区分<br>参考：<a href="https://halfrost.com/http2_begin/" target="_blank" rel="noopener">HTTP/2 是如何建立连接的</a><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349822059.jpg"  alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><ul>
<li>获取发射机</li>
<li>获取有效连接，RealConnection</li>
<li>创建编码器，ExchangeCodex，实际I/O工作逻辑</li>
<li>创建一个Exchange，封装上面结果，为后续网络读写工作提供API </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object ConnectInterceptor : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    &#x2F;&#x2F; 取发射机，RealCall 创建时默认会创建一个实例</span><br><span class="line">    val transmitter &#x3D; realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于非GET请求 检查为true</span><br><span class="line">    val doExtensiveHealthChecks &#x3D; request.method !&#x3D; &quot;GET&quot;</span><br><span class="line">    &#x2F;&#x2F; 构建Exchange </span><br><span class="line">    val exchange &#x3D; transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, transmitter, exchange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发射机-Transmitter"><a href="#发射机-Transmitter" class="headerlink" title="发射机 Transmitter"></a>发射机 Transmitter</h3><blockquote>
<p>Bridge between OkHttp’s application and network layers. This class exposes high-level application layer primitives: connections, requests, responses, and streams.</p>
</blockquote>
<p>OkHttp 应用层和网络层的桥梁，它提供了应用层连接、请求、响应的最上层函数</p>
<h4 id="Transmitter构造方法"><a href="#Transmitter构造方法" class="headerlink" title="Transmitter构造方法"></a>Transmitter构造方法</h4><p>RealCall 创建时默认会创建一个实例，持有client、call、connectionPool的引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Transmitter(</span><br><span class="line">  private val client: OkHttpClient,</span><br><span class="line">  private val call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 持有连接池引用</span><br><span class="line">  private val connectionPool: RealConnectionPool &#x3D; client.connectionPool.delegate</span><br><span class="line">  &#x2F;&#x2F; 监听器</span><br><span class="line">  private val eventListener: EventListener &#x3D; client.eventListenerFactory.create(call)</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Transmitter-prepareToConnect"><a href="#Transmitter-prepareToConnect" class="headerlink" title="Transmitter.prepareToConnect"></a>Transmitter.prepareToConnect</h4><p>准备连接，触发时机：重试桥开始会执行此方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun prepareToConnect(request: Request) &#123;</span><br><span class="line">  if (this.request !&#x3D; null) &#123;</span><br><span class="line">    if (this.request!!.url.canReuseConnectionFor(request.url) &amp;&amp; exchangeFinder!!.hasRouteToTry()) &#123;</span><br><span class="line">      return &#x2F;&#x2F; 可以重用下，结束</span><br><span class="line">    &#125;</span><br><span class="line">    check(exchange &#x3D;&#x3D; null)</span><br><span class="line">    &#x2F;&#x2F; 重置</span><br><span class="line">    if (exchangeFinder !&#x3D; null) &#123;</span><br><span class="line">      maybeReleaseConnection(null, true)</span><br><span class="line">      exchangeFinder &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 构造一个ExchangeFinder实例（下面介绍）</span><br><span class="line">  this.request &#x3D; request</span><br><span class="line">  this.exchangeFinder &#x3D; ExchangeFinder(</span><br><span class="line">      this, connectionPool, createAddress(request.url), call, eventListener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h3><p>核心类</p>
<ul>
<li>Exchange ，单个Http请求，传输交换数据实现类</li>
<li>ExchangeFinder ，请求连接获取，请求编解码实例构建，逻辑累</li>
<li>ExchangeCodec，Http连接I/O操作上层封装类</li>
</ul>
<h4 id="Transmitter-newExchange"><a href="#Transmitter-newExchange" class="headerlink" title="Transmitter.newExchange"></a>Transmitter.newExchange</h4><ul>
<li>获取连接 RealConnection</li>
<li>构造连接的编码器，ExchangeCodec</li>
<li>创建Exchange，它主要负责HTTP连接的维护管理及通知ExchangeCodec编码器进行实际的I/O操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 建立连接初始方法，获取连接后，会创建一个ExchangeCodec用于I&#x2F;O工作</span><br><span class="line">  val codec &#x3D; exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)</span><br><span class="line">  &#x2F;&#x2F; 创建一个 Exchange </span><br><span class="line">  val result &#x3D; Exchange(this, call, eventListener, exchangeFinder!!, codec)</span><br><span class="line"></span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    this.exchange &#x3D; result</span><br><span class="line">    this.exchangeRequestDone &#x3D; false</span><br><span class="line">    this.exchangeResponseDone &#x3D; false</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ExchangeFinder-find"><a href="#ExchangeFinder-find" class="headerlink" title="ExchangeFinder.find"></a>ExchangeFinder.find</h4><ul>
<li>获取连接 RealConnection</li>
<li>构造连接的编码器，ExchangeCodec</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun find(</span><br><span class="line">  client: OkHttpClient,</span><br><span class="line">  chain: Interceptor.Chain,</span><br><span class="line">  doExtensiveHealthChecks: Boolean</span><br><span class="line">): ExchangeCodec &#123;</span><br><span class="line">  val connectTimeout &#x3D; chain.connectTimeoutMillis()</span><br><span class="line">  val readTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">  val writeTimeout &#x3D; chain.writeTimeoutMillis()</span><br><span class="line">  val pingIntervalMillis &#x3D; client.pingIntervalMillis</span><br><span class="line">  val connectionRetryEnabled &#x3D; client.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取有效连接</span><br><span class="line">    val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">        connectTimeout &#x3D; connectTimeout,</span><br><span class="line">        readTimeout &#x3D; readTimeout,</span><br><span class="line">        writeTimeout &#x3D; writeTimeout,</span><br><span class="line">        pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled &#x3D; connectionRetryEnabled,</span><br><span class="line">        doExtensiveHealthChecks &#x3D; doExtensiveHealthChecks</span><br><span class="line">    )</span><br><span class="line">    &#x2F;&#x2F; 创建 编码器</span><br><span class="line">    return resultConnection.newCodec(client, chain)</span><br><span class="line">  &#125; catch (e: RouteException) &#123;</span><br><span class="line">    trackFailure()</span><br><span class="line">    throw e</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    trackFailure()</span><br><span class="line">    throw RouteException(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ExchangeFinder-findHealthyConnection"><a href="#ExchangeFinder-findHealthyConnection" class="headerlink" title="ExchangeFinder.findHealthyConnection"></a>ExchangeFinder.findHealthyConnection</h4><ul>
<li>执行获取连接方法，获取连接</li>
<li>如果连接是新创建的连接，则直接返回结果</li>
<li>如果连接是复用连接池的连接，则继续判断该连接是否可用，可用则返回，不可用则继续find</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun findHealthyConnection(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   connectionRetryEnabled: Boolean,</span><br><span class="line">   doExtensiveHealthChecks: Boolean</span><br><span class="line"> ): RealConnection &#123;</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     &#x2F;&#x2F; 执行连接获取方法</span><br><span class="line">     val candidate &#x3D; findConnection(</span><br><span class="line">         connectTimeout &#x3D; connectTimeout,</span><br><span class="line">         readTimeout &#x3D; readTimeout,</span><br><span class="line">         writeTimeout &#x3D; writeTimeout,</span><br><span class="line">         pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">         connectionRetryEnabled &#x3D; connectionRetryEnabled</span><br><span class="line">     )</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 新创建的连接，无需判断可用，可以直接返回连接结果</span><br><span class="line">     synchronized(connectionPool) &#123;</span><br><span class="line">       if (candidate.successCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         return candidate</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 判断该连接是否可用</span><br><span class="line">     if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">       candidate.noNewExchanges()</span><br><span class="line">       continue</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return candidate</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ExchangeFinder-findConnection"><a href="#ExchangeFinder-findConnection" class="headerlink" title="ExchangeFinder.findConnection"></a>ExchangeFinder.findConnection</h4><p>获取连接过程</p>
<ol>
<li>第一次，先从连接池获取连接</li>
<li>第二次，选择新的路由，再次尝试从连接池获取</li>
<li>构造一个新的连接</li>
<li>第三次，在高并发情况下，尝试走HTTP2的多路复用连接</li>
<li>如果连接池没有获取到连接，则走构造的那个新的连接，新的连接会加入到连接池</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun findConnection(</span><br><span class="line">  connectTimeout: Int,</span><br><span class="line">  readTimeout: Int,</span><br><span class="line">  writeTimeout: Int,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  connectionRetryEnabled: Boolean</span><br><span class="line">): RealConnection &#123;</span><br><span class="line">  var foundPooledConnection &#x3D; false</span><br><span class="line">  var result: RealConnection? &#x3D; null</span><br><span class="line">  var selectedRoute: Route? &#x3D; null</span><br><span class="line">  var releasedConnection: RealConnection?</span><br><span class="line">  val toClose: Socket?</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    hasStreamFailure &#x3D; false</span><br><span class="line">    &#x2F;&#x2F; 之前的连接 </span><br><span class="line">    releasedConnection &#x3D; transmitter.connection</span><br><span class="line">    &#x2F;&#x2F; 前连接不为null 且不支持新的ExChange了则释放连接 否则toClose 赋值null</span><br><span class="line">    toClose &#x3D; if (transmitter.connection !&#x3D; null &amp;&amp; transmitter.connection!!.noNewExchanges) &#123;</span><br><span class="line">      transmitter.releaseConnectionNoEvents()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      null</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (transmitter.connection !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 之前的连接可用，直接赋值result</span><br><span class="line">      result &#x3D; transmitter.connection</span><br><span class="line">      releasedConnection &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有可用连接，则尝试获取新的连接</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 先从连接池获取链接</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">        selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">        nextRouteToTry &#x3D; null</span><br><span class="line">      &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">        selectedRoute &#x3D; transmitter.connection!!.route()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 如果等待close的连接不为null则关闭掉</span><br><span class="line">  toClose?.closeQuietly()</span><br><span class="line">  &#x2F;&#x2F; 释放的连接不为空，事件通知连接回收</span><br><span class="line">  if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">    eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 连接池获取的连接不为空，事件通知连接连接获得</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  &#125;</span><br><span class="line">  if (result !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到了连接，返回连接，结束方法</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果至此没有获取到可用连接，则尝试更改路由，在连接</span><br><span class="line">  var newRouteSelection &#x3D; false</span><br><span class="line">  if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">    &#x2F;&#x2F; 有新的路由，则标记选了新的路由，以及获取新的路由</span><br><span class="line">    newRouteSelection &#x3D; true</span><br><span class="line">    routeSelection &#x3D; routeSelector.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">    if (newRouteSelection) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果更改了路由，则有新的一批地址，尝试从新的一批地址获取可用连接</span><br><span class="line">      routes &#x3D; routeSelection!!.routes</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">              address, transmitter, routes, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    if (!foundPooledConnection) &#123;</span><br><span class="line">      if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">        selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果仍然没有获取到可用连接，则直接创建一个新的连接实例</span><br><span class="line">      result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">      connectingConnection &#x3D; result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果第二次从连接池中找到了可用连接，则直接返回该连接</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果没有找到直接用的连接，则尝试TCP+TLC握手（阻塞过程）</span><br><span class="line">  result!!.connect(</span><br><span class="line">      connectTimeout,</span><br><span class="line">      readTimeout,</span><br><span class="line">      writeTimeout,</span><br><span class="line">      pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled,</span><br><span class="line">      call,</span><br><span class="line">      eventListener</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 连接 可用，则从路由黑名单中移除 该路由地址</span><br><span class="line">  connectionPool.routeDatabase.connected(result!!.route())</span><br><span class="line">  </span><br><span class="line">  var socket: Socket? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    connectingConnection &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 最后一次尝试连接 （这个只在一个host多个并发连接情况下发生）</span><br><span class="line">    if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果成功，则优先使用连接池的连接，并关闭之前创建的连接socket</span><br><span class="line">      result!!.noNewExchanges &#x3D; true</span><br><span class="line">      socket &#x3D; result!!.socket()</span><br><span class="line">      result &#x3D; transmitter.connection</span><br><span class="line"></span><br><span class="line">      nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 没有从连接池获取到连接，则把之前创建的连接存储进入</span><br><span class="line">      connectionPool.put(result!!)</span><br><span class="line">      transmitter.acquireConnectionNoEvents(result!!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  return result!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h4><p>OkHttpClient.Builder构造时，会默认构造一个连接池</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class Builder constructor() &#123;</span><br><span class="line">    internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConnectionPool"><a href="#ConnectionPool" class="headerlink" title="ConnectionPool"></a>ConnectionPool</h4><p>连接池，管理HTTP 和HTTP/2的所有连接，维护一定的连接，清理超过配置的连接，及提供可复用的连接。<br>默认最大空闲连接数目5个，最长连接时长5分钟</p>
<p>结构：内部持有delegate为RealConnectionPool，它是连接池管理的逻辑实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConnectionPool internal constructor(</span><br><span class="line">  internal val delegate: RealConnectionPool &#x2F;&#x2F; 连接池管理逻辑真正实现类</span><br><span class="line">) &#123;</span><br><span class="line">  constructor(</span><br><span class="line">    maxIdleConnections: Int,</span><br><span class="line">    keepAliveDuration: Long,</span><br><span class="line">    timeUnit: TimeUnit</span><br><span class="line">  ) : this(RealConnectionPool(</span><br><span class="line">      taskRunner &#x3D; TaskRunner.INSTANCE, &#x2F;&#x2F; 工作线程</span><br><span class="line">      maxIdleConnections &#x3D; maxIdleConnections, &#x2F;&#x2F; 最大空闲连接数5</span><br><span class="line">      keepAliveDuration &#x3D; keepAliveDuration, &#x2F;&#x2F; 最长连接时长5min</span><br><span class="line">      timeUnit &#x3D; timeUnit</span><br><span class="line">  ))</span><br><span class="line"></span><br><span class="line">  constructor() : this(5, 5, TimeUnit.MINUTES)</span><br><span class="line"></span><br><span class="line">  fun idleConnectionCount(): Int &#x3D; delegate.idleConnectionCount()</span><br><span class="line"></span><br><span class="line">  fun connectionCount(): Int &#x3D; delegate.connectionCount()</span><br><span class="line"></span><br><span class="line">  &#x2F;** Close and remove all idle connections in the pool. *&#x2F;</span><br><span class="line">  fun evictAll() &#123;</span><br><span class="line">    delegate.evictAll()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-transmitterAcquirePooledConnection"><a href="#RealConnectionPool-transmitterAcquirePooledConnection" class="headerlink" title="RealConnectionPool.transmitterAcquirePooledConnection"></a>RealConnectionPool.transmitterAcquirePooledConnection</h4><p>前面我们知道Transmitter持有ConnectionPool，且看它持有的变量是直接以RealConnectionPool作为类型的，可以显示执行到它的其它方法<br>transmitterAcquirePooledConnection尝试获取连接池中的连接，达到复用连接的目的<br>一共两种情况可以使用复用的连接，1.需要多路复用连接且有支持多路复用的连接；2.能给目标Address分配stream的连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun transmitterAcquirePooledConnection(</span><br><span class="line">  address: Address,</span><br><span class="line">  transmitter: Transmitter,</span><br><span class="line">  routes: List&lt;Route&gt;?,</span><br><span class="line">  requireMultiplexed: Boolean</span><br><span class="line">): Boolean &#123;</span><br><span class="line">  this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  for (connection in connections) &#123;</span><br><span class="line">    &#x2F;&#x2F; 需要复用连接 &amp;&amp; 该连接不支持复用连接（HTTP2） 则该连接不可用</span><br><span class="line">    if (requireMultiplexed &amp;&amp; !connection.isMultiplexed) continue</span><br><span class="line">    &#x2F;&#x2F; 如果该连接可以给对应的 address 分配stream 则返回true</span><br><span class="line">    if (!connection.isEligible(address, routes)) continue</span><br><span class="line">    &#x2F;&#x2F; 满足条件下，获取</span><br><span class="line">    transmitter.acquireConnectionNoEvents(connection)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-acquireConnectionNoEvents"><a href="#RealConnectionPool-acquireConnectionNoEvents" class="headerlink" title="RealConnectionPool.acquireConnectionNoEvents"></a>RealConnectionPool.acquireConnectionNoEvents</h4><p>获取连接，然后在连接实例中的transmitters中添加对应承载的Transmitter弱引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun acquireConnectionNoEvents(connection: RealConnection) &#123;</span><br><span class="line">  connectionPool.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  check(this.connection &#x3D;&#x3D; null)</span><br><span class="line">  this.connection &#x3D; connection</span><br><span class="line">  &#x2F;&#x2F; 连接的transmitters集合添加一个弱引用</span><br><span class="line">  connection.transmitters.add(TransmitterReference(this, callStackTrace))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-put"><a href="#RealConnectionPool-put" class="headerlink" title="RealConnectionPool.put"></a>RealConnectionPool.put</h4><p>ExchangeFinder最后find的connection是创建的新的connection，则会执行Pool的put新连接方法<br>put方法 先将新的连接添加到连接集合中，然后执行清理任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun put(connection: RealConnection) &#123;</span><br><span class="line">  this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  connections.add(connection)</span><br><span class="line">  cleanupQueue.schedule(cleanupTask) &#x2F;&#x2F; 执行清理任务一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnectionPool-cleanup"><a href="#RealConnectionPool-cleanup" class="headerlink" title="RealConnectionPool.cleanup"></a>RealConnectionPool.cleanup</h4><p>对连接池的连接进行维护，主要是清理长时间无用的连接（超过空闲连接个数且超过最大空闲时长）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun cleanup(now: Long): Long &#123;</span><br><span class="line">    var inUseConnectionCount &#x3D; 0</span><br><span class="line">    var idleConnectionCount &#x3D; 0</span><br><span class="line">    var longestIdleConnection: RealConnection? &#x3D; null</span><br><span class="line">    var longestIdleDurationNs &#x3D; Long.MIN_VALUE</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      for (connection in connections) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果该连接正在被使用，则继续遍历，使用连接数+1</span><br><span class="line">        if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123;</span><br><span class="line">          inUseConnectionCount++</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 空闲连接数+1</span><br><span class="line">        idleConnectionCount++</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 记录最长空闲时长，以及最长空闲时长对应的连接</span><br><span class="line">        val idleDurationNs &#x3D; now - connection.idleAtNanos</span><br><span class="line">        if (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs &#x3D; idleDurationNs</span><br><span class="line">          longestIdleConnection &#x3D; connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      when &#123;</span><br><span class="line">        &#x2F;&#x2F; 当连接最长空闲时长大于配置的时长 &amp; 空闲连接个是&gt; 配置的个数</span><br><span class="line">        longestIdleDurationNs &gt;&#x3D; this.keepAliveDurationNs</span><br><span class="line">            || idleConnectionCount &gt; this.maxIdleConnections -&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 则移除 最大的那个空闲连接</span><br><span class="line">          connections.remove(longestIdleConnection)</span><br><span class="line">          &#x2F;&#x2F; 如果连接为空了，则停止所有的清除任务</span><br><span class="line">          if (connections.isEmpty()) cleanupQueue.cancelAll()</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 其它情况则结束语句</span><br><span class="line">        ...      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 关闭被移除的连接，释放资源</span><br><span class="line">    longestIdleConnection!!.socket().closeQuietly()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cleanup again immediately.</span><br><span class="line">    return 0L</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="RealConnection-connect"><a href="#RealConnection-connect" class="headerlink" title="RealConnection.connect"></a>RealConnection.connect</h4><p>连接操作，根据是否代理会做两个逻辑区分，最后都是执行socket连接，然后进行协议的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun connect(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    call: Call,</span><br><span class="line">    eventListener: EventListener</span><br><span class="line">  ) &#123;</span><br><span class="line">    check(protocol &#x3D;&#x3D; null) &#123; &quot;already connected&quot; &#125;</span><br><span class="line"></span><br><span class="line">    var routeException: RouteException? &#x3D; null</span><br><span class="line">    val connectionSpecs &#x3D; route.address.connectionSpecs</span><br><span class="line">    val connectionSpecSelector &#x3D; ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否走代理通道， 即一个HTTPS请求 但是其有HTTP的代理通道</span><br><span class="line">        if (route.requiresTunnel()) &#123;</span><br><span class="line">          &#x2F;&#x2F; 通过代理通道建立连接 ，也叫隧道连接</span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">          if (rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; We were </span><br><span class="line">            break</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 建立连接</span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        &#125;</span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">        break</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        ... &#x2F;&#x2F; 异常处理</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (route.requiresTunnel() &amp;&amp; rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw RouteException(ProtocolException(</span><br><span class="line">          &quot;Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-connectSocket"><a href="#RealConnection-connectSocket" class="headerlink" title="RealConnection.connectSocket"></a>RealConnection.connectSocket</h4><ul>
<li>创建原生Socket</li>
<li>进行Socket连接，至此对应的底层Socket通道已经建立</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun connectSocket(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   val proxy &#x3D; route.proxy</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line">   &#x2F;&#x2F; 创建原生Socket</span><br><span class="line">   val rawSocket &#x3D; when (proxy.type()) &#123;</span><br><span class="line">     Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">     else -&gt; Socket(proxy)</span><br><span class="line">   &#125;</span><br><span class="line">   this.rawSocket &#x3D; rawSocket</span><br><span class="line">   &#x2F;&#x2F; 发送开始连接事件</span><br><span class="line">   eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">   rawSocket.soTimeout &#x3D; readTimeout</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 找应用对应的平台 进行连接</span><br><span class="line">     Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">   &#125; catch (e: ConnectException) &#123;</span><br><span class="line">     throw ConnectException(&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;).apply &#123;</span><br><span class="line">       initCause(e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-establishProtocol"><a href="#RealConnection-establishProtocol" class="headerlink" title="RealConnection.establishProtocol"></a>RealConnection.establishProtocol</h4><p>前面已经建立Socket连接通道，现在是对各个协议进行支持</p>
<ul>
<li>非HTTPS，1. 支持HTTP2情况下，优先走HTTP/2协议连接，2. 不支持，则走HTTP/1协议</li>
<li>HTTPS，则先进行TLS握手，握手成功后，如果是HTTP/2协议，则走HTTP/2连接方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun establishProtocol(</span><br><span class="line">  connectionSpecSelector: ConnectionSpecSelector,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  call: Call,</span><br><span class="line">  eventListener: EventListener</span><br><span class="line">) &#123;</span><br><span class="line">  if (route.address.sslSocketFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">      &#x2F;&#x2F; 非HTTPS，支持HTTP2，优先走HTTP2</span><br><span class="line">      socket &#x3D; rawSocket</span><br><span class="line">      protocol &#x3D; Protocol.H2_PRIOR_KNOWLEDGE</span><br><span class="line">      startHttp2(pingIntervalMillis)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socket &#x3D; rawSocket</span><br><span class="line">    protocol &#x3D; Protocol.HTTP_1_1</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 加密连接开始</span><br><span class="line">  eventListener.secureConnectStart(call)</span><br><span class="line">  &#x2F;&#x2F; 开始Tls连接</span><br><span class="line">  connectTls(connectionSpecSelector)</span><br><span class="line">  &#x2F;&#x2F; 加密连接结束</span><br><span class="line">  eventListener.secureConnectEnd(call, handshake)</span><br><span class="line"></span><br><span class="line">  if (protocol &#x3D;&#x3D;&#x3D; Protocol.HTTP_2) &#123;</span><br><span class="line">    startHttp2(pingIntervalMillis)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-connectTls"><a href="#RealConnection-connectTls" class="headerlink" title="RealConnection.connectTls"></a>RealConnection.connectTls</h4><p>进行Tls连接</p>
<ul>
<li>基于之前的原生Socket建立包装的SSLSocket</li>
<li>对SSLSocket进行相关安全信息的配置</li>
<li>通过SSLSocket进行握手，及握手过程中，进行一些证书信息校验</li>
<li>握手成功，构建对应连接的source及sink读写流</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) &#123;</span><br><span class="line">  val address &#x3D; route.address</span><br><span class="line">  val sslSocketFactory &#x3D; address.sslSocketFactory</span><br><span class="line">  var success &#x3D; false</span><br><span class="line">  var sslSocket: SSLSocket? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 基于之前创建的原生Socket 建立一个SSLSocket</span><br><span class="line">    sslSocket &#x3D; sslSocketFactory!!.createSocket(</span><br><span class="line">        rawSocket, address.url.host, address.url.port, true &#x2F;* autoClose *&#x2F;) as SSLSocket</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对sslSocket进行 安全连接的配置 以及Tls的扩展配置</span><br><span class="line">    val connectionSpec &#x3D; connectionSpecSelector.configureSecureSocket(sslSocket)</span><br><span class="line">    if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">      Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 开始握手</span><br><span class="line">    sslSocket.startHandshake()</span><br><span class="line">    &#x2F;&#x2F; 获取sslSession</span><br><span class="line">    val sslSocketSession &#x3D; sslSocket.session</span><br><span class="line">    val unverifiedHandshake &#x3D; sslSocketSession.handshake()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 验证证书对主机是否ok </span><br><span class="line">    if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123;</span><br><span class="line">      val peerCertificates &#x3D; unverifiedHandshake.peerCertificates</span><br><span class="line">      if (peerCertificates.isNotEmpty()) &#123;</span><br><span class="line">        val cert &#x3D; peerCertificates[0] as X509Certificate</span><br><span class="line">        throw SSLPeerUnverifiedException(&quot;&quot;&quot;</span><br><span class="line">            |Hostname $&#123;address.url.host&#125; not verified:</span><br><span class="line">            |    certificate: $&#123;CertificatePinner.pin(cert)&#125;</span><br><span class="line">            |    DN: $&#123;cert.subjectDN.name&#125;</span><br><span class="line">            |    subjectAltNames: $&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125;</span><br><span class="line">            &quot;&quot;&quot;.trimMargin())</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw SSLPeerUnverifiedException(</span><br><span class="line">            &quot;Hostname $&#123;address.url.host&#125; not verified (no certificates)&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val certificatePinner &#x3D; address.certificatePinner!!</span><br><span class="line"></span><br><span class="line">    handshake &#x3D; Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,</span><br><span class="line">        unverifiedHandshake.localCertificates) &#123;</span><br><span class="line">      certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,</span><br><span class="line">          address.url.host)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the certificate pinner is satisfied by the certificates presented.</span><br><span class="line">    certificatePinner.check(address.url.host) &#123;</span><br><span class="line">      handshake!!.peerCertificates.map &#123; it as X509Certificate &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Success! Save the handshake and the ALPN protocol.</span><br><span class="line">    val maybeProtocol &#x3D; if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">      Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      null</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 握手成功，获取source和sink流</span><br><span class="line">    socket &#x3D; sslSocket</span><br><span class="line">    source &#x3D; sslSocket.source().buffer()</span><br><span class="line">    sink &#x3D; sslSocket.sink().buffer()</span><br><span class="line">    protocol &#x3D; if (maybeProtocol !&#x3D; null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1</span><br><span class="line">    success &#x3D; true</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (sslSocket !&#x3D; null) &#123;</span><br><span class="line">      Platform.get().afterHandshake(sslSocket)</span><br><span class="line">    &#125;</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">      sslSocket?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-startHttp2"><a href="#RealConnection-startHttp2" class="headerlink" title="RealConnection.startHttp2"></a>RealConnection.startHttp2</h4><p>构建一个Http2Connection，然后启动HTTP/2协议连接，<br>http2连接实现是OkHttp中http2的包模块进行实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun startHttp2(pingIntervalMillis: Int) &#123;</span><br><span class="line">  val socket &#x3D; this.socket!!  </span><br><span class="line">  val source &#x3D; this.source!!</span><br><span class="line">  val sink &#x3D; this.sink!!</span><br><span class="line">  socket.soTimeout &#x3D; 0 </span><br><span class="line">  &#x2F;&#x2F; 构建Http2Connection ，然后启动</span><br><span class="line">  val http2Connection &#x3D; Http2Connection.Builder(client &#x3D; true, taskRunner &#x3D; TaskRunner.INSTANCE)</span><br><span class="line">      .socket(socket, route.address.url.host, source, sink)</span><br><span class="line">      .listener(this) &#x2F;&#x2F; 添加RealConnection作为listerner</span><br><span class="line">      .pingIntervalMillis(pingIntervalMillis)</span><br><span class="line">      .build()</span><br><span class="line">  this.http2Connection &#x3D; http2Connection</span><br><span class="line">  this.allocationLimit &#x3D; Http2Connection.DEFAULT_SETTINGS.getMaxConcurrentStreams()</span><br><span class="line">  http2Connection.start() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealConnection-newCodec"><a href="#RealConnection-newCodec" class="headerlink" title="RealConnection.newCodec"></a>RealConnection.newCodec</h4><p>构造编码器，Http2ExchangeCodec 或者 Http1ExchangeCodec，它们的作用封装了对请求和响应的读写操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Throws(SocketException::class)</span><br><span class="line">internal fun newCodec(client: OkHttpClient, chain: Interceptor.Chain): ExchangeCodec &#123;</span><br><span class="line">  val socket &#x3D; this.socket!!</span><br><span class="line">  val source &#x3D; this.source!!</span><br><span class="line">  val sink &#x3D; this.sink!!</span><br><span class="line">  val http2Connection &#x3D; this.http2Connection</span><br><span class="line"></span><br><span class="line">  return if (http2Connection !&#x3D; null) &#123;</span><br><span class="line">    Http2ExchangeCodec(client, this, chain, http2Connection)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    socket.soTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">    source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)</span><br><span class="line">    sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)</span><br><span class="line">    Http1ExchangeCodec(client, this, source, sink)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HTTP2连接"><a href="#HTTP2连接" class="headerlink" title="HTTP2连接"></a>HTTP2连接</h3><h4 id="Http2Connection-start"><a href="#Http2Connection-start" class="headerlink" title="Http2Connection.start"></a>Http2Connection.start</h4><p>配置HTTP2的请求前置信息，开启线程进行连接前置的信息读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun start(sendConnectionPreface: Boolean &#x3D; true) &#123;</span><br><span class="line">  if (sendConnectionPreface) &#123; &#x2F;&#x2F; 必为true</span><br><span class="line">    &#x2F;&#x2F; 配置“连接前奏”，每个端点都需要发送连接前奏作为正在使用的协议的最终确认，并建立 HTTP&#x2F;2 连接的初始设置。</span><br><span class="line">    writer.connectionPreface() </span><br><span class="line">    writer.settings(okHttpSettings)</span><br><span class="line">    val windowSize &#x3D; okHttpSettings.initialWindowSize</span><br><span class="line">    if (windowSize !&#x3D; DEFAULT_INITIAL_WINDOW_SIZE) &#123;</span><br><span class="line">      writer.windowUpdate(0, (windowSize - DEFAULT_INITIAL_WINDOW_SIZE).toLong())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 开启线程 进行连接前奏的读取工作</span><br><span class="line">  Thread(readerRunnable, connectionName).start() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http2Connection-ReaderRunnable"><a href="#Http2Connection-ReaderRunnable" class="headerlink" title="Http2Connection.ReaderRunnable"></a>Http2Connection.ReaderRunnable</h4><p>读取连接前奏信息，确认连接正常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inner class ReaderRunnable internal constructor(</span><br><span class="line">  internal val reader: Http2Reader</span><br><span class="line">) : Runnable, Http2Reader.Handler &#123;</span><br><span class="line">  override fun run() &#123;</span><br><span class="line">    var connectionErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">    var streamErrorCode &#x3D; ErrorCode.INTERNAL_ERROR</span><br><span class="line">    var errorException: IOException? &#x3D; null</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 读取连接前奏信息</span><br><span class="line">      reader.readConnectionPreface(this)</span><br><span class="line">      while (reader.nextFrame(false, this)) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      connectionErrorCode &#x3D; ErrorCode.NO_ERROR</span><br><span class="line">      streamErrorCode &#x3D; ErrorCode.CANCEL</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      errorException &#x3D; e</span><br><span class="line">      connectionErrorCode &#x3D; ErrorCode.PROTOCOL_ERROR</span><br><span class="line">      streamErrorCode &#x3D; ErrorCode.PROTOCOL_ERROR</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      close(connectionErrorCode, streamErrorCode, errorException)</span><br><span class="line">      reader.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/097b1904f580" target="_blank" rel="noopener">下一篇 OkHttp 4源码（5）— 请求和响应 I/O操作</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp 4源码（3）—缓存机制分析</title>
    <url>/blog/2020/01/13/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%883%EF%BC%89%E2%80%94%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><a href="https://www.jianshu.com/p/6ec0d13d85bb" target="_blank" rel="noopener">HTTP缓存原理</a><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349399526.jpg"  alt=""></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884354446240.png"  alt=""></p>
<p>缓存处理流程<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884354566322.png"  alt=""></p>
<p>缓存文件夹<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884354900850.png"  alt=""></p>
<p>缓存日志格式<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884355023778.png"  alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>如果需要缓存机制，那么在构造OkHttpClient的时候需要传入一个Cache实例。<br>下面是OkHttp提供的一个CacheResponse的用例，除了传入一个Cache构造OkHttpClient，其它完全一样。<br>OkHttp实现缓存的切入点依旧是拦截器，之前的文章我们知道拦截器处理对象可以接受命令对象并根据自身情况选择处理还是不处理，所以接下来就是直接从CacheInterceptor开始分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class CacheResponse &#123;</span><br><span class="line">  private final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public CacheResponse(File cacheDirectory) throws Exception &#123;</span><br><span class="line">    int cacheSize &#x3D; 10 * 1024 * 1024; &#x2F;&#x2F; 10 MiB 大小</span><br><span class="line">    Cache cache &#x3D; new Cache(cacheDirectory, cacheSize); &#x2F;&#x2F; 路径</span><br><span class="line">    &#x2F;&#x2F; 要使用缓存功能，需要在构造OkHttpClient的时候传入 cache （缓存大小，缓存路径地址）</span><br><span class="line">    client &#x3D; new OkHttpClient.Builder()</span><br><span class="line">        .cache(cache)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run() throws Exception &#123;</span><br><span class="line">    Request request &#x3D; new Request.Builder()</span><br><span class="line">        .url(&quot;http:&#x2F;&#x2F;publicobject.com&#x2F;helloworld.txt&quot;)</span><br><span class="line">        .build();</span><br><span class="line">    </span><br><span class="line">    String response1Body;</span><br><span class="line">    try (Response response1 &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String response2Body;</span><br><span class="line">    try (Response response2 &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 两次请求结果一致</span><br><span class="line">    System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) throws Exception &#123;</span><br><span class="line">    new CacheResponse(new File(&quot;CacheResponse.tmp&quot;)).run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存拦截器逻辑"><a href="#缓存拦截器逻辑" class="headerlink" title="缓存拦截器逻辑"></a>缓存拦截器逻辑</h3><h4 id="CacheInterceptor-intercept"><a href="#CacheInterceptor-intercept" class="headerlink" title="CacheInterceptor.intercept"></a>CacheInterceptor.intercept</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; </span><br><span class="line">   val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">   val now &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">   val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">   val networkRequest &#x3D; strategy.networkRequest</span><br><span class="line">   val cacheResponse &#x3D; strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 缓存追踪，网络请求数、命中缓存数，两者比值可以查看缓存命中率</span><br><span class="line">   cache?.trackResponse(strategy)</span><br><span class="line"></span><br><span class="line">   if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">     cacheCandidate.body?.closeQuietly()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 异常情况</span><br><span class="line">   if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return Response.Builder()</span><br><span class="line">         .request(chain.request())</span><br><span class="line">         .protocol(Protocol.HTTP_1_1)</span><br><span class="line">         .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">         .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">         .body(EMPTY_RESPONSE)</span><br><span class="line">         .sentRequestAtMillis(-1L)</span><br><span class="line">         .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果networkRequest为null，则直接使用缓存数据，拦截器处理至此终结，开始响应阶段</span><br><span class="line">   if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return cacheResponse!!.newBuilder()</span><br><span class="line">         .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   var networkResponse: Response? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 继续执行 拦截器链处理方法，最终发送网络请求，到读取网络数据</span><br><span class="line">     networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">       cacheCandidate.body?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">     if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123; &#x2F;&#x2F; 304</span><br><span class="line">     &#x2F;&#x2F; 如果网络数据标志性没有改变，开始返回数据</span><br><span class="line">       val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">           .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">           .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">           .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">           .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">           .networkResponse(stripBody(networkResponse))</span><br><span class="line">           .build()</span><br><span class="line"></span><br><span class="line">       networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">       &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">       cache!!.trackConditionalCacheHit()</span><br><span class="line">       cache.update(cacheResponse, response)</span><br><span class="line">       return response</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       cacheResponse.body?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">       .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">       .networkResponse(stripBody(networkResponse))</span><br><span class="line">       .build()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   if (cache !&#x3D; null) &#123;</span><br><span class="line">     if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">       &#x2F;&#x2F; 对响应数据进行缓存</span><br><span class="line">       val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">       &#x2F;&#x2F; 返回一个带有new Source的body读取流 的 Response</span><br><span class="line">       return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">     &#125;</span><br><span class="line">       </span><br><span class="line">     if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         cache.remove(networkRequest)</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return response</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存获取逻辑"><a href="#缓存获取逻辑" class="headerlink" title="缓存获取逻辑"></a>缓存获取逻辑</h3><h4 id="Cache-get"><a href="#Cache-get" class="headerlink" title="Cache.get"></a>Cache.get</h4><ul>
<li>生成请求对应的唯一标志key</li>
<li>通过DiskLruCache获取对应key的缓存快照数据</li>
<li>如果有快照，则将快照对应的缓存资源数据通过Okio中流读写转换成内存数据</li>
<li>最后返回构造好的Response</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun get(request: Request): Response? &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据请求url字符串进行md5作为缓存对应的key标识</span><br><span class="line">  val key &#x3D; key(request.url)</span><br><span class="line">  &#x2F;&#x2F; Cache成员变量DiskLruCache，缓存逻辑实现类</span><br><span class="line">  &#x2F;&#x2F; snapshot</span><br><span class="line">  val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">    &#x2F;&#x2F; 从DiskLruCache中取缓存</span><br><span class="line">    cache[key] ?: return null</span><br><span class="line">  &#125; catch (_: IOException) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 读取快照中的缓存资源流 ，构造数据Entry</span><br><span class="line">  val entry: Entry &#x3D; try &#123;</span><br><span class="line">    Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">  &#125; catch (_: IOException) &#123;</span><br><span class="line">    snapshot.closeQuietly()</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 取 response</span><br><span class="line">  val response &#x3D; entry.response(snapshot)</span><br><span class="line">  if (!entry.matches(request, response)) &#123; </span><br><span class="line">    response.body?.closeQuietly() &#x2F;&#x2F; 响应和请求 不匹配则关闭</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response &#x2F;&#x2F; 返回响应数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cache-Entry-构造"><a href="#Cache-Entry-构造" class="headerlink" title="Cache.Entry 构造"></a>Cache.Entry 构造</h4><p>缓存数据实例，DiskLruCache中lruEntries存储了请求key对应的快照，快照里有key对应的本地文件读取流，根据读取流读取本地数据，转换输出构造Entry实例，最终应用构造出一个缓存的Response</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal constructor(rawSource: Source) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        val source &#x3D; rawSource.buffer()</span><br><span class="line">        &#x2F;&#x2F; 从缓存文件流中 读取数据 ，写入到Entry中</span><br><span class="line">        ... &#x2F;&#x2F; 一堆 读取流 写入内存操作</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">        rawSource.close()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="DiskLruCache-get"><a href="#DiskLruCache-get" class="headerlink" title="DiskLruCache.get"></a>DiskLruCache.get</h4><ul>
<li>初始化或者确认初始化（主要目的是将key和对应缓存本地文件标识存储到内存Map中，便于查询）</li>
<li>如果找到了就返回一个快照对象，没有则为null</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator fun get(key: String): Snapshot? &#123;</span><br><span class="line">  initialize() &#x2F;&#x2F; 初始化 || 确认已经初始化</span><br><span class="line"></span><br><span class="line">  checkNotClosed() &#x2F;&#x2F; check cache是否关闭</span><br><span class="line">  validateKey(key) &#x2F;&#x2F; 确认key 符合 写入的规则</span><br><span class="line">  &#x2F;&#x2F; 找key对应的缓存entry</span><br><span class="line">  val entry &#x3D; lruEntries[key] ?: return null </span><br><span class="line">  if (!entry.readable) return null</span><br><span class="line">  &#x2F;&#x2F; 有缓存entry 取对应的快照</span><br><span class="line">  val snapshot &#x3D; entry.snapshot() ?: return null</span><br><span class="line">  &#x2F;&#x2F; 标识一次操作</span><br><span class="line">  redundantOpCount++ </span><br><span class="line">  &#x2F;&#x2F; 写入 标记READ 和对应 key 一行</span><br><span class="line">  journalWriter!!.writeUtf8(READ)</span><br><span class="line">      .writeByte(&#39; &#39;.toInt())</span><br><span class="line">      .writeUtf8(key)</span><br><span class="line">      .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">  &#x2F;&#x2F; 如果操作&gt;2000次了，则需要重新清理 日志 </span><br><span class="line">  if (journalRebuildRequired()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行清理任务</span><br><span class="line">    cleanupQueue.schedule(cleanupTask)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回快照</span><br><span class="line">  return snapshot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-initialize"><a href="#DiskLruCache-initialize" class="headerlink" title="DiskLruCache.initialize"></a>DiskLruCache.initialize</h4><ul>
<li>整理日志文件，删除backup或者重命名bakcup日志文件</li>
<li>读取日志文件，生成lruEntries内存缓存</li>
<li>处理日志文件</li>
<li>按需是否重新构建日志文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化方法</span><br><span class="line">fun initialize() &#123;</span><br><span class="line">   this.assertThreadHoldsLock()</span><br><span class="line">   &#x2F;&#x2F; 是否已经初始化 ，内存缓存</span><br><span class="line">   if (initialized) &#123;</span><br><span class="line">     return &#x2F;&#x2F; Already initialized.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 开始初始化工作</span><br><span class="line">   &#x2F;&#x2F; 如果存在backup的日志文件，</span><br><span class="line">   &#x2F;&#x2F; 则看是否存在日志文件，如果存在日志文件则删除backup的，</span><br><span class="line">   &#x2F;&#x2F; 如果没有则将backup文件转化为日志文件</span><br><span class="line">   if (fileSystem.exists(journalFileBackup)) &#123;</span><br><span class="line">     if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">       fileSystem.delete(journalFileBackup)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       fileSystem.rename(journalFileBackup, journalFile)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; journal文件存在 开始读取工作</span><br><span class="line">   if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       readJournal()</span><br><span class="line">       processJournal()</span><br><span class="line">       initialized &#x3D; true</span><br><span class="line">       return</span><br><span class="line">     &#125; catch (journalIsCorrupt: IOException) &#123;</span><br><span class="line">       Platform.get().log(</span><br><span class="line">           &quot;DiskLruCache $directory is corrupt: $&#123;journalIsCorrupt.message&#125;, removing&quot;,</span><br><span class="line">           WARN,</span><br><span class="line">           journalIsCorrupt)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span><br><span class="line">     &#x2F;&#x2F; we&#39;ll let that propagate out as it likely means there is a severe filesystem problem.</span><br><span class="line">     try &#123;</span><br><span class="line">       delete()</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       closed &#x3D; false</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   rebuildJournal()</span><br><span class="line"></span><br><span class="line">   initialized &#x3D; true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-readJournal"><a href="#DiskLruCache-readJournal" class="headerlink" title="DiskLruCache.readJournal"></a>DiskLruCache.readJournal</h4><ul>
<li>读取日志，判断日志是否可用</li>
<li>日志可用，则读取每行日志，构建Key、Entry的map到内存缓存</li>
<li>如果读取过程中有问题，则根据tmp日志重新构建日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取日志文件，构造[key,entry]内存缓存集合</span><br><span class="line">private fun readJournal() &#123;</span><br><span class="line">  fileSystem.source(journalFile).buffer().use &#123; source -&gt;</span><br><span class="line">    &#x2F;&#x2F; 基于Okio读写本地数据</span><br><span class="line">    &#x2F;&#x2F; libcore.io.DiskLruCache</span><br><span class="line">    val magic &#x3D; source.readUtf8LineStrict() </span><br><span class="line">    val version &#x3D; source.readUtf8LineStrict() &#x2F;&#x2F; 版本 1</span><br><span class="line">    val appVersionString &#x3D; source.readUtf8LineStrict() &#x2F;&#x2F; app version</span><br><span class="line">    val valueCountString &#x3D; source.readUtf8LineStrict()&#x2F;&#x2F; </span><br><span class="line">    val blank &#x3D; source.readUtf8LineStrict()</span><br><span class="line"></span><br><span class="line">    if (MAGIC !&#x3D; magic ||</span><br><span class="line">        VERSION_1 !&#x3D; version ||</span><br><span class="line">        appVersion.toString() !&#x3D; appVersionString ||</span><br><span class="line">        valueCount.toString() !&#x3D; valueCountString ||</span><br><span class="line">        blank.isNotEmpty()) &#123;</span><br><span class="line">      throw IOException(</span><br><span class="line">          &quot;unexpected journal header: [$magic, $version, $valueCountString, $blank]&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var lineCount &#x3D; 0</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 见readJournalLine方法分析（读取key，构造entry）</span><br><span class="line">        readJournalLine(source.readUtf8LineStrict())</span><br><span class="line">        lineCount++</span><br><span class="line">      &#125; catch (_: EOFException) &#123;</span><br><span class="line">        break &#x2F;&#x2F; End of journal.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 无用的line数目</span><br><span class="line">    redundantOpCount &#x3D; lineCount - lruEntries.size</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果读取有无，则重构建日志</span><br><span class="line">    if (!source.exhausted()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 通过Okio读取tmp日志文件重新写Journal文件</span><br><span class="line">      rebuildJournal() </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      journalWriter &#x3D; newJournalWriter() &#x2F;&#x2F; 创建日志writer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-readJournalLine"><a href="#DiskLruCache-readJournalLine" class="headerlink" title="DiskLruCache.readJournalLine"></a>DiskLruCache.readJournalLine</h4><ul>
<li>读取每一行日志</li>
<li>根据行日志属性，CLEAN、DIRTY、REMOVE、READ进行对应的处理</li>
<li>缓存到内存缓存LruEntries的Map中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取每一行日志，存储到LruEntries Map中</span><br><span class="line">private fun readJournalLine(line: String) &#123;</span><br><span class="line">  &#x2F;&#x2F; 找 第一个空格的 指引</span><br><span class="line">  val firstSpace &#x3D; line.indexOf(&#39; &#39;)</span><br><span class="line">  if (firstSpace &#x3D;&#x3D; -1) throw IOException(&quot;unexpected journal line: $line&quot;)</span><br><span class="line">  &#x2F;&#x2F; 从第一个空格指引+1位置开始找第二个空格指引</span><br><span class="line">  val keyBegin &#x3D; firstSpace + 1</span><br><span class="line">  val secondSpace &#x3D; line.indexOf(&#39; &#39;, keyBegin)</span><br><span class="line">  val key: String</span><br><span class="line">  &#x2F;&#x2F; 如果第二个空格指引没有找到</span><br><span class="line">  if (secondSpace &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 截取第一个空格指引到字符串最后的字段，截取的字段赋值key</span><br><span class="line">    key &#x3D; line.substring(keyBegin)</span><br><span class="line">    &#x2F;&#x2F; 如果第一个空格指引大小为Remove长度或者line是以remove开头</span><br><span class="line">    if (firstSpace &#x3D;&#x3D; REMOVE.length &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">      &#x2F;&#x2F; lruEntries 移除key</span><br><span class="line">      lruEntries.remove(key)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果第二个空格存在，则key赋值为第一个空格和第二个空格之间的字符串值</span><br><span class="line">    key &#x3D; line.substring(keyBegin, secondSpace)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 取key对应的Entry</span><br><span class="line">  var entry: Entry? &#x3D; lruEntries[key]</span><br><span class="line">  if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 不存砸，则创建Entry并赋值</span><br><span class="line">    entry &#x3D; Entry(key)</span><br><span class="line">    lruEntries[key] &#x3D; entry</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  when &#123;</span><br><span class="line">    secondSpace !&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; CLEAN.length &amp;&amp; line.startsWith(CLEAN) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 示例数据 CLEAN 4b217e04ba52215f3a6b64d28f6729c6 333 194</span><br><span class="line">      &#x2F;&#x2F; 读line间隔有多少个 方便存储对应大小数据</span><br><span class="line">      val parts &#x3D; line.substring(secondSpace + 1)</span><br><span class="line">          .split(&#39; &#39;)</span><br><span class="line">      entry.readable &#x3D; true &#x2F;&#x2F; 设置可读</span><br><span class="line">      entry.currentEditor &#x3D; null &#x2F;&#x2F; 重置null</span><br><span class="line">      entry.setLengths(parts) &#x2F;&#x2F; 根据文件个数，设置每个文件大小</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 示例数据：DIRTY 4b217e04ba52215f3a6b64d28f6729c6</span><br><span class="line">    secondSpace &#x3D;&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; DIRTY.length &amp;&amp; line.startsWith(DIRTY) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 赋值currentEditor为对应Entry的Editor</span><br><span class="line">      entry.currentEditor &#x3D; Editor(entry)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; READ，不做处理</span><br><span class="line">    secondSpace &#x3D;&#x3D; -1 &amp;&amp; firstSpace &#x3D;&#x3D; READ.length &amp;&amp; line.startsWith(READ) -&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; This work was already done by calling lruEntries.get().</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else -&gt; throw IOException(&quot;unexpected journal line: $line&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-processJournal"><a href="#DiskLruCache-processJournal" class="headerlink" title="DiskLruCache.processJournal"></a>DiskLruCache.processJournal</h4><ul>
<li>计算有效文件的总大小值</li>
<li>删除无效本地缓存文件和内存缓存key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun processJournal() &#123;</span><br><span class="line">  &#x2F;&#x2F; 删除journal.tmp临时文件</span><br><span class="line">  fileSystem.delete(journalFileTmp)</span><br><span class="line">  val i &#x3D; lruEntries.values.iterator()</span><br><span class="line">  &#x2F;&#x2F; 遍历lruEntries ，计算currentEditor为null对应的文件总大小</span><br><span class="line">  while (i.hasNext()) &#123; </span><br><span class="line">    val entry &#x3D; i.next()</span><br><span class="line">    if (entry.currentEditor &#x3D;&#x3D; null) &#123;</span><br><span class="line">      for (t in 0 until valueCount) &#123;</span><br><span class="line">        size +&#x3D; entry.lengths[t]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      entry.currentEditor &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; 删除currentEditor文件（对应Dirty文件）</span><br><span class="line">      for (t in 0 until valueCount) &#123;</span><br><span class="line">        fileSystem.delete(entry.cleanFiles[t])</span><br><span class="line">        fileSystem.delete(entry.dirtyFiles[t])</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存使用策略逻辑"><a href="#缓存使用策略逻辑" class="headerlink" title="缓存使用策略逻辑"></a>缓存使用策略逻辑</h3><p>缓存使用策略：给定请求和缓存响应，决策出用网络响应还是缓存响应，或者两者都有</p>
<h4 id="CacheStrategy-init"><a href="#CacheStrategy-init" class="headerlink" title="CacheStrategy.init"></a>CacheStrategy.init</h4><ul>
<li>读取请求时间戳、响应时间戳</li>
<li>读取缓存策略决策的关键Header，Date、Expires、Last-Modified、ETag</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">      if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">        this.sentRequestMillis &#x3D; cacheResponse.sentRequestAtMillis</span><br><span class="line">        this.receivedResponseMillis &#x3D; cacheResponse.receivedResponseAtMillis</span><br><span class="line">        val headers &#x3D; cacheResponse.headers</span><br><span class="line">        for (i in 0 until headers.size) &#123;</span><br><span class="line">          val fieldName &#x3D; headers.name(i)</span><br><span class="line">          val value &#x3D; headers.value(i)</span><br><span class="line">          when &#123;</span><br><span class="line">            &#x2F;&#x2F; 读取缓存策略决策的关键Header</span><br><span class="line">            &#x2F;&#x2F; Date、Expires、Last-Modified、ETag</span><br><span class="line">            fieldName.equals(&quot;Date&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              servedDate &#x3D; value.toHttpDateOrNull()</span><br><span class="line">              servedDateString &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Expires&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              expires &#x3D; value.toHttpDateOrNull()</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Last-Modified&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              lastModified &#x3D; value.toHttpDateOrNull()</span><br><span class="line">              lastModifiedString &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;ETag&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              etag &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">            fieldName.equals(&quot;Age&quot;, ignoreCase &#x3D; true) -&gt; &#123;</span><br><span class="line">              ageSeconds &#x3D; value.toNonNegativeInt(-1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheStrategy-compute"><a href="#CacheStrategy-compute" class="headerlink" title="CacheStrategy.compute"></a>CacheStrategy.compute</h4><p>执行CacheStrategy.computeCandidate策略，最后返回四种策略结果</p>
<ol>
<li>CacheStrategy(request, null)； 无缓存，需要取网络数据</li>
<li>CacheStrategy(null, cacheResponse)；直接使用缓存</li>
<li>CacheStrategy(conditionalRequestHeaders,cacheResponse)；构建新的网络请求（加Header）需要新的网络请求返回后判断是否使用哪一个</li>
<li>CacheStrategy(null, null)； 错误场景</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun compute(): CacheStrategy &#123;</span><br><span class="line">  val candidate &#x3D; computeCandidate()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 禁止构建新的请求 且 缓存数据有没有，则返回null，这一般是个错误场景</span><br><span class="line">  if (candidate.networkRequest !&#x3D; null &amp;&amp; request.cacheControl.onlyIfCached) &#123;</span><br><span class="line">    return CacheStrategy(null, null)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return candidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheStrategy-computeCandidate"><a href="#CacheStrategy-computeCandidate" class="headerlink" title="CacheStrategy.computeCandidate"></a>CacheStrategy.computeCandidate</h4><p>缓存策略一系列判断，最后有三种策略返回结果</p>
<ol>
<li>CacheStrategy(request, null)； 无缓存，需要取网络数据</li>
<li>CacheStrategy(null, cacheResponse)；直接使用缓存</li>
<li>CacheStrategy(conditionalRequestHeaders,cacheResponse)；构建新的网络请求（加Header）需要新的网络请求返回后判断是否使用哪一个</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun computeCandidate(): CacheStrategy &#123;</span><br><span class="line">    &#x2F;&#x2F; 无缓存</span><br><span class="line">    if (cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; https请求 且无handshake数据</span><br><span class="line">    if (request.isHttps &amp;&amp; cacheResponse.handshake &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 不支持缓存</span><br><span class="line">    if (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 配置了cacheControl字段 说明不需要cache</span><br><span class="line">    val requestCaching &#x3D; request.cacheControl</span><br><span class="line">    if (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 计算!noCache情况Header下，是否过期，是否可以直接使用Cache数据</span><br><span class="line">    val responseCaching &#x3D; cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">    val ageMillis &#x3D; cacheResponseAge()</span><br><span class="line">    var freshMillis &#x3D; computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">    if (requestCaching.maxAgeSeconds !&#x3D; -1) &#123;</span><br><span class="line">      freshMillis &#x3D; minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var minFreshMillis: Long &#x3D; 0</span><br><span class="line">    if (requestCaching.minFreshSeconds !&#x3D; -1) &#123;</span><br><span class="line">      minFreshMillis &#x3D; SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var maxStaleMillis: Long &#x3D; 0</span><br><span class="line">    if (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds !&#x3D; -1) &#123;</span><br><span class="line">      maxStaleMillis &#x3D; SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; !noCache Header标志，且缓存数据未过期，则直接使用</span><br><span class="line">    if (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">      val builder &#x3D; cacheResponse.newBuilder()</span><br><span class="line">      if (ageMillis + minFreshMillis &gt;&#x3D; freshMillis) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      val oneDayMillis &#x3D; 24 * 60 * 60 * 1000L</span><br><span class="line">      if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return CacheStrategy(null, builder.build())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将header数据取出，带入新的请求header中</span><br><span class="line">    val conditionName: String</span><br><span class="line">    val conditionValue: String?</span><br><span class="line">    when &#123;</span><br><span class="line">      etag !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-None-Match&quot;</span><br><span class="line">        conditionValue &#x3D; etag</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastModified !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; lastModifiedString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      servedDate !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; servedDateString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      else -&gt; return CacheStrategy(request, null) &#x2F;&#x2F; No condition! Make a regular request.</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 构建新的网络请求，返回带有新的网络请求+cacheReponse数据</span><br><span class="line">    val conditionalRequestHeaders &#x3D; request.headers.newBuilder()</span><br><span class="line">    conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">    val conditionalRequest &#x3D; request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build()</span><br><span class="line">    return CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存存储逻辑"><a href="#缓存存储逻辑" class="headerlink" title="缓存存储逻辑"></a>缓存存储逻辑</h3><h4 id="Cache-put"><a href="#Cache-put" class="headerlink" title="Cache.put"></a>Cache.put</h4><p>⚠️ 对于非GET请求，不做缓存逻辑，原因：POST请求虽然可以做到缓存逻辑，但是实现复杂度和收益比非常低，所以没有处理非Get的请求缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal fun put(response: Response): CacheRequest? &#123;</span><br><span class="line">   &#x2F;&#x2F; 请求方法</span><br><span class="line">   val requestMethod &#x3D; response.request.method</span><br><span class="line">   &#x2F;&#x2F; 如果是非Get则为true</span><br><span class="line">   if (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       remove(response.request) &#x2F;&#x2F; 移除缓存</span><br><span class="line">     &#125; catch (_: IOException) &#123;</span><br><span class="line">       &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">     &#125;</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 对于非GET请求，不做缓存逻辑，原因：POST请求虽然可以做到缓存逻辑，但是实现复杂度和收益比非常低，所以没有做处理</span><br><span class="line">   if (requestMethod !&#x3D; &quot;GET&quot;) &#123;</span><br><span class="line">     &#x2F;&#x2F; Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache HEAD requests and some</span><br><span class="line">     &#x2F;&#x2F; POST requests, but the complexity of doing so is high and the benefit is low.</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (response.hasVaryAll()) &#123;</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造 Entry</span><br><span class="line">   val entry &#x3D; Entry(response)</span><br><span class="line">   var editor: DiskLruCache.Editor? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Entry 编辑器，数据书写</span><br><span class="line">     editor &#x3D; cache.edit(key(response.request.url)) ?: return null</span><br><span class="line">     entry.writeTo(editor)</span><br><span class="line">     &#x2F;&#x2F; 构造一个 RealCacheRequest返回 </span><br><span class="line">     return RealCacheRequest(editor)</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     abortQuietly(editor)</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DiskLruCache-edit"><a href="#DiskLruCache-edit" class="headerlink" title="DiskLruCache.edit"></a>DiskLruCache.edit</h4><p>主要是获取编辑器，编辑器获取的同时，DiskLruCache内存缓存中会存储对应的key和Entry，entry会指定对应的Editor，且会写入一条数据到日志中，目前日志key对应的数据是DIRTY</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun edit(key: String, expectedSequenceNumber: Long &#x3D; ANY_SEQUENCE_NUMBER): Editor? &#123;</span><br><span class="line">   initialize()</span><br><span class="line"></span><br><span class="line">   checkNotClosed()</span><br><span class="line">   validateKey(key)</span><br><span class="line">   &#x2F;&#x2F; key对应Entry</span><br><span class="line">   var entry: Entry? &#x3D; lruEntries[key] </span><br><span class="line">   if (expectedSequenceNumber !&#x3D; ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">       (entry &#x3D;&#x3D; null || entry.sequenceNumber !&#x3D; expectedSequenceNumber)) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Snapshot is stale.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 是否正在编辑</span><br><span class="line">   if (entry?.currentEditor !&#x3D; null) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Another edit is in progress.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 是否需要执行clean</span><br><span class="line">   if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 写入 key 到日志中 ，目前对应是 DIRTY</span><br><span class="line">   val journalWriter &#x3D; this.journalWriter!!</span><br><span class="line">   journalWriter.writeUtf8(DIRTY)</span><br><span class="line">       .writeByte(&#39; &#39;.toInt())</span><br><span class="line">       .writeUtf8(key)</span><br><span class="line">       .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">   journalWriter.flush()</span><br><span class="line"></span><br><span class="line">   if (hasJournalErrors) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Don&#39;t edit; the journal can&#39;t be written.</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造Entry，存储到map中</span><br><span class="line">   if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">     entry &#x3D; Entry(key)</span><br><span class="line">     lruEntries[key] &#x3D; entry</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 构造编辑器，及Etry赋值当前编辑器</span><br><span class="line">   val editor &#x3D; Editor(entry)</span><br><span class="line">   entry.currentEditor &#x3D; editor</span><br><span class="line">   return editor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cache-writeTo"><a href="#Cache-writeTo" class="headerlink" title="Cache.writeTo"></a>Cache.writeTo</h4><p>通过Okio将响应数据写入到本地缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun writeTo(editor: DiskLruCache.Editor) &#123;</span><br><span class="line">      val sink &#x3D; editor.newSink(ENTRY_METADATA).buffer()</span><br><span class="line">      sink.writeUtf8(url).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      sink.writeUtf8(requestMethod).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      for (i in 0 until varyHeaders.size) &#123;</span><br><span class="line">        sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">            .writeUtf8(&quot;: &quot;)</span><br><span class="line">            .writeUtf8(varyHeaders.value(i))</span><br><span class="line">            .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 写入数据</span><br><span class="line">      ...</span><br><span class="line">      sink.close()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/be6d09f2656b" target="_blank" rel="noopener">下一篇 OkHttp 4源码（4）— 连接机制分析</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp 4源码（2）— 拦截器机制分析</title>
    <url>/blog/2020/01/12/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%882%EF%BC%89%E2%80%94%20%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OkHttp整体流程（本文覆盖红色部分）</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884355133199.png"  alt=""></p>
<p>Interceptor流程</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-02-15884349359474.jpg"  alt=""></p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>概念<br>责任链模式（Chain of Responsibility Pattern），包含命令对象和一系列实现了相同接口的处理对象，这些处理对象相互连接成为一条责任链。每一个处理对象能决定它能处理哪些命令对象，对于它不能处理的命令对象，将会传递给该链中的下一个处理对象。负责链模式就是对这种顺序处理事件的行为的抽象,通过接口来定义处理事件的方法，顺序分发/处理事件。</p>
<p>主要解决<br>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p>优点</p>
<ol>
<li>降低耦合度。它将请求的发送者和接收者解耦。 </li>
<li>简化了对象。使得对象不需要知道链的结构。 </li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li>
<li>增加新的请求处理类很方便。</li>
</ol>
<p>特点</p>
<ol>
<li>每个责任人实现相同的接口,处理一个事件对象</li>
<li>让事件对象责任人之间顺序传递</li>
<li>事件的处理结果的返回是逆序的</li>
<li>责任链中的每个责任人都可以有权不继续传递事件,以自身为终点处理事件返回结果</li>
</ol>
<p>OkHttp中应用<br>在 OkHttp 中，命令对象就是 Request 对象，处理对象就是每一个 Interceptor 对象。每个 interceptor 对 request 进行一些步骤的处理，而将其余的工作交给下一个 interceptor。另外，责任链中的处理对象如果可以全权处理命令对象，则不需要交给下一个处理对象。OkHttp 中的 CacheInterceptor 也是具有全权处理的能力。如果请求的结果已经缓存，则不需要再交给 ConnectInterceptor 等进行连接服务器、发送请求的处理，直接返回已缓存的 response 即可。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p>拦截器，即处理对象类，Chain和Interceptor共同实现顺序调用，最终反响依次返回Response<br>拦截器一般可以概括三个步骤</p>
<ol>
<li>请求前处理逻辑</li>
<li>执行 chain.proceed，顺序调用</li>
<li>获取响应结果后逻辑处理</li>
</ol>
<p>默认拦截器依次包括</p>
<ol>
<li>RetryAndFollowUpInterceptor （重试机制）</li>
<li>BridgeInterceptor    （Http连接转换桥）</li>
<li>CacheInterceptor     （缓存策略）</li>
<li>ConnectInterceptor   （连接）</li>
<li>CallServerInterceptor  （响应读取）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 拦截器，处理对象</span><br><span class="line">interface Interceptor &#123;</span><br><span class="line">  &#x2F;&#x2F; 拦截方法，接受拦截器链（包括命令对象Request及Call、和一系列辅助对象），返回处理结果</span><br><span class="line">  fun intercept(chain: Chain): Response</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 链接口</span><br><span class="line">  interface Chain &#123;</span><br><span class="line">    &#x2F;&#x2F; 核心方法， 顺序执行 处理方法</span><br><span class="line">    fun proceed(request: Request): Response</span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RealInterceptorChain-拦截器链"><a href="#RealInterceptorChain-拦截器链" class="headerlink" title="RealInterceptorChain 拦截器链"></a>RealInterceptorChain 拦截器链</h3><p>完成责任链模式核心类，拦截器顺序执行、反向返回及中途中断核心实现<br>前一篇文章知道，命令对象RealCall，执行RealInterceptorChain的proceed方法，该方法最后会按照拦截器的加入顺序，循环构建Chain对象，然后执行拦截器的拦截方法，执导最后一个拦截器或者是中途拦截器直接返回了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RealInterceptorChain(</span><br><span class="line">  private val interceptors: List&lt;Interceptor&gt;, &#x2F;&#x2F; 拦截器，处理对象</span><br><span class="line">  private val transmitter: Transmitter, &#x2F;&#x2F; 发射机</span><br><span class="line">  private val exchange: Exchange?, &#x2F;&#x2F; 交换器 请求和响应 </span><br><span class="line">  private val index: Int,</span><br><span class="line">  private val request: Request, &#x2F;&#x2F; 请求</span><br><span class="line">  private val call: Call,  &#x2F;&#x2F; 一次请求和返回封装</span><br><span class="line">  private val connectTimeout: Int,</span><br><span class="line">  private val readTimeout: Int,</span><br><span class="line">  private val writeTimeout: Int</span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  override fun proceed(request: Request): Response &#123;</span><br><span class="line">    return proceed(request, transmitter, exchange)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 顺序调用方法 </span><br><span class="line">  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response &#123;</span><br><span class="line">    ...</span><br><span class="line">    calls++</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 构造一个 RealInterceptorChain</span><br><span class="line">    val next &#x3D; RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    &#x2F;&#x2F; 根据index 依次取拦截器</span><br><span class="line">    val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 所有拦截器顺序执行，拦截器方法中执行 chain.proceed完成reponse返回，将命令对象交给下一个拦截器进行处理，如果不执行chain.proceed则在该拦截器进行终结。</span><br><span class="line">    val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line">    ...</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>重试拦截器</p>
<h4 id="RetryAndFollowUpInterceptor-intercept"><a href="#RetryAndFollowUpInterceptor-intercept" class="headerlink" title="RetryAndFollowUpInterceptor.intercept"></a>RetryAndFollowUpInterceptor.intercept</h4><ul>
<li>请求连接准备工作</li>
<li>执行chain.proceed顺序执行，获取response</li>
<li>若出现异常，则判断是否需要进行重试机制</li>
<li>根据服务端返回的状态码，进行重定向请求生成</li>
<li>进行重试，直到不需要重试或者成功，最多20次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  var request &#x3D; chain.request()</span><br><span class="line">  val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">  val transmitter &#x3D; realChain.transmitter()</span><br><span class="line">  var followUpCount &#x3D; 0</span><br><span class="line">  var priorResponse: Response? &#x3D; null</span><br><span class="line">  while (true) &#123; &#x2F;&#x2F; 循环</span><br><span class="line">    &#x2F;&#x2F; 发射机 执行连接准备工作</span><br><span class="line">    transmitter.prepareToConnect(request)</span><br><span class="line">  </span><br><span class="line">    if (transmitter.isCanceled) &#123; &#x2F;&#x2F; 处理取消的请求</span><br><span class="line">      throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var response: Response</span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行 proceed顺序执行流程，最终获取response</span><br><span class="line">      response &#x3D; realChain.proceed(request, transmitter, null)</span><br><span class="line">      success &#x3D; true</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      &#x2F;&#x2F; 若不满足重试条件，则抛出异常</span><br><span class="line">      if (!recover(e.lastConnectException, transmitter, false, request)) &#123;</span><br><span class="line">        throw e.firstConnectException</span><br><span class="line">      &#125;</span><br><span class="line">      continue    &#x2F;&#x2F; 满足，则重试</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      &#x2F;&#x2F; 若不满足重试条件，则抛出异常</span><br><span class="line">      val requestSendStarted &#x3D; e !is ConnectionShutdownException</span><br><span class="line">      if (!recover(e, transmitter, requestSendStarted, request)) throw e</span><br><span class="line">      continue    &#x2F;&#x2F; 满足，则重试</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 异常抛出，则success&#x3D;false，执行释放资源</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        transmitter.exchangeDoneDueToException()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (priorResponse !&#x3D; null) &#123; &#x2F;&#x2F; 赋值上一次的response</span><br><span class="line">      response &#x3D; response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">              .body(null)</span><br><span class="line">              .build())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val exchange &#x3D; response.exchange</span><br><span class="line">    val route &#x3D; exchange?.connection()?.route()</span><br><span class="line">    &#x2F;&#x2F; 获取进一步重试的请求</span><br><span class="line">    val followUp &#x3D; followUpRequest(response, route)</span><br><span class="line"></span><br><span class="line">    if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (exchange !&#x3D; null &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">        transmitter.timeoutEarlyExit() &#x2F;&#x2F; 无重试，停止timeout并退出</span><br><span class="line">      &#125;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val followUpBody &#x3D; followUp.body</span><br><span class="line">    &#x2F;&#x2F; 如果期望执行一次，则结束</span><br><span class="line">    if (followUpBody !&#x3D; null &amp;&amp; followUpBody.isOneShot()) &#123; </span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.body?.closeQuietly()</span><br><span class="line">    if (transmitter.hasExchange()) &#123;</span><br><span class="line">      exchange?.detachWithViolence()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 重试不超过20此</span><br><span class="line">    if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 修改下次的请求</span><br><span class="line">    request &#x3D; followUp</span><br><span class="line">    &#x2F;&#x2F; 记录上一次的response</span><br><span class="line">    priorResponse &#x3D; response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RetryAndFollowUpInterceptor-followUpRequest"><a href="#RetryAndFollowUpInterceptor-followUpRequest" class="headerlink" title="RetryAndFollowUpInterceptor.followUpRequest"></a>RetryAndFollowUpInterceptor.followUpRequest</h4><p>主要针对重定向的几个状态码进行特殊里，从Header中取Location字段，构造重定向request</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun followUpRequest(userResponse: Response, route: Route?): Request? &#123;</span><br><span class="line">    val responseCode &#x3D; userResponse.code</span><br><span class="line"></span><br><span class="line">    val method &#x3D; userResponse.request.method</span><br><span class="line">    when (responseCode) &#123;</span><br><span class="line">      HTTP_PROXY_AUTH -&gt; &#123; &#x2F;&#x2F; 407</span><br><span class="line">        val selectedProxy &#x3D; route!!.proxy</span><br><span class="line">        if (selectedProxy.type() !&#x3D; Proxy.Type.HTTP) &#123;</span><br><span class="line">          throw ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 代理身份认证</span><br><span class="line">        return client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 身份认证</span><br><span class="line">      HTTP_UNAUTHORIZED -&gt; return client.authenticator.authenticate(route, userResponse)</span><br><span class="line">      &#x2F;&#x2F; 针对Get、Head请求 执行构建重定向请求</span><br><span class="line">      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -&gt; &#123; &#x2F;&#x2F; 307 、308</span><br><span class="line">        if (method !&#x3D; &quot;GET&quot; &amp;&amp; method !&#x3D; &quot;HEAD&quot;) &#123;</span><br><span class="line">          return null</span><br><span class="line">        &#125;</span><br><span class="line">        return buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 针对300、301、302、303 执行构建重定向请求</span><br><span class="line">      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">        return buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 408 ，说明需要重新发送一次相同的请求</span><br><span class="line">        ... &#x2F;&#x2F; 判断是否有必要重新发送</span><br><span class="line">        return userResponse.request</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAVAILABLE -&gt; &#123; &#x2F;&#x2F; 503</span><br><span class="line">        return null</span><br><span class="line">      &#125;</span><br><span class="line">      else -&gt; return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private fun buildRedirectRequest(userResponse: Response, method: String): Request? &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置不需要执行重定向</span><br><span class="line">    if (!client.followRedirects) return null</span><br><span class="line">    &#x2F;&#x2F; location header 是否支持</span><br><span class="line">    val location &#x3D; userResponse.header(&quot;Location&quot;) ?: return null</span><br><span class="line">    &#x2F;&#x2F; Don&#39;t follow redirects to unsupported protocols.</span><br><span class="line">    val url &#x3D; userResponse.request.url.resolve(location) ?: return null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果不允许SSL和Non-SSL之间的重定向，则返回null</span><br><span class="line">    val sameScheme &#x3D; url.scheme &#x3D;&#x3D; userResponse.request.url.scheme</span><br><span class="line">    if (!sameScheme &amp;&amp; !client.followSslRedirects) return null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Most redirects don&#39;t include a request body.</span><br><span class="line">    val requestBuilder &#x3D; userResponse.request.newBuilder()</span><br><span class="line">    if (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">      val maintainBody &#x3D; HttpMethod.redirectsWithBody(method)</span><br><span class="line">      if (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">        requestBuilder.method(&quot;GET&quot;, null)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val requestBody &#x3D; if (maintainBody) userResponse.request.body else null</span><br><span class="line">        requestBuilder.method(method, requestBody)</span><br><span class="line">      &#125;</span><br><span class="line">      if (!maintainBody) &#123;</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Type&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; When redirecting across hosts, drop all authentication headers. This</span><br><span class="line">    &#x2F;&#x2F; is potentially annoying to the application layer since they have no</span><br><span class="line">    &#x2F;&#x2F; way to retain them.</span><br><span class="line">    if (!userResponse.request.url.canReuseConnectionFor(url)) &#123;</span><br><span class="line">      requestBuilder.removeHeader(&quot;Authorization&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 构建 新的请求</span><br><span class="line">    return requestBuilder.url(url).build()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><blockquote>
<p>Bridges from application code to network code. </p>
</blockquote>
<p>连接应用层和网络层的桥梁</p>
<ul>
<li>主要针对请求Header进行处理，如gzip、cookie及其他Header字段等</li>
<li>响应则进行gzip解压</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val userRequest &#x3D; chain.request()</span><br><span class="line">    val requestBuilder &#x3D; userRequest.newBuilder()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将userRequest中的属性设置到request中</span><br><span class="line">    val body &#x3D; userRequest.body</span><br><span class="line">    if (body !&#x3D; null) &#123;</span><br><span class="line">      val contentType &#x3D; body.contentType()</span><br><span class="line">      if (contentType !&#x3D; null) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      val contentLength &#x3D; body.contentLength()</span><br><span class="line">      if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有设置Accept-Encoding，则自动设置为gzip</span><br><span class="line">    var transparentGzip &#x3D; false</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      transparentGzip &#x3D; true</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将userRequest中的cookie解析出来并设置到Request中的Cookie字段中</span><br><span class="line">    val cookies &#x3D; cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    if (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置 User-Agent</span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 顺序执行处理方法</span><br><span class="line">    val networkResponse &#x3D; chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理响应的headers，并缓存cookie</span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    val responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line">    &#x2F;&#x2F; 设置了Gzip，且响应结果支持gzip，则进行Gzip解析</span><br><span class="line">    if (transparentGzip &amp;&amp;</span><br><span class="line">        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase &#x3D; true) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">        </span><br><span class="line">      val responseBody &#x3D; networkResponse.body</span><br><span class="line">      if (responseBody !&#x3D; null) &#123;</span><br><span class="line">        val gzipSource &#x3D; GzipSource(responseBody.source())</span><br><span class="line">        val strippedHeaders &#x3D; networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">            .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        val contentType &#x3D; networkResponse.header(&quot;Content-Type&quot;)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Returns a &#39;Cookie&#39; HTTP request header with all cookies, like &#96;a&#x3D;b; c&#x3D;d&#96;. *&#x2F;</span><br><span class="line">  private fun cookieHeader(cookies: List&lt;Cookie&gt;): String &#x3D; buildString &#123;</span><br><span class="line">    cookies.forEachIndexed &#123; index, cookie -&gt;</span><br><span class="line">      if (index &gt; 0) append(&quot;; &quot;)</span><br><span class="line">      append(cookie.name).append(&#39;&#x3D;&#39;).append(cookie.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/2eafcd161dd9" target="_blank" rel="noopener">下一篇 OkHttp 4源码（3）— 缓存机制分析</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp 4源码（1）—OkHttp初始化和请求构造分析 </title>
    <url>/blog/2020/01/11/OkHttp%204%E6%BA%90%E7%A0%81%EF%BC%881%EF%BC%89%E2%80%94OkHttp%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%9E%84%E9%80%A0%E5%88%86%E6%9E%90%20/</url>
    <content><![CDATA[<blockquote>
<p>本文基于OkHttp 4.3.1源码分析<br><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp - 官方地址</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp - GitHub代码地址</a></p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>本篇主要从OkHttp的两个请求示例开始，对Okhttp的初始化工作，和请求从构造、分发到执行的流程进行源码分析介绍</p>
<p>OkHttp整体流程（本文覆盖红色部分）</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884355438056.png"  alt=""></p>
<p>本文覆盖代码流程图<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884355537016.png"  alt=""></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用OkHttp一般流程，初始化一个共享OkHttpClient，构建Request，然后OkHttpClient根据Request构建Call，接着执行call，最后进行Response处理</p>
<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GetExample &#123;</span><br><span class="line">  OkHttpClient client &#x3D; new OkHttpClient(); &#x2F;&#x2F; 构建共享的Client</span><br><span class="line"></span><br><span class="line">  String run(String url) throws IOException &#123;</span><br><span class="line">    Request request &#x3D; new Request.Builder() &#x2F;&#x2F; 构建request</span><br><span class="line">        .url(url)</span><br><span class="line">        .build();</span><br><span class="line">    &#x2F;&#x2F; 构建Call，执行</span><br><span class="line">    try (Response response &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">      return response.body().string();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    GetExample example &#x3D; new GetExample();</span><br><span class="line">    String response &#x3D; example.run(&quot;https:&#x2F;&#x2F;raw.github.com&#x2F;square&#x2F;okhttp&#x2F;master&#x2F;README.md&quot;);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class AsynchronousGet &#123;</span><br><span class="line">  private final OkHttpClient client &#x3D; new OkHttpClient();&#x2F;&#x2F; 构建共享Client</span><br><span class="line"></span><br><span class="line">  public void run() throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 构建Request</span><br><span class="line">    Request request &#x3D; new Request.Builder()</span><br><span class="line">        .url(&quot;http:&#x2F;&#x2F;publicobject.com&#x2F;helloworld.txt&quot;)</span><br><span class="line">        .build();</span><br><span class="line">    &#x2F;&#x2F; 构建Call，执行，回调接受处理</span><br><span class="line">    client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">      @Override public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">        try (ResponseBody responseBody &#x3D; response.body()) &#123;</span><br><span class="line">          if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class="line"></span><br><span class="line">          Headers responseHeaders &#x3D; response.headers();</span><br><span class="line">          for (int i &#x3D; 0, size &#x3D; responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(responseBody.string());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) throws Exception &#123;</span><br><span class="line">    new AsynchronousGet().run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构建OkHttpClient"><a href="#构建OkHttpClient" class="headerlink" title="构建OkHttpClient"></a>构建OkHttpClient</h3><ul>
<li>OkHttpClient是Call的一个工厂类，OkHttpClient应该是共享的，或者说是单例</li>
<li>可以通过newBuilder来自定义Client</li>
<li>没有必要关心 关闭和资源释放</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Factory for [calls][Call], which can be used to send HTTP requests and read their responses.</span><br><span class="line"> * ## OkHttpClients Should Be Shared</span><br><span class="line"> * ## Customize Your Client With newBuilder()</span><br><span class="line"> * ## Shutdown Isn&#39;t Necessary</span><br><span class="line"> * &#x2F;</span><br><span class="line">open class OkHttpClient internal constructor(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">    &#x2F;&#x2F; 3. 成员变量初始化</span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1. 内部无参数构造函数</span><br><span class="line">    constructor() : this(Builder())</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 4. OkHttpClient函数初始化 </span><br><span class="line">    init &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化证书和拦截器等判断逻辑</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2. Builder构造函数</span><br><span class="line">    class Builder constructor() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="OkHttpClient-Builder"><a href="#OkHttpClient-Builder" class="headerlink" title="OkHttpClient.Builder"></a>OkHttpClient.Builder</h4><p>Builder模式，提供自定义配置化能力，同时有一份无需关心的默认配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Builder constructor() &#123;</span><br><span class="line">      internal var dispatcher: Dispatcher &#x3D; Dispatcher()</span><br><span class="line">      internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()</span><br><span class="line">      internal val interceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()</span><br><span class="line">      internal val networkInterceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()</span><br><span class="line">      internal var eventListenerFactory: EventListener.Factory &#x3D; EventListener.NONE.asFactory()</span><br><span class="line">      internal var retryOnConnectionFailure &#x3D; true</span><br><span class="line">      internal var authenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">      internal var followRedirects &#x3D; true</span><br><span class="line">      internal var followSslRedirects &#x3D; true</span><br><span class="line">      internal var cookieJar: CookieJar &#x3D; CookieJar.NO_COOKIES</span><br><span class="line">      internal var cache: Cache? &#x3D; null</span><br><span class="line">      internal var dns: Dns &#x3D; Dns.SYSTEM</span><br><span class="line">      internal var proxy: Proxy? &#x3D; null</span><br><span class="line">      internal var proxySelector: ProxySelector? &#x3D; null</span><br><span class="line">      internal var proxyAuthenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">      internal var socketFactory: SocketFactory &#x3D; SocketFactory.getDefault()</span><br><span class="line">      internal var sslSocketFactoryOrNull: SSLSocketFactory? &#x3D; null</span><br><span class="line">      internal var x509TrustManagerOrNull: X509TrustManager? &#x3D; null</span><br><span class="line">      internal var connectionSpecs: List&lt;ConnectionSpec&gt; &#x3D; DEFAULT_CONNECTION_SPECS</span><br><span class="line">      internal var protocols: List&lt;Protocol&gt; &#x3D; DEFAULT_PROTOCOLS</span><br><span class="line">      internal var hostnameVerifier: HostnameVerifier &#x3D; OkHostnameVerifier</span><br><span class="line">      internal var certificatePinner: CertificatePinner &#x3D; CertificatePinner.DEFAULT</span><br><span class="line">      internal var certificateChainCleaner: CertificateChainCleaner? &#x3D; null</span><br><span class="line">      internal var callTimeout &#x3D; 0</span><br><span class="line">      internal var connectTimeout &#x3D; 10_000</span><br><span class="line">      internal var readTimeout &#x3D; 10_000</span><br><span class="line">      internal var writeTimeout &#x3D; 10_000</span><br><span class="line">      internal var pingInterval &#x3D; 0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="OkHttpClient成员变量初始化"><a href="#OkHttpClient成员变量初始化" class="headerlink" title="OkHttpClient成员变量初始化"></a>OkHttpClient成员变量初始化</h4><ul>
<li>初始化成员变量</li>
<li>JvmName是为了支持兼容3.x</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@get:JvmName(&quot;dispatcher&quot;) val dispatcher: Dispatcher &#x3D; builder.dispatcher</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;connectionPool&quot;) val connectionPool: ConnectionPool &#x3D; builder.connectionPool</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;interceptors&quot;) val interceptors: List&lt;Interceptor&gt; &#x3D;</span><br><span class="line">    builder.interceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;networkInterceptors&quot;) val networkInterceptors: List&lt;Interceptor&gt; &#x3D;</span><br><span class="line">    builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;eventListenerFactory&quot;) val eventListenerFactory: EventListener.Factory &#x3D;</span><br><span class="line">    builder.eventListenerFactory</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;retryOnConnectionFailure&quot;) val retryOnConnectionFailure: Boolean &#x3D;</span><br><span class="line">    builder.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;cookieJar&quot;) val cookieJar: CookieJar &#x3D; builder.cookieJar</span><br><span class="line"></span><br><span class="line">@get:JvmName(&quot;cache&quot;) val cache: Cache? &#x3D; builder.cache</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h3 id="构建Request"><a href="#构建Request" class="headerlink" title="构建Request"></a>构建Request</h3><p>Request 对应HTTP请求中的Request，OkHttp依旧是Builder构建模式构建Request</p>
<h4 id="Request-Builder"><a href="#Request-Builder" class="headerlink" title="Request.Builder"></a>Request.Builder</h4><p>支持url、method、headers、body的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> open class Builder &#123;</span><br><span class="line">    internal var url: HttpUrl? &#x3D; null </span><br><span class="line">    internal var method: String</span><br><span class="line">    internal var headers: Headers.Builder</span><br><span class="line">    internal var body: RequestBody? &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 构造Request</span><br><span class="line">    open fun build(): Request &#123;</span><br><span class="line">      return Request(</span><br><span class="line">          checkNotNull(url) &#123; &quot;url &#x3D;&#x3D; null&quot; &#125;,</span><br><span class="line">          method,</span><br><span class="line">          headers.build(),</span><br><span class="line">          body,</span><br><span class="line">          tags.toImmutableMap()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>通过Request.Builder构造Request实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Request internal constructor(</span><br><span class="line">  @get:JvmName(&quot;url&quot;) val url: HttpUrl,</span><br><span class="line">  @get:JvmName(&quot;method&quot;) val method: String,</span><br><span class="line">  @get:JvmName(&quot;headers&quot;) val headers: Headers,</span><br><span class="line">  @get:JvmName(&quot;body&quot;) val body: RequestBody?,</span><br><span class="line">  internal val tags: Map&lt;Class&lt;*&gt;, Any&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建Call"><a href="#构建Call" class="headerlink" title="构建Call"></a>构建Call</h3><h4 id="OkHttpClient-newCall"><a href="#OkHttpClient-newCall" class="headerlink" title="OkHttpClient.newCall"></a>OkHttpClient.newCall</h4><p>OkHttpClient 实现了Call.Factory，作为Call的构造工厂类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun newCall(request: Request): Call &#123;</span><br><span class="line">  &#x2F;&#x2F; 执行 RealCall的构造call方法</span><br><span class="line">  return RealCall.newRealCall(this, request, forWebSocket &#x3D; false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealCall-newRealCall"><a href="#RealCall-newRealCall" class="headerlink" title="RealCall.newRealCall"></a>RealCall.newRealCall</h4><p>构造Call真正方法，另外创建了一个 发射器，接下来先了解下Call</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">    fun newRealCall(</span><br><span class="line">      client: OkHttpClient,</span><br><span class="line">      originalRequest: Request,</span><br><span class="line">      forWebSocket: Boolean</span><br><span class="line">    ): RealCall &#123;</span><br><span class="line">      </span><br><span class="line">      return RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">       &#x2F;&#x2F; 构造了一个 发射器，它是应用层和网络层交互的桥梁，后面会着重介绍</span><br><span class="line">        transmitter &#x3D; Transmitter(client, this) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h4><p>Call定义为一个准备好执行的请求，它是能被取消的，且它只能被执行一次（http请求也是一次执行）<br><strong>包括一个核心成员变量 Transmitter ，两个重要方法 execute（同步） 和 enqueue（异步）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">internal class RealCall private constructor(</span><br><span class="line">  val client: OkHttpClient,</span><br><span class="line">  &#x2F;** The application&#39;s original request unadulterated by redirects or auth headers. *&#x2F;</span><br><span class="line">  val originalRequest: Request,</span><br><span class="line">  val forWebSocket: Boolean</span><br><span class="line">) : Call &#123;</span><br><span class="line"> &#x2F;&#x2F; 发射机</span><br><span class="line"> private lateinit var transmitter: Transmitter</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 同步请求执行方法</span><br><span class="line"> override fun execute(): Response &#123;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">  &#x2F;&#x2F; 异步请求执行方法 </span><br><span class="line">  override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 取消请求</span><br><span class="line">  override fun cancel() &#123;</span><br><span class="line">    transmitter.cancel()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步请求-1"><a href="#同步请求-1" class="headerlink" title="同步请求"></a>同步请求</h3><h4 id="RealCall-execute"><a href="#RealCall-execute" class="headerlink" title="RealCall.execute"></a>RealCall.execute</h4><ul>
<li>请求前校验逻辑，仅能执行一次，和过期时间逻辑判断逻辑</li>
<li>通知请求start事件，便于metrics 指标数据收集</li>
<li>将call加入分发器的同步请求队列中</li>
<li>通过拦截器责任链模式进行请求和返回一系列逻辑处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun execute(): Response &#123;</span><br><span class="line">  &#x2F;&#x2F; 检查是否已经执行</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 过期时间逻辑，如果配置了会有WatchDog线程进行Watch然后执行退出逻辑</span><br><span class="line">  transmitter.timeoutEnter()</span><br><span class="line">  &#x2F;&#x2F; 通知start，最后会通过 EventListener 发出时间，主要目的是收集 metrics events</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用client的dispatcher分发器执行call（将call加入同步call队列）</span><br><span class="line">    client.dispatcher.executed(this)</span><br><span class="line">    &#x2F;&#x2F; 通过拦截器责任链模式进行请求和返回处理等一系类逻辑</span><br><span class="line">    return getResponseWithInterceptorChain()</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    client.dispatcher.finished(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealCall-getResponseWithInterceptorChain"><a href="#RealCall-getResponseWithInterceptorChain" class="headerlink" title="RealCall.getResponseWithInterceptorChain"></a>RealCall.getResponseWithInterceptorChain</h4><ul>
<li>配置拦截器，所有请求和响应处理逻辑解耦到各个拦截器负责模块</li>
<li>构造拦截器链式调用处理类RealInterceptorChain实例</li>
<li>chain.proceed 进行拦截器的链式调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">  &#x2F;&#x2F; 构建所有的拦截器</span><br><span class="line">  val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  interceptors +&#x3D; client.interceptors &#x2F;&#x2F; client配置的拦截器</span><br><span class="line">  interceptors +&#x3D; RetryAndFollowUpInterceptor(client) &#x2F;&#x2F; 重试机制拦截器</span><br><span class="line">  interceptors +&#x3D; BridgeInterceptor(client.cookieJar) &#x2F;&#x2F; 请求和返回桥（http信息配置和解析）拦截器</span><br><span class="line">  interceptors +&#x3D; CacheInterceptor(client.cache) &#x2F;&#x2F; 缓存拦截</span><br><span class="line">  interceptors +&#x3D; ConnectInterceptor &#x2F;&#x2F; 连接拦截器</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors +&#x3D; CallServerInterceptor(forWebSocket)  &#x2F;&#x2F; 执行拦截器</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 拦截器核心处理类 </span><br><span class="line">  val chain &#x3D; RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,</span><br><span class="line">      client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">  var calledNoMoreExchanges &#x3D; false</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 链式调用</span><br><span class="line">    val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">    if (transmitter.isCanceled) &#123; &#x2F;&#x2F; 处理取消</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response &#x2F;&#x2F;返回请求结果</span><br><span class="line">  &#125; catch (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges &#x3D; true</span><br><span class="line">    throw transmitter.noMoreExchanges(e) as Throwable</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(null)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h3><h4 id="RealCall-enqueue"><a href="#RealCall-enqueue" class="headerlink" title="RealCall.enqueue"></a>RealCall.enqueue</h4><ul>
<li>构造一个异步call</li>
<li>调用dispatcher 入队AsyncCall</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">  synchronized(this) &#123; </span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  &#x2F;&#x2F; 构造 AsyncCall ，接着分发器入队操作</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatcher-分发器队Call进行分发执行"><a href="#Dispatcher-分发器队Call进行分发执行" class="headerlink" title="Dispatcher 分发器队Call进行分发执行"></a>Dispatcher 分发器队Call进行分发执行</h4><p><a href="https://www.jianshu.com/p/d9e46d5a4af9" target="_blank" rel="noopener">参考：线程池理解</a></p>
<ul>
<li>初始化时，构造分发器的线程池，及对应执行参数</li>
<li>主要管理异步请求的处理（异步Call入队、并发执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dispatcher constructor() &#123;</span><br><span class="line">  &#x2F;&#x2F; 默认最大请求数 64</span><br><span class="line">  @get:Synchronized var maxRequests &#x3D; 64</span><br><span class="line">  &#x2F;&#x2F; 默认最大并发Host 5</span><br><span class="line">  @get:Synchronized var maxRequestsPerHost &#x3D; 5</span><br><span class="line">  &#x2F;&#x2F; 线程池执行器 默认创建可缓存线程池 </span><br><span class="line">  @get:JvmName(&quot;executorService&quot;) val executorService: ExecutorService</span><br><span class="line">    get() &#123;</span><br><span class="line">      if (executorServiceOrNull &#x3D;&#x3D; null) &#123;</span><br><span class="line">        executorServiceOrNull &#x3D; ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">            SynchronousQueue(), threadFactory(&quot;OkHttp Dispatcher&quot;, false))</span><br><span class="line">      &#125;</span><br><span class="line">      return executorServiceOrNull!!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#x2F;** 准备好的异步Call对列 *&#x2F;</span><br><span class="line">  private val readyAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 执行中异步call对列 *&#x2F;</span><br><span class="line">  private val runningAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 同步call对列 *&#x2F;</span><br><span class="line">  private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 异步Call 入队操作  </span><br><span class="line">  internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line">      &#x2F;&#x2F; same host情况下的复用逻辑处理</span><br><span class="line">      if (!call.get().forWebSocket) &#123;</span><br><span class="line">        val existingCall &#x3D; findExistingCallWithHost(call.host())</span><br><span class="line">        if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute() &#x2F;&#x2F; 准备线程池执行器，及执行</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行Call</span><br><span class="line">private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line">    this.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    val isRunning: Boolean</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      &#x2F;&#x2F; 遍历所有的ready 异步 call</span><br><span class="line">      val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">      while (i.hasNext()) &#123;</span><br><span class="line">        val asyncCall &#x3D; i.next()</span><br><span class="line"></span><br><span class="line">        if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.</span><br><span class="line">        if (asyncCall.callsPerHost().get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity.</span><br><span class="line"></span><br><span class="line">        i.remove()</span><br><span class="line">        asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">        executableCalls.add(asyncCall) &#x2F;&#x2F; 加入此次执行队列缓存</span><br><span class="line">        runningAsyncCalls.add(asyncCall) &#x2F;&#x2F; 加入正在执行队列</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">      val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">      asyncCall.executeOn(executorService) &#x2F;&#x2F; 将线程执行器传入call，在Call中进行执行</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isRunning</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;** 同步call，添加到队列 *&#x2F;</span><br><span class="line">  @Synchronized internal fun executed(call: RealCall) &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AsyncCall执行"><a href="#AsyncCall执行" class="headerlink" title="AsyncCall执行"></a>AsyncCall执行</h4><ul>
<li>executeOn ，线程池执行器执行Runnable</li>
<li>run，通过拦截器进行请求和获取响应结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line">    </span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池 执行器执行</span><br><span class="line">        executorService.execute(this)</span><br><span class="line">        success &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 执行方法</span><br><span class="line">override fun run() &#123;</span><br><span class="line">    threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">        var signalledCallback &#x3D; false</span><br><span class="line">        transmitter.timeoutEnter()</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 同“同步请求” 最终执行拦截器链式调用</span><br><span class="line">            val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">            signalledCallback &#x3D; true</span><br><span class="line">            &#x2F;&#x2F; 响应 回调</span><br><span class="line">            responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">        &#125; catch (e: IOException) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            client.dispatcher.finished(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://www.jianshu.com/p/0c830962c6e3" target="_blank" rel="noopener">下一篇 OkHttp 4源码（2）— 拦截器机制分析</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>目标管理-SMART原则</title>
    <url>/blog/2020/01/10/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86-SMART%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="一图以蔽之"><a href="#一图以蔽之" class="headerlink" title="一图以蔽之"></a>一图以蔽之</h2><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884355625226.png"  alt=""></p>
<h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul>
<li>提出者：彼得·德鲁克</li>
<li>出处：《管理的实践》</li>
<li>时间：1954年</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>促使工作更明确、更高效</li>
<li>提供了考核目标和考核标准</li>
<li>保证了考核公正、公开与公平</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>重视人的因素。<br>目标管理是一种参与的、民主的、自我控制的管理制度，也是一种把个人需求与组织目标结合起来的管理制度。在这一制度下，上级与下级的关系是平等、尊重、依赖、支持，下级在承诺目标和被授权之后是自觉、自主和自治的。</p>
</li>
<li><p>建立目标锁链与目标体系。<br>目标管理通过专门设计的过程，将组织的整体目标逐级分解，转换为各单位、各员工的分目标。从组织目标到经营单位目标，再到部门目标，最后到个人目标。在目标分解过程中，权、责、利三者已经明确，而且相互对称。这些目标方向一致，环环相扣，相互配合，形成协调统一的目标体系。只有每个人员完成了自己的分目标，整个企业的总目标才有完成的希望。</p>
</li>
<li><p>重视成果<br>目标管理以制定目标为起点，以目标完成情况的考核为终结。工作成果是评定目标完成程度的标准，也是人事考核和奖评的依据，成为评价管理工作绩效的唯一标志。至于完成目标的具体过程、途径和方法，上级并不过多干预。所以，在目标管理制度下，监督的成分很少，而控制目标实现的能力却很强。<br>“目标管理”的概念是管理专家彼得·德鲁克（Peter·Drucker）1954年在其名著《管理实践》中最先提出的，其后他又提出“目标管理和自我控制”的主张。德鲁克认为，并不是有了工作才有目标，而是相反，有了目标才能确定每个人的工作。所以“企业的使命和任务，必须转化为目标”，如果一个领域没有目标，这个领域的工作必然被忽视。因此管理者应该通过目标对下级进行管理，当组织最高层管理者确定了组织目标后，必须对其进行有效分解，转变成各个部门以及各个人的分目标，管理者根据分目标的完成情况对下级进行考核、评价和奖惩。</p>
</li>
</ul>
<h2 id="原则详解"><a href="#原则详解" class="headerlink" title="原则详解"></a>原则详解</h2><h3 id="1-Specific—明确性"><a href="#1-Specific—明确性" class="headerlink" title="1. Specific—明确性"></a>1. Specific—明确性</h3><p>所谓明确就是要用具体的语言清楚地说明要达成的行为标准。明确的目标几乎是所有成功团队的一致特点。很多团队不成功的重要原因之一就因为目标定的模棱两可，或没有将目标有效的传达给相关成员。</p>
<p><strong>示例</strong><br>目标——“增强客户意识”。这种对目标的描述就很不明确，因为增强客户意识有许多具体做法，如：减少客户投诉，过去客户投诉率是３％，现在把它减低到１．５％或者１％。提升服务的速度，使用规范礼貌的用语，采用规范的服务流程，也是增强客户意识的一个方面。</p>
<p>有这么多增强客户意识的做法，我们所说的“增强客户意识”到底指哪一块？不明确就没有办法评判、衡量。所以建议这样修改，比方说，我们将在月底前把前台收银的速度提升至正常的标准，这个正常的标准可能是两分钟，也可能是一分钟，或分时段来确定标准。</p>
<p><strong>实施要求</strong><br>目标设置要有项目、衡量标准、达成措施、完成期限以及资源要求，使考核人能够很清晰的看到部门或科室月计划要做哪些那些事情，计划完成到什么样的程度。
　　</p>
<h3 id="2-Measurable—衡量性"><a href="#2-Measurable—衡量性" class="headerlink" title="2. Measurable—衡量性"></a>2. Measurable—衡量性</h3><p>衡量性就是指目标应该是明确的，而不是模糊的。应该有一组明确的数据，作为衡量是否达成目标的依据。</p>
<p>如果制定的目标没有办法衡量，就无法判断这个目标是否实现。比如领导有一天问“这个目标离实现大概有多远？”团队成员的回答是“我们早实现了”。这就是领导和下属对团队目标所产生的一种分歧。原因就在于没有给他一个定量的可以衡量的分析数据。但并不是所有的目标可以衡量，有时也会有例外，比如说大方向性质的目标就难以衡量。</p>
<p>比方说，“为所有的老员工安排进一步的管理培训”。进一步是一个既不明确也不容易衡量的概念，到底指什么？是不是只要安排了这个培训，不管谁讲，也不管效果好坏都叫“进一步”？</p>
<p>改进一下：准确地说，在什么时间完成对所有老员工关于某个主题的培训，并且在这个课程结束后，学员的评分在８５分以上，低于８５分就认为效果不理想，高于８５分就是所期待的结果。这样目标变得可以</p>
<p><strong>实施要求</strong><br>目标的衡量标准遵循“能量化的量化，不能量化的质化”。使制定人与考核人有一个统一的、标准的、清晰的可度量的标尺，杜绝在目标设置中使用形容词等概念模糊、无法衡量的描述。对于目标的可衡量性应该首先从数量、质量、成本、时间、上级或客户的满意程度五个方面来进行，如果仍不能进行衡量，其次可考虑将目标细化，细化成分目标后再从以上五个方面衡量，如果仍不能衡量，还可以将完成目标的工作进行流程化，通过流程化使目标可衡量。</p>
<h3 id="3-Attainable—可实现性"><a href="#3-Attainable—可实现性" class="headerlink" title="3. Attainable—可实现性"></a>3. Attainable—可实现性</h3><p>目标是要可以让执行人实现、达到的，如果上司利用一些行政手段，利用权利性的影响力一厢情愿地把自己所制定的目标强压给下属，下属典型的反映是一种心理和行为上的抗拒：我可以接受，但是否完成这个目标，有没有最终的把握，这个可不好说。一旦有一天这个目标真完成不了的时候，下属有一百个理由可以推卸责任：你看我早就说了，这个目标肯定完成不了，但你坚持要压给我。</p>
<p>“控制式”的领导喜欢自己定目标，然后交给下属去完成，他们不在乎下属的意见和反映，这种做法越来越没有市场。今天员工的知识层次、学历、自己本身的素质，以及他们主张的个性张扬的程度都远远超出从前。因此，领导者应该更多的吸纳下属来参与目标制定的过程，即便是团队整体的</p>
<p>定目标成长，就先不要想达成的困难，不然热情还没点燃就先被畏惧给打消念头了。</p>
<p><strong>实施要求</strong><br>目标设置要坚持员工参与、上下左右沟通，使拟定的工作目标在组织及个人之间达成一致。既要使工作内容饱满，也要具有可达性。可以制定出跳起来“摘桃”的目标，不能制定出跳起来“摘星星”的目标。</p>
<h3 id="4-Relevant—相关性"><a href="#4-Relevant—相关性" class="headerlink" title="4. Relevant—相关性"></a>4. Relevant—相关性</h3><p>目标的相关性是指实现此目标与其他目标的关联情况。如果实现了这个目标，但对其他的目标完全不相关，或者相关度很低，那这个目标即使被达到了，意义也不是很大。</p>
<p>因为毕竟工作目标的设定，是要和岗位职责相关联的，不能跑题。比如一个前台，你让她学点英语以便接电话的时候用得上，这时候提升英语水平和前台接电话的服务质量有关联，即学英语这一目标与提高前台工作水准这一目标直接相关。若你让她去学习6sigma，就比较跑题了，因为前台学习6sigma这一目标与提高前台工作水准这一目标相关度很低。</p>
<h3 id="5-Time-bound—时限性"><a href="#5-Time-bound—时限性" class="headerlink" title="5. Time-bound—时限性"></a>5. Time-bound—时限性</h3><p>目标特性的时限性就是指目标是有时间限制的。例如，我将在2020年5月31日之前完成某事。5月31日就是一个确定的时间限制。没有时间限制的目标没有办法考核，或带来考核的不公。上下级之间对目标轻重缓急的认识程度不同，上司着急，但下面不知道。到头来上司可以暴跳如雷，而下属觉得委屈。这种没有明确的时间限定的方式也会带来考核的不公正，伤害工作关系，伤害下属的工作热情。</p>
<p><strong>实施要求</strong><br>目标设置要具有时间限制，根据工作任务的权重、事情的轻重缓急，拟定出完成目标项目的时间要求，定期检查项目的完成进度，及时掌握项目进展的变化情况，以方便对下属进行及时的工作指导，以及根据工作计划的异常情况变化及时地调整工作计划。</p>
<h2 id="相关变体"><a href="#相关变体" class="headerlink" title="相关变体"></a>相关变体</h2><p><strong>SMART（ER）</strong>所对应的单词在不同场合并不一致、有各种变体，下表就列出了一些变体：</p>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><p>Specific（明确）<br>Significant（重要）, Stretching（延伸）, Simple（简易）</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>Measurable（可衡量）<br>Meaningful（有意义）, Motivational（激励）, Manageable（可管理）</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>Attainable（可达成）<br>Appropriate（适宜）, Achievable（可达成）, Agreed（同意）, Assignable（可分配）, Actionable（可行动）, Action-oriented（行动导向）, Ambitious（雄心）</p>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>Relevant（相关）<br>Realistic（实际）, Results/Results-focused/Results-oriented, Resourced（资源）, Rewarding（奖励）</p>
<h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>Time-bound（时限）<br>Time-oriented（时限）, Time framed（时限）, Timed（时限）, Time-based（基于时间）, Timeboxed（时限）, Timely（及时）, Time-Specific（明确时间）, Timetabled（时效）, Time limited（时限）, Trackable（可跟踪）, Tangible（明白）</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>Evaluate（评估）<br>Excitable（兴奋）, Ethical（伦理）</p>
<h3 id="R-1"><a href="#R-1" class="headerlink" title="R"></a>R</h3><p>Reevaluate（再评估）<br>Rewarded（奖励）, Reassess（再评估）, Revisit（再访）, Recorded（记录）</p>
<hr>
<p>参考：<a href="https://wiki.mbalib.com/wiki/SMART%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">SMART原则</a></p>
]]></content>
      <categories>
        <category>方法论</category>
        <category>思维模型</category>
      </categories>
      <tags>
        <tag>目标管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《金字塔原理》学习总结</title>
    <url>/blog/2019/12/30/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>请问你工作过程中是否经常遇到？</p>
<ul>
<li>工作回报，Boss摇头又叹气：“请说重点！！！”</li>
<li>晋升答辩，评委们认为：“体现不出价值…”</li>
<li>分享沟通，听众表示：“一脸懵逼？？？”</li>
</ul>
<p><strong>世界上最遥远的距离，不是我没有说，而是我说了你却不明白</strong></p>
<p>坏消息：几乎大部分会同学命中上面的问题<br>好消息：《金字塔原理》这本书可以带给你一系列方法来解决上述问题</p>
<h2 id="为什么使用金字塔原理"><a href="#为什么使用金字塔原理" class="headerlink" title="为什么使用金字塔原理"></a>为什么使用金字塔原理</h2><p><strong>常见的偏见</strong></p>
<ul>
<li>我写不出“好”的文章，是因为我的文笔不够</li>
<li>我画不出“好”的架构图，是因为我没有找到好的软件，或者我不会很好地应用这个软件</li>
<li>我写不出“好”的ppt，是因为我的ppt模版不行</li>
<li>我读完这本书，全忘了，是因为这本书写的不好或者我记性不好</li>
</ul>
<p><strong>核心问题</strong></p>
<p>我们在写文章，或写PPT时，我们自己没有非常清晰的思路，没有梳理清楚自己的表达逻辑。我们表达思想时采用的逻辑顺序和读者的理解力发生了矛盾，我们的表达结构不是读者容易理解的结构。</p>
<p><strong>核心诉求</strong></p>
<ul>
<li>读者：一目了然（Don’t Make Me Think）</li>
<li>作者：想清楚（思考），说明白（表达）</li>
</ul>
<p><strong>金字塔原理能带给你的</strong></p>
<p>人类思维特征：大脑自动将信息归类分组，以便于理解和记忆。如果你所表达的内容结构，思路呈金字塔结构，由顶部开始逐渐向下展开，这样的思路不仅让自己，也让读者会更清晰，更易懂。</p>
<p>金字塔原理可以让你的输出</p>
<ul>
<li><strong>重点突出</strong>（避免啰嗦）：人通常都是没有耐心的，对未知也是有恐惧的。所以你的表达和文章一开始就得让对方知道你讲的到底是什么</li>
<li><strong>逻辑清晰</strong>（增加可读性）：能够看到明显因果关系和逻辑顺序，如时间顺序、空间顺序、程度顺序等</li>
<li><strong>主次分明</strong>（强化逻辑）：分清楚主要和次要，先主要后次要</li>
<li><strong>规范动作</strong>（减少耗时时间）：使用标准动作健身和使用非标准动作健身，花同样的时间，两者呈现的结果可能是千差万别；金字塔原理也是写作、思考、表达的规范性动作，在前期训练的过程，你会感觉很不舒适，但是一旦动作成型，那么你的写作、思考、表达的记忆性肌肉就炼成了，后期将会释放出力量。</li>
</ul>
<p><strong>图例</strong><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884356429749.jpg"  alt=""></p>
<h2 id="什么是金字塔原理"><a href="#什么是金字塔原理" class="headerlink" title="什么是金字塔原理"></a>什么是金字塔原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>金字塔原理是一种结构化思考、表达和解决问题的艺术</p>
<h3 id="金字塔原理的234"><a href="#金字塔原理的234" class="headerlink" title="金字塔原理的234"></a>金字塔原理的234</h3><h4 id="2个目标"><a href="#2个目标" class="headerlink" title="2个目标"></a>2个目标</h4><ul>
<li>想清楚：自下而上思考，总结概括</li>
<li>说明白：自上而下表达，结论先行</li>
</ul>
<h4 id="3种结构"><a href="#3种结构" class="headerlink" title="3种结构"></a>3种结构</h4><ol>
<li>序言：SCQA 抛出问题，吸引阅读</li>
<li>纵向：（问题-&gt;回答，论点-&gt;论据）文章中任意层次上的思想必须是其下一层思想的概括</li>
<li>横向：每组中的思想必须属于同一逻辑范畴且按逻辑顺序组织</li>
</ol>
<h4 id="4项原则"><a href="#4项原则" class="headerlink" title="4项原则"></a>4项原则</h4><ol>
<li>结论先行：每篇文章只有一个中心思想，并放在文章的最前面</li>
<li>以上统下：每一层次上的思想必须是对下一层次思想的总结</li>
<li>归类分组：每一组中的思想必须属于同一逻辑</li>
<li>逻辑递进：每一组中的思想必须按照逻辑顺序排列</li>
</ol>
<h2 id="怎么构建金字塔结构"><a href="#怎么构建金字塔结构" class="headerlink" title="怎么构建金字塔结构"></a>怎么构建金字塔结构</h2><p>主要在于如何熟练运用，对于一个事情，如何提炼中心点，层层剥离，分清主次，需要不断的思考与刻意练习。</p>
<h3 id="4大金句"><a href="#4大金句" class="headerlink" title="4大金句"></a>4大金句</h3><ul>
<li>自上而下表达，结论先行；</li>
<li>自下而上思考，总结概括；</li>
<li>纵向总结概括，横向归类分组；</li>
<li>序言讲故事，标题提炼思想精华；</li>
</ul>
<h3 id="自上而下法"><a href="#自上而下法" class="headerlink" title="自上而下法"></a>自上而下法</h3><p>确定主题、回答主要疑问，想好序言，提出中心思想和关键句要点，在关键句要点下展开讨论</p>
<ol>
<li>提出主题思想</li>
<li>设想主要疑问：想清楚要解决谁的什么问题</li>
<li>写序言：背景-冲突-疑问-回答。背景是问题产生的前提条件，冲突是背景中发生了哪些能使读者产生疑问的“冲突”，疑问是我们要解决的问题，回答就是主题思想。</li>
<li>进行疑问、回答式对话。从上一层思想到下一层思想。</li>
<li>对受众的新疑问，重复进行疑问/回答式对话。思想慢慢开展，层级慢慢丰富。</li>
</ol>
<h3 id="自下而上法"><a href="#自下而上法" class="headerlink" title="自下而上法"></a>自下而上法</h3><p>如果没有确定的主题思想，可以从关键句层次下手，自下而上的组织思想</p>
<ol>
<li>列出想表达的所有思想要点</li>
<li>找出各要点之间的逻辑关系</li>
<li>概括各组思想，得出结论</li>
<li>倒推出序言</li>
</ol>
<h3 id="序言结构"><a href="#序言结构" class="headerlink" title="序言结构"></a>序言结构</h3><p><strong>概念</strong>：交代故事发生的背景、环境，提出问题；根据已知信息，与后续将要回答问题间建立起某种关联</p>
<p><strong>作用</strong>：引起受众的兴趣</p>
<p><strong>关键</strong>：准确的界定问题</p>
<p><strong>SCQA序言设计方法</strong><br>S（情景）：介绍背景<br>C（冲突）：指出冲突<br>Q（疑问）：引发疑问<br>A（回答）：给出答案</p>
<h3 id="纵向结构"><a href="#纵向结构" class="headerlink" title="纵向结构"></a>纵向结构</h3><p>“问题-&gt;回答” 结构</p>
<ul>
<li>三类问题：What（是什么）、Why（为什么）、How（如何做）</li>
<li>设身处地站在受众角度设定问题</li>
<li>受众最关心的问题要放到关键位置</li>
</ul>
<h3 id="横向结构"><a href="#横向结构" class="headerlink" title="横向结构"></a>横向结构</h3><p>两个结构方法</p>
<ul>
<li>归纳结构<ul>
<li>时间顺序。在按照时间顺序组织的思想组中，按照采取行动的顺序（第一步、第二步、第三步 或 事前、事中、事后）依次表述达到某一结果必须采取的行动。</li>
<li>结构顺序。组织结构、空间结构等顺序中，分组后的各部分需要符合 MECE原则：不重不漏 </li>
<li>程度顺序。首要、次要等重要性顺序</li>
</ul>
</li>
<li>演绎结构<ul>
<li>标准式：大前提 -&gt; 小前提 -&gt; 结论</li>
<li>常见式：现象 -&gt; 原因 -&gt; 解决方案</li>
</ul>
</li>
</ul>
<h2 id="一图以蔽之"><a href="#一图以蔽之" class="headerlink" title="一图以蔽之"></a>一图以蔽之</h2><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884355946547.png"  alt=""></p>
]]></content>
      <categories>
        <category>方法论</category>
        <category>思维模型</category>
      </categories>
      <tags>
        <tag>金字塔原理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好复盘</title>
    <url>/blog/2019/12/28/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h2 id="什么是复盘"><a href="#什么是复盘" class="headerlink" title="什么是复盘"></a>什么是复盘</h2><h3 id="传统释义"><a href="#传统释义" class="headerlink" title="传统释义"></a>传统释义</h3><p>围棋术语，指下完一盘棋后，双方棋手把对弈过程重新摆一遍，看哪里下得好，哪里下得不好，哪些关键节点有不同甚至更好的下法，以检查对局中招法的优劣与得失，并从中寻找提高自己水平的方法。</p>
<h3 id="管理释义"><a href="#管理释义" class="headerlink" title="管理释义"></a>管理释义</h3><p>一句话概括：“做过的事情，再从头过一遍”<br>对于我们经历过的事情，“从头”指的是‘从目的“开始审视和思考，从中发现问题、分析原因、总结经验</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>考查“目标”和“结果”的Gap，根据差异，回顾、反思、探究、提升</p>
<h2 id="为什么要复盘"><a href="#为什么要复盘" class="headerlink" title="为什么要复盘"></a>为什么要复盘</h2><h3 id="对事"><a href="#对事" class="headerlink" title="对事"></a>对事</h3><p>战略上及时校准方向、调适路线<br>战术上攻克具体难题、及时总结方法、不断提升经营水平</p>
<h3 id="对人"><a href="#对人" class="headerlink" title="对人"></a>对人</h3><p>规避重复问题：分析问题，探索可能的解决方案以避免同样的错误再次发生<br>提升能力：积累经验，总结规律，并抽象成方法论</p>
<h3 id="核心价值"><a href="#核心价值" class="headerlink" title="核心价值"></a>核心价值</h3><p>巩固成功与改正错误</p>
<h2 id="什么时候复盘"><a href="#什么时候复盘" class="headerlink" title="什么时候复盘"></a>什么时候复盘</h2><h3 id="及时复盘"><a href="#及时复盘" class="headerlink" title="及时复盘"></a>及时复盘</h3><p>高风险和高阻塞等任务行动结束后，花很短的时间再过一次整个过程，及时制定改进方案并落实。</p>
<h3 id="阶段性复盘"><a href="#阶段性复盘" class="headerlink" title="阶段性复盘"></a>阶段性复盘</h3><p>大项目的执行过程中，阶段性复盘，思考原定的目标是什么，目前达成的结果是什么，阶段性地对目标或策略进行调整。</p>
<h3 id="全面复盘"><a href="#全面复盘" class="headerlink" title="全面复盘"></a>全面复盘</h3><p>在项目或战略结束后，全面总结目的、目标以及达成的结果，过程中哪些地方做得不好，哪些地方做得好，以及收获的经验教训和规律。</p>
<h2 id="如何复盘"><a href="#如何复盘" class="headerlink" title="如何复盘"></a>如何复盘</h2><h3 id="四步复盘法"><a href="#四步复盘法" class="headerlink" title="四步复盘法"></a>四步复盘法</h3><h4 id="1-回顾目标"><a href="#1-回顾目标" class="headerlink" title="1. 回顾目标"></a>1. 回顾目标</h4><p>回顾当初的目的或期望的结果是什么</p>
<p>抓手</p>
<ul>
<li>需求是如何从提出到立项的？</li>
<li>想要实现的目标和收益是什么？</li>
<li>最初的计划是怎样的？</li>
<li>预期的风险和应对措施是怎样的？</li>
</ul>
<p>注意点</p>
<ul>
<li>分清目的与目标的不同，正确的目的保证目标的方向；清晰而适配的目标能更好地分解和保障目的实现。</li>
<li>确定目的之外，最好能确定出可量化的目标或具有里程碑性质的标志。无量化或可考核的目标，很难保证目的实现，也难与结果对照评估。</li>
<li>事前所提目的、目标不清晰，复盘时追补清晰，便于本次对照，提高下次定目标的准确度。可参考SMART原则制定目标</li>
</ul>
<h4 id="2-评估结果"><a href="#2-评估结果" class="headerlink" title="2. 评估结果"></a>2. 评估结果</h4><p>对照原来设定的目标找出过程中的亮点和不足</p>
<p>抓手</p>
<ul>
<li>最初的目标和收益有没有实现？</li>
<li>最初制定的计划执行情况如何？（如进度计划、成本计划、资源计划等）       </li>
<li>预期风险是否发生？应对措施是否有效？</li>
<li>发生了哪些意料之外的事情？有何影响？</li>
</ul>
<p>注意点</p>
<ul>
<li>首先要与原定的目标相比较，客观分析意料外的重要亮点或不足。</li>
<li>亮点与不足同样重要，不能弱化亮点</li>
<li>多引入外部典型事实样本，让我们的结果评估视野更广阔、结论更客观。</li>
</ul>
<h4 id="3-分析原因"><a href="#3-分析原因" class="headerlink" title="3. 分析原因"></a>3. 分析原因</h4><p>寻找成功的关键原因和失败的根本原因</p>
<p>抓手</p>
<ul>
<li>叙述过程：实事求是的过程叙述，让复盘参与者知悉背景、对齐信息</li>
<li>自我剖析：自己对做过的事情进行反思和分析，看看有哪些问题，有哪些成绩，并试着去找出原因，发现规律。</li>
<li>众人设问：突破事件本身的局限，突破个人见识的局限。设问要多探索可能性，考察每一种可能性的条件，以及其边界。</li>
</ul>
<p>注意点</p>
<ul>
<li>成功时，主要看客观原因，多列举客观因素，精选自身真正的优势。</li>
<li>失败时，主要看主观原因。多从自身深挖原因，狠挑不足以补足短板</li>
</ul>
<h4 id="4-总结经验"><a href="#4-总结经验" class="headerlink" title="4. 总结经验"></a>4. 总结经验</h4><p>总结体会、体验、反思、规律，以及接下来的行动计划</p>
<p>抓手</p>
<ul>
<li>我们从过程中学到了什么新</li>
<li>如果有人要进行类似的项目，我会给到什么建议?</li>
<li>接下来我们该做些什么?需要实施哪些新举措？继续哪些动作？叫停哪些动作？</li>
</ul>
<p>注意点</p>
<ul>
<li><p>总结规律</p>
<ul>
<li><p>复盘结论的落脚点是否在偶发性的因素上？<br>当复盘的结论落脚在偶发性因素上，那一定是错误的。如果复盘没有进入到逻辑层面，没有经受住逻辑的验证，则这样的复盘结论，一定是不可信的。</p>
</li>
<li><p>复盘结论是指向人还是指向事？<br>复盘的结论如果是指向人，则很可能说明复盘没有真正到位。因为复盘得出的是规律性的认识，而人是具体的，各不相同。指向事，则复盘到规律的可能性更高。复盘的结论不是指向人，而是从事物的本质去理解分析，这是验证复盘结论是否可靠的标准之一。</p>
</li>
<li><p>复盘结论的得出，是否有过3次以上连续的 why 或者 why not 的追问？<br>如果次数不够，也很可能意味着复盘没有找到真正的原因。探寻问题背后的问题，找出答案之后的答案，这就是追问的目的。</p>
</li>
<li><p>是否是经过交叉验证得出的结论？<br>“孤证不能定案”是法律上的术语，用来比喻复盘得出的结论通过其他事情交叉验证，也可以为结论的有效性提供一定的保障。</p>
</li>
</ul>
</li>
<li><p>案例佐证<br>除了从因果关系上去验证规律外，为了验证规律的可信度，还应该用其他案例进行佐证。这是从规律的适用性出发的一次实验。案例佐证面临着案例选择的问题，所选的案例应该是同类型的、同行业的，不能选取跟所复盘的事件无关的案例。</p>
</li>
<li><p>归档复盘<br>复盘进行归档，这其实也是知识管理的一种。归档将复盘得到的认识知识化或者形成方法论，更加方便传播和查阅，这让没有参与复盘的人也能掌握复盘得出的规律和观念，让新人可以在自己的工作中进行学习和参考，少走弯路。</p>
</li>
</ul>
<h2 id="复盘模版"><a href="#复盘模版" class="headerlink" title="复盘模版"></a>复盘模版</h2><p><img src="/blog/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/9696036-b088afab48869a76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"  alt=""></p>
<h2 id="项目复盘示例"><a href="#项目复盘示例" class="headerlink" title="项目复盘示例"></a>项目复盘示例</h2><h3 id="项目目标复盘"><a href="#项目目标复盘" class="headerlink" title="项目目标复盘"></a>项目目标复盘</h3><h4 id="项目进度复盘"><a href="#项目进度复盘" class="headerlink" title="项目进度复盘"></a>项目进度复盘</h4><ul>
<li>是否按照原计划交付时间交付？</li>
<li>原计划的需求点实现了多少？哪些需求点没有按计划实现？每一个需求点延后原因分别是什么？</li>
<li>哪些里程碑有延迟，延迟原因是什么？</li>
</ul>
<h4 id="项目结果复盘"><a href="#项目结果复盘" class="headerlink" title="项目结果复盘"></a>项目结果复盘</h4><ul>
<li>项目中出现了哪些意外？为什么会出现这些意外？</li>
<li>用户对新增功能点的接受程度和项目规划中的是否一致？</li>
</ul>
<h3 id="需求阶段复盘"><a href="#需求阶段复盘" class="headerlink" title="需求阶段复盘"></a>需求阶段复盘</h3><h4 id="需求定义复盘："><a href="#需求定义复盘：" class="headerlink" title="需求定义复盘："></a>需求定义复盘：</h4><ul>
<li>是否提供完整的需求输出，包括：原型、MRD、PRD、UML等</li>
<li>设计师、交互师、开发人员分别对需求是否明确：如果出现需求不明确的情况，将会严重影响项目的进度和质量</li>
<li>是否对典型用户和使用场景有清晰的描述？</li>
</ul>
<h4 id="需求变更复盘"><a href="#需求变更复盘" class="headerlink" title="需求变更复盘"></a>需求变更复盘</h4><ul>
<li>需求变更次数：敏捷开发已经将需求变更的影响降到最低，但是较少的需求变更仍然是项目进展顺利的前提之一</li>
<li>哪些需求变更影响了项目实际进度</li>
<li>每次变更的原因：领导干预？前期考虑欠缺？需求无法实现？分析每一次的变更原因，可以在后期项目中进行合理的避免。</li>
<li>每个项目成员是否都清晰的知道每一次的变更：只有每位项目成员清楚的了解每次需求变更，并做好充分的沟通，才能保证项目的进度和质量。</li>
<li>项目成员是否能接收需求变更：这就要求每次需求变更，都要和相关人员做好沟通。</li>
</ul>
<h3 id="设计阶段复盘"><a href="#设计阶段复盘" class="headerlink" title="设计阶段复盘"></a>设计阶段复盘</h3><ul>
<li>是否确定视觉设计的最终审核人？</li>
<li>UI设计产出是否符合统一标准？</li>
<li>设计工作是否影响开发工作的进度？影响原因是什么？</li>
<li>产品设计工作在什么时候，由谁来完成的？</li>
</ul>
<h3 id="开发阶段复盘"><a href="#开发阶段复盘" class="headerlink" title="开发阶段复盘"></a>开发阶段复盘</h3><h4 id="工期评估复盘"><a href="#工期评估复盘" class="headerlink" title="工期评估复盘"></a>工期评估复盘</h4><ul>
<li>开发实施前，是否有充分的时间做工期预估：工期评估一方面是让项目成员能够对项目的整体进度有所准备，也是对项目需求进行详细梳理的过程。</li>
<li>工期预估与实际开发时间是否有差异，及差异原因分析</li>
</ul>
<h4 id="开发文档复盘"><a href="#开发文档复盘" class="headerlink" title="开发文档复盘"></a>开发文档复盘</h4><ul>
<li>是否有提供开发文档？</li>
<li>开发文档是否符合规范</li>
</ul>
<h4 id="突发状况复盘"><a href="#突发状况复盘" class="headerlink" title="突发状况复盘"></a>突发状况复盘</h4><ul>
<li>是否出现需求无法实现的状况？原因是什么？</li>
<li>是否出现团队成员变动情况？如何应对成员变动？后期如何避免？</li>
<li>是否出现功能模块与需求不符的情况？出现原因是什么？</li>
</ul>
<h4 id="Code-Review复盘"><a href="#Code-Review复盘" class="headerlink" title="Code Review复盘"></a>Code Review复盘</h4><ul>
<li>是如何进行的：包括如何分工，如何复查等。</li>
<li>Code Review结果是什么？</li>
<li>是否严格执行了代码规范？对不规范的代码如何处理？</li>
</ul>
<h3 id="测试阶段复盘"><a href="#测试阶段复盘" class="headerlink" title="测试阶段复盘"></a>测试阶段复盘</h3><h4 id="测试计划复盘"><a href="#测试计划复盘" class="headerlink" title="测试计划复盘"></a>测试计划复盘</h4><ul>
<li>是否有完整、准确的测试用例？</li>
<li>是否有一个测试计划？这样的计划是否有效？</li>
<li>团队是如何测试并跟踪产品开发效果的？</li>
</ul>
<h4 id="测试工具复盘"><a href="#测试工具复盘" class="headerlink" title="测试工具复盘"></a>测试工具复盘</h4><ul>
<li>使用了哪些测试工具来帮助测试？是否可以持续使用？</li>
<li>测试的时间、人力和软件/硬件资源是否足够?</li>
</ul>
<h4 id="测试结果复盘"><a href="#测试结果复盘" class="headerlink" title="测试结果复盘"></a>测试结果复盘</h4><ul>
<li>哪个功能模块产生的Bug最多，为什么？</li>
<li>哪些BUG出现回滚，原因是什么？</li>
</ul>
<h3 id="上线阶段复盘"><a href="#上线阶段复盘" class="headerlink" title="上线阶段复盘"></a>上线阶段复盘</h3><h4 id="验收复盘"><a href="#验收复盘" class="headerlink" title="验收复盘"></a>验收复盘</h4><ul>
<li>是否进行了正式的上线验收？</li>
<li>在正式发布的过程中是否有出现状况？后续如何避免？</li>
<li>上线前是否和运营、文案进行充分的沟通？</li>
<li>是否检查了数据埋点，数据埋点是否满足运营要求？</li>
</ul>
<h4 id="上线后效果复盘"><a href="#上线后效果复盘" class="headerlink" title="上线后效果复盘"></a>上线后效果复盘</h4><ul>
<li>在上线之后是否出现重大bug? 为什么测试阶段没有发现？</li>
<li>产品上线后的问题反馈渠道是否顺畅？</li>
<li>产品上线后收集到哪些问题反馈？都是什么类型？如何改进？</li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
        <category>基本功</category>
      </categories>
      <tags>
        <tag>复盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/blog/2019/12/23/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884356753906.jpg"  alt=""></p>
<h2 id="Git库创建"><a href="#Git库创建" class="headerlink" title="Git库创建"></a>Git库创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 远程仓库克隆到本地</span><br><span class="line">git clone [ssh]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 本地构建仓库</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>以MAC系统，Git配置文件一般有两个配置文件，其作用域分别为全局级、仓库级</p>
<ol>
<li>全局级配置： ~/.gitconfig</li>
<li>仓库级配置： ${ProjectFile}/.git/.gitconfig</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看当前配置信息</span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置git用户信息</span><br><span class="line">git config [--local | --global] user.name &quot;[name]&quot;</span><br><span class="line">git config [--local | --global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>


<h2 id="Git分支相关"><a href="#Git分支相关" class="headerlink" title="Git分支相关"></a>Git分支相关</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 列出所有本地分支</span><br><span class="line">git branch </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有本地分支和远程分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出本地分支及其对应的远端分支，并附最新commit信息 （-v ）</span><br><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>

<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，指向指定commit</span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果本地有branch-name分支，则切换到该分支，如果没有切远程有branch-name分支，则直接以远程分支为基准创建branch-name本地分支</span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行本地分支 branch 追踪远端 remote-branch</span><br><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>

<h3 id="同步-amp-合并"><a href="#同步-amp-合并" class="headerlink" title="同步&amp;合并"></a>同步&amp;合并</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步远端变到本地</span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步远端变更，并与本地分支合并，可能有conflict</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并N个提交记录为一个</span><br><span class="line">git rebase -i HEAD~N</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 场景：个人分支 rebase 其它分支 ，（分支commit记录更清爽，相比merge操作少一个Merge commit）</span><br><span class="line">git rebase [branch]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并指定分支到当前分支</span><br><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>

<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上传当前分支到跟踪的远端分支</span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传本地指定分支到远程仓库</span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">git push [remote] --force</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除本地分支</span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除远端分支</span><br><span class="line">git push origin --delete [branch-name]</span><br></pre></td></tr></table></figure>


<h2 id="Git提交相关"><a href="#Git提交相关" class="headerlink" title="Git提交相关"></a>Git提交相关</h2><h3 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示当前分支的提交历史</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示当前分支的最近几次提交</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>


<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 提交暂存区到本地仓库区</span><br><span class="line">git commit </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交快捷方式 带message</span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交到上一次commit，可变更message</span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将某个commit，合并到当前分支</span><br><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>

<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个提交，并对指定commit后的所有变更进行回滚</span><br><span class="line">git revert [commit]</span><br></pre></td></tr></table></figure>

<h2 id="Git文件相关"><a href="#Git文件相关" class="headerlink" title="Git文件相关"></a>Git文件相关</h2><h3 id="查看-2"><a href="#查看-2" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示变更的文件</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示暂存区和工作区的差异</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加指定文件到工作区</span><br><span class="line">git add [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加所有文件到工作区</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除工作区指定文件</span><br><span class="line">git rm [file]</span><br></pre></td></tr></table></figure>

<h3 id="撤销-1"><a href="#撤销-1" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 恢复暂存区的所有文件到工作区</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将所有工作区文件 存储到stash区</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将stash 存储区最上面的一个，恢复到工作区</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出所有的标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个tag</span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定commit傻姑娘新建一个tag</span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除本地tag</span><br><span class="line">git tag -d [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除远程tag</span><br><span class="line">git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 推送指定tag</span><br><span class="line">git push [remote] [tag]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以指定某个分支的tag处新建一个分支</span><br><span class="line">git checkout -b [branch][tag]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>开发效率</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>EventBus 3.1 源码分析</title>
    <url>/blog/2019/12/22/EventBus%203.1%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>基于V3.1.1<br><a href="http://greenrobot.org/eventbus/documentation/" target="_blank" rel="noopener">EventBus 官方地址</a><br><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus GitHub地址</a></p>
</blockquote>
<h3 id="EventBus-是什么"><a href="#EventBus-是什么" class="headerlink" title="EventBus 是什么"></a>EventBus 是什么</h3><p>概念：EventBus是一个Android事件发布/订阅框架<br>同类：Otto、RxBus<br>出品方：greenrobot</p>
<h3 id="EventBus-优缺点"><a href="#EventBus-优缺点" class="headerlink" title="EventBus 优缺点"></a>EventBus 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>通过消息总线形式，解耦发布者和订阅者，简化Android事件传递，从而代替Android传统的Intent、Handler、Broadcast方式或接口回调</li>
<li>支持注解配置消息<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4></li>
<li>消息事件满天飞，维护难</li>
<li>无延迟发送</li>
<li>不支持跨进程/App</li>
<li>Android生命周期无感知</li>
</ul>
<h3 id="EventBus-工作原理"><a href="#EventBus-工作原理" class="headerlink" title="EventBus 工作原理"></a>EventBus 工作原理</h3><h4 id="消息发布和订阅模型"><a href="#消息发布和订阅模型" class="headerlink" title="消息发布和订阅模型"></a>消息发布和订阅模型</h4><p>生产者：发布者发布消息<br>消费者：订阅者注册消息<br>调度中心： 执行消息的分发到位</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884357993255.png"  alt=""><br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884358099948.png"  alt=""></p>
<h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><p>主要就是两个切换，主线程切子线程，子线程切主线程<br>一个进程内通过Looper.getMainLooper可以顺利切换到主线程<br>子线程通过是通过主线程执行某个线程，自动切换，也可以借助ThreadLocal缓存对象来切换</p>
<p>参考：<a href="https://www.jianshu.com/p/75258d19a964" target="_blank" rel="noopener">Android线程消息机制</a></p>
<h3 id="EventBus-类图"><a href="#EventBus-类图" class="headerlink" title="EventBus 类图"></a>EventBus 类图</h3><ul>
<li>EventBus：核心类，代表了一个事件总线。实现发布-订阅模式。</li>
<li>SubscriberMethodFinder：寻找订阅者的订阅方法</li>
<li>FindState：寻找订阅方法过程中的缓存Buffer，目的内存复用</li>
<li>SubscriberMethod：订阅者的方法封装类</li>
<li>Subscription：订阅者对象的封装</li>
<li>ThreadMode：线程模型，用来标识不同线程执行消息</li>
<li>PostingThreadState：消息发布状态封装</li>
<li>Poster：不同线程消息发布器</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884358247600.png"  alt=""></p>
<h3 id="EventBus-订阅-发布时序图"><a href="#EventBus-订阅-发布时序图" class="headerlink" title="EventBus 订阅-发布时序图"></a>EventBus 订阅-发布时序图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884358375057.png"  alt=""></p>
<h3 id="EventBus-订阅-发布流程图"><a href="#EventBus-订阅-发布流程图" class="headerlink" title="EventBus 订阅-发布流程图"></a>EventBus 订阅-发布流程图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884358457957.png"  alt=""></p>
<h3 id="订阅流程源码分析"><a href="#订阅流程源码分析" class="headerlink" title="订阅流程源码分析"></a>订阅流程源码分析</h3><p>EventBus.getDefault<br>获取EventBus单例，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 提供默认单例 EventBus</span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">   EventBus instance &#x3D; defaultInstance;</span><br><span class="line">   if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">       synchronized (EventBus.class) &#123;</span><br><span class="line">           instance &#x3D; EventBus.defaultInstance;</span><br><span class="line">           if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">               instance &#x3D; EventBus.defaultInstance &#x3D; new EventBus();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">   logger &#x3D; builder.getLogger();</span><br><span class="line">   &#x2F;&#x2F; &lt;订阅事件类型，订阅对象集合&gt;</span><br><span class="line">   subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; &lt;订阅者，订阅事件类型集合&gt;</span><br><span class="line">   typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; 粘性事件 map</span><br><span class="line">   stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; 主线程支持类</span><br><span class="line">   mainThreadSupport &#x3D; builder.getMainThreadSupport();</span><br><span class="line">   &#x2F;&#x2F; 主线程分发者</span><br><span class="line">   mainThreadPoster &#x3D; mainThreadSupport !&#x3D; null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">   &#x2F;&#x2F; 后天线程分发者</span><br><span class="line">   backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">   &#x2F;&#x2F; 异步现场分发者</span><br><span class="line">   asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">   indexCount &#x3D; builder.subscriberInfoIndexes !&#x3D; null ? builder.subscriberInfoIndexes.size() : 0;</span><br><span class="line">   &#x2F;&#x2F; 订阅方法寻找器</span><br><span class="line">   subscriberMethodFinder &#x3D; new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">           builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">   logSubscriberExceptions &#x3D; builder.logSubscriberExceptions;</span><br><span class="line">   logNoSubscriberMessages &#x3D; builder.logNoSubscriberMessages;</span><br><span class="line">   sendSubscriberExceptionEvent &#x3D; builder.sendSubscriberExceptionEvent;</span><br><span class="line">   sendNoSubscriberEvent &#x3D; builder.sendNoSubscriberEvent;</span><br><span class="line">   throwSubscriberException &#x3D; builder.throwSubscriberException;</span><br><span class="line">   &#x2F;&#x2F; 是否执行分发父类事件类型</span><br><span class="line">   eventInheritance &#x3D; builder.eventInheritance;</span><br><span class="line">   &#x2F;&#x2F; 线程执行器 </span><br><span class="line">   executorService &#x3D; builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.register</p>
<ol>
<li>获取订阅者Class</li>
<li>通过反射，获取Class的所有订阅方法集合</li>
<li>遍历订阅方法集合，存储两个Map，Map&lt;订阅事件类型，订阅对象集合&gt;， Map&lt;订阅者，订阅事件集合&gt;</li>
<li>如果订阅的是Stick事件类型，则直接寻找对应事件，然后分发到订阅方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 订阅对象的 Class</span><br><span class="line">   Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();</span><br><span class="line">   &#x2F;&#x2F;  通过注解反射拿到 订阅Class的订阅方法</span><br><span class="line">   List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注册 订阅</span><br><span class="line">           subscribe(subscriber, subscriberMethod);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubscriberMethodFinder.findSubscriberMethods</p>
<ol>
<li>先从内存缓存 Map&lt;订阅对象Class,订阅对象Class的订阅方法&gt; 找</li>
<li>然后通过反射方法获取订阅者Class的所有订阅方法</li>
<li>Map 存储</li>
<li>返回订阅者的订阅方法集合</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; 内存缓存 Map&lt;订阅对象Class,订阅对象Class的订阅方法&gt;</span><br><span class="line">   List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; METHOD_CACHE.get(subscriberClass);</span><br><span class="line">   if (subscriberMethods !&#x3D; null) &#123;</span><br><span class="line">       return subscriberMethods;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   if (ignoreGeneratedIndex) &#123;  &#x2F;&#x2F; 默认false</span><br><span class="line">       subscriberMethods &#x3D; findUsingReflection(subscriberClass);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 反射查找所有订阅方法</span><br><span class="line">       subscriberMethods &#x3D; findUsingInfo(subscriberClass);</span><br><span class="line">   &#125;</span><br><span class="line">   if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">       throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">               + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; map存储</span><br><span class="line">       METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">       return subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubscriberMethodFinder.findUsingInfo</p>
<ol>
<li>通过FIND_STATE_POOL构建FindState，用做找寻订阅方法时的缓存对象</li>
<li>执行反射寻找订阅者的订阅方法，存储到FindState中</li>
<li>循环遍历找订阅者的父类的订阅方法</li>
<li>返回订阅者的订阅方法集合，并释放FindState</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; FindState 在寻找订阅方法过程中 用于存储相关信息，为了内存复用，通过FIND_STATE_POOL维护了4个FindState来循环使用</span><br><span class="line">   FindState findState &#x3D; prepareFindState();</span><br><span class="line">   findState.initForSubscriber(subscriberClass);</span><br><span class="line">   while (findState.clazz !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取SubscriberInfo 包含订阅者Class、Methods等</span><br><span class="line">       findState.subscriberInfo &#x3D; getSubscriberInfo(findState);</span><br><span class="line">       </span><br><span class="line">       if (findState.subscriberInfo !&#x3D; null) &#123;</span><br><span class="line">            ... &#x2F;&#x2F; 如果有 ，直接遍历 设置methods数据</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行 反射获取订阅methods</span><br><span class="line">           findUsingReflectionInSingleClass(findState);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 父类Class，然后继续遍历找所有订阅方法</span><br><span class="line">       findState.moveToSuperclass();</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 返回订阅者的订阅方法集合，并释放FindState</span><br><span class="line">   return getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">   List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">   findState.recycle();</span><br><span class="line">   synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">       for (int i &#x3D; 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">           if (FIND_STATE_POOL[i] &#x3D;&#x3D; null) &#123;</span><br><span class="line">               FIND_STATE_POOL[i] &#x3D; findState;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubscriberMethodFinder.findUsingReflectionInSingleClass<br>遍历类中所有方法，寻找目标订阅方法，封装成SubscriberMethod存储到findState的subscriberMethods集合中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">   Method[] methods;</span><br><span class="line">   try &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取所有声明的方法</span><br><span class="line">       methods &#x3D; findState.clazz.getDeclaredMethods();</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 遍历方法</span><br><span class="line">   for (Method method : methods) &#123;</span><br><span class="line">       int modifiers &#x3D; method.getModifiers();</span><br><span class="line">       &#x2F;&#x2F; 找 public 方法</span><br><span class="line">       if ((modifiers &amp; Modifier.PUBLIC) !&#x3D; 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 找参数为1的方法</span><br><span class="line">           Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">           if (parameterTypes.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                &#x2F;&#x2F; 找 含有 Subscribe注解的方法</span><br><span class="line">               Subscribe subscribeAnnotation &#x3D; method.getAnnotation(Subscribe.class);</span><br><span class="line">               if (subscribeAnnotation !&#x3D; null) &#123;</span><br><span class="line">                   Class&lt;?&gt; eventType &#x3D; parameterTypes[0];</span><br><span class="line">                   if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 添加 ThreadMode</span><br><span class="line">                       ThreadMode threadMode &#x3D; subscribeAnnotation.threadMode();</span><br><span class="line">                       &#x2F;&#x2F; findState 添加订阅的方法</span><br><span class="line">                       findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                               subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.subscribe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">    &#x2F;&#x2F; 事件类型 （订阅的事件）</span><br><span class="line">   Class&lt;?&gt; eventType &#x3D; subscriberMethod.eventType;</span><br><span class="line">   &#x2F;&#x2F; 构造 Subscription （封装订阅对象及对应方法）</span><br><span class="line">   Subscription newSubscription &#x3D; new Subscription(subscriber, subscriberMethod);</span><br><span class="line">   &#x2F;&#x2F; 针对eventType取对应的 CopyOnWriteArrayList【主要用来实现事件优先级接受】</span><br><span class="line">   CopyOnWriteArrayList&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);</span><br><span class="line">   if (subscriptions &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 没有，则创建 订阅集合</span><br><span class="line">       subscriptions &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">       &#x2F;&#x2F; 存储 &lt;订阅事件类型，订阅对象集合&gt;</span><br><span class="line">       subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   int size &#x3D; subscriptions.size();</span><br><span class="line">   &#x2F;&#x2F; 根据优先级添加 订阅对象</span><br><span class="line">   for (int i &#x3D; 0; i &lt;&#x3D; size; i++) &#123;</span><br><span class="line">       if (i &#x3D;&#x3D; size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">           subscriptions.add(i, newSubscription);</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 缓存 Map&lt;订阅者，订阅事件集合&gt;</span><br><span class="line"></span><br><span class="line">   List&lt;Class&lt;?&gt;&gt; subscribedEvents &#x3D; typesBySubscriber.get(subscriber);</span><br><span class="line">   if (subscribedEvents &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 存储</span><br><span class="line">       subscribedEvents &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">       typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">   &#125;</span><br><span class="line">   subscribedEvents.add(eventType); &#x2F;&#x2F; 添加订阅事件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果订阅方法是 支持sticky事件,则直接执行分发sticky事件</span><br><span class="line">   if (subscriberMethod.sticky) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示是否分发订阅了响应事件类父类事件的方法</span><br><span class="line">       if (eventInheritance) &#123;</span><br><span class="line">           Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries &#x3D; stickyEvents.entrySet();</span><br><span class="line">           for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">               Class&lt;?&gt; candidateEventType &#x3D; entry.getKey();</span><br><span class="line">               if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                   Object stickyEvent &#x3D; entry.getValue();</span><br><span class="line">                   checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据事件类型，获取事件</span><br><span class="line">           Object stickyEvent &#x3D; stickyEvents.get(eventType);</span><br><span class="line">           &#x2F;&#x2F; 分发到订阅方法</span><br><span class="line">           checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发布流程源码分析"><a href="#发布流程源码分析" class="headerlink" title="发布流程源码分析"></a>发布流程源码分析</h4><p>EventBus.post</p>
<p>参考：<a href="https://www.jianshu.com/p/8a7fe7d592f8" target="_blank" rel="noopener">深入理解ThreadLocal</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过ThreadLocal&lt;PostingThreadState&gt; 获取当前现场的 PostingThreadState </span><br><span class="line">   PostingThreadState postingState &#x3D; currentPostingThreadState.get();</span><br><span class="line">   &#x2F;&#x2F; 通过List 存储 事件</span><br><span class="line">   List&lt;Object&gt; eventQueue &#x3D; postingState.eventQueue;</span><br><span class="line">   eventQueue.add(event);</span><br><span class="line">    &#x2F;&#x2F; 是否正在分发中，没有则开始分发</span><br><span class="line">   if (!postingState.isPosting) &#123;</span><br><span class="line">       postingState.isMainThread &#x3D; isMainThread(); &#x2F;&#x2F; 是否主线程</span><br><span class="line">       postingState.isPosting &#x3D; true; &#x2F;&#x2F; 标记为true</span><br><span class="line">       if (postingState.canceled) &#123;</span><br><span class="line">           throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">            &#x2F;&#x2F; 循环取事件，进行分发</span><br><span class="line">           while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 分发单个事件</span><br><span class="line">               postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 结束重置状态</span><br><span class="line">           postingState.isPosting &#x3D; false;</span><br><span class="line">           postingState.isMainThread &#x3D; false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.postSingleEvent<br>根据eventInheritance确认是否需要分发父类Class，最终执行postSingleEventForEventType 进行事件分发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">   Class&lt;?&gt; eventClass &#x3D; event.getClass();</span><br><span class="line">   boolean subscriptionFound &#x3D; false;</span><br><span class="line">   if (eventInheritance) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询事件对象的父类对象Class</span><br><span class="line">       List&lt;Class&lt;?&gt;&gt; eventTypes &#x3D; lookupAllEventTypes(eventClass);</span><br><span class="line">       int countTypes &#x3D; eventTypes.size();</span><br><span class="line">       for (int h &#x3D; 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">           Class&lt;?&gt; clazz &#x3D; eventTypes.get(h);</span><br><span class="line">           subscriptionFound |&#x3D; postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       subscriptionFound &#x3D; postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.postSingleEventForEventType</p>
<ol>
<li>获取订阅对象集合</li>
<li>遍历订阅对象，执行事件分发</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 订阅对象集合</span><br><span class="line">   CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       subscriptions &#x3D; subscriptionsByEventType.get(eventClass);</span><br><span class="line">   &#125;</span><br><span class="line">   if (subscriptions !&#x3D; null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">       &#x2F;&#x2F; 遍历订阅对象集合 一个个分发</span><br><span class="line">       for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">           postingState.event &#x3D; event;</span><br><span class="line">           postingState.subscription &#x3D; subscription;</span><br><span class="line">           boolean aborted &#x3D; false;</span><br><span class="line">           try &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行分发</span><br><span class="line">               postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">               aborted &#x3D; postingState.canceled;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               postingState.event &#x3D; null;</span><br><span class="line">               postingState.subscription &#x3D; null;</span><br><span class="line">               postingState.canceled &#x3D; false;</span><br><span class="line">           &#125;</span><br><span class="line">           if (aborted) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventBus.postToSubscription<br>根据不同的 ThreadMode 进行处理 </p>
<ol>
<li>执行线程与目标线程匹配，则直接反射执行订阅方法</li>
<li>不匹配，则先将事件添加到PendingPostQueue，然后通过ExecutorService执行Runnable</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据不同的 ThreadMode 进行处理 </span><br><span class="line">   switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">       case POSTING:</span><br><span class="line">           invokeSubscriber(subscription, event);</span><br><span class="line">           break;</span><br><span class="line">       case MAIN:</span><br><span class="line">           if (isMainThread) &#123;</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case MAIN_ORDERED:</span><br><span class="line">           if (mainThreadPoster !&#x3D; null) &#123;</span><br><span class="line">               mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; temporary: technically not correct as poster not decoupled from subscriber</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case BACKGROUND:</span><br><span class="line">           if (isMainThread) &#123;</span><br><span class="line">               backgroundPoster.enqueue(subscription, event);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               invokeSubscriber(subscription, event);</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br><span class="line">       case ASYNC:</span><br><span class="line">           asyncPoster.enqueue(subscription, event);</span><br><span class="line">           break;</span><br><span class="line">       default:</span><br><span class="line">           throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行订阅者的订阅方法</span><br><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">        &#x2F;&#x2F; 反射调用执行方法</span><br><span class="line">       subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">   &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">       handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">   &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BackgroundPoster<br>以BackgroundPoster为例，进行代码分析</p>
<ol>
<li>构建PendingPost，然后加入PendingPostQueue队列，接着调用线程执行器执行线程</li>
<li>线程执行，循环获取PendingPost，调用EventBus.invokeSubscriber反射执行订阅者的订阅方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">final class BackgroundPoster implements Runnable, Poster &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 入队</span><br><span class="line">    public void enqueue(Subscription subscription, Object event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 订阅者和事件封装为一个 PendingPost</span><br><span class="line">        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            queue.enqueue(pendingPost); &#x2F;&#x2F; 入队</span><br><span class="line">            if (!executorRunning) &#123;</span><br><span class="line">                executorRunning &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F; 调用现场执行器，执行</span><br><span class="line">                eventBus.getExecutorService().execute(this); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    PendingPost pendingPost &#x3D; queue.poll(1000);</span><br><span class="line">                    轮训取 post，1s没有则停止执行</span><br><span class="line">                    if (pendingPost &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        synchronized (this) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Check again, this time in synchronized</span><br><span class="line">                            pendingPost &#x3D; queue.poll();</span><br><span class="line">                            if (pendingPost &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                executorRunning &#x3D; false;</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 最后执行eventBus的invokeSubscriber方法</span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><img src="/blog/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/9696036-70673e2d55e85b18.gif?imageMogr2/auto-orient/strip"  alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>LeakCanary 2.0源码分析</title>
    <url>/blog/2019/12/16/LeakCanary%202.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>本文基于LeakCanary 2.0源码分析<br><a href="https://square.github.io/leakcanary/" target="_blank" rel="noopener">LeakCanary - 官方地址</a><br><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary - GitHub代码地址</a></p>
</blockquote>
<h3 id="LeakCanary-是什么"><a href="#LeakCanary-是什么" class="headerlink" title="LeakCanary 是什么"></a>LeakCanary 是什么</h3><p>概念：LeakCanary是针对Android应用的一个内存泄漏监控三方库<br>能力：Activity、Fragment以及自主监控的任何对象<br>出品：Square</p>
<h3 id="LeakCanary-作用"><a href="#LeakCanary-作用" class="headerlink" title="LeakCanary 作用"></a>LeakCanary 作用</h3><p>基于对Android Framework层的认知，LeakCanary提供更精准的泄漏原因分析能力，从而帮助开发者快速减少OOM Crash问题</p>
<h3 id="LeakCanary-工作原理"><a href="#LeakCanary-工作原理" class="headerlink" title="LeakCanary 工作原理"></a>LeakCanary 工作原理</h3><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><h5 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h5><p>在Java运行环境下，内存泄漏是指某个程序错误导致应用长时间一直保留某个不在需要的对象，以至于它不能被回收，而它是会占用内存的，这就意味着内存泄漏了。持续累加，最终有可能导致发生内存溢出问题。<br>例如一个Activity执行完onDestroy方法后，它仍然被一个static变量强引用，从而阻止了Activity被GC回收，导致Activity发生内存泄漏</p>
<h5 id="怎么判断一个对象是否泄漏"><a href="#怎么判断一个对象是否泄漏" class="headerlink" title="怎么判断一个对象是否泄漏"></a>怎么判断一个对象是否泄漏</h5><p>从GC Roots出发进行遍历，强引用可到达对象，都是存活对象，不可达对象则为即将被回收的对象。如果那些存活对象本应该是要被回收的，那么这个对象就是发生了内存泄漏（见下图，引用一张图说明）<br>实际过程通常作法是针对核心对象Activity、Fragment进行监控分析</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884358756080.png"  alt=""></p>
<h4 id="如何开始监控"><a href="#如何开始监控" class="headerlink" title="如何开始监控"></a>如何开始监控</h4><p>LeakCanary通过实现四大组件中的ContentProvider，所以可以在App启动的时候执行到LeakCanary的AppWatcherInstaller.onCreate方法，从而完成<strong>0侵入</strong>实现注册监控流程</p>
<h4 id="监控什么对象以及如何监控到目标对象"><a href="#监控什么对象以及如何监控到目标对象" class="headerlink" title="监控什么对象以及如何监控到目标对象"></a>监控什么对象以及如何监控到目标对象</h4><p>Activity: 通过注册 Application.ActivityLifecycleCallbacks实现onActivityDestroyed执行回调，以监控需要被回收的Activity是否被回收<br>Fragment： 通过注册 FragmentManager.FragmentLifecycleCallbacks实现onFragmentViewDestroyed和onFragmentDestroyed回调，以监控需要被回收的Fragment或者View是否被回收</p>
<h4 id="如何确认目标对象泄漏"><a href="#如何确认目标对象泄漏" class="headerlink" title="如何确认目标对象泄漏"></a>如何确认目标对象泄漏</h4><ol>
<li>执行回收：目标对象如果在一个缓冲时间（5s）仍未被回收，我们通过手动执行GC，然后在确认其是否真的不能被回收</li>
<li>确认是否回收：JVM中，如果创建一个含有ReferenceQueue的WeakReference的A对象，这个WeakReference对应的A对象如果被回收了，则A会被自动加入到ReferenceQueue，所以我们可以通过维护一个ReferenceQueue，通过创建目标对象的含有ReferenceQueue的WeakReference，从而监听到目标对象是否被回收</li>
</ol>
<p>更多参考：<a href="https://www.jianshu.com/p/439a8f738153" target="_blank" rel="noopener">Reference和ReferenceQueue深入解读
</a></p>
<h4 id="如何分析目标对象泄漏的原因"><a href="#如何分析目标对象泄漏的原因" class="headerlink" title="如何分析目标对象泄漏的原因"></a>如何分析目标对象泄漏的原因</h4><p>泄漏原因即寻找泄漏路径</p>
<ol>
<li>通过Debug.dumpHprofData，dump一份hprof数据</li>
<li>读取hprof数据，整理出一份GcRoots对象索引</li>
<li>排序GcRoots对象，并构造一份ReferencePathNode树</li>
<li>BFS遍历，找到泄漏对象的最短路径节点</li>
<li>根据节点，生成泄漏路径</li>
</ol>
<h4 id="如何呈现目标对象泄漏的原因"><a href="#如何呈现目标对象泄漏的原因" class="headerlink" title="如何呈现目标对象泄漏的原因"></a>如何呈现目标对象泄漏的原因</h4><ol>
<li>生成一个HeapDumpScreen，呈现泄漏信息</li>
<li>发出通知</li>
</ol>
<h3 id="LeakCanary-2-0与1-x版本对比"><a href="#LeakCanary-2-0与1-x版本对比" class="headerlink" title="LeakCanary 2.0与1.x版本对比"></a>LeakCanary 2.0与1.x版本对比</h3><table>
<thead>
<tr>
<th>内容</th>
<th>2.0</th>
<th>1.0</th>
</tr>
</thead>
<tbody><tr>
<td>语言</td>
<td>kotlin</td>
<td>java</td>
</tr>
<tr>
<td>使用</td>
<td>仅需引入库，自动注册监控</td>
<td>除引入库，还需要手动执行install</td>
</tr>
<tr>
<td>内存分析</td>
<td>shark，基于Okio的自实现的轻巧内存分析库</td>
<td>haha三方库</td>
</tr>
<tr>
<td>其它</td>
<td>fragment，支持 androidx</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="LeakCanary-源码分析"><a href="#LeakCanary-源码分析" class="headerlink" title="LeakCanary 源码分析"></a>LeakCanary 源码分析</h3><h4 id="主要包的结构介绍"><a href="#主要包的结构介绍" class="headerlink" title="主要包的结构介绍"></a>主要包的结构介绍</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884358857649.png"  alt=""></p>
<h4 id="主要工作的时序图"><a href="#主要工作的时序图" class="headerlink" title="主要工作的时序图"></a>主要工作的时序图</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884358946353.png"  alt=""></p>
<h4 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h4><h5 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h5><p>AppWatcherInstaller.onCreate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 继承 ContentProvider</span><br><span class="line">internal sealed class AppWatcherInstaller : ContentProvider() &#123;</span><br><span class="line">    &#x2F;&#x2F; App启动 执行 onCreate </span><br><span class="line">  override fun onCreate(): Boolean &#123;</span><br><span class="line">    val application &#x3D; context!!.applicationContext as Application</span><br><span class="line">    &#x2F;&#x2F; 注册启动（0 侵入）</span><br><span class="line">    InternalAppWatcher.install(application)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternalAppWatcher.install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun install(application: Application) &#123;</span><br><span class="line">    InternalAppWatcher.application &#x3D; application</span><br><span class="line">    </span><br><span class="line">    val configProvider &#x3D; &#123; AppWatcher.config &#125;</span><br><span class="line">    &#x2F;&#x2F; Activity destroy方法监控注册</span><br><span class="line">    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    &#x2F;&#x2F; Fragment destroy方法监控注册</span><br><span class="line">    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    onAppWatcherInstalled(application)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityDestroyWatcher.install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal class ActivityDestroyWatcher private constructor(</span><br><span class="line">  private val objectWatcher: ObjectWatcher,</span><br><span class="line">  private val configProvider: () -&gt; Config</span><br><span class="line">) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构造 Application.ActivityLifecycleCallbacks</span><br><span class="line">  private val lifecycleCallbacks &#x3D;</span><br><span class="line">    object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">      override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">        if (configProvider().watchActivities) &#123;</span><br><span class="line">          objectWatcher.watch(activity, &quot;Activity received Activity#onDestroy() callback&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  companion object &#123;</span><br><span class="line">    fun install(</span><br><span class="line">      application: Application,</span><br><span class="line">      objectWatcher: ObjectWatcher,</span><br><span class="line">      configProvider: () -&gt; Config</span><br><span class="line">    ) &#123;</span><br><span class="line">      val activityDestroyWatcher &#x3D;</span><br><span class="line">        ActivityDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">      &#x2F;&#x2F; 注册 生命周期监听回调</span><br><span class="line">      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InternalLeakCanary.invoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; 初始化相关类</span><br><span class="line">override fun invoke(application: Application) &#123;</span><br><span class="line">    this.application &#x3D; application</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 添加保留对象监听</span><br><span class="line">AppWatcher.objectWatcher.addOnObjectRetainedListener(this)</span><br><span class="line">    &#x2F;&#x2F; Android heap dumper类</span><br><span class="line">    val heapDumper &#x3D; AndroidHeapDumper(application, leakDirectoryProvider)</span><br><span class="line">    &#x2F;&#x2F; GC触发器</span><br><span class="line">    val gcTrigger &#x3D; GcTrigger.Default</span><br><span class="line">    </span><br><span class="line">    val configProvider &#x3D; &#123; LeakCanary.config &#125;</span><br><span class="line">    &#x2F;&#x2F; 相关线程 handler</span><br><span class="line">    val handlerThread &#x3D; HandlerThread(LEAK_CANARY_THREAD_NAME)</span><br><span class="line">    handlerThread.start()</span><br><span class="line">    val backgroundHandler &#x3D; Handler(handlerThread.looper)</span><br><span class="line">    &#x2F;&#x2F; Heap Dump 触发器</span><br><span class="line">    heapDumpTrigger &#x3D; HeapDumpTrigger(</span><br><span class="line">       application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,</span><br><span class="line">       configProvider</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="监控流程"><a href="#监控流程" class="headerlink" title="监控流程"></a>监控流程</h5><p>以Activity.onDestory为例<br>ActivityDestroyWatcher.lifecycleCallbacks</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private val lifecycleCallbacks &#x3D;</span><br><span class="line">  object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">    override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">      if (configProvider().watchActivities) &#123;</span><br><span class="line">          &#x2F;&#x2F; 开始监控 销毁的activity</span><br><span class="line">        objectWatcher.watch(activity, &quot;Activity received Activity#onDestroy() callback&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ObjectWatcher.watch</span><br></pre></td></tr></table></figure>
<p>  @Synchronized fun watch(<br>    watchedObject: Any,<br>    description: String<br>  ) {<br>    // 移除已经回收的监听对象<br>    removeWeaklyReachableObjects()<br>    // 随机key<br>    val key = UUID.randomUUID()<br>        .toString()<br>    val watchUptimeMillis = clock.uptimeMillis()<br>    // 构造KeyedWeakReference 用来监听目标对象<br>    val reference =<br>      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)<br>    // 存储 key + reference<br>    watchedObjects[key] = reference<br>    checkRetainedExecutor.execute {<br>        // 执行 没有回收流程<br>      moveToRetained(key)<br>    }<br>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ObjectWatcher.moveToRetained</span><br></pre></td></tr></table></figure>
<p>  @Synchronized private fun moveToRetained(key: String) {<br>    // 再次移除被回收的对象<br>    removeWeaklyReachableObjects()<br>    val retainedRef = watchedObjects[key]<br>    // 如果没有被回收 则开始执行对象未被回收流程<br>    if (retainedRef != null) {<br>      retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>      onObjectRetainedListeners.forEach { it.onObjectRetained() }<br>    }<br>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">HeapDumpTrigger</span><br></pre></td></tr></table></figure>
<p>  override fun onObjectRetained() {<br>    if (this::heapDumpTrigger.isInitialized) {<br>      heapDumpTrigger.onObjectRetained()<br>    }<br>  }</p>
<p>  fun onObjectRetained() {<br>    scheduleRetainedObjectCheck(“found new object retained”)<br>  }</p>
<p>  private fun scheduleRetainedObjectCheck(reason: String) {<br>    checkScheduled = true<br>    backgroundHandler.post {<br>      checkScheduled = false<br>      checkRetainedObjects(reason)<br>    }<br>  }</p>
<p>private fun checkRetainedObjects(reason: String) {<br>    val config = configProvider()<br>    // A tick will be rescheduled when this is turned back on.<br>    if (!config.dumpHeap) {<br>      SharkLog.d { “No checking for retained object: LeakCanary.Config.dumpHeap is false” }<br>      return<br>    }<br>    SharkLog.d { “Checking retained object because $reason” }</p>
<pre><code>var retainedReferenceCount = objectWatcher.retainedObjectCount
// 如果还有未被回收的目标对象，则出发GC，
if (retainedReferenceCount &gt; 0) {
  gcTrigger.runGc()
  retainedReferenceCount = objectWatcher.retainedObjectCount
}

if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return

// 触发GC后，对象仍未被回收，开始dump
dumpHeap(retainedReferenceCount, retry = true)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HeapDumpTrigger.dumpHeap</span><br></pre></td></tr></table></figure>
<p>  private fun dumpHeap(<br>    retainedReferenceCount: Int,<br>    retry: Boolean<br>  ) {<br>    // 储存Android 的资源id 及其对应的name<br>    saveResourceIdNamesToMemory()<br>    val heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    // dumpHeap 到file<br>    val heapDumpFile = heapDumper.dumpHeap()</p>
<pre><code>lastDisplayedRetainedObjectCount = 0
objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
// 启动service 开始dump分析
HeapAnalyzerService.runAnalysis(application, heapDumpFile)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AndroidHeapDumper.dumpHeap</span><br></pre></td></tr></table></figure>
<p> override fun dumpHeap(): File? {<br>    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null<br>    …<br>    // 调用Debug的dumpHprofData 到目标文件<br>    return Debug.dumpHprofData(heapDumpFile.absolutePath)<br>             heapDumpFile<br>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 分析流程</span><br><span class="line"></span><br><span class="line">HeapAnalyzerService.onHandleIntentInForeground</span><br></pre></td></tr></table></figure>
<p>  override fun onHandleIntentInForeground(intent: Intent?) {<br>    // 获取目标 heap dump file<br>     val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File<br>    // 构造 heap分析器<br>    val heapAnalyzer = HeapAnalyzer(this)<br>    // …<br>    // 执行分析流程<br>    val heapAnalysis =<br>      heapAnalyzer.analyze(<br>          heapDumpFile,<br>          config.referenceMatchers,<br>          config.computeRetainedHeapSize,<br>          config.objectInspectors,<br>          if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(<br>              ObjectInspectors.KEYED_WEAK_REFERENCE<br>          ),<br>          config.metatadaExtractor,<br>          proguardMappingReader?.readProguardMapping()<br>      )</p>
<pre><code>// 回调分析完成
config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HeapAnalyzer.analyze</span><br></pre></td></tr></table></figure>
<p>fun analyze(<br>    heapDumpFile: File,<br>    referenceMatchers: List<ReferenceMatcher> = emptyList(),<br>    computeRetainedHeapSize: Boolean = false,<br>    objectInspectors: List<ObjectInspector> = emptyList(),<br>    leakFinders: List<ObjectInspector> = objectInspectors,<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,<br>    proguardMapping: ProguardMapping? = null<br>  ): HeapAnalysis {<br>    val analysisStartNanoTime = System.nanoTime()</p>
<pre><code>try {
  listener.onAnalysisProgress(PARSING_HEAP_DUMP)
  // 读取 文件，然后执行分析
  Hprof.open(heapDumpFile)
      .use { hprof -&gt;
        // Hprof -&gt; graph 转换过程 目标获取GcRoots index
        val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)

        listener.onAnalysisProgress(EXTRACTING_METADATA)
        // 获取Android相关 metadata （如sdk版本、收集厂商等信息）
        val metadata = metadataExtractor.extractMetadata(graph)

        val findLeakInput = FindLeakInput(
            graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors
        )
        // 找泄漏最短路径
        val (applicationLeaks, libraryLeaks) = findLeakInput.findLeaks()
        listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
        // 返回分析成功结果
        return HeapAnalysisSuccess(
            heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime), metadata,
            applicationLeaks, libraryLeaks
        )
      }

}</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HeapAnalyzer.findLeaks</span><br></pre></td></tr></table></figure>
<p>  private fun FindLeakInput.findLeaks(): Pair&lt;List<ApplicationLeak>, List<LibraryLeak>&gt; {<br>    // 找未被回收对象的 objectId<br>    val leakingInstanceObjectIds = findRetainedObjects()<br>    // 构造pathFinder对象<br>    val pathFinder = PathFinder(graph, listener, referenceMatchers)<br>    val pathFindingResults =<br>    // ⚠️ 找泄漏对象到GcRoots的最短路径<br>    pathFinder.findPathsFromGcRoots(leakingInstanceObjectIds, computeRetainedHeapSize)</p>
<p>   // 返回 泄漏路径<br>    return buildLeakTraces(pathFindingResults)<br>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PathFinder.findPatchsFromGcRoots</span><br></pre></td></tr></table></figure>
<p>  fun findPathsFromGcRoots(<br>    leakingObjectIds: Set<Long>,<br>    computeRetainedHeapSize: Boolean<br>  ): PathFindingResults {<br>    listener.onAnalysisProgress(FINDING_PATHS_TO_RETAINED_OBJECTS)</p>
<pre><code>val sizeOfObjectInstances = determineSizeOfObjectInstances(graph)

val state = State(leakingObjectIds, sizeOfObjectInstances, computeRetainedHeapSize)
// 执行 state。findPathsFromGcRoots
return state.findPathsFromGcRoots()</code></pre><p>  }</p>
<p>  private fun State.findPathsFromGcRoots(): PathFindingResults {<br>    // GcRoots 生成节点队列树<br>    enqueueGcRoots()</p>
<pre><code>val shortestPathsToLeakingObjects = mutableListOf&lt;ReferencePathNode&gt;()
visitingQueue@ while (queuesNotEmpty) {
  val node = poll() // 循环取node

    // 泄漏的节点，则添加到shortestPathsToLeakingObjects 直到，全部找完 
  if (node.objectId in leakingObjectIds) {
    shortestPathsToLeakingObjects.add(node)
    // Found all refs, stop searching (unless computing retained size)
    if (shortestPathsToLeakingObjects.size == leakingObjectIds.size) {
      if (computeRetainedHeapSize) {
        listener.onAnalysisProgress(FINDING_DOMINATORS)
      } else {
        break@visitingQueue
      }
    }
  }
}
return PathFindingResults(shortestPathsToLeakingObjects, dominatedObjectIds)</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 呈现流程</span><br><span class="line"></span><br><span class="line">DefaultOnHeapAnalyzedListener.onHeapAnalyzed</span><br></pre></td></tr></table></figure>
<p>  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {<br>    // 写入 db<br>    val (id, groupProjections) = LeaksDbHelper(application)<br>        .writableDatabase.use { db -&gt;<br>      val id = HeapAnalysisTable.insert(db, heapAnalysis)<br>      id to LeakTable.retrieveHeapDumpLeaks(db, id)<br>    }</p>
<pre><code>// 生成 泄漏信息到屏幕展示
val (contentTitle, screenToShow) = when (heapAnalysis) {
  is HeapAnalysisFailure -&gt; application.getString(
      R.string.leak_canary_analysis_failed
  ) to HeapAnalysisFailureScreen(id)
  is HeapAnalysisSuccess -&gt; {
    var leakCount = 0
    var newLeakCount = 0
    var knownLeakCount = 0
    var libraryLeakCount = 0

    for ((_, projection) in groupProjections) {
      leakCount += projection.leakCount
      when {
        projection.isLibraryLeak -&gt; libraryLeakCount += projection.leakCount
        projection.isNew -&gt; newLeakCount += projection.leakCount
        else -&gt; knownLeakCount += projection.leakCount
      }
    }

    application.getString(
        R.string.leak_canary_analysis_success_notification, leakCount, newLeakCount,
        knownLeakCount, libraryLeakCount
    ) to HeapDumpScreen(id)
  }
}

val pendingIntent = LeakActivity.createPendingIntent(
    application, arrayListOf(HeapDumpsScreen(), screenToShow)
)

val contentText = application.getString(R.string.leak_canary_notification_message)
// 构建通知
Notifications.showNotification(
    application, contentTitle, contentText, pendingIntent,
    R.id.leak_canary_notification_analysis_result,
    LEAKCANARY_MAX
)</code></pre><p>  }</p>
<pre><code>


---
![](https://upload-images.jianshu.io/upload_images/9696036-70673e2d55e85b18.gif?imageMogr2/auto-orient/strip)

</code></pre>]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>LeakCanary</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统_Surface渲染过程分析（软件绘制）</title>
    <url>/blog/2019/12/08/Android%E7%B3%BB%E7%BB%9F_Surface%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>基于API 23</p>
</blockquote>
<p>前篇：<a href="https://www.jianshu.com/p/956db9044cd8" target="_blank" rel="noopener">Android系统_Surface创建流程分析</a></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884359400748.png"  alt=""></p>
<h3 id="申请Buffer"><a href="#申请Buffer" class="headerlink" title="申请Buffer"></a>申请Buffer</h3><h4 id="ViewRootImpl-draw"><a href="#ViewRootImpl-draw" class="headerlink" title="ViewRootImpl.draw"></a>ViewRootImpl.draw</h4><p>执行遍历 &gt; 执行Draw &gt; draw方法 &gt; 软件绘制流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private void performTraversals() &#123;</span><br><span class="line">    ...</span><br><span class="line">    relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">    ...</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    ...         </span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    ...</span><br><span class="line">    performDraw();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void performDraw() &#123;</span><br><span class="line">    draw(fullRedrawNeeded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        &#x2F;&#x2F; 硬件加速 ，绘制绘制流程</span><br><span class="line">        if (mAttachInfo.mHardwareRenderer !&#x3D; null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">             ...</span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">           &#x2F;&#x2F; 软件绘制 流程</span><br><span class="line">            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewRootImpl-drawSoftware"><a href="#ViewRootImpl-drawSoftware" class="headerlink" title="ViewRootImpl.drawSoftware"></a>ViewRootImpl.drawSoftware</h4><p>主要三个步骤 申请Buffer、绘制、绘制完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo,...) &#123;</span><br><span class="line">    &#x2F;&#x2F; Draw with software renderer.</span><br><span class="line">    final Canvas canvas;</span><br><span class="line">    ...</span><br><span class="line">    canvas &#x3D; mSurface.lockCanvas(dirty);  &#x2F;&#x2F;申请Buffer</span><br><span class="line">    ...</span><br><span class="line">    mView.draw(canvas);  &#x2F;&#x2F;绘制</span><br><span class="line">    ...</span><br><span class="line">    mSurface.unlockCanvasAndPost(canvas);  &#x2F;&#x2F;绘制完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-lockCanvas"><a href="#Surface-lockCanvas" class="headerlink" title="Surface.lockCanvas"></a>Surface.lockCanvas</h4><p>执行JNI层的nativeLockCanvas，mNativeObject就是native层Surface指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Canvas lockCanvas(Rect inOutDirty)</span><br><span class="line">       throws Surface.OutOfResourcesException, IllegalArgumentException &#123;</span><br><span class="line">   synchronized (mLock) &#123;</span><br><span class="line">       checkNotReleasedLocked();</span><br><span class="line">       </span><br><span class="line">       mLockedObject &#x3D; nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">       return mCanvas;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="android-view-Surface-cpp"><a href="#android-view-Surface-cpp" class="headerlink" title="android_view_Surface.cpp"></a>android_view_Surface.cpp</h4><p>创建一个Rect对象，确定要重绘制的区域，执行Surface的lock方法来申请bugger，然后新建了一个SKBitmap，设置了内存地址，并把这个bitmap放入了Canvas中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static jlong nativeLockCanvas(JNIEnv* env, jclass clazz,jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123;</span><br><span class="line">    sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject)); &#x2F;&#x2F;转换指针</span><br><span class="line">    ...</span><br><span class="line">    Rect dirtyRect;</span><br><span class="line">    Rect* dirtyRectPtr &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    if (dirtyRectObj) &#123;</span><br><span class="line">        dirtyRect.left   &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">        dirtyRect.top    &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">        dirtyRect.right  &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">        dirtyRect.bottom &#x3D; env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">        dirtyRectPtr &#x3D; &amp;dirtyRect;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 申请内存Buffer</span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    status_t err &#x3D; surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    SkImageInfo info &#x3D; SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                     convertPixelFormat(outBuffer.format),</span><br><span class="line">                                     kPremul_SkAlphaType);               </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 新建一个SkBitmap 并进行一系列设置</span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    ssize_t bpr &#x3D; outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">    bitmap.setInfo(info, bpr);</span><br><span class="line">    if (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123;</span><br><span class="line">        bitmap.setPixels(outBuffer.bits);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; be safe with an empty bitmap.</span><br><span class="line">        bitmap.setPixels(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 把创建的bitmap 设置到Canvas中</span><br><span class="line">    Canvas* nativeCanvas &#x3D; GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;setBitmap(bitma</span><br><span class="line">    if (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">                dirtyRect.right, dirtyRect.bottom);</span><br><span class="line">    </span><br><span class="line">    if (dirtyRectObj) &#123;</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">        env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Create another reference to the surface and return it.  This reference</span><br><span class="line">    &#x2F;&#x2F; should be passed to nativeUnlockCanvasAndPost in place of mNativeObject,</span><br><span class="line">    &#x2F;&#x2F; because the latter could be replaced while the surface is locked.</span><br><span class="line">    sp&lt;Surface&gt; lockedSurface(surface);</span><br><span class="line">    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    return (jlong) lockedSurface.get();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-cpp"><a href="#Surface-cpp" class="headerlink" title="Surface.cpp"></a>Surface.cpp</h4><p>通过dequeueBuffer获取一个ANativeWindowBuffer，之后构造一个GraphicBuffer，这个bugger用来传递绘制的元数据<br>BufferQueueProducer中dequeueBuffer，将分配的内存放到mSlots中，outSlot就是给应用进程mSlots的序号<br>BufferQueueProducer中requestBuffer，根据序号，从mSlots拿到buffer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_t Surface::lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)&#123;</span><br><span class="line"></span><br><span class="line">    ANativeWindowBuffer* out; int fenceFd &#x3D; -1;</span><br><span class="line">    status_t err &#x3D; dequeueBuffer(&amp;out, &amp;fenceFd);  &#x2F;&#x2F;从 GraphicBufferProduce 中 拿出来一个 buffer </span><br><span class="line">    </span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));&#x2F;&#x2F;放到backBuffer中</span><br><span class="line">        const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height);</span><br><span class="line"> </span><br><span class="line">        .......</span><br><span class="line"> </span><br><span class="line">        void* vaddr;</span><br><span class="line">        status_t res &#x3D; backBuffer-&gt;lockAsync(&#x2F;&#x2F;把buffer的handle中的地址传到vaddr中</span><br><span class="line">                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">                newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line"> </span><br><span class="line">        if (res !&#x3D; 0) &#123;</span><br><span class="line">            err &#x3D; INVALID_OPERATION;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLockedBuffer &#x3D; backBuffer;</span><br><span class="line">            outBuffer-&gt;width  &#x3D; backBuffer-&gt;width;</span><br><span class="line">            outBuffer-&gt;height &#x3D; backBuffer-&gt;height;</span><br><span class="line">            outBuffer-&gt;stride &#x3D; backBuffer-&gt;stride;</span><br><span class="line">            outBuffer-&gt;format &#x3D; backBuffer-&gt;format;</span><br><span class="line">            outBuffer-&gt;bits   &#x3D; vaddr;&#x2F;&#x2F;buffer地址</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return err &#x2F;&#x2F; 返回GraphicBuffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    status_t result &#x3D; mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,</span><br><span class="line">                                                            reqFormat, reqUsage, &amp;mBufferAge,</span><br><span class="line">                                                            enableFrameTimestamps ? &amp;frameTimestamps</span><br><span class="line">                                                                                  : nullptr);</span><br><span class="line">                                                                                  </span><br><span class="line">                                                                        </span><br><span class="line">     if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        result &#x3D; mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);&#x2F;&#x2F;根据需要拿到buffer</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line">    *buffer &#x3D; gbuf.get();</span><br><span class="line">    </span><br><span class="line">    return OK;                                                                            </span><br><span class="line">                                                                                                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="View绘制"><a href="#View绘制" class="headerlink" title="View绘制"></a>View绘制</h3><h4 id="View-draw"><a href="#View-draw" class="headerlink" title="View.draw"></a>View.draw</h4><p>执行<a href="https://www.jianshu.com/p/9b759b4a1aa5" target="_blank" rel="noopener">View的绘制流程</a><br>下面看常见的 canvas.drawRect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void drawRect(float left, float top, float right, float bottom, @NonNull Paint paint) &#123;</span><br><span class="line">   native_drawRect(mNativeCanvasWrapper, left, top, right, bottom, paint.getNativeInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="android-graphics-Canvas-cpp"><a href="#android-graphics-Canvas-cpp" class="headerlink" title="android_graphics_Canvas.cpp"></a>android_graphics_Canvas.cpp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static void drawRect(JNIEnv* env, jobject, jlong canvasHandle, jfloat left, jfloat top,</span><br><span class="line">                     jfloat right, jfloat bottom, jlong paintHandle) &#123;</span><br><span class="line">    const Paint* paint &#x3D; reinterpret_cast&lt;Paint*&gt;(paintHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawRect(left, top, right, bottom, *paint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SkiaCanvas-drawRect"><a href="#SkiaCanvas-drawRect" class="headerlink" title="SkiaCanvas.drawRect"></a>SkiaCanvas.drawRect</h4><p>执行Skia库的绘制方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SkiaCanvas::drawRect(float left, float top, float right, float bottom,</span><br><span class="line">        const SkPaint&amp; paint) &#123;</span><br><span class="line">    mCanvas-&gt;drawRectCoords(left, top, right, bottom, paint);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SkCanvas-drawRectCoords"><a href="#SkCanvas-drawRectCoords" class="headerlink" title="SkCanvas.drawRectCoords"></a>SkCanvas.drawRectCoords</h4><p>执行 到SkBitmap写入Buffer数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void SkCanvas::drawRectCoords(SkScalar left, SkScalar top,</span><br><span class="line">                              SkScalar right, SkScalar bottom,</span><br><span class="line">                              const SkPaint&amp; paint) &#123;</span><br><span class="line">    TRACE_EVENT0(&quot;disabled-by-default-skia&quot;, &quot;SkCanvas::drawRectCoords()&quot;);</span><br><span class="line">    SkRect  r;</span><br><span class="line"> </span><br><span class="line">    r.set(left, top, right, bottom);</span><br><span class="line">    this-&gt;drawRect(r, paint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SkCanvas::DrawRect(const SkDraw&amp; draw, const SkPaint&amp; paint,</span><br><span class="line">                        const SkRect&amp; r, SkScalar textSize) &#123;</span><br><span class="line">    if (paint.getStyle() &#x3D;&#x3D; SkPaint::kFill_Style) &#123;</span><br><span class="line">        &#x2F;&#x2F; fDevice 即SKBitmap ，从而实现将数据写入buffer</span><br><span class="line">        draw.fDevice-&gt;drawRect(draw, r, paint);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        SkPaint p(paint);</span><br><span class="line">        p.setStrokeWidth(SkScalarMul(textSize, paint.getStrokeWidth()));</span><br><span class="line">        draw.fDevice-&gt;drawRect(draw, r, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="View绘制完成后通知刷新"><a href="#View绘制完成后通知刷新" class="headerlink" title="View绘制完成后通知刷新"></a>View绘制完成后通知刷新</h3><h4 id="Surface-unlockCanvasAndPost-canvas"><a href="#Surface-unlockCanvasAndPost-canvas" class="headerlink" title="Surface.unlockCanvasAndPost(canvas)"></a>Surface.unlockCanvasAndPost(canvas)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void unlockCanvasAndPost(Canvas canvas) &#123;</span><br><span class="line">   synchronized (mLock) &#123;</span><br><span class="line">       checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">       if (mHwuiContext !&#x3D; null) &#123;</span><br><span class="line">           mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 走软件绘制流程</span><br><span class="line">           unlockSwCanvasAndPost(canvas);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="android-view-Surface-nativeUnlockCanvasAndPost"><a href="#android-view-Surface-nativeUnlockCanvasAndPost" class="headerlink" title="android_view.Surface.nativeUnlockCanvasAndPost"></a>android_view.Surface.nativeUnlockCanvasAndPost</h4><p>设置一个空的SkBitmap<br>然后执行Surface的unlockANdPost函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void unlockSwCanvasAndPost(Canvas canvas) &#123;</span><br><span class="line">   if (canvas !&#x3D; mCanvas) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;canvas object must be the same instance that &quot;</span><br><span class="line">               + &quot;was previously returned by lockCanvas&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   if (mNativeObject !&#x3D; mLockedObject) &#123;</span><br><span class="line">       Log.w(TAG, &quot;WARNING: Surface&#39;s mNativeObject (0x&quot; +</span><br><span class="line">               Long.toHexString(mNativeObject) + &quot;) !&#x3D; mLockedObject (0x&quot; +</span><br><span class="line">               Long.toHexString(mLockedObject) +&quot;)&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   if (mLockedObject &#x3D;&#x3D; 0) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Surface was not locked&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">       nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       nativeRelease(mLockedObject);</span><br><span class="line">       mLockedObject &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-cpp-unlockAndPost"><a href="#Surface-cpp-unlockAndPost" class="headerlink" title="Surface.cpp.unlockAndPost"></a>Surface.cpp.unlockAndPost</h4><p>解除buffer锁定，执行queueBuffer最后执行到GraphicBufferProducer的queueBuffer函数，将buffer清除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_t Surface::unlockAndPost()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    int fd &#x3D; -1;</span><br><span class="line">    status_t err &#x3D; mLockedBuffer-&gt;unlockAsync(&amp;fd);&#x2F;&#x2F;通过Gralloc模块，最后是操作的ioctl</span><br><span class="line">     </span><br><span class="line">    err &#x3D; queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"> </span><br><span class="line">    mPostedBuffer &#x3D; mLockedBuffer;</span><br><span class="line">    mLockedBuffer &#x3D; 0;</span><br><span class="line">    return err;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Surface-queueBuffer"><a href="#Surface-queueBuffer" class="headerlink" title="Surface.queueBuffer"></a>Surface.queueBuffer</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 获取Slot数组保存的buffer</span><br><span class="line">    int i &#x3D; getSlotFromBufferLocked(buffer); </span><br><span class="line">    ..</span><br><span class="line">    IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">    IGraphicBufferProducer::QueueBufferInput input(timestamp, isAutoTimestamp,</span><br><span class="line">            static_cast&lt;android_dataspace&gt;(mDataSpace), crop, mScalingMode,</span><br><span class="line">            mTransform ^ mStickyTransform, fence, mStickyTransform,</span><br><span class="line">            mEnableFrameTimestamps);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 插入buffer</span><br><span class="line">    status_t err &#x3D; mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output); </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 通知</span><br><span class="line">    mQueueBufferCondition.broadcast();</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mSlog集合为按照顺序保存GraphicBuffer的数组</span><br><span class="line">int Surface::getSlotFromBufferLocked(android_native_buffer_t* buffer) const &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; NUM_BUFFER_SLOTS; i++) &#123;</span><br><span class="line">        if (mSlots[i].buffer !&#x3D; NULL &amp;&amp; mSlots[i].buffer-&gt;handle &#x3D;&#x3D; buffer-&gt;handle) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return BAD_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BufferQueueProducer-cpp-queueBuffer"><a href="#BufferQueueProducer-cpp-queueBuffer" class="headerlink" title="BufferQueueProducer.cpp.queueBuffer"></a>BufferQueueProducer.cpp.queueBuffer</h4><p>根据输入参数完善一个BufferItem，然后通知frameAvailabel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_t BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) &#123; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从input中获取一些列参数</span><br><span class="line">    input.deflate(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace,</span><br><span class="line">        &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform,</span><br><span class="line">        &amp;getFrameTimestamps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sp&lt;IConsumerListener&gt; frameAvailableListener;</span><br><span class="line">    sp&lt;IConsumerListener&gt; frameReplacedListener;</span><br><span class="line">    BufferItem item; &#x2F;&#x2F;一个待渲染的帧</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;item的一系列赋值操作</span><br><span class="line"></span><br><span class="line">    item.mAcquireCalled &#x3D; mSlots[slot].mAcquireCalled; </span><br><span class="line">    item.mGraphicBuffer &#x3D; mSlots[slot].mGraphicBuffer; &#x2F;&#x2F;根据slot获取GraphicBuffer。</span><br><span class="line">    item.mCrop &#x3D; crop;</span><br><span class="line">    item.mTransform &#x3D; transform &amp;</span><br><span class="line">            ~static_cast&lt;uint32_t&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);</span><br><span class="line">    item.mTransformToDisplayInverse &#x3D;</span><br><span class="line">            (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) !&#x3D; 0;</span><br><span class="line">    item.mScalingMode &#x3D; static_cast&lt;uint32_t&gt;(scalingMode);</span><br><span class="line">    item.mTimestamp &#x3D; requestedPresentTimestamp;</span><br><span class="line">    item.mIsAutoTimestamp &#x3D; isAutoTimestamp;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (frameAvailableListener !&#x3D; NULL) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item); &#x2F;&#x2F;item是一个frame，准备完毕，要通知外界</span><br><span class="line">    &#125; else if (frameReplacedListener !&#x3D; NULL) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addAndGetFrameTimestamps(&amp;newFrameEventsEntry,etFrameTimestamps ? &amp;output-&gt;frameTimestamps : nullptr);</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BufferLayer-cpp"><a href="#BufferLayer-cpp" class="headerlink" title="BufferLayer.cpp"></a>BufferLayer.cpp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BufferLayer::onFrameAvailable(const BufferItem&amp; item) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SurfaceFlinger-cpp"><a href="#SurfaceFlinger-cpp" class="headerlink" title="SurfaceFlinger.cpp"></a>SurfaceFlinger.cpp</h4><p>执行SurfaceFlinger的invalidate方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">    mEventQueue-&gt;invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>————————————————————————————————————<br><strong>推荐阅读</strong>：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Surface</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统_SurfaceFlinger分析</title>
    <url>/blog/2019/12/01/Android%E7%B3%BB%E7%BB%9F_SurfaceFlinger%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>基于API 23</p>
</blockquote>
<p>SurfaceFlinger，合成抛射机，它在Android系统是一个独立的服务进程<br>它的作用是接受多个来源的图形显示数据，将他们合成，然后发送到显示设备。<br>它的工作内容主要包括合成的创建和管理、Vsync信号的处理<br>本文分析SurfaceFlinger的启动流程，和Vsync信号的处理流程</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884359629340.png"  alt=""></p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>SurfaceFlinger 进程是由 init 进程创建的，运行在独立的 SurfaceFlinger 进程中。init 进程读取 init.rc 文件启动 SurfaceFlinger。首先来看main方法</p>
<h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><ul>
<li>设定线程池上线4，并启动binder线程池</li>
<li>创建SF对象</li>
<li>初始化SF</li>
<li>执行SF的run方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int, char**) &#123;</span><br><span class="line">    &#x2F;&#x2F;设定surfaceflinger进程的binder线程池个数上限为4，并启动binder线程池</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);</span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;实例化surfaceflinger</span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger &#x3D;  new SurfaceFlinger();</span><br><span class="line"></span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(0, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将服务注册到Service Manager</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 运行在当前线程</span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>继承BnSurfaceCompose<br>构造过程仅仅初始化了SurfaceFlinger的成员变量，同时调用了父类BnSurfaceComposer的构造函数。最后执行onFirstRef 走init方法来作一些初始化工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SurfaceFlinger::SurfaceFlinger()</span><br><span class="line">    :   BnSurfaceComposer(),</span><br><span class="line">        mTransactionFlags(0),</span><br><span class="line">        mTransactionPending(false),</span><br><span class="line">        mAnimTransactionPending(false),</span><br><span class="line">        mLayersRemoved(false),</span><br><span class="line">        mRepaintEverything(0),</span><br><span class="line">        mRenderEngine(NULL),</span><br><span class="line">        mBootTime(systemTime()),</span><br><span class="line">        mVisibleRegionsDirty(false),</span><br><span class="line">        mHwWorkListDirty(false),</span><br><span class="line">        mAnimCompositionPending(false),</span><br><span class="line">        mDebugRegion(0),</span><br><span class="line">        mDebugDDMS(0),</span><br><span class="line">        mDebugDisableHWC(0),</span><br><span class="line">        mDebugDisableTransformHint(0),</span><br><span class="line">        mDebugInSwapBuffers(0),</span><br><span class="line">        mLastSwapBufferTime(0),</span><br><span class="line">        mDebugInTransaction(0),</span><br><span class="line">        mLastTransactionTime(0),</span><br><span class="line">        mBootFinished(false),</span><br><span class="line">        mForceFullDamage(false),</span><br><span class="line">        mPrimaryHWVsyncEnabled(false),</span><br><span class="line">        mHWVsyncAvailable(false),</span><br><span class="line">        mDaltonize(false),</span><br><span class="line">        mHasColorMatrix(false),</span><br><span class="line">        mHasPoweredOff(false),</span><br><span class="line">        mFrameBuckets(),</span><br><span class="line">        mTotalTime(0),</span><br><span class="line">        mLastSwapTime(0)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(&quot;SurfaceFlinger is starting&quot;);</span><br><span class="line">    char value[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">    property_get(&quot;ro.bq.gpu_to_cpu_unsupported&quot;, value, &quot;0&quot;);</span><br><span class="line">    mGpuToCpuSupported &#x3D; !atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(&quot;debug.sf.showupdates&quot;, value, &quot;0&quot;);</span><br><span class="line">    mDebugRegion &#x3D; atoi(value);</span><br><span class="line"></span><br><span class="line">    property_get(&quot;debug.sf.ddms&quot;, value, &quot;0&quot;);</span><br><span class="line">    mDebugDDMS &#x3D; atoi(value);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-onFirstRef"><a href="#SF-onFirstRef" class="headerlink" title="SF.onFirstRef"></a>SF.onFirstRef</h4><p>由于SurfaceFlinger继承于RefBase类，同时实现了RefBase的onFirstRef()方法，因此在第一次引用SurfaceFlinger对象时，onFirstRef()函数自动被调用。初始化MessageQueue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    mEventQueue.init(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>messageQueue对象的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">&#123;</span><br><span class="line">    mFlinger &#x3D; flinger;</span><br><span class="line">    mLooper &#x3D; new Looper(true);</span><br><span class="line">    mHandler &#x3D; new Handler(*this); </span><br><span class="line">&#125;</span><br><span class="line">class MessageQueue &#123;</span><br><span class="line">    class Handler : public MessageHandler &#123;</span><br><span class="line">        enum &#123;</span><br><span class="line">            eventMaskInvalidate     &#x3D; 0x1,</span><br><span class="line">            eventMaskRefresh        &#x3D; 0x2,</span><br><span class="line">            eventMaskTransaction    &#x3D; 0x4</span><br><span class="line">        &#125;;</span><br><span class="line">        MessageQueue&amp; mQueue;</span><br><span class="line">        int32_t mEventMask;</span><br><span class="line">    public:</span><br><span class="line">        Handler(MessageQueue&amp; queue) : mQueue(queue), mEventMask(0) &#123; &#125;</span><br><span class="line">        virtual void handleMessage(const Message&amp; message);</span><br><span class="line">        void dispatchRefresh();</span><br><span class="line">        void dispatchInvalidate();</span><br><span class="line">        void dispatchTransaction();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceFlinger-init"><a href="#SurfaceFlinger-init" class="headerlink" title="SurfaceFlinger.init"></a>SurfaceFlinger.init</h4><ul>
<li>初始化 EGL</li>
<li>创建 HWComposer</li>
<li>初始化非虚拟显示屏</li>
<li>启动 EventThread 线程</li>
<li>启动开机动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化EGL，作为默认的显示</span><br><span class="line">    mEGLDisplay &#x3D; eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化硬件composer对象</span><br><span class="line">    mHwc &#x3D; new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取RenderEngine引擎</span><br><span class="line">    mRenderEngine &#x3D; RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建的EGL上下文</span><br><span class="line">    mEGLContext &#x3D; mRenderEngine-&gt;getEGLContext();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化非虚拟显示屏</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        &#x2F;&#x2F;建立已连接的显示设备</span><br><span class="line">        if (mHwc-&gt;isConnected(i) || type&#x3D;&#x3D;DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            bool isSecure &#x3D; true;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token &#x3D; mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            &#x2F;&#x2F;创建BufferQueue的生产者和消费者</span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    new GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs &#x3D; new FramebufferSurface(*mHwc, i, consumer);</span><br><span class="line">            int32_t hwcId &#x3D; allocateHwcDisplayId(type);</span><br><span class="line">            &#x2F;&#x2F;创建显示设备</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw &#x3D; new DisplayDevice(this,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当应用和sf的vsync偏移量一致时，则只创建一个EventThread线程</span><br><span class="line">    if (vsyncPhaseOffsetNs !&#x3D; sfVsyncPhaseOffsetNs) &#123;</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;app&quot;);</span><br><span class="line">        mEventThread &#x3D; new EventThread(vsyncSrc);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, true, &quot;sf&quot;);</span><br><span class="line">        mSFEventThread &#x3D; new EventThread(sfVsyncSrc);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;创建DispSyncSource对象</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;sf-app&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建线程EventThread </span><br><span class="line">        mEventThread &#x3D; new EventThread(vsyncSrc);</span><br><span class="line">        &#x2F;&#x2F;设置EventThread </span><br><span class="line">        mEventQueue.setEventThread(mEventThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建EventControl</span><br><span class="line">    mEventControlThread &#x3D; new EventControlThread(this);</span><br><span class="line">    mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当不存在HWComposer时，则设置软件vsync</span><br><span class="line">    if (mHwc-&gt;initCheck() !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        mPrimaryDispSync.setPeriod(16666667);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化绘图状态</span><br><span class="line">    mDrawingState &#x3D; mCurrentState;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化显示设备</span><br><span class="line">    initializeDisplays();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动开机动画</span><br><span class="line">    startBootAnim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HWComposer构建"><a href="#HWComposer构建" class="headerlink" title="HWComposer构建"></a>HWComposer构建</h4><p>HWComposer代表着硬件显示设备，注册了VSYNC信号的回调。VSYNC信号本身是由显示驱动产生的， 在不支持硬件的VSYNC，则会创建“VSyncThread”线程来模拟定时VSYNC信号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HWComposer::HWComposer(</span><br><span class="line">        const sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(0), mHwc(0), mNumDisplays(1),</span><br><span class="line">      mCBContext(new cb_context),</span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(false)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    bool needVSyncThread &#x3D; true;</span><br><span class="line">    int fberr &#x3D; loadFbHalModule(); &#x2F;&#x2F;加载framebuffer的HAL层模块</span><br><span class="line">    loadHwcModule(); &#x2F;&#x2F;加载HWComposer模块</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记已分配的display ID</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;</span><br><span class="line">        mAllocatedDisplayIDs.markBit(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mHwc) &#123;</span><br><span class="line">        if (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            mCBContext-&gt;hwc &#x3D; this;</span><br><span class="line">            mCBContext-&gt;procs.invalidate &#x3D; &amp;hook_invalidate;</span><br><span class="line">            &#x2F;&#x2F;VSYNC信号的回调方法</span><br><span class="line">            mCBContext-&gt;procs.vsync &#x3D; &amp;hook_vsync;</span><br><span class="line">            if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                mCBContext-&gt;procs.hotplug &#x3D; &amp;hook_hotplug;</span><br><span class="line">            else</span><br><span class="line">                mCBContext-&gt;procs.hotplug &#x3D; NULL;</span><br><span class="line">            memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero));</span><br><span class="line">            &#x2F;&#x2F;注册回调函数</span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;进入此处，说明已成功打开硬件composer设备，则不再需要vsync线程</span><br><span class="line">        needVSyncThread &#x3D; false;</span><br><span class="line">        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (needVSyncThread) &#123;</span><br><span class="line">        &#x2F;&#x2F;不支持硬件的VSYNC，则会创建线程来模拟定时VSYNC信号</span><br><span class="line">        mVSyncThread &#x3D; new VSyncThread(*this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化显示设备"><a href="#初始化显示设备" class="headerlink" title="初始化显示设备"></a>初始化显示设备</h4><p>创建IGraphicBufferProducer和IGraphicBufferConsumer，以及FramebufferSurface，DisplayDevice对象。另外， 显示设备有3类：主设备，扩展设备，虚拟设备。其中前两个都是内置显示设备，故NUM_BUILTIN_DISPLAY_TYPES=2，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        &#x2F;&#x2F;建立已连接的显示设备</span><br><span class="line">        if (mHwc-&gt;isConnected(i) || type&#x3D;&#x3D;DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            bool isSecure &#x3D; true;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token &#x3D; mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            &#x2F;&#x2F;创建BufferQueue的生产者和消费者</span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    new GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs &#x3D; new FramebufferSurface(*mHwc, i, consumer);</span><br><span class="line">            int32_t hwcId &#x3D; allocateHwcDisplayId(type);</span><br><span class="line">            &#x2F;&#x2F;创建显示设备</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw &#x3D; new DisplayDevice(this,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EventThread构造方法"><a href="#EventThread构造方法" class="headerlink" title="EventThread构造方法"></a>EventThread构造方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventThread::EventThread(const sp&lt;VSyncSource&gt;&amp; src)</span><br><span class="line">    : mVSyncSource(src),</span><br><span class="line">      mUseSoftwareVSync(false),</span><br><span class="line">      mVsyncEnabled(false),</span><br><span class="line">      mDebugVsyncEnabled(false),</span><br><span class="line">      mVsyncHintSent(false) &#123;</span><br><span class="line"></span><br><span class="line">    for (int32_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        mVSyncEvent[i].header.type &#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        mVSyncEvent[i].header.id &#x3D; 0;</span><br><span class="line">        mVSyncEvent[i].header.timestamp &#x3D; 0;</span><br><span class="line">        mVSyncEvent[i].vsync.count &#x3D;  0;</span><br><span class="line">    &#125;</span><br><span class="line">    struct sigevent se;</span><br><span class="line">    se.sigev_notify &#x3D; SIGEV_THREAD;</span><br><span class="line">    se.sigev_value.sival_ptr &#x3D; this;</span><br><span class="line">    se.sigev_notify_function &#x3D; vsyncOffCallback;</span><br><span class="line">    se.sigev_notify_attributes &#x3D; NULL;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventThread::onFirstRef() &#123;</span><br><span class="line">    &#x2F;&#x2F;运行EventThread线程</span><br><span class="line">    run(&quot;EventThread&quot;, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ET-threadLoop"><a href="#ET-threadLoop" class="headerlink" title="ET.threadLoop"></a>ET.threadLoop</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    &#x2F;&#x2F; 等待事件</span><br><span class="line">    signalConnections &#x3D; waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分发事件给所有的监听者</span><br><span class="line">    const size_t count &#x3D; signalConnections.size();</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;count ; i++) &#123;</span><br><span class="line">        const sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        &#x2F;&#x2F;传递事件【见小节3.10】</span><br><span class="line">        status_t err &#x3D; conn-&gt;postEvent(event);</span><br><span class="line">        if (err &#x3D;&#x3D; -EAGAIN || err &#x3D;&#x3D; -EWOULDBLOCK) &#123;</span><br><span class="line">            &#x2F;&#x2F;可能此时connection已满，则直接抛弃事件</span><br><span class="line">            ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;,</span><br><span class="line">                    event.header.type, conn.get());</span><br><span class="line">        &#125; else if (err &lt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;发生致命错误，则清理该连接</span><br><span class="line">            removeDisplayEventConnection(signalConnections[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ET-waitForEvent"><a href="#ET-waitForEvent" class="headerlink" title="ET.waitForEvent"></a>ET.waitForEvent</h4><p>EventThread线程，进入mCondition的wait()方法，等待唤醒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        bool eventPending &#x3D; false;</span><br><span class="line">        bool waitForVSync &#x3D; false;</span><br><span class="line"></span><br><span class="line">        size_t vsyncCount &#x3D; 0;</span><br><span class="line">        nsecs_t timestamp &#x3D; 0;</span><br><span class="line">        for (int32_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">            timestamp &#x3D; mVSyncEvent[i].header.timestamp;</span><br><span class="line">            if (timestamp) &#123;</span><br><span class="line">                *event &#x3D; mVSyncEvent[i];</span><br><span class="line">                mVSyncEvent[i].header.timestamp &#x3D; 0;</span><br><span class="line">                vsyncCount &#x3D; mVSyncEvent[i].vsync.count;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!timestamp) &#123;</span><br><span class="line">            &#x2F;&#x2F;没有vsync事件，则查看其它事件</span><br><span class="line">            eventPending &#x3D; !mPendingEvents.isEmpty();</span><br><span class="line">            if (eventPending) &#123;</span><br><span class="line">                &#x2F;&#x2F;存在其它事件可用于分发</span><br><span class="line">                *event &#x3D; mPendingEvents[0];</span><br><span class="line">                mPendingEvents.removeAt(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;查找正在等待事件的连接</span><br><span class="line">        size_t count &#x3D; mDisplayEventConnections.size();</span><br><span class="line">        for (size_t i&#x3D;0 ; i&lt;count ; i++) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection(mDisplayEventConnections[i].promote());</span><br><span class="line">            if (connection !&#x3D; NULL) &#123;</span><br><span class="line">                bool added &#x3D; false;</span><br><span class="line">                if (connection-&gt;count &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;需要vsync事件，由于至少存在一个连接正在等待vsync</span><br><span class="line">                    waitForVSync &#x3D; true;</span><br><span class="line">                    if (timestamp) &#123;</span><br><span class="line">                        if (connection-&gt;count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            connection-&gt;count &#x3D; -1;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added &#x3D; true;</span><br><span class="line">                        &#125; else if (connection-&gt;count &#x3D;&#x3D; 1 ||</span><br><span class="line">                                (vsyncCount % connection-&gt;count) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added &#x3D; true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    &#x2F;&#x2F;没有vsync事件需要处理(timestamp&#x3D;&#x3D;0),但存在pending消息</span><br><span class="line">                    signalConnections.add(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;该连接已死亡，则直接清理</span><br><span class="line">                mDisplayEventConnections.removeAt(i);</span><br><span class="line">                --i; --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            &#x2F;&#x2F;接收到VSYNC，但没有client需要它，则直接关闭VSYNC</span><br><span class="line">            disableVSyncLocked();</span><br><span class="line">        &#125; else if (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            &#x2F;&#x2F;至少存在一个client，则需要使能VSYNC</span><br><span class="line">            enableVSyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            if (waitForVSync) &#123;</span><br><span class="line">                bool softwareSync &#x3D; mUseSoftwareVSync;</span><br><span class="line">                nsecs_t timeout &#x3D; softwareSync ? ms2ns(16) : ms2ns(1000);</span><br><span class="line">                if (mCondition.waitRelative(mLock, timeout) &#x3D;&#x3D; TIMED_OUT) &#123;</span><br><span class="line">                    mVSyncEvent[0].header.type &#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[0].header.id &#x3D; DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[0].header.timestamp &#x3D; systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[0].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;不存在对vsync感兴趣的连接，即将要进入休眠</span><br><span class="line">                mCondition.wait(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (signalConnections.isEmpty());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;到此处，则保证存在timestamp以及连接</span><br><span class="line">    return signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MQ-setEvenetThread"><a href="#MQ-setEvenetThread" class="headerlink" title="MQ.setEvenetThread"></a>MQ.setEvenetThread</h4><p>设置EventThread，并监听BitTube<br>创建一个BitTube对象mEventTube<br>创建一个EventConnection</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MessageQueue::setEventThread(const sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">&#123;</span><br><span class="line">    mEventThread &#x3D; eventThread;</span><br><span class="line">    &#x2F;&#x2F;创建连接</span><br><span class="line">    mEvents &#x3D; eventThread-&gt;createEventConnection();</span><br><span class="line">    &#x2F;&#x2F;获取BitTube对象</span><br><span class="line">    mEventTube &#x3D; mEvents-&gt;getDataChannel();</span><br><span class="line">    &#x2F;&#x2F;监听BitTube，一旦有数据到来则调用cb_eventReceiver()</span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, Looper::EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-run"><a href="#SF-run" class="headerlink" title="SF.run"></a>SF.run</h4><p>主线程进入waitMessage状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::run() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;不断循环地等待事件</span><br><span class="line">        waitForEvent();</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::waitForEvent() &#123;</span><br><span class="line">    mEventQueue.waitMessage(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MessageQueue::waitMessage() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">        int32_t ret &#x3D; mLooper-&gt;pollOnce(-1);</span><br><span class="line">        ...</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Vsync信号处理"><a href="#Vsync信号处理" class="headerlink" title="Vsync信号处理"></a>Vsync信号处理</h3><p>HWComposer对象创建过程，会注册一些回调方法，当硬件产生VSYNC信号时，则会回调hook_vsync()方法。</p>
<h4 id="HWComposer-hook-vsync"><a href="#HWComposer-hook-vsync" class="headerlink" title="HWComposer.hook_vsync"></a>HWComposer.hook_vsync</h4><p>hook 监听Vysnc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HWComposer::hook_vsync(const struct hwc_procs* procs, int disp,</span><br><span class="line">        int64_t timestamp) &#123;</span><br><span class="line">    cb_context* ctx &#x3D; reinterpret_cast&lt;cb_context*&gt;(</span><br><span class="line">            const_cast&lt;hwc_procs_t*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp); 】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HWComposer-vsync"><a href="#HWComposer-vsync" class="headerlink" title="HWComposer.vsync"></a>HWComposer.vsync</h4><p>Vsync信号回调，执行SF的onVSyncReceived方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HWComposer::vsync(int disp, int64_t timestamp) &#123;</span><br><span class="line">    if (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line">            if (timestamp &#x3D;&#x3D; mLastHwVSync[disp]) &#123;</span><br><span class="line">                return; &#x2F;&#x2F;忽略重复的VSYNC信号</span><br><span class="line">            &#125;</span><br><span class="line">            mLastHwVSync[disp] &#x3D; timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-onVSyncReceived"><a href="#SF-onVSyncReceived" class="headerlink" title="SF.onVSyncReceived"></a>SF.onVSyncReceived</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::onVSyncReceived(int type, nsecs_t timestamp) &#123;</span><br><span class="line">    bool needsHwVsync &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        if (type &#x3D;&#x3D; 0 &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            &#x2F;&#x2F; 此处mPrimaryDispSync为DispSync类 kai是分析DispSync</span><br><span class="line">            needsHwVsync &#x3D; mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        disableHardwareVsync(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DispSync构建"><a href="#DispSync构建" class="headerlink" title="DispSync构建"></a>DispSync构建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DispSync::DispSync() :</span><br><span class="line">        mRefreshSkipCount(0),</span><br><span class="line">        mThread(new DispSyncThread()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 运行在DispSync线程</span><br><span class="line">    mThread-&gt;run(&quot;DispSync&quot;, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    reset();</span><br><span class="line">    beginResync();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DispSyncThread线程"><a href="#DispSyncThread线程" class="headerlink" title="DispSyncThread线程"></a>DispSyncThread线程</h4><p>线程”DispSync”停留在mCond的wait()过程，等待被唤醒<br>当收集到Vsync信号后开始回调onDispSyncEvent方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual bool threadLoop() &#123;</span><br><span class="line">     status_t err;</span><br><span class="line">     nsecs_t now &#x3D; systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">     nsecs_t nextEventTime &#x3D; 0;</span><br><span class="line"></span><br><span class="line">     while (true) &#123;</span><br><span class="line">         Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">         nsecs_t targetTime &#x3D; 0;</span><br><span class="line">         &#123; &#x2F;&#x2F; Scope for lock</span><br><span class="line">             Mutex::Autolock lock(mMutex);</span><br><span class="line">             if (mStop) &#123;</span><br><span class="line">                 return false;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (mPeriod &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                 err &#x3D; mCond.wait(mMutex);</span><br><span class="line">                 continue;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             nextEventTime &#x3D; computeNextEventTimeLocked(now);</span><br><span class="line">             targetTime &#x3D; nextEventTime;</span><br><span class="line">             bool isWakeup &#x3D; false;</span><br><span class="line"></span><br><span class="line">             if (now &lt; targetTime) &#123;</span><br><span class="line">                 err &#x3D; mCond.waitRelative(mMutex, targetTime - now);</span><br><span class="line">                 if (err &#x3D;&#x3D; TIMED_OUT) &#123;</span><br><span class="line">                     isWakeup &#x3D; true;</span><br><span class="line">                 &#125; else if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">                     return false;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             now &#x3D; systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">             if (isWakeup) &#123;</span><br><span class="line">                 mWakeupLatency &#x3D; ((mWakeupLatency * 63) +</span><br><span class="line">                         (now - targetTime)) &#x2F; 64;</span><br><span class="line">                 if (mWakeupLatency &gt; 500000) &#123;</span><br><span class="line">                     mWakeupLatency &#x3D; 500000;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             &#x2F;&#x2F;收集vsync信号的所有回调方法</span><br><span class="line">             callbackInvocations &#x3D; gatherCallbackInvocationsLocked(now);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (callbackInvocations.size() &gt; 0) &#123;</span><br><span class="line">             &#x2F;&#x2F;回调所有对象的onDispSyncEvent方法</span><br><span class="line">             fireCallbackInvocations(callbackInvocations);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return false;</span><br><span class="line"> &#125;   </span><br><span class="line"> </span><br><span class="line">void fireCallbackInvocations(const Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;执行DSP 的接受方法</span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DispSyncSource-onDispSyncEvent"><a href="#DispSyncSource-onDispSyncEvent" class="headerlink" title="DispSyncSource.onDispSyncEvent"></a>DispSyncSource.onDispSyncEvent</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual void onDispSyncEvent(nsecs_t when) &#123;</span><br><span class="line">    sp&lt;VSyncSource::Callback&gt; callback;</span><br><span class="line">    &#123;</span><br><span class="line">       Mutex::Autolock lock(mCallbackMutex);</span><br><span class="line">       callback &#x3D; mCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callback !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行 EventThread接受Vsync方法</span><br><span class="line">      callback-&gt;onVSyncEvent(when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EventThread-onVsyncEvent"><a href="#EventThread-onVsyncEvent" class="headerlink" title="EventThread.onVsyncEvent"></a>EventThread.onVsyncEvent</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void EventThread::onVSyncEvent(nsecs_t timestamp) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mVSyncEvent[0].header.type &#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">    mVSyncEvent[0].header.id &#x3D; 0;</span><br><span class="line">    mVSyncEvent[0].header.timestamp &#x3D; timestamp;</span><br><span class="line">    mVSyncEvent[0].vsync.count++;</span><br><span class="line">    mCondition.broadcast(); &#x2F;&#x2F;唤醒EventThread线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EventThread-postEvent"><a href="#EventThread-postEvent" class="headerlink" title="EventThread.postEvent"></a>EventThread.postEvent</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_t EventThread::Connection::postEvent(</span><br><span class="line">        const DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    ssize_t size &#x3D; DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1);</span><br><span class="line">    return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DisplayEventReceiver-sendEvents"><a href="#DisplayEventReceiver-sendEvents" class="headerlink" title="DisplayEventReceiver.sendEvents"></a>DisplayEventReceiver.sendEvents</h4><p>MQ.setEvenetThread监听BitTube，此处调用BitTube来sendObjects。一旦收到数据，则调用MQ.cb_eventReceiver()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssize_t DisplayEventReceiver::sendEvents(const sp&lt;BitTube&gt;&amp; dataChannel,</span><br><span class="line">        Event const* events, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    return BitTube::sendObjects(dataChannel, events, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MQ-cb-eventReceiver"><a href="#MQ-cb-eventReceiver" class="headerlink" title="MQ.cb_eventReceiver"></a>MQ.cb_eventReceiver</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123;</span><br><span class="line">    MessageQueue* queue &#x3D; reinterpret_cast&lt;MessageQueue *&gt;(data);</span><br><span class="line">    return queue-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MQ-eventReceiver"><a href="#MQ-eventReceiver" class="headerlink" title="MQ.eventReceiver"></a>MQ.eventReceiver</h4><p>接受事件，分发dispatchInvalidate、dispatchRefresh<br>消息接收，执行SF的onMessageReceived</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int MessageQueue::eventReceiver(int &#x2F;*fd*&#x2F;, int &#x2F;*events*&#x2F;) &#123;</span><br><span class="line">    ssize_t n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[8];</span><br><span class="line">    while ((n &#x3D; DisplayEventReceiver::getEvents(mEventTube, buffer, 8)) &gt; 0) &#123;</span><br><span class="line">        for (int i&#x3D;0 ; i&lt;n ; i++) &#123;</span><br><span class="line">            if (buffer[i].header.type &#x3D;&#x3D; DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">#if INVALIDATE_ON_VSYNC</span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line">#else</span><br><span class="line">                mHandler-&gt;dispatchRefresh(); </span><br><span class="line">#endif</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 发送refresh</span><br><span class="line">void MessageQueue::Handler::dispatchRefresh() &#123;</span><br><span class="line">    if ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送消息，则进入handleMessage过程【</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::REFRESH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; MQ的消息接受处理</span><br><span class="line">void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123;</span><br><span class="line">    switch (message.what) &#123;</span><br><span class="line">        case INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">        case REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">        case TRANSACTION:</span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SF-onMessageReceived"><a href="#SF-onMessageReceived" class="headerlink" title="SF.onMessageReceived"></a>SF.onMessageReceived</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::onMessageReceived(int32_t what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    switch (what) &#123;</span><br><span class="line">        case MessageQueue::TRANSACTION: &#123;</span><br><span class="line">            handleMessageTransaction();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            bool refreshNeeded &#x3D; handleMessageTransaction();</span><br><span class="line">            refreshNeeded |&#x3D; handleMessageInvalidate(); </span><br><span class="line">            refreshNeeded |&#x3D; mRepaintEverything;</span><br><span class="line">            if (refreshNeeded) &#123;</span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh(); &#x2F;&#x2F; 执行refresh流程</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SF-handleMessageRefresh"><a href="#SF-handleMessageRefresh" class="headerlink" title="SF.handleMessageRefresh"></a>SF.handleMessageRefresh</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    &#x2F;&#x2F; 处理显示设备与 layers 的改变</span><br><span class="line">    preComposition(); </span><br><span class="line">    &#x2F;&#x2F; 重建所有layer，根据z轴排序</span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    &#x2F;&#x2F; 更新 HWComposer涂层</span><br><span class="line">    setUpHWComposer();</span><br><span class="line">    doDebugFlashRegions();</span><br><span class="line">    &#x2F;&#x2F; 生成OpenGL 纹理图像</span><br><span class="line">    doComposition();</span><br><span class="line">    &#x2F;&#x2F; 将图像传递到物理屏幕</span><br><span class="line">    postComposition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a><br>参考：<br><a href="https://blog.csdn.net/freekiteyu/article/details/79483406" target="_blank" rel="noopener">一篇文章看明白 Android 图形系统 Surface 与 SurfaceFlinger 之间的关系</a><br><a href="http://gityuan.com/2017/02/11/surface_flinger/" target="_blank" rel="noopener">SurfaceFlinger启动篇</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>SurfaceFlinger</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统_Choreographer分析</title>
    <url>/blog/2019/12/01/Android%E7%B3%BB%E7%BB%9F_Choreographer%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>基于API 23w</p>
</blockquote>
<h3 id="图文概述"><a href="#图文概述" class="headerlink" title="图文概述"></a>图文概述</h3><p>Choreographer 编舞者。统一动画、输入和绘制时机<br>Choreographer 的作用，主要是配合 Vsync ，给上层 App 的渲染提供一个稳定的 Message 处理的时机，即 Vsync 到来的时候 ，系统通过对 Vsync 信号周期的调整，来控制每一帧绘制操作的时机</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884364964319.png"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884365104209.png"  alt=""></p>
<h3 id="Choreographer启动流程"><a href="#Choreographer启动流程" class="headerlink" title="Choreographer启动流程"></a>Choreographer启动流程</h3><p>Window添加流程中，当Activity启动执行onResume后，会执行到创建ViewRootImpt <a href="https://www.jianshu.com/p/6571fbdd1bcb" target="_blank" rel="noopener">Android系统_Window的创建和添加流程分析</a></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; VoewRootImpl 构造方法 会获取Choreographer实例</span><br><span class="line">    mChoreographer &#x3D; Choreographer.getInstance();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer构造"><a href="#Choreographer构造" class="headerlink" title="Choreographer构造"></a>Choreographer构造</h4><p>通过单例模式构建，这里是每一个线程有一个Choreographer对象，而这里的线程为应用进程的主线程</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static Choreographer getInstance() &#123;</span><br><span class="line">    return sThreadInstance.get(); &#x2F;&#x2F;单例模式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance &#x3D;</span><br><span class="line">    new ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    protected Choreographer initialValue() &#123;</span><br><span class="line">        Looper looper &#x3D; Looper.myLooper(); &#x2F;&#x2F;获取当前线程的Looper</span><br><span class="line">        if (looper &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The current thread must have a looper!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Choreographer(looper); 创建</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer构造方法"><a href="#Choreographer构造方法" class="headerlink" title="Choreographer构造方法"></a>Choreographer构造方法</h4><p> 初始化一个Looper和一个FrameHandler变量用来处理消息，另外创建了一个 FrameDisplayEventReceiver用来请求和接受Vysnc事件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private Choreographer(Looper looper) &#123;</span><br><span class="line">    mLooper &#x3D; looper;</span><br><span class="line">    &#x2F;&#x2F;创建Handler对象</span><br><span class="line">    mHandler &#x3D; new FrameHandler(looper);</span><br><span class="line">    &#x2F;&#x2F;创建用于接收VSync信号的对象 （使用Vsync同步机制情况下创建）</span><br><span class="line">    mDisplayEventReceiver &#x3D; USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;</span><br><span class="line">    &#x2F;&#x2F;是指上一次帧绘制时间点</span><br><span class="line">    mLastFrameTimeNanos &#x3D; Long.MIN_VALUE;</span><br><span class="line">    &#x2F;&#x2F;帧间时长，默认16.7ms.</span><br><span class="line">    mFrameIntervalNanos &#x3D; (long)(1000000000 &#x2F; getRefreshRate());</span><br><span class="line">    &#x2F;&#x2F;创建回调对象</span><br><span class="line">    mCallbackQueues &#x3D; new CallbackQueue[CALLBACK_LAST + 1];</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] &#x3D; new CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建FrameHandler"><a href="#创建FrameHandler" class="headerlink" title="创建FrameHandler"></a>创建FrameHandler</h4><p> Choreographer 处理绘制的逻辑核心在 Choreographer.doFrame 函数中，doFrame 函数主要做三件事情，计算掉帧逻辑、记录帧绘制信息、<br>执行 CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_INSETS_ANIMATION、CALLBACK_TRAVERSAL、CALLBACK_COMMIT</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private final class FrameHandler extends Handler &#123;</span><br><span class="line">    public FrameHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case MSG_DO_FRAME:</span><br><span class="line">                doFrame(System.nanoTime(), 0);</span><br><span class="line">                break;</span><br><span class="line">            case MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                break;</span><br><span class="line">            case MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建FrameDisplayEventReceiver"><a href="#创建FrameDisplayEventReceiver" class="headerlink" title="创建FrameDisplayEventReceiver"></a>创建FrameDisplayEventReceiver</h4><p>它继承DisPlayEvetReceiver，调用父类构造方法<br>另外FrameDisplayEventReceiver中三个比较重要的方法</p>
<ul>
<li>onVsync – Vsync 信号回调</li>
<li>run – 执行 doFrame</li>
<li>scheduleVsync – 请求 Vsync 信号</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123;</span><br><span class="line">            </span><br><span class="line">        public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123;</span><br><span class="line">         super(looper, vsyncSource);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        @Override</span><br><span class="line">        public void onVsync(long timestampNanos, long physicalDisplayId, int frame) &#123;</span><br><span class="line">           ......</span><br><span class="line">           mTimestampNanos &#x3D; timestampNanos;</span><br><span class="line">           mFrame &#x3D; frame;</span><br><span class="line">           Message msg &#x3D; Message.obtain(mHandler, this);</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, timestampNanos &#x2F; TimeUtils.NANOS_PER_MS);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">           mHavePendingVsync &#x3D; false;</span><br><span class="line">           doFrame(mTimestampNanos, mFrame);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        public void scheduleVsync() &#123;</span><br><span class="line">           ......  </span><br><span class="line">           nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DisplayEventReceiver构造"><a href="#DisplayEventReceiver构造" class="headerlink" title="DisplayEventReceiver构造"></a>DisplayEventReceiver构造</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DisplayEventReceiver(Looper looper) &#123;</span><br><span class="line">    mMessageQueue &#x3D; looper.getQueue(); &#x2F;&#x2F;获取主线程的消息队列</span><br><span class="line">    &#x2F;&#x2F; 通过JNI执行native层初始化</span><br><span class="line">    mReceiverPtr &#x3D; nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="android-view-DisplayEventReceiver-cpp-初始化"><a href="#android-view-DisplayEventReceiver-cpp-初始化" class="headerlink" title="android_view_DisplayEventReceiver.cpp 初始化"></a>android_view_DisplayEventReceiver.cpp 初始化</h4><p> 创建NativeDisplayEventReceiver， 监听mReceiver的所获取的文件句柄，一旦有数据到来，则回调this(此处NativeDisplayEventReceiver)中所复写LooperCallback对象的 handleEvent</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj) &#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue &#x3D; android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;创建NativeDisplayEventReceiver</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver &#x3D; new NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    status_t status &#x3D; receiver-&gt;initialize();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取DisplayEventReceiver对象的引用</span><br><span class="line">    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NativeDisplayEventReceiver继承于LooperCallback对象，此处mReceiverWeakGlobal记录的是Java层 DisplayEventReceiver对象的全局引用</span><br><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)),</span><br><span class="line">        mMessageQueue(messageQueue), mWaitingForVsync(false) &#123;</span><br><span class="line">    ALOGV(&quot;receiver %p ~ Initializing display event receiver.&quot;, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t NativeDisplayEventReceiver::initialize() &#123;</span><br><span class="line">    &#x2F;&#x2F;mReceiver为DisplayEventReceiver类型</span><br><span class="line">    status_t result &#x3D; mReceiver.initCheck();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;监听mReceiver的所获取的文件句柄。</span><br><span class="line">    int rc &#x3D; mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT,</span><br><span class="line">            this, NULL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callback添加流程"><a href="#Callback添加流程" class="headerlink" title="Callback添加流程"></a>Callback添加流程</h3><p>Choreographer提供postCallback和postFrameCallback两种回调方式及对应的delay两种，其最终执行的内部postCallbackDelayedInternal方法</p>
<h4 id="Choreographer-postCallbackDelayedInternal"><a href="#Choreographer-postCallbackDelayedInternal" class="headerlink" title="Choreographer.postCallbackDelayedInternal"></a>Choreographer.postCallbackDelayedInternal</h4><p>创建Callback，然后添加到mCallbackQueues队列上，<br>然后根据是否立即执行，决定是发消息还是直接调用<br>最终执行scheduleFrameLocked方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void postCallbackDelayedInternal(int callbackType,</span><br><span class="line">       Object action, Object token, long delayMillis) &#123;</span><br><span class="line">   synchronized (mLock) &#123;</span><br><span class="line">       &#x2F;&#x2F;当前时间</span><br><span class="line">       final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">       &#x2F;&#x2F;回调执行时间，&#x3D;当前时间+delay时间</span><br><span class="line">       final long dueTime &#x3D; now + delayMillis;</span><br><span class="line">       &#x2F;&#x2F;添加到callback队列</span><br><span class="line">mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">       if (dueTime &lt;&#x3D; now) &#123;</span><br><span class="line">           scheduleFrameLocked(now); &#x2F;&#x2F; 立即执行</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; 发送消息执行</span><br><span class="line">           Message msg &#x3D; mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">           msg.arg1 &#x3D; callbackType;</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Choreographer-scheduleFrameLocked"><a href="#Choreographer-scheduleFrameLocked" class="headerlink" title="Choreographer.scheduleFrameLocked"></a>Choreographer.scheduleFrameLocked</h4><p>使用Vsync，按时间执行到scheduleVsyncLocked方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void scheduleFrameLocked(long now) &#123;</span><br><span class="line">   if (!mFrameScheduled) &#123;</span><br><span class="line">       mFrameScheduled &#x3D; true;</span><br><span class="line">       if (USE_VSYNC) &#123;</span><br><span class="line">           &#x2F;&#x2F; If running on the Looper thread, then schedule the vsync immediately,</span><br><span class="line">           &#x2F;&#x2F; otherwise post a message to schedule the vsync from the UI thread</span><br><span class="line">           &#x2F;&#x2F; as soon as possible.</span><br><span class="line">           if (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">               &#x2F;&#x2F; 请求Vsync信号，最终会调用到native层，natie层处理完成后出发onVsync信号接收回调流程</span><br><span class="line">               scheduleVsyncLocked();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; 发送消息，delay后执行此方法</span><br><span class="line">               Message msg &#x3D; mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">               msg.setAsynchronous(true);</span><br><span class="line">               mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有使用Vsync 则直接发送msg，然后调用doFrame</span><br><span class="line">           final long nextFrameTime &#x3D; Math.max(</span><br><span class="line">                   mLastFrameTimeNanos &#x2F; TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">          </span><br><span class="line">           Message msg &#x3D; mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-scheduleVsyncLocked"><a href="#Choreographer-scheduleVsyncLocked" class="headerlink" title="Choreographer.scheduleVsyncLocked"></a>Choreographer.scheduleVsyncLocked</h4><p>执行FrameDisplayEventReceiver.scheduleVsync<br>di层向SurfaceFlinger服务注册，即下一次Vsync事件会调用DisplayEventReceiver的disptachVsync方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private void scheduleVsyncLocked() &#123;</span><br><span class="line">   mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public void scheduleVsync() &#123;</span><br><span class="line">    nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Vsync回调流程"><a href="#Vsync回调流程" class="headerlink" title="Vsync回调流程"></a>Vsync回调流程</h3><p> 当vysnc信号由底层HWC触发后会执行android_view_DisplayEventReceiver的handleEvent方法。<br> JNI层接受HWC的Vysnc信号，过滤处理，分发到Java层DisplayEventReceiver</p>
<h4 id="android-view-DisplayEventReceiver-handleEvent"><a href="#android-view-DisplayEventReceiver-handleEvent" class="headerlink" title="android_view_DisplayEventReceiver.handleEvent"></a>android_view_DisplayEventReceiver.handleEvent</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int NativeDisplayEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    nsecs_t vsyncTimestamp;</span><br><span class="line">    int32_t vsyncDisplayId;</span><br><span class="line">    uint32_t vsyncCount;</span><br><span class="line">    &#x2F;&#x2F;清除所有的pending事件，只保留最后一次vsync</span><br><span class="line">    if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;分发Vsync</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历所有的事件，当有多个VSync事件到来，则只关注最近一次的事件</span><br><span class="line">bool NativeDisplayEventReceiver::processPendingEvents(</span><br><span class="line">        nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123;</span><br><span class="line">    bool gotVsync &#x3D; false;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    ssize_t n;</span><br><span class="line">    while ((n &#x3D; mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123;</span><br><span class="line">        for (ssize_t i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            const DisplayEventReceiver::Event&amp; ev &#x3D; buf[i];</span><br><span class="line">            switch (ev.header.type) &#123;</span><br><span class="line">            case DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                gotVsync &#x3D; true; &#x2F;&#x2F;获取VSync信号</span><br><span class="line">                *outTimestamp &#x3D; ev.header.timestamp;</span><br><span class="line">                *outId &#x3D; ev.header.id;</span><br><span class="line">                *outCount &#x3D; ev.vsync.count;</span><br><span class="line">                break;</span><br><span class="line">            case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return gotVsync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 分发Vsync ，DisplayEventReceiver进行接受</span><br><span class="line">void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123;</span><br><span class="line">    JNIEnv* env &#x3D; AndroidRuntime::getJNIEnv();</span><br><span class="line"></span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));</span><br><span class="line">    if (receiverObj.get()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 此处调用到Java层的DisplayEventReceiver对象的dispatchVsync()方法，执行进入Java层</span><br><span class="line">        env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, &quot;dispatchVsync&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FrameDisplayEventReceiver-onVsync"><a href="#FrameDisplayEventReceiver-onVsync" class="headerlink" title="FrameDisplayEventReceiver.onVsync"></a>FrameDisplayEventReceiver.onVsync</h4><p>Java层接受Vsync事件，通过Handler通信机制发送消息，后续执行到它自身的run方法，然后执行doFrame操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final class FrameDisplayEventReceiver extends DisplayEventReceiver</span><br><span class="line">        implements Runnable &#123;</span><br><span class="line">    private boolean mHavePendingVsync;</span><br><span class="line">    private long mTimestampNanos;</span><br><span class="line">    private int mFrame;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mHavePendingVsync &#x3D; false;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mTimestampNanos &#x3D; timestampNanos;</span><br><span class="line">        mFrame &#x3D; frame;</span><br><span class="line">        &#x2F;&#x2F;该消息的callback为当前对象FrameDisplayEventReceiver</span><br><span class="line">        Message msg &#x3D; Message.obtain(mHandler, this);</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">        &#x2F;&#x2F;此处mHandler为FrameHandler</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos &#x2F; TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-doFrame"><a href="#Choreographer-doFrame" class="headerlink" title="Choreographer.doFrame"></a>Choreographer.doFrame</h4><ul>
<li>先判断Vsync信号间隔时间和刷新时间是否符合</li>
<li>顺序执行4种时间对应的CallbackQueue队列中注册的回调函数<ol>
<li>CALLBACK_INPUT : 处理输入事件处理有关</li>
<li>CALLBACK_ANIMATION ： 处理 Animation 的处理有关</li>
<li>CALLBACK_INSETS_ANIMATION ： 处理 Insets Animation 的相关回调</li>
<li>CALLBACK_TRAVERSAL : 处理和 UI 等控件绘制有关</li>
<li>CALLBACK_COMMIT ： 处理 Commit 相关回调</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void doFrame(long frameTimeNanos, int frame) &#123;</span><br><span class="line">    final long startNanos;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; 每调用一次scheduleFrameLocked()，则mFrameScheduled&#x3D;true，能执行一次doFrame()操作，执行完doFrame()并设置mFrameScheduled&#x3D;false；</span><br><span class="line">        if (!mFrameScheduled) &#123;</span><br><span class="line">            return; &#x2F;&#x2F; mFrameScheduled&#x3D;false，则直接返回。</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;原本计划的绘帧时间点</span><br><span class="line">        long intendedFrameTimeNanos &#x3D; frameTimeNanos;        </span><br><span class="line">        &#x2F;&#x2F;起始时间</span><br><span class="line">        startNanos &#x3D; System.nanoTime();</span><br><span class="line">        &#x2F;&#x2F;计算消息发送与函数调用开始之间所花费的时间</span><br><span class="line">        final long jitterNanos &#x3D; startNanos - frameTimeNanos;</span><br><span class="line">        &#x2F;&#x2F;如果线程处理该消息的时间超过了屏幕刷新周期</span><br><span class="line">        if (jitterNanos &gt;&#x3D; mFrameIntervalNanos) &#123;</span><br><span class="line">            &#x2F;&#x2F; 计算函数调用期间所错过的帧数</span><br><span class="line">            final long skippedFrames &#x3D; jitterNanos &#x2F; mFrameIntervalNanos;</span><br><span class="line">            &#x2F;&#x2F;当掉帧个数超过30，则输出相应log</span><br><span class="line">            if (skippedFrames &gt;&#x3D; SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, &quot;Skipped &quot; + skippedFrames + &quot; frames!  &quot;</span><br><span class="line">                        + &quot;The application may be doing too much work on its main thread.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            final long lastFrameOffset &#x3D; jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            &#x2F;&#x2F;对齐帧的时间间隔</span><br><span class="line">            frameTimeNanos &#x3D; startNanos - lastFrameOffset; </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;此处frameTimeNanos是底层VSYNC信号到达的时间戳，如果frameTimeNanos小于一个屏幕刷新周期，则重新请求VSync信号</span><br><span class="line">        if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        mFrameScheduled &#x3D; false;</span><br><span class="line">        mLastFrameTimeNanos &#x3D; frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;Choreographer#doFrame&quot;);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        &#x2F;&#x2F;执行4种事件对应的回调方法</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;标记动画开始时间</span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-doCallbacks"><a href="#Choreographer-doCallbacks" class="headerlink" title="Choreographer.doCallbacks"></a>Choreographer.doCallbacks</h4><ul>
<li>从队列头mHead查找CallbackRecord对象，当队列头部的callbacks对象为空或者执行时间还没到达，则直接返回；</li>
<li>开始执行相应回调的run()方法；</li>
<li>回收callbacks，加入对象池mCallbackPool，就是说callback一旦执行完成，则会被回收。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void doCallbacks(int callbackType, long frameTimeNanos) &#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        final long now &#x3D; System.nanoTime();</span><br><span class="line">        &#x2F;&#x2F; 从队列查找相应类型的CallbackRecord对象</span><br><span class="line">        callbacks &#x3D; mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now &#x2F; TimeUtils.NANOS_PER_MS);</span><br><span class="line">        if (callbacks &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;  &#x2F;&#x2F;当队列为空，则直接返回</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning &#x3D; true;</span><br><span class="line"></span><br><span class="line">        if (callbackType &#x3D;&#x3D; Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            final long jitterNanos &#x3D; now - frameTimeNanos;</span><br><span class="line">            &#x2F;&#x2F;当commit类型回调执行的时间点超过2帧，则更新mLastFrameTimeNanos。</span><br><span class="line">            if (jitterNanos &gt;&#x3D; 2 * mFrameIntervalNanos) &#123;</span><br><span class="line">                final long lastFrameOffset &#x3D; jitterNanos % mFrameIntervalNanos</span><br><span class="line">                        + mFrameIntervalNanos;</span><br><span class="line">                frameTimeNanos &#x3D; now - lastFrameOffset;</span><br><span class="line">                mLastFrameTimeNanos &#x3D; frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (CallbackRecord c &#x3D; callbacks; c !&#x3D; null; c &#x3D; c.next) &#123;</span><br><span class="line">            c.run(frameTimeNanos); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          mCallbacksRunning &#x3D; false;</span><br><span class="line">          &#x2F;&#x2F;回收callbacks，加入对象池mCallbackPool</span><br><span class="line">          do &#123;</span><br><span class="line">              final CallbackRecord next &#x3D; callbacks.next;</span><br><span class="line">              recycleCallbackLocked(callbacks);</span><br><span class="line">              callbacks &#x3D; next;</span><br><span class="line">          &#125; while (callbacks !&#x3D; null);</span><br><span class="line">      &#125;</span><br><span class="line">      Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CallbackRecord-run"><a href="#CallbackRecord-run" class="headerlink" title="CallbackRecord.run"></a>CallbackRecord.run</h4><ul>
<li>当token的数据类型为FRAME_CALLBACK_TOKEN，则执行该对象的doFrame()方法;</li>
<li>当token为其他类型，则执行该对象的run()方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final class CallbackRecord &#123;</span><br><span class="line">    public CallbackRecord next;</span><br><span class="line">    public long dueTime;</span><br><span class="line">    public Object action; &#x2F;&#x2F; Runnable或者 FrameCallback</span><br><span class="line">    public Object token;</span><br><span class="line"></span><br><span class="line">    public void run(long frameTimeNanos) &#123;</span><br><span class="line">        if (token &#x3D;&#x3D; FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Choreographer-CALLBACK-TRAVERSAL"><a href="#Choreographer-CALLBACK-TRAVERSAL" class="headerlink" title="Choreographer.CALLBACK_TRAVERSAL"></a>Choreographer.CALLBACK_TRAVERSAL</h4><p>这里主要分析Traversal类型，即View的绘制流程</p>
<ul>
<li>ViewRootImpl.scheduleTraversals , 添加callback</li>
<li>回调 TraversalRunnable.run 方法</li>
<li>开始View的绘制流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">    if (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;为了提高优先级，先 postSyncBarrier</span><br><span class="line">        mTraversalBarrier &#x3D; mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 真正开始执行 measure、layout、draw</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void doTraversal() &#123;</span><br><span class="line">    if (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 这里把 SyncBarrier remove</span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        &#x2F;&#x2F; 真正开始</span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void performTraversals() &#123;</span><br><span class="line">      &#x2F;&#x2F; measure 操作</span><br><span class="line">      if (focusChangedDueToTouchMode || mWidth !&#x3D; host.getMeasuredWidth() || mHeight !&#x3D; host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; layout 操作</span><br><span class="line">      if (didLayout) &#123;</span><br><span class="line">          performLayout(lp, mWidth, mHeight);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; draw 操作</span><br><span class="line">      if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">          performDraw();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a><br>参考<br><a href="https://www.androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android 基于 Choreographer 的渲染机制详解</a><br><a href="http://gityuan.com/2017/02/25/choreographer" target="_blank" rel="noopener">Choreographer原理</a><br><a href="https://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="noopener">源码分析</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Choreogprapher</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统_图形系统总结01</title>
    <url>/blog/2019/11/27/Android%E7%B3%BB%E7%BB%9F_%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%9301/</url>
    <content><![CDATA[<blockquote>
<p>本文基于API23源码</p>
</blockquote>
<h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><h4 id="Android系统启动流程介绍"><a href="#Android系统启动流程介绍" class="headerlink" title="Android系统启动流程介绍"></a>Android系统启动流程介绍</h4><p><a href="https://www.jianshu.com/p/4d02ac462733" target="_blank" rel="noopener">Android系统_启动流程分析</a><br><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Android系统_Zygote启动流程分析</a><br><a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">Android系统_SystemServer启动流程分析</a><br><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">Android系统_ActivityManagerService启动流程</a><br><a href="https://www.jianshu.com/p/c7fb582987ad" target="_blank" rel="noopener">Android系统_进程创建流程分析</a><br><a href="https://www.jianshu.com/p/6df6ddac15d5" target="_blank" rel="noopener">Android系统_Launcher启动流程分析</a></p>
<h4 id="Android图形系统重要流程介绍"><a href="#Android图形系统重要流程介绍" class="headerlink" title="Android图形系统重要流程介绍"></a>Android图形系统重要流程介绍</h4><p><a href="https://www.jianshu.com/p/66eb92cca405" target="_blank" rel="noopener">Android系统_View.MeasureSpec分析</a><br><a href="https://www.jianshu.com/p/e893950d6cb3" target="_blank" rel="noopener">Android系统_View_LinearLayout.measure分析</a><br><a href="https://www.jianshu.com/p/c7859e02cf25" target="_blank" rel="noopener">Android系统_View.measure解析</a><br><a href="https://www.jianshu.com/p/f36b54feb7c5" target="_blank" rel="noopener">Android系统_View.layout解析</a><br><a href="https://www.jianshu.com/p/9b759b4a1aa5" target="_blank" rel="noopener">Android系统_View.draw解析</a><br><a href="https://www.jianshu.com/p/052c635a8853" target="_blank" rel="noopener">Android系统_WindowManagerService分析</a><br><a href="https://www.jianshu.com/p/6571fbdd1bcb" target="_blank" rel="noopener">Android系统_Window的创建和添加流程分析</a><br><a href="https://www.jianshu.com/p/956db9044cd8" target="_blank" rel="noopener">Android系统_Surface相关创建过程分析</a><br><a href="https://www.jianshu.com/p/c247013616d0" target="_blank" rel="noopener">Android系统_Surface绘制流程分析</a><br><a href="https://www.jianshu.com/p/538df44171b1" target="_blank" rel="noopener">Android系统_Choreographer工作流程分析</a><br><a href="https://www.jianshu.com/p/23a722df662f" target="_blank" rel="noopener">Android系统_SurfaceFlinger源码分析01</a></p>
<h3 id="一图以蔽之"><a href="#一图以蔽之" class="headerlink" title="一图以蔽之"></a>一图以蔽之</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884365317939.png"  alt=""></p>
<h3 id="Android系统启动流程图文总结"><a href="#Android系统启动流程图文总结" class="headerlink" title="Android系统启动流程图文总结"></a>Android系统启动流程图文总结</h3><h4 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884365382979.png"  alt=""></p>
<h4 id="进程创建流程"><a href="#进程创建流程" class="headerlink" title="进程创建流程"></a>进程创建流程</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884365716401.jpg"  alt=""></p>
<h4 id="WMS启动流程"><a href="#WMS启动流程" class="headerlink" title="WMS启动流程"></a>WMS启动流程</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884365828689.jpg"  alt=""></p>
<h4 id="Launcher启动时序图"><a href="#Launcher启动时序图" class="headerlink" title="Launcher启动时序图"></a>Launcher启动时序图</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884365938266.jpg"  alt=""></p>
<h3 id="App、AMS、WMS三者关系类图"><a href="#App、AMS、WMS三者关系类图" class="headerlink" title="App、AMS、WMS三者关系类图"></a>App、AMS、WMS三者关系类图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884366176146.jpg"  alt=""></p>
<h3 id="Android图形绘制流程图文总结"><a href="#Android图形绘制流程图文总结" class="headerlink" title="Android图形绘制流程图文总结"></a>Android图形绘制流程图文总结</h3><h4 id="Window的创建和添加流程"><a href="#Window的创建和添加流程" class="headerlink" title="Window的创建和添加流程"></a>Window的创建和添加流程</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884366852421.jpg"  alt=""></p>
<h4 id="Surface的创建时序图"><a href="#Surface的创建时序图" class="headerlink" title="Surface的创建时序图"></a>Surface的创建时序图</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884366467784.jpg"  alt=""></p>
<h4 id="Surface的绘制流程"><a href="#Surface的绘制流程" class="headerlink" title="Surface的绘制流程"></a>Surface的绘制流程</h4><p>surface的绘制时序图 （软件绘制流程、硬件绘制待后续补充）</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884367048437.jpg"  alt=""></p>
<h4 id="View的measure、layout、draw三大流程"><a href="#View的measure、layout、draw三大流程" class="headerlink" title="View的measure、layout、draw三大流程"></a>View的measure、layout、draw三大流程</h4><h5 id="View-measure-流程"><a href="#View-measure-流程" class="headerlink" title="View.measure 流程"></a>View.measure 流程</h5><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884367160885.jpg"  alt=""></p>
<h5 id="View-MeasureSpec-说明"><a href="#View-MeasureSpec-说明" class="headerlink" title="View.MeasureSpec 说明"></a>View.MeasureSpec 说明</h5><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884367264365.jpg"  alt=""></p>
<h5 id="View-layout-流程"><a href="#View-layout-流程" class="headerlink" title="View.layout 流程"></a>View.layout 流程</h5><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884367860883.jpg"  alt=""></p>
<h5 id="View-draw-流程"><a href="#View-draw-流程" class="headerlink" title="View.draw 流程"></a>View.draw 流程</h5><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884368029280.jpg"  alt=""></p>
<h3 id="Android图形Vsync信号刷新原理总结"><a href="#Android图形Vsync信号刷新原理总结" class="headerlink" title="Android图形Vsync信号刷新原理总结"></a>Android图形Vsync信号刷新原理总结</h3><p>Android系统确保帧缓存刷新、图形合成、图形绘制一致的原理 ？<br>引用一张图<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884368139622.jpg"  alt=""></p>
<p>Vsync信号流转流程图 （看完图相信就知道上面的疑问了）<br><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884368202735.png"  alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统_Surface</title>
    <url>/blog/2019/11/25/Android%E7%B3%BB%E7%BB%9F_Surface/</url>
    <content><![CDATA[<blockquote>
<p>基于API 23</p>
</blockquote>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884368895776.png"  alt=""></p>
<h3 id="SurfaceComposerClient的创建过程"><a href="#SurfaceComposerClient的创建过程" class="headerlink" title="SurfaceComposerClient的创建过程"></a>SurfaceComposerClient的创建过程</h3><h4 id="WMS-addWinodw"><a href="#WMS-addWinodw" class="headerlink" title="WMS.addWinodw"></a>WMS.addWinodw</h4><p>WMS添加window过程，最后会执行到session.windowAddedLocked</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;WMS</span><br><span class="line">public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123;</span><br><span class="line">    ...</span><br><span class="line">    win.attach(); &#x2F;&#x2F; WindowState</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; WindowState.attch</span><br><span class="line">void attach() &#123;</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Session-windowAddedLocked"><a href="#Session-windowAddedLocked" class="headerlink" title="Session.windowAddedLocked"></a>Session.windowAddedLocked</h4><p>创建 SurfaceSession 对象，并将当前 Session 添加到 WMS.mSessions 成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void windowAddedLocked() &#123;</span><br><span class="line">    if (mSurfaceSession &#x3D;&#x3D; null) &#123;</span><br><span class="line">        mSurfaceSession &#x3D; new SurfaceSession();</span><br><span class="line">        mService.mSessions.add(this);</span><br><span class="line">        if (mLastReportedAnimatorScale !&#x3D; mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="android-view-SurfaceSession-cpp"><a href="#android-view-SurfaceSession-cpp" class="headerlink" title="android_view_SurfaceSession.cpp"></a>android_view_SurfaceSession.cpp</h4><p>SurfaceSession 的创建会调用 JNI，在 JNI 调用 nativeCreate()<br>构造了一个SurfaceComposerClient对象。并返回它的指针。这个对象一个应用程序就有一个，它是应用程序与SurfaceFlinger沟通的桥梁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SurfaceSeesion</span><br><span class="line">public SurfaceSession() &#123;</span><br><span class="line">   mNativeClient &#x3D; nativeCreate();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; JNI</span><br><span class="line">static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 SurfaceComposeClient 空实现，查看onFirstRef</span><br><span class="line">    SurfaceComposerClient* client &#x3D; new SurfaceComposerClient();</span><br><span class="line">    client-&gt;incStrong((void*)nativeCreate);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceComposerClient-onFirstRef"><a href="#SurfaceComposerClient-onFirstRef" class="headerlink" title="SurfaceComposerClient.onFirstRef"></a>SurfaceComposerClient.onFirstRef</h4><p>通过SurfaceFlinger创造了一个Client对象，每一个APP都有一个Client对象向对应，通过这个代理对象可以跟SurfaceFlinger通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line">    ....</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn;</span><br><span class="line">    &#x2F;&#x2F;sf 就是SurfaceFlinger</span><br><span class="line">    conn &#x3D; (rootProducer !&#x3D; nullptr) ? sf-&gt;createScopedConnection(rootProducer) :</span><br><span class="line">            sf-&gt;createConnection();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceFlinger-cpp"><a href="#SurfaceFlinger-cpp" class="headerlink" title="SurfaceFlinger.cpp"></a>SurfaceFlinger.cpp</h4><p>构造了一个Client对象，Client实现了ISurfaceComposerClient接口。是一个可以跨进程通信的aidl对象。除此之外它还可以创建Surface，并且维护一个应用程序的所有Layer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()&#123;</span><br><span class="line">  sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">  sp&lt;Client&gt; client(new Client(this));</span><br><span class="line">  return bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Client-h"><a href="#Client-h" class="headerlink" title="Client.h"></a>Client.h</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Client : public BnSurfaceComposerClient</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void attachLayer(const sp&lt;IBinder&gt;&amp; handle, const sp&lt;Layer&gt;&amp; layer);</span><br><span class="line">    void detachLayer(const Layer* layer);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Surface的创建"><a href="#Surface的创建" class="headerlink" title="Surface的创建"></a>Surface的创建</h3><p>一个ViewRootImpl就对应一个Surface</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Surface mSurface &#x3D; new Surface();</span><br><span class="line"></span><br><span class="line">public Surface() &#123;</span><br><span class="line">    &#x2F;&#x2F; 空构造函数，需要继续追看Surface赋值过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewRootImpl-relayoutWindow"><a href="#ViewRootImpl-relayoutWindow" class="headerlink" title="ViewRootImpl.relayoutWindow"></a>ViewRootImpl.relayoutWindow</h4><p>直接看ViewRootImpl的绘制流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    finalView host &#x3D; mView; &#x2F;&#x2F;mView是一个Window的根View，对于Activity来说就是DecorView</span><br><span class="line">    ...</span><br><span class="line">    relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">    ...</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    ...         </span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    ...</span><br><span class="line">    performDraw();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 重布window</span><br><span class="line">private int relayoutWindow(WindowManager.LayoutParams params, ...) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    int relayoutResult &#x3D; mWindowSession.relayout(mWindow,..., mSurface);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WindowManagerService-relayoutWindow"><a href="#WindowManagerService-relayoutWindow" class="headerlink" title="WindowManagerService.relayoutWindow"></a>WindowManagerService.relayoutWindow</h4><p>winAnimator.createSurfaceLocked实际上是创建了一个SurfaceControl。即上面是先构造SurfaceControl，然后在构造Surface</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int relayoutWindow(Session session, IWindow client....Surface outSurface)&#123; </span><br><span class="line">    ...</span><br><span class="line">    result &#x3D; createSurfaceControl(outSurface, result, win, winAnimator);  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int createSurfaceControl(Surface outSurface, int result, WindowState win,WindowStateAnimator winAnimator) &#123;</span><br><span class="line">    ...</span><br><span class="line">    surfaceController &#x3D; winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line">    ...</span><br><span class="line">    surfaceController.getSurface(outSurface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceControl的创建"><a href="#SurfaceControl的创建" class="headerlink" title="SurfaceControl的创建"></a>SurfaceControl的创建</h4><p>通过SurfaceControl的构造函数创建了一个SurfaceControl对象,这个对象的作用其实就是负责维护Surface,Surface其实也是由这个对象负责创建的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long mNativeObject; &#x2F;&#x2F;成员指针变量，指向native创建的SurfaceControl</span><br><span class="line"></span><br><span class="line">private SurfaceControl(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    mNativeObject &#x3D; nativeCreate(session, name, w, h, format, flags,</span><br><span class="line">        parent !&#x3D; null ? parent.mNativeObject : 0, windowType, ownerUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="android-view-SurfaceControl-cpp"><a href="#android-view-SurfaceControl-cpp" class="headerlink" title="android_view_SurfaceControl.cpp"></a>android_view_SurfaceControl.cpp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static jlong nativeCreate(JNIEnv* env, ...) &#123;</span><br><span class="line">    &#x2F;&#x2F;这个client为前面创建的SurfaceComposerClinent</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj)); </span><br><span class="line">    &#x2F;&#x2F;创建成功之后，这个指针会指向新创建的SurfaceControl</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;</span><br><span class="line">    status_t err &#x3D; client-&gt;createSurface(String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);</span><br><span class="line">    ...</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(surface.get()); &#x2F;&#x2F;返回这个SurfaceControl的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceComposerClient-createSurface"><a href="#SurfaceComposerClient-createSurface" class="headerlink" title="SurfaceComposerClient.createSurface"></a>SurfaceComposerClient.createSurface</h4><p>创建时传入了一个对象 sp<IGraphicBufferProducer> gbp, 后面会说吗应用所渲染的每一帧，实际上都会添加到IGraphicBufferProducer中，来等待SurfaceFlinger的渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;outSurface会指向新创建的SurfaceControl</span><br><span class="line">status_t SurfaceComposerClient::createSurface(...sp&lt;SurfaceControl&gt;* outSurface..) </span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp; </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用 之前缓存的client进行创建</span><br><span class="line">    err &#x3D; mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, windowType, ownerUid, &amp;handle, &amp;gbp);</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        &#x2F;&#x2F;SurfaceControl创建成功, 指针赋值</span><br><span class="line">        sur &#x3D; new SurfaceControl(this, handle, gbp, true);</span><br><span class="line">    &#125;</span><br><span class="line">    return sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Client-createSurface"><a href="#Client-createSurface" class="headerlink" title="Client.createSurface"></a>Client.createSurface</h4><p>Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger，因为同一时刻可以有多个应用程序请求SurfaceFlinger为其创建Surface，通过消息队列可以实现请求排队，然后SurfaceFlinger依次为应用程序创建Surface</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">status_t Client::createSurface(</span><br><span class="line">        const String8&amp; name,</span><br><span class="line">        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg &#x3D; new MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, this, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceFlinger-createLayer"><a href="#SurfaceFlinger-createLayer" class="headerlink" title="SurfaceFlinger.createLayer"></a>SurfaceFlinger.createLayer</h4><p>该函数中根据flag创建不同的Layer，Layer用于标示一个图层。<br>除了SurfaceFlinger需要统一管理系统中创建的所有Layer对象外，专门为每个应用程序进程服务的Client也需要统一管理当前应用程序进程所创建的Layer，因此在addClientLayer函数里还会通过Client::attachLayer将创建的Layer和该类对应的handle以键值对的方式保存到Client的成员变量mLayers表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_t SurfaceFlinger::createLayer(const String8&amp; name,const sp&lt;Client&gt;&amp; client...)</span><br><span class="line">&#123;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line">    &#x2F;&#x2F;创建的layer</span><br><span class="line">    sp&lt;Layer&gt; layer; </span><br><span class="line">    switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        case ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result &#x3D; createBufferLayer(client,</span><br><span class="line">                    uniqueName, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            break;</span><br><span class="line">            ... &#x2F;&#x2F;Layer 其它情况的创建</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;这个layer和client相关联, 添加到Client的mLayers集合中</span><br><span class="line">    result &#x3D; addClientLayer(client, *handle, *gbp, layer, *parent);  </span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SurfaceFlinger-createNormalLayer"><a href="#SurfaceFlinger-createNormalLayer" class="headerlink" title="SurfaceFlinger.createNormalLayer"></a>SurfaceFlinger.createNormalLayer</h4><p>SurfaceFlinger为应用程序创建好Layer后，需要统一管理这些Layer对象，因此通过函数addClientLayer将创建的Layer保存到当前State的Z秩序列表layersSortedByZ中，同时将这个Layer所对应的IGraphicBufferProducer本地Binder对象gbp保存到SurfaceFlinger的成员变量mGraphicBufferProducerList中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client,</span><br><span class="line">        const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; initialize the surfaces</span><br><span class="line">    switch (format) &#123;</span><br><span class="line">    case PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    case PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">        format &#x3D; PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">        break;</span><br><span class="line">    case PIXEL_FORMAT_OPAQUE:</span><br><span class="line">        format &#x3D; PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *outLayer &#x3D; new Layer(this, client, name, w, h, flags);</span><br><span class="line">    status_t err &#x3D; (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        *handle &#x3D; (*outLayer)-&gt;getHandle();</span><br><span class="line">        *gbp &#x3D; (*outLayer)-&gt;getProducer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, &quot;createNormalLayer() failed (%s)&quot;, strerror(-err));</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Layer-cpp"><a href="#Layer-cpp" class="headerlink" title="Layer.cpp"></a>Layer.cpp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Layer::onFirstRef() &#123;</span><br><span class="line">    &#x2F;&#x2F; Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">    mProducer &#x3D; new MonitoredProducer(producer, mFlinger);</span><br><span class="line">    mSurfaceFlingerConsumer &#x3D; new SurfaceFlingerConsumer(consumer, mTextureName);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"></span><br><span class="line">#ifdef TARGET_DISABLE_TRIPLE_BUFFERING</span><br><span class="line">#warning &quot;disabling triple buffering&quot;</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(2);</span><br><span class="line">#else</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(3);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    const sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">    updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BufferQueue-cpp"><a href="#BufferQueue-cpp" class="headerlink" title="BufferQueue.cpp"></a>BufferQueue.cpp</h4><ul>
<li>BufferQueue是一个服务中心，IGraphicBufferProducer和IGraphicBufferConsumer<br>所需要使用的buffer必须要通过它来管理。比如说当IGraphicBufferProducer想要获取一个buffer时，它不能越过BufferQueue直接与IGraphicBufferConsumer进行联系，反之亦然。</li>
<li>IGraphicBufferProducer就是“填充”buffer空间的人，通常情况下是应用程序。因为应用程序不断地刷新UI，从而将产生的显示数据源源不断地写到buffer中。当IGraphicBufferProducer需要使用一块buffer时，它首先会向中介BufferQueue发起dequeueBuffer申请，然后才能对指定的buffer进行操作。此时buffer就只属于IGraphicBufferProducer一个人的了，它可以对buffer进行任何必要的操作，而IGraphicBufferConsumer此刻绝不能操作这块buffer。当IGraphicBufferProducer认为一块buffer已经写入完成后，它进一步调用queueBuffer函数。从字面上看这个函数是“入列”的意思，形象地表达了buffer此时的操作，把buffer归还到BufferQueue的队列中。一旦queue成功后，buffer的owner也就随之改变为BufferQueue了</li>
<li>IGraphicBufferConsumer是与IGraphicBufferProducer相对应的，它的操作同样受到BufferQueue的管控。当一块buffer已经就绪后，IGraphicBufferConsumer就可以开始工作了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span><br><span class="line">        const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;</span><br><span class="line"></span><br><span class="line">    sp&lt;BufferQueueCore&gt; core(new BufferQueueCore(allocator));</span><br><span class="line">    *outProducer &#x3D; producer;</span><br><span class="line">    *outConsumer &#x3D; consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="从SurfaceControl中获取Surface"><a href="#从SurfaceControl中获取Surface" class="headerlink" title="从SurfaceControl中获取Surface"></a>从SurfaceControl中获取Surface</h4><p>上面完成了 surfaceController的创建跟踪，下面分析从surfaceController获取surface过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int createSurfaceControl(Surface outSurface, int result, WindowState win,WindowStateAnimator winAnimator) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 上面完成了 surfaceController的创建</span><br><span class="line">    SurfaceControl surfaceController &#x3D; winAnimator.createSurfaceLocked();</span><br><span class="line">    &#x2F;&#x2F; 下面分析 surfaceController获取surface</span><br><span class="line">    outSurface.copyFrom(surfaceControl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="android-view-Surface-nativeCreateFromSurfaceControl"><a href="#android-view-Surface-nativeCreateFromSurfaceControl" class="headerlink" title="android_view_Surface.nativeCreateFromSurfaceControl"></a>android_view_Surface.nativeCreateFromSurfaceControl</h4><p>JNI构建方法获取到一个指针，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;</span><br><span class="line">    &#x2F;&#x2F; 把java指针转化内native指针</span><br><span class="line">    sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">    &#x2F;&#x2F; 直接构造一个Surface，指向 ctrl-&gt;getSurface()</span><br><span class="line">    sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line">    if (surface !&#x3D; NULL) &#123;</span><br><span class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner); &#x2F;&#x2F;强引用</span><br><span class="line">    &#125;</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SurfaceControl-getSurface"><a href="#SurfaceControl-getSurface" class="headerlink" title="SurfaceControl.getSurface"></a>SurfaceControl.getSurface</h4><p>创建一个native层的Surface对象，并将该对象指针返回给Java层的Surface，从而建立Java层的Surface和native层Surface的关联关系<br>另外Surface和SurfaceControl都持有mGraphicBufferProducer用于操作位于SurfaceFlinger中的图形buffer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() const</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    if (mSurfaceData &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         mSurfaceData &#x3D; new Surface(mGraphicBufferProducer, false);</span><br><span class="line">    &#125;</span><br><span class="line">    return mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Surface</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统_Window的创建与添加过程分析</title>
    <url>/blog/2019/11/24/Android%E7%B3%BB%E7%BB%9F_Window%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<hr>
<p>cover: <a href="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369035725.png" target="_blank" rel="noopener">http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369035725.png</a><br>tags: </p>
<ul>
<li>源码</li>
<li>Window<br>categories:</li>
<li>[Android, 系统]</li>
</ul>
<hr>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>（大体流程，从Activity接受启动开始）</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369035725.png"  alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><blockquote>
<p>基于API 23</p>
</blockquote>
<h4 id="Window创建"><a href="#Window创建" class="headerlink" title="Window创建"></a>Window创建</h4><h5 id="ActivityThread-handleLaunchActivity"><a href="#ActivityThread-handleLaunchActivity" class="headerlink" title="ActivityThread.handleLaunchActivity"></a>ActivityThread.handleLaunchActivity</h5><h5 id="ActivityThread-performLaunchActivity"><a href="#ActivityThread-performLaunchActivity" class="headerlink" title="ActivityThread.performLaunchActivity"></a>ActivityThread.performLaunchActivity</h5><p>ActivityThread处理并执行Activity启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ActivityThread</span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;获取WindowManagerService的Binder引用(proxy端)。</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行Activity的onCreate,onStart,onResotreInstanceState方法</span><br><span class="line">    Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line">    if (a !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;执行Activity的onResume方法.</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;通过类加载器创建Activity</span><br><span class="line">   Activity activity &#x3D; mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line"></span><br><span class="line">   ...      </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;通过LoadedApk的makeApplication方法来创建Application对象</span><br><span class="line">   Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   if (activity !&#x3D; null) &#123;</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 执行 attach 方法</span><br><span class="line">       activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">               r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">               r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">               r.referrer, r.voiceInteractor, window);</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;onCreate</span><br><span class="line">       mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;onStart</span><br><span class="line">       activity.performStart();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Activity-attach"><a href="#Activity-attach" class="headerlink" title="Activity.attach"></a>Activity.attach</h5><ul>
<li>构造PhoneWindow （Window唯一具体实现）</li>
<li>设置自身为Window的Callback，从而Activity能作为callback接受window的key和touch事件</li>
<li>初始化且设置WindowManager，每个Activity对应一个WindowManager，通过WM与WMS进行通信</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void attach(...) &#123;</span><br><span class="line">    &#x2F;&#x2F;绑定上下文</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建Window,PhoneWindow是Window的唯一具体实现类</span><br><span class="line">    mWindow &#x3D; new PhoneWindow(this, window);&#x2F;&#x2F;此处的window&#x3D;&#x3D;null，但不影响</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    &#x2F;&#x2F; 设置 Window.Callback</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置WindowManager</span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">          (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">          mToken, mComponent.flattenToString(),</span><br><span class="line">          (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) !&#x3D; 0);</span><br><span class="line">    if (mParent !&#x3D; null) &#123;</span><br><span class="line">      mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;创建完后通过getWindowManager就可以得到WindowManager实例</span><br><span class="line">    mWindowManager &#x3D; mWindow.getWindowManager();&#x2F;&#x2F;其实它是WindowManagerImpl</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Window添加View过程"><a href="#Window添加View过程" class="headerlink" title="Window添加View过程"></a>Window添加View过程</h4><p>前面在handleLauncherActivity完成了PhoneWindow的创建过程，下面我们继续查看Activity执行生命周期handleResumeActivity方法，查看Activity对应View被加载到PhoneWindow容器过程</p>
<h5 id="ActivityThread-handleResumeActivity"><a href="#ActivityThread-handleResumeActivity" class="headerlink" title="ActivityThread.handleResumeActivity"></a>ActivityThread.handleResumeActivity</h5><ul>
<li>获取ActivityClientRecord，将对应DecorView设置为不可见，因为当前View还未绘制</li>
<li>通过Window对应的WindowManager执行addView（decor，l）操作</li>
<li>View绘制完成后，会将decorView设置可见，展示该Activity对应内容，最后onResume完成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;把activity数据记录更新到ActivityClientRecord</span><br><span class="line">   ActivityClientRecord r &#x3D; performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">   if (r !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">       if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">           r.window &#x3D; r.activity.getWindow();</span><br><span class="line">           View decor &#x3D; r.window.getDecorView();</span><br><span class="line">           decor.setVisibility(View.INVISIBLE);&#x2F;&#x2F;不可见</span><br><span class="line">           ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">           WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">           a.mDecor &#x3D; decor;</span><br><span class="line">           l.type &#x3D; WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">               a.mWindowAdded &#x3D; true;</span><br><span class="line">               wm.addView(decor, l);&#x2F;&#x2F; 把decor添加到窗口上</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; </span><br><span class="line">           &#x2F;&#x2F;屏幕参数发生了改变</span><br><span class="line">           performConfigurationChanged(r.activity, r.tmpConfig);</span><br><span class="line"></span><br><span class="line">           WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line"></span><br><span class="line">               if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                   ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                   View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                   wm.updateViewLayout(decor, l);&#x2F;&#x2F;更新窗口状态</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">           if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">               &#x2F;&#x2F;已经成功添加到窗口上了（绘制和事件接收），设置为可见</span><br><span class="line">               r.activity.makeVisible();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;通知ActivityManagerService，Activity完成Resumed</span><br><span class="line">        ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WindowManagerImply-addView"><a href="#WindowManagerImply-addView" class="headerlink" title="WindowManagerImply.addView"></a>WindowManagerImply.addView</h5><h5 id="WindowManagerGlobal-addView"><a href="#WindowManagerGlobal-addView" class="headerlink" title="WindowManagerGlobal.addView"></a>WindowManagerGlobal.addView</h5><ul>
<li>WindowManagerImpl的全局变量通过单例模式初始化了WindowManagerGlobal，（一个进程一个WMG对象）</li>
<li>Window管理类添加View过程，创建ViewRootImpl，将View处理操作交给ViewRootImpl实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WindowManagerImply</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; WindowManagerGlobal</span><br><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">           Display display, Window parentWindow) &#123;</span><br><span class="line">     </span><br><span class="line">    synchronized (mLock) &#123; </span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 创建ViewRootImpl，并将View与之绑定</span><br><span class="line">        root &#x3D; new ViewRootImpl(view.getContext(), display);</span><br><span class="line">        </span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        </span><br><span class="line">        mViews.add(view); &#x2F;&#x2F; 将当前view添加到mView集合中</span><br><span class="line">        mRoots.add(root); &#x2F;&#x2F; 将当前root添加mRoots集合中</span><br><span class="line">        mParams.add(wparams); &#x2F;&#x2F; 将当前window的params添加到mParams集合中</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; setView 完成View的绘制流程，并添加到window上 </span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewRootImpl-setView"><a href="#ViewRootImpl-setView" class="headerlink" title="ViewRootImpl.setView"></a>ViewRootImpl.setView</h4><ul>
<li>ViewRootImpl构建过程中，会通过WindowManagerGlobal的getWindowSession（static方法）获取IWindowSession即WindowSession</li>
<li>执行requestLayout方法完成View的绘制流程</li>
<li>通过WindowSession与WindowManagerService通信，将View和InputChannel添加到WMS，从而展示View并可以接受输入事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      int res</span><br><span class="line">      requestLayout();&#x2F;&#x2F;执行 View的绘制流程</span><br><span class="line"></span><br><span class="line">      if ((mWindowAttributes.inputFeatures</span><br><span class="line">              &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          &#x2F;&#x2F; 创建InputChannel</span><br><span class="line">          mInputChannel &#x3D; new InputChannel();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;通过WindowSession进行IPC调用，将View添加到Window上</span><br><span class="line">          &#x2F;&#x2F;mWindow即W类，用来接收WmS信息</span><br><span class="line">          &#x2F;&#x2F;同时通过InputChannel接收触摸事件回调</span><br><span class="line">          res &#x3D; mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                  getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                  mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                  mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;处理触摸事件回调</span><br><span class="line">      mInputEventReceiver &#x3D; new WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                  Looper.myLooper());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WindowSession-addToDisplay"><a href="#WindowSession-addToDisplay" class="headerlink" title="WindowSession.addToDisplay"></a>WindowSession.addToDisplay</h4><ul>
<li>Session执行addToDisplay方法，通过调用成员变量WMS进行addWindow操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int addToDisplay(...) &#123;</span><br><span class="line">   return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">           outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WindowManagerService-addWindow"><a href="#WindowManagerService-addWindow" class="headerlink" title="WindowManagerService.addWindow"></a>WindowManagerService.addWindow</h4><ul>
<li>创建WindowState，保存Window状态</li>
<li>调整LayoutParams参数、设置input、设置window zOrder</li>
<li>执行WindowState的attach（创建Surface过程，详情见下一篇）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int addWindow(Session session, IWindow client, int seq,</span><br><span class="line">       WindowManager.LayoutParams attrs, int viewVisibility, int displayId,</span><br><span class="line">       Rect outContentInsets, Rect outStableInsets, Rect outOutsets,InputChannel outInputChannel) &#123;</span><br><span class="line">   </span><br><span class="line">    ... &#x2F;&#x2F; 一堆check逻辑</span><br><span class="line"></span><br><span class="line">    WindowToken token &#x3D; mTokenMap.get(attrs.token);</span><br><span class="line">    &#x2F;&#x2F;创建 WindowState</span><br><span class="line">    WindowState win &#x3D; new WindowState(this, session, client, token,</span><br><span class="line">          attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调整 WindowManager 的 LayoutParams 参数</span><br><span class="line">    mPolicy.adjustWindowParamsLw(win.mAttrs);</span><br><span class="line">    res &#x3D; mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">    addWindowToListInOrderLocked(win, true);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置 input</span><br><span class="line">    mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 Surface 与 SurfaceFlinger 通信，</span><br><span class="line">    win.attach();</span><br><span class="line">    mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        </span><br><span class="line">    if (win.canReceiveKeys()) &#123;</span><br><span class="line">    &#x2F;&#x2F;当该窗口能接收按键事件，则更新聚焦窗口</span><br><span class="line">    focusChanged &#x3D; updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">          false &#x2F;*updateInputWindows*&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line">    assignLayersLocked(displayContent.getWindowList());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a><br>参考<br><a href="https://juejin.im/entry/5a123c31f265da430d579cda" target="_blank" rel="noopener">Android Window 机制探索
</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何写好个人周报（1）</title>
    <url>/blog/2019/11/22/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A5%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h3 id="什么是周报"><a href="#什么是周报" class="headerlink" title="什么是周报"></a>什么是周报</h3><ul>
<li>起源：管理者对下属的不了解，不信任。因为不知道你最近在做什么，接下来准备做什么，所以需要一份汇报，而这汇报又比较高频，从而成为了周报</li>
<li>内容：对本周工作的总结和沉淀，对下周工作的计划和安排；同时也可以辅助思考，讨论，困难，失误，经验，成长等更多维度的信息</li>
</ul>
<h3 id="为什么要写周报"><a href="#为什么要写周报" class="headerlink" title="为什么要写周报"></a>为什么要写周报</h3><blockquote>
<p>如果管理者不知道你做了某件事情，相当于你就没有做过这件事情<br>沟通越充分，获得信任感越多<br>管理者掌握信息越全面细致，通常执行力也就越强</p>
</blockquote>
<ul>
<li>个人<ul>
<li>提升自己复盘、思考和规划能力、培养全局观、加强条理性</li>
<li>合理的计划决定时间管理水平，时间管理又决定工作效率的高低</li>
<li>个人与团队之间进行更有效沟通，促成协同与互补</li>
<li>个人与领导高效沟通，获取信任，并寻求资源与帮助</li>
</ul>
</li>
<li>领导<ul>
<li>更高的管理效率：周报是Leader与同学沟通成本最低的一种载体</li>
<li>思想和目标对齐：目标、进展、风险等项目大方面把控</li>
</ul>
</li>
</ul>
<h3 id="周报内容"><a href="#周报内容" class="headerlink" title="周报内容"></a>周报内容</h3><h4 id="本周工作内容"><a href="#本周工作内容" class="headerlink" title="本周工作内容"></a>本周工作内容</h4><p>按项目分类，包含但不限于背景、目标、里程碑|计划、进展、风险&amp;问题，下面对其中几个重要点进行分析</p>
<ul>
<li>目标：量化项目目标指标，遵循SMART原则<ul>
<li>Specific，必须具体</li>
<li>Measurable，必须是可以衡量</li>
<li>Attainable，必须是可以达到的</li>
<li>Relevant，要与其他目标具有一定的相关性</li>
<li>Time-bound，必须具有明确的截止期限</li>
</ul>
</li>
<li>进展 <ul>
<li>细化任务，计划任务量、合理时间分配、明确完成时间点</li>
<li>反馈各个任务执行结果，如完成情况/耗时情况/未达预期的原因/改进方案等 </li>
</ul>
</li>
<li>问题<ul>
<li>维度：人、事、流程、关系等</li>
<li>内容：思考、建议、方案或者Todo、行动</li>
<li>回溯上一周面临的问题是否得到解决，解决方案是否有效，并总结经验</li>
</ul>
</li>
</ul>
<h4 id="下周工作计划"><a href="#下周工作计划" class="headerlink" title="下周工作计划"></a>下周工作计划</h4><ul>
<li>工作内容：做什么？（明确目标和任务）</li>
<li>工作分工：谁来做？（落实责任到人和标准）</li>
<li>工作方法：怎么做？（具体执行方案或者策略）</li>
<li>工作进度：时间点？（任务量、预计投入、完成时间点）</li>
</ul>
<h4 id="本周工作感悟"><a href="#本周工作感悟" class="headerlink" title="本周工作感悟"></a>本周工作感悟</h4><ul>
<li>维度：思考、建议、疑惑、分享等</li>
<li>举例<ul>
<li>工作中遇到问题的提炼，应对方案的分享</li>
<li>工作过程中不同点呈现，创新思考或者亮点的提炼</li>
<li>指标数据的呈现，及差异化分析总结</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
        <category>基本功</category>
      </categories>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统_WMS启动流程</title>
    <url>/blog/2019/11/20/Android%E7%B3%BB%E7%BB%9F_WMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="图文概括"><a href="#图文概括" class="headerlink" title="图文概括"></a>图文概括</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369229565.png"  alt=""></p>
<h4 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369281784.png"  alt=""></p>
<ul>
<li>Session<ul>
<li>WMS的成员变量mSessions保存着所有的Session对象,Session继承于IWindowSession.Stub, 作为Binder服务端</li>
<li>每一个应用进程都有一个唯一的 Session 对象与 WMS 通信</li>
<li>ViewRootImpl 和 WMS 之间的通信就是通过 Session 对象完成的</li>
</ul>
</li>
<li>WindowState<ul>
<li>WMS中，通过mWindowMap（WindowHashMap ）保存所有的WindowState对象</li>
<li>WindowState 中保存了 WMS 对象、WMP 对象、Session 对象和 IWindow对象,一个 WindowState 对象就对应着一个应用进程中的 Window 对象; IWindow -&gt; ViewRootImpl.W extends IWindow.Stub</li>
</ul>
</li>
<li>WindowToken<ul>
<li>WMS成员变量mTokenMap: 保存所有的WindowToken对象; 以IBinder为key,可以是IAppWindowToken或者其他Binder的Bp端;IBinder -&gt; ActivityRecord.Token extends IApplicationToken.Stub</li>
<li>一个 WindowToken 就代表着一个应用组件，应用组件包括：Activity、InputMethod 等。在 WMS 中，会将属于同一 WindowToken 的做统一处理，比如在对窗口进行 ZOrder 排序时，会将属于统一 WindowToken 的排在一起</li>
<li>WindowToken 也具有令牌的作用。应用组件在创建 Window 时都需要提供一个有效的 WindowToken 以表明自己的身份，并且窗口的类型必须与所持有的 WindowToken 类型保持一致。</li>
</ul>
</li>
</ul>
<h3 id="源码分析—启动流程"><a href="#源码分析—启动流程" class="headerlink" title="源码分析—启动流程"></a>源码分析—启动流程</h3><blockquote>
<p>基于API23 </p>
</blockquote>
<h4 id="SystemServer启动WMS"><a href="#SystemServer启动WMS" class="headerlink" title="SystemServer启动WMS"></a>SystemServer启动WMS</h4><ul>
<li>执行WMS的main方法，进行WMS创建及初始化</li>
<li>执行WMS的displayReady方法，初始化显示信息</li>
<li>执行WMS的systemReady方法，通知 WMS 系统的初始化工作完成</li>
</ul>
<p>参考：<a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">Android系统_SystemServer启动流程分析
</a></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F; system server 执行启动其它系统服务</span><br><span class="line"> private void startOtherServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 执行 WMS的main方法</span><br><span class="line">    WindowManagerService wm &#x3D; WindowManagerService.main(context, inputManager,</span><br><span class="line">    mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">    !mFirstBoot, mOnlyCore);</span><br><span class="line">    </span><br><span class="line">    wm.displayReady(); </span><br><span class="line">    ...</span><br><span class="line">    wm.systemReady(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><ul>
<li>WMS为单例模式</li>
<li>WMS的main方法，通过DisplayThread创建了一个WMS单例对象</li>
<li>运行在”android.display”线程，DisplayThread 线程是一个系统前台线程，用于执行一些延时要非常小的关于显示的操作，一般只会在 WindowManager、DisplayManager 和 InputManager 中使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WindowManagerService extends IWindowManager.Stub</span><br><span class="line">        implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs &#123;</span><br><span class="line"></span><br><span class="line">    private static WindowManagerService sInstance;</span><br><span class="line">    static WindowManagerService getInstance() &#123;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static WindowManagerService main(final Context context, final InputManagerService im,</span><br><span class="line">            final boolean haveInputMethods, final boolean showBootMsgs, final boolean onlyCore,</span><br><span class="line">            WindowManagerPolicy policy) &#123;</span><br><span class="line">        &#x2F;&#x2F; &quot;android.display&quot;线程</span><br><span class="line">        DisplayThread.getHandler().runWithScissors(() -&gt;</span><br><span class="line">                sInstance &#x3D; new WindowManagerService(context, im, haveInputMethods, showBootMsgs,</span><br><span class="line">                        onlyCore, policy), 0);</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li>赋值及初始化成员变量（context、inputManager、policy）等</li>
<li>创建一个 WindowAnimator 对象，用于管理所有窗口的动画</li>
<li>初始化 mPolicy ，具体的实现类是 PhoneWindowManager，WMS 的许多操作都是需要 WMP 规定的，比如：多个窗口的上下顺序，监听屏幕旋转的状态，预处理一些系统按键事件（例如HOME、BACK键等的默认行为就是在这里实现的）</li>
<li>将 WMS 实例对象本身添加到 Watchdog 中，WMS 类实现了 Watchdog.Monitor 接口。Watchdog 用于监控系统的一些关键服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private WindowManagerService(Context context, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) &#123;</span><br><span class="line">    mContext &#x3D; context;</span><br><span class="line">    mHaveInputMethods &#x3D; haveInputMethods;</span><br><span class="line">    mAllowBootMessages &#x3D; showBootMsgs;</span><br><span class="line">    mOnlyCore &#x3D; onlyCore;</span><br><span class="line">    ...</span><br><span class="line">    mInputManager &#x3D; inputManager; </span><br><span class="line">    mDisplayManagerInternal &#x3D; LocalServices.getService(DisplayManagerInternal.class);</span><br><span class="line">    mDisplaySettings &#x3D; new DisplaySettings();</span><br><span class="line">    mDisplaySettings.readSettingsLocked();</span><br><span class="line"></span><br><span class="line">    LocalServices.addService(WindowManagerPolicy.class, mPolicy);</span><br><span class="line">    mPointerEventDispatcher &#x3D; new PointerEventDispatcher(mInputManager.monitorInput(TAG));</span><br><span class="line"></span><br><span class="line">    mFxSession &#x3D; new SurfaceSession();</span><br><span class="line">    mDisplayManager &#x3D; (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line">    mDisplays &#x3D; mDisplayManager.getDisplays();</span><br><span class="line"></span><br><span class="line">    for (Display display : mDisplays) &#123;</span><br><span class="line">        createDisplayContentLocked(display);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mKeyguardDisableHandler &#x3D; new KeyguardDisableHandler(mContext, mPolicy);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mAppTransition &#x3D; new AppTransition(context, mH);</span><br><span class="line">    mAppTransition.registerListenerLocked(mActivityManagerAppTransitionNotifier);</span><br><span class="line">    mActivityManager &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">    ...</span><br><span class="line">    mAnimator &#x3D; new WindowAnimator(this);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    LocalServices.addService(WindowManagerInternal.class, new LocalService());</span><br><span class="line">    &#x2F;&#x2F;初始化策略</span><br><span class="line">    initPolicy();</span><br><span class="line"></span><br><span class="line">    Watchdog.getInstance().addMonitor(this);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initPolicy"><a href="#initPolicy" class="headerlink" title="initPolicy"></a>initPolicy</h4><ul>
<li>UiThread进行policy的初始化，此过程为同步阻塞过程，运行在android.ui线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initPolicy() &#123;</span><br><span class="line">    &#x2F;&#x2F; 切换到 UiThread 执行，运行在&quot;android.ui&quot;线程，runWithScissors会判断当前执行线程，来决定是直接执行还是等待执行</span><br><span class="line">    UiThread.getHandler().runWithScissors(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">    WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line">            &#x2F;&#x2F; 初始化</span><br><span class="line">            mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="displayReady"><a href="#displayReady" class="headerlink" title="displayReady"></a>displayReady</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void displayReady() &#123;</span><br><span class="line">    for (Display display : mDisplays) &#123;</span><br><span class="line">        displayReady(display.getDisplayId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(mWindowMap) &#123;</span><br><span class="line">        final DisplayContent displayContent &#x3D; getDefaultDisplayContentLocked();</span><br><span class="line">        readForcedDisplayPropertiesLocked(displayContent);</span><br><span class="line">        mDisplayReady &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActivityManager.updateConfiguration(null);</span><br><span class="line"></span><br><span class="line">    synchronized(mWindowMap) &#123;</span><br><span class="line">        mIsTouchDevice &#x3D; mContext.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_TOUCHSCREEN);</span><br><span class="line">        configureDisplayPolicyLocked(getDefaultDisplayContentLocked());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActivityManager.updateConfiguration(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="systemReady"><a href="#systemReady" class="headerlink" title="systemReady"></a>systemReady</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void systemReady() &#123;</span><br><span class="line">    mPolicy.systemReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void systemReady() &#123;</span><br><span class="line">    mKeyguardDelegate &#x3D; new KeyguardServiceDelegate(mContext);</span><br><span class="line">    mKeyguardDelegate.onSystemReady();</span><br><span class="line"></span><br><span class="line">    readCameraLensCoverState();</span><br><span class="line">    updateUiMode();</span><br><span class="line">    boolean bindKeyguardNow;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        updateOrientationListenerLp();</span><br><span class="line">        mSystemReady &#x3D; true;</span><br><span class="line">        </span><br><span class="line">        mHandler.post(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                updateSettings();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        bindKeyguardNow &#x3D; mDeferBindKeyguard;</span><br><span class="line">        if (bindKeyguardNow) &#123;</span><br><span class="line">            mDeferBindKeyguard &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bindKeyguardNow) &#123;</span><br><span class="line">        mKeyguardDelegate.bindService(mContext);</span><br><span class="line">        mKeyguardDelegate.onBootCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">    mSystemGestures.systemReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析—重要成员"><a href="#源码分析—重要成员" class="headerlink" title="源码分析—重要成员"></a>源码分析—重要成员</h3><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><ul>
<li>WMS的成员变量mSessions保存着所有的Session对象,Session继承于IWindowSession.Stub, 作为Binder服务端;</li>
<li>每一个应用进程都有一个唯一的 Session 对象与 WMS 通信</li>
<li>ViewRootImpl 和 WMS 之间的通信就是通过 Session 对象完成的。</li>
</ul>
<h5 id="WMS-mSessions"><a href="#WMS-mSessions" class="headerlink" title="WMS.mSessions"></a>WMS.mSessions</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WindowManagerService extends IWindowManager.Stub</span><br><span class="line">        implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs &#123;</span><br><span class="line">        &#x2F;&#x2F; All currently active sessions with clients.</span><br><span class="line">        final ArraySet&lt;Session&gt; mSessions &#x3D; new ArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,</span><br><span class="line">            IInputContext inputContext) &#123;</span><br><span class="line">            </span><br><span class="line">            Session session &#x3D; new Session(this, callback, client, inputContext);</span><br><span class="line">            return session;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Session extends IWindowSession.Stub</span><br><span class="line">        implements IBinder.DeathRecipient &#123;</span><br><span class="line">    final WindowManagerService mService; &#x2F;&#x2F; 持有WMS</span><br><span class="line">    private int mNumWindow &#x3D; 0; </span><br><span class="line">    </span><br><span class="line">    public Session(WindowManagerService service, IWindowSessionCallback callback,</span><br><span class="line">            IInputMethodClient client, IInputContext inputContext) &#123;</span><br><span class="line">        mService &#x3D; service; &#x2F;&#x2F; 赋值</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 添加</span><br><span class="line">    void windowAddedLocked(String packageName) &#123;</span><br><span class="line">        if (mSurfaceSession &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mService.mSessions.add(this);</span><br><span class="line">        &#125;</span><br><span class="line">        mNumWindow++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 移除</span><br><span class="line">    void windowRemovedLocked() &#123;</span><br><span class="line">        mNumWindow--;</span><br><span class="line">        killSessionLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void killSessionLocked() &#123;</span><br><span class="line">        if (mNumWindow &gt; 0 || !mClientDead) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mService.mSessions.remove(this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="WindowState"><a href="#WindowState" class="headerlink" title="WindowState"></a>WindowState</h4><ul>
<li>WMS中，通过mWindowMap（WindowHashMap ）保存所有的WindowState对象</li>
<li>WindowState 中保存了 WMS 对象、WMP 对象、Session 对象和 IWindow对象,一个 WindowState 对象就对应着一个应用进程中的 Window 对象; IWindow -&gt; ViewRootImpl.W extends IWindow.Stub</li>
</ul>
<h5 id="WindowManagerService-addWindowToken"><a href="#WindowManagerService-addWindowToken" class="headerlink" title="WindowManagerService.addWindowToken"></a>WindowManagerService.addWindowToken</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final HashMap&lt;IBinder, WindowToken&gt; mTokenMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void addWindowToken(IBinder token, int type) &#123;</span><br><span class="line">   synchronized(mWindowMap) &#123;</span><br><span class="line">       WindowToken wtoken &#x3D; mTokenMap.get(token);</span><br><span class="line">       wtoken &#x3D; new WindowToken(this, token, type, true);</span><br><span class="line">       mTokenMap.put(token, wtoken);</span><br><span class="line">       if (type &#x3D;&#x3D; TYPE_WALLPAPER) &#123;</span><br><span class="line">           mWallpaperTokens.add(wtoken);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WindowState extends WindowContainer&lt;WindowState&gt; implements WindowManagerPolicy.WindowState &#123;</span><br><span class="line">    final WindowManagerService mService; &#x2F;&#x2F; WMS</span><br><span class="line">    final WindowManagerPolicy mPolicy; &#x2F;&#x2F; WMP</span><br><span class="line">    final Context mContext; &#x2F;&#x2F;ctx</span><br><span class="line">    final Session mSession; &#x2F;&#x2F; session </span><br><span class="line">    final IWindow mClient;  &#x2F;&#x2F; 应用进程中的 Window 对象</span><br><span class="line"></span><br><span class="line">    WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">           WindowState parentWindow, int appOp, int seq, WindowManager.LayoutParams a,</span><br><span class="line">           int viewVisibility, int ownerId, boolean ownerCanAddInternalSystemWindow) &#123;</span><br><span class="line">        mService &#x3D; service;</span><br><span class="line">        mSession &#x3D; s;</span><br><span class="line">        mClient &#x3D; c;</span><br><span class="line">        mAppOp &#x3D; appOp;</span><br><span class="line">        mToken &#x3D; token;</span><br><span class="line">        mAppToken &#x3D; mToken.asAppWindowToken();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void attach() &#123;</span><br><span class="line">        mSession.windowAddedLocked(mAttrs.packageName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; IWindow mClient 就是 ViewRootImpl 中的 final W mWindow 成员</span><br><span class="line">public final class ViewRootImpl implements ViewParent,</span><br><span class="line">        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;</span><br><span class="line">    final W mWindow;</span><br><span class="line"></span><br><span class="line">    static class W extends IWindow.Stub &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="WindowToken"><a href="#WindowToken" class="headerlink" title="WindowToken"></a>WindowToken</h4><ul>
<li>WMS成员变量mTokenMap: 保存所有的WindowToken对象; 以IBinder为key,可以是IAppWindowToken或者其他Binder的Bp端;IBinder -&gt; ActivityRecord.Token extends IApplicationToken.Stub</li>
<li>一个 WindowToken 就代表着一个应用组件，应用组件包括：Activity、InputMethod 等。在 WMS 中，会将属于同一 WindowToken 的做统一处理，比如在对窗口进行 ZOrder 排序时，会将属于统一 WindowToken 的排在一起</li>
<li>WindowToken 也具有令牌的作用。应用组件在创建 Window 时都需要提供一个有效的 WindowToken 以表明自己的身份，并且窗口的类型必须与所持有的 WindowToken 类型保持一致。</li>
</ul>
<h5 id="WMS-mTokenMap相关"><a href="#WMS-mTokenMap相关" class="headerlink" title="WMS.mTokenMap相关"></a>WMS.mTokenMap相关</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final HashMap&lt;IBinder, WindowToken&gt; mTokenMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void addWindowToken(IBinder token, int type) &#123;</span><br><span class="line">     synchronized(mWindowMap) &#123;</span><br><span class="line">       WindowToken wtoken &#x3D; mTokenMap.get(token);</span><br><span class="line">       wtoken &#x3D; new WindowToken(this, token, type, true);</span><br><span class="line">       mTokenMap.put(token, wtoken);</span><br><span class="line">       if (type &#x3D;&#x3D; TYPE_WALLPAPER) &#123;</span><br><span class="line">           mWallpaperTokens.add(wtoken);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a><br>参考：<br><a href="http://gityuan.com/2017/01/08/windowmanger/" target="_blank" rel="noopener">WMS—启动过程</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>WMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图形系统—View.draw解析</title>
    <url>/blog/2019/11/20/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E2%80%94View.draw%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="图文概括"><a href="#图文概括" class="headerlink" title="图文概括"></a>图文概括</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>绘制背景</li>
<li>绘制内容</li>
<li>分发子View绘制</li>
<li>绘制装饰</li>
</ol>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369434255.png"  alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="View-draw"><a href="#View-draw" class="headerlink" title="View.draw"></a>View.draw</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">    .... </span><br><span class="line">    &#x2F;&#x2F; 1. 绘制本身View背景</span><br><span class="line">    if (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        &#x2F;&#x2F; Step 3, draw the content</span><br><span class="line">        &#x2F;&#x2F; 2. 绘制内容，默认空实现 需复写</span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 3. 绘制 children </span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4. 分发Draw （单一View空实现，ViewGroup见下面分析）</span><br><span class="line">        if (mOverlay !&#x3D; null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 5. 绘制装饰 (前景色，滚动条)</span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制背景</span><br><span class="line">private void drawBackground(Canvas canvas) &#123;</span><br><span class="line">    final Drawable background &#x3D; mBackground;</span><br><span class="line">    if (background &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据在 layout 过程中获取的 View 的位置参数，来设置背景的边界</span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 先尝试用HWUI绘制</span><br><span class="line">    if (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo !&#x3D; null</span><br><span class="line">            &amp;&amp; mAttachInfo.mThreadedRenderer !&#x3D; null) &#123;</span><br><span class="line">        mBackgroundRenderNode &#x3D; getDrawableRenderNode(background, mBackgroundRenderNode);</span><br><span class="line"></span><br><span class="line">        final RenderNode renderNode &#x3D; mBackgroundRenderNode;</span><br><span class="line">        if (renderNode !&#x3D; null &amp;&amp; renderNode.isValid()) &#123;</span><br><span class="line">            setBackgroundRenderNodeProperties(renderNode);</span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int scrollX &#x3D; mScrollX;</span><br><span class="line">    final int scrollY &#x3D; mScrollY;</span><br><span class="line">    if ((scrollX | scrollY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;调用 Drawable 的 draw 方法来进行背景的绘制</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 若 mScrollX 和 mScrollY 有值，则对 canvas 的坐标进行偏移平移画布</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        &#x2F;&#x2F;调用 Drawable 的 draw 方法来进行背景的绘制</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绘制View本身内容，空实现，子类必须复写</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 单一View无子View，空实现</span><br><span class="line">protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onDrawForeground(Canvas canvas) &#123;</span><br><span class="line">    &#x2F;&#x2F;绘制指示器</span><br><span class="line">    onDrawScrollIndicators(canvas);</span><br><span class="line">    &#x2F;&#x2F;绘制滚动条</span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">    final Drawable foreground &#x3D; mForegroundInfo !&#x3D; null ? mForegroundInfo.mDrawable : null;</span><br><span class="line">    if (foreground !&#x3D; null) &#123;</span><br><span class="line">        if (mForegroundInfo.mBoundsChanged) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged &#x3D; false;</span><br><span class="line">            final Rect selfBounds &#x3D; mForegroundInfo.mSelfBounds;</span><br><span class="line">            final Rect overlayBounds &#x3D; mForegroundInfo.mOverlayBounds;</span><br><span class="line"></span><br><span class="line">            if (mForegroundInfo.mInsidePadding) &#123;</span><br><span class="line">                selfBounds.set(0, 0, getWidth(), getHeight());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                selfBounds.set(getPaddingLeft(), getPaddingTop(),</span><br><span class="line">                        getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int ld &#x3D; getLayoutDirection();</span><br><span class="line">            Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),</span><br><span class="line">                    foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);</span><br><span class="line">            foreground.setBounds(overlayBounds);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用 Drawable 的 draw 方法，绘制前景色</span><br><span class="line">        foreground.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ViewGroup-draw"><a href="#ViewGroup-draw" class="headerlink" title="ViewGroup.draw"></a>ViewGroup.draw</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用View.draw 方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 1. 遍历子View</span><br><span class="line">    final int childrenCount &#x3D; mChildrenCount;</span><br><span class="line">    ...</span><br><span class="line">    for (int i &#x3D; 0; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        while (transientIndex &gt;&#x3D; 0 &amp;&amp; mTransientIndices.get(transientIndex) &#x3D;&#x3D; i) &#123;</span><br><span class="line">            final View transientChild &#x3D; mTransientViews.get(transientIndex);</span><br><span class="line">            if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) &#x3D;&#x3D; VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() !&#x3D; null) &#123;</span><br><span class="line">                more |&#x3D; drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            transientIndex++;</span><br><span class="line">            if (transientIndex &gt;&#x3D; transientCount) &#123;</span><br><span class="line">                transientIndex &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int childIndex &#x3D; getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        final View child &#x3D; getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        if ((child.mViewFlags &amp; VISIBILITY_MASK) &#x3D;&#x3D; VISIBLE || child.getAnimation() !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 drawChild 方法，进行子元素绘制</span><br><span class="line">            more |&#x3D; drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">-</span><br></pre></td></tr></table></figure>

<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图形系统—View.layout解析</title>
    <url>/blog/2019/11/19/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E2%80%94View.layout%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="图文概括"><a href="#图文概括" class="headerlink" title="图文概括"></a>图文概括</h3><ol>
<li>单一View通过layout方法确定位置，ViewGroup子类通过重写抽象onLayout方法来实现子视图以及自己的位置分配逻辑</li>
<li>getWidth|getHeight与getMeasuredWidth|getMeasureHeight区别</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>概念</th>
<th>时机</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>getMeasuredWidth和Height</td>
<td>测量的宽和高</td>
<td>measure过程</td>
<td>onMeasure使用</td>
</tr>
<tr>
<td>getWidth和Height</td>
<td>计算的宽和高</td>
<td>layout过程</td>
<td>onLayout使用</td>
</tr>
</tbody></table>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369522264.png"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369582497.png"  alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="View-measure过程"><a href="#View-measure过程" class="headerlink" title="View.measure过程"></a>View.measure过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 计算View的四个顶点为孩子（left、top、right、bottom）</span><br><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断是否需要重新测量</span><br><span class="line">    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0) &#123;</span><br><span class="line">      onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">      mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保存上一次View的四个位置</span><br><span class="line">    int oldL &#x3D; mLeft;</span><br><span class="line">    int oldT &#x3D; mTop;</span><br><span class="line">    int oldB &#x3D; mBottom;</span><br><span class="line">    int oldR &#x3D; mRight;</span><br><span class="line">    &#x2F;&#x2F; 设置当前视图View的l、t、r、b位置，及判断布局是否有改变</span><br><span class="line">    boolean changed &#x3D; isLayoutModeOptical(mParent) ?</span><br><span class="line">          setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    &#x2F;&#x2F; View大小 或者 位置发生变化 则重新布局View</span><br><span class="line">    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 对于单一View，onLayout是一个空实现</span><br><span class="line">        &#x2F;&#x2F; 2. 对于ViewGroup，因为位置的确定与布局有关，所以onLayout是一个抽象方法，需要重写实现</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过传入的4个顶点位置设置View的四个顶点位置 ，返回位置是否变化</span><br><span class="line">protected boolean setFrame(int left, int top, int right, int bottom) &#123;</span><br><span class="line">    boolean changed &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 是否改变</span><br><span class="line">    if (mLeft !&#x3D; left || mRight !&#x3D; right || mTop !&#x3D; top || mBottom !&#x3D; bottom) &#123;</span><br><span class="line">      changed &#x3D; true;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; Remember our drawn bit</span><br><span class="line">      int drawn &#x3D; mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line">    </span><br><span class="line">      int oldWidth &#x3D; mRight - mLeft;</span><br><span class="line">      int oldHeight &#x3D; mBottom - mTop;</span><br><span class="line">      int newWidth &#x3D; right - left;</span><br><span class="line">      int newHeight &#x3D; bottom - top;</span><br><span class="line">      boolean sizeChanged &#x3D; (newWidth !&#x3D; oldWidth) || (newHeight !&#x3D; oldHeight);</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 位置变化，执行invalidate</span><br><span class="line">      invalidate(sizeChanged);</span><br><span class="line">      &#x2F;&#x2F; 设置新的顶点位置</span><br><span class="line">      mLeft &#x3D; left;</span><br><span class="line">      mTop &#x3D; top;</span><br><span class="line">      mRight &#x3D; right;</span><br><span class="line">      mBottom &#x3D; bottom;</span><br><span class="line">      mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line">      ...    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return changed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单一View在layout已经确定了位置，所以onLayout空实现</span><br><span class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewGroup-measure"><a href="#ViewGroup-measure" class="headerlink" title="ViewGroup.measure"></a>ViewGroup.measure</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; measure过程调用的View.measure，不同在于onLayout</span><br><span class="line">    @Override</span><br><span class="line">public final void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">   if (!mSuppressLayout &amp;&amp; (mTransition &#x3D;&#x3D; null || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">       if (mTransition !&#x3D; null) &#123;</span><br><span class="line">           mTransition.layoutChange(this);</span><br><span class="line">       &#125;</span><br><span class="line">       super.layout(l, t, r, b);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; record the fact that we noop&#39;d it; request layout when transition finishes</span><br><span class="line">       mLayoutCalledWhileSuppressed &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 抽象方法，子类需要实现以实现child的layout计算</span><br><span class="line">protected abstract void onLayout(boolean changed,</span><br><span class="line">       int l, int t, int r, int b);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 大体过程</span><br><span class="line">protected void onLayout(boolean changed,</span><br><span class="line">       int l, int t, int r, int b)&#123;</span><br><span class="line">    for (int i&#x3D;0; i&lt;getChildCount(); i++) &#123;</span><br><span class="line">       View child &#x3D; getChildAt(i);  </span><br><span class="line">       &#x2F;&#x2F; 计算子View的测量宽高</span><br><span class="line">       &#x2F;&#x2F; 执行child的layout方法，child.layout </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图形系统-View之LinearLayout.onMeasure分析</title>
    <url>/blog/2019/11/18/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F-View%E4%B9%8BLinearLayout.onMeasure%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="图文概括"><a href="#图文概括" class="headerlink" title="图文概括"></a>图文概括</h3><p><strong>总结</strong></p>
<ol>
<li>【父非EXACTLY &amp; 子控件有weight并且指定高度为0】 则会执行二次测量方法</li>
<li>【不满足1条件 &amp; weight&gt;0】的控件因为没有跳过第一次测量，而在第二次测量方法中也会进行测量</li>
<li>【父非EXACTLY &amp; 子height未指定0 】则weight属性不生效</li>
</ol>
<p><strong>流程</strong></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884369823424.png"  alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><blockquote>
<p>基于API23分析</p>
</blockquote>
<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">   if (mOrientation &#x3D;&#x3D; VERTICAL) &#123;</span><br><span class="line">       measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; 变量声明</span><br><span class="line">    &#x2F;&#x2F; 第一次测量，循环测量（非EXACTLY &amp; lp.height&#x3D;&#x3D;0 &amp; lp.weight&gt;0,父不定高且子高度为0还有权重）</span><br><span class="line">    &#x2F;&#x2F; 忽略，useLargestChild&#x3D;true下的测量</span><br><span class="line">    &#x2F;&#x2F; 第二次测量 （weight相关）</span><br><span class="line">    &#x2F;&#x2F; 设置宽高值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; 变量声明</span><br><span class="line">    &#x2F;&#x2F; 成员变量，核心目的，求总高度</span><br><span class="line">    mTotalLength &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 记录子空间中最大宽度</span><br><span class="line">    int maxWidth &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 子控件的测量状态，会在遍历子控件测量的时候通过combineMeasuredStates来合并上一个子控件测量状态与当前遍历到的子控件的测量状态，采取的是按位相或</span><br><span class="line">    int childState &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; layout_weight&lt;&#x3D;0的子控件最大宽度</span><br><span class="line">    int alternativeMaxWidth &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; layout_weight&gt;0的子控件最大宽度</span><br><span class="line">    int weightedMaxWidth &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 以上两个最大宽度跟上面的maxWidth最大的区别在于matchWidthLocally这个参数</span><br><span class="line">    &#x2F;&#x2F; 当matchWidthLocally为真，那么以下两个变量只会跟当前子控件的左右margin和相比较取大值</span><br><span class="line">    &#x2F;&#x2F; 否则，则跟maxWidth的计算方法一样</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否子控件全是match_parent的标志位，用于判断是否需要重新测量</span><br><span class="line">    boolean allFillParent &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F; 所有子控件的weight之和</span><br><span class="line">    float totalWeight &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 子控件数目（不含孙及以下控件）</span><br><span class="line">    final int count &#x3D; getVirtualChildCount();</span><br><span class="line">    &#x2F;&#x2F; 测量模式</span><br><span class="line">    final int widthMode &#x3D; MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    final int heightMode &#x3D; MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    &#x2F;&#x2F; 当子控件为match_parent的时候，该值为ture，同时判定的还有上面所说的matchWidthLocally，这个变量决定了子控件的测量是父控件干预还是填充父控件（剩余的空白位置）。</span><br><span class="line">    boolean matchWidth &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 是否跳过第一次测量</span><br><span class="line">    boolean skippedMeasure &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    final int baselineChildIndex &#x3D; mBaselineAlignedChildIndex;        </span><br><span class="line">    final boolean useLargestChild &#x3D; mUseLargestChild;</span><br><span class="line">    </span><br><span class="line">    int largestChildHeight &#x3D; Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第一次测量"><a href="#第一次测量" class="headerlink" title="第一次测量"></a>第一次测量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一次测量</span><br><span class="line">    &#x2F;&#x2F; See how tall everyone is. Also remember max width.</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; ++i) &#123;</span><br><span class="line">        final View child &#x3D; getVirtualChildAt(i);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 添加 Divider高度</span><br><span class="line">        if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">         mTotalLength +&#x3D; mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LinearLayout.LayoutParams lp &#x3D; (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">        &#x2F;&#x2F; 总weight 添加weight</span><br><span class="line">        totalWeight +&#x3D; lp.weight;</span><br><span class="line">        </span><br><span class="line">        if (heightMode &#x3D;&#x3D; MeasureSpec.EXACTLY &amp;&amp; lp.height &#x3D;&#x3D; 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">           &#x2F;&#x2F; EXACTLY 且 高度为0 且 weight&gt;0 则先跳过该控件的测量</span><br><span class="line">           final int totalLength &#x3D; mTotalLength;</span><br><span class="line">           mTotalLength &#x3D; Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">           skippedMeasure &#x3D; true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int oldHeight &#x3D; Integer.MIN_VALUE;</span><br><span class="line">               </span><br><span class="line">            if (lp.height &#x3D;&#x3D; 0 &amp;&amp; lp.weight &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 此条件下，防止height为0</span><br><span class="line">                oldHeight &#x3D; 0;</span><br><span class="line">                lp.height &#x3D; LayoutParams.WRAP_CONTENT;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 测量child（已经使用的height通过padding实现剔除）</span><br><span class="line">            measureChildBeforeLayout(</span><br><span class="line">                 child, i, widthMeasureSpec, 0, heightMeasureSpec,</span><br><span class="line">                 totalWeight &#x3D;&#x3D; 0 ? mTotalLength : 0);</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            final int totalLength &#x3D; mTotalLength;</span><br><span class="line">            mTotalLength &#x3D; Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                 lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 计算 宽度 和最大宽度等</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    </span><br><span class="line">        i +&#x3D; getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用子测量方法"><a href="#调用子测量方法" class="headerlink" title="调用子测量方法"></a>调用子测量方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void measureChildBeforeLayout(View child, int childIndex,</span><br><span class="line">       int widthMeasureSpec, int totalWidth, int heightMeasureSpec,</span><br><span class="line">       int totalHeight) &#123;</span><br><span class="line">    measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class="line">      heightMeasureSpec, totalHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">       int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">       int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">    final MarginLayoutParams lp &#x3D; (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    &#x2F;&#x2F; child测量时，会将已经用过的height和weight当作measure的padding来剔除</span><br><span class="line">    final int childWidthMeasureSpec &#x3D; getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">          mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                  + widthUsed, lp.width);</span><br><span class="line">    final int childHeightMeasureSpec &#x3D; getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">          mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                  + heightUsed, lp.height);</span><br><span class="line">    </span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useLargestChild相关测量"><a href="#useLargestChild相关测量" class="headerlink" title="useLargestChild相关测量"></a>useLargestChild相关测量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; 下面的这一段代码主要是为useLargestChild属性服务的，忽略</span><br><span class="line">    if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">      mTotalLength +&#x3D; mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (useLargestChild &amp;&amp;</span><br><span class="line">          (heightMode &#x3D;&#x3D; MeasureSpec.AT_MOST || heightMode &#x3D;&#x3D; MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">      mTotalLength &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">      for (int i &#x3D; 0; i &lt; count; ++i) &#123;</span><br><span class="line">          final View child &#x3D; getVirtualChildAt(i);</span><br><span class="line">    </span><br><span class="line">          if (child &#x3D;&#x3D; null) &#123;</span><br><span class="line">              mTotalLength +&#x3D; measureNullChild(i);</span><br><span class="line">              continue;</span><br><span class="line">          &#125;</span><br><span class="line">    </span><br><span class="line">          if (child.getVisibility() &#x3D;&#x3D; GONE) &#123;</span><br><span class="line">              i +&#x3D; getChildrenSkipCount(child, i);</span><br><span class="line">              continue;</span><br><span class="line">          &#125;</span><br><span class="line">    </span><br><span class="line">          final LinearLayout.LayoutParams lp &#x3D; (LinearLayout.LayoutParams)</span><br><span class="line">                  child.getLayoutParams();</span><br><span class="line">          &#x2F;&#x2F; Account for negative margins</span><br><span class="line">          final int totalLength &#x3D; mTotalLength;</span><br><span class="line">          mTotalLength &#x3D; Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                  lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; Add in our padding</span><br><span class="line">    mTotalLength +&#x3D; mPaddingTop + mPaddingBottom;</span><br><span class="line">    </span><br><span class="line">    int heightSize &#x3D; mTotalLength;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Check against our minimum height</span><br><span class="line">    heightSize &#x3D; Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; Reconcile our calculated size with the heightMeasureSpec</span><br><span class="line">    int heightSizeAndState &#x3D; resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class="line">    heightSize &#x3D; heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二次测量"><a href="#第二次测量" class="headerlink" title="第二次测量"></a>第二次测量</h4><p>⚠️ <strong>weight</strong></p>
<ol>
<li>【父非EXACTLY &amp; 子控件有weight并且指定高度为0】 则会执行二次测量方法</li>
<li>【不满足1条件 &amp; weight&gt;0】的控件因为没有跳过第一次测量，而在第二次测量方法中也会进行测量</li>
<li>【父非EXACTLY &amp; 子height未制定0 则weight属性不生效】</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公式：</span><br><span class="line">第一次测量：mTotalLength &#x3D; (是否跳过第一次测量) ？ 子.h ：0 </span><br><span class="line">剩余高度： delta &#x3D; heightSize - mTotalLength </span><br><span class="line">分配子高度： share &#x3D; (int) (childExtra * delta &#x2F; weightSum) </span><br><span class="line">剩余权重： weightSum -&#x3D; childExtra</span><br><span class="line">剩余分配高度：  delta -&#x3D; share </span><br><span class="line">子高度： childHeight &#x3D; child.getMeasuredHeight() + share</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">假设： LinearLayout.h &#x3D; 100 , A.w : B.w &#x3D; 2 :8 (权重)</span><br><span class="line">结果： 子控件设置不同的height，结果如下（-1 &#x3D; match_parent）</span><br><span class="line"></span><br><span class="line">|  | A.h&#x3D;0 | B.h&#x3D;0 | A.h&#x3D;-1 | B.h&#x3D;-1 |</span><br><span class="line">| --- | --- | --- | --- | --- |</span><br><span class="line">| mTotalLength | 0 | 0 | 200 | 200 |</span><br><span class="line">| delta | 100 | 80  | -100 | -80 |</span><br><span class="line">| share | 20 | 80 | -20 | -80 |</span><br><span class="line">| delta | 80 | 0 | -80 | 0 |</span><br><span class="line">| childHeight | 20 | 80 | 80 | 20 |</span><br></pre></td></tr></table></figure>
<p>void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {<br>    // 计算剩余高度<br>    int delta = heightSize - mTotalLength;<br>    // 上面skippedMeasure为true，剩余高度!=0 ，且totalWeight&gt;0<br>    // 有weight的会测量两次，测量两次的控件是上面没有跳过测量的控件而跳过测量的控件这里进行测量（父非EXACTLY且子高度为0还有权重）<br>    if (skippedMeasure || delta != 0 &amp;&amp; totalWeight &gt; 0.0f) {<br>        // 限定weight总和范围，如果设置过weighSum范围，那么子控件的weight为设置的weight<br>      float weightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;</p>
<pre><code>mTotalLength = 0;

for (int i = 0; i &lt; count; ++i) {
    final View child = getVirtualChildAt(i);

    if (child.getVisibility() == View.GONE) {
        continue;
    }

    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();

    float childExtra = lp.weight;
    // weight  &gt; 0 的控件进行测量
    if (childExtra &gt; 0) {
      // 公式 = 剩余高度*（子控件的weight/weightSum）
      int share = (int) (childExtra * delta / weightSum);
      // weightSum计余
      weightSum -= childExtra;
      // 剩余高度
      delta -= share;
      // 计算child 的测量规格    
      final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
             mPaddingLeft + mPaddingRight +
                     lp.leftMargin + lp.rightMargin, lp.width);
      // 如果child height没有指定0（wrap或者match） 且非 EXACTLY
      if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
          // childHeight = 测量高度+分配高度
          // ⚠️ 此处share为 负数
          int childHeight = child.getMeasuredHeight() + share;
          if (childHeight &lt; 0) {
              childHeight = 0;
          }
          // child测量
          child.measure(childWidthMeasureSpec,
                  MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
      } else {
          // 用分配高度进行child 测量
          child.measure(childWidthMeasureSpec,
             MeasureSpec.makeMeasureSpec(share &gt; 0 ? share : 0,</code></pre><p>MeasureSpec.EXACTLY));<br>              }</p>
<pre><code>          childState = combineMeasuredStates(childState, child.getMeasuredState()
                  &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));
      }

    // 计算宽度 
    // ...  省略
  }


  mTotalLength += mPaddingTop + mPaddingBottom;

}  else {
    // 没有weight，只有usrLargestChild为true的计算，省略 
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 设置宽高值</span><br></pre></td></tr></table></figure>
<p>void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {<br>    // 设置宽高<br>    if (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) {<br>      maxWidth = alternativeMaxWidth;<br>    }</p>
<pre><code>maxWidth += mPaddingLeft + mPaddingRight;

// Check against our minimum width
maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
// 设置 LinearLayout的宽、高值
setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
      heightSizeAndState);

if (matchWidth) {
  forceUniformWidth(count, heightMeasureSpec);
}   </code></pre><p>}</p>
<pre><code>
-------

推荐阅读：[图形系统总结](https://www.jianshu.com/p/238eb0a17760)
</code></pre>]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>LinearLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图形系统—View.measure解析</title>
    <url>/blog/2019/11/17/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F%E2%80%94View.measure%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="图文概览"><a href="#图文概览" class="headerlink" title="图文概览"></a>图文概览</h3><h4 id="View测量流程"><a href="#View测量流程" class="headerlink" title="View测量流程"></a>View测量流程</h4><ol>
<li>measure<ul>
<li>性质：final方法，View测量初始方法  </li>
<li>作用：基本逻辑计算，是否重新测量，调用onMeasure，缓存测量规格</li>
</ul>
</li>
<li>onMeasure <ul>
<li>性质：测量方法，子类可复写实现自己的测量方式</li>
<li>作用：进行测量规格计算，调用getDefaultSize和setMeasureDimension</li>
</ul>
</li>
<li>getDefaultSize<ul>
<li>作用：根据View的测量规格计算宽/高值</li>
</ul>
</li>
<li>setMeasureDimension<ul>
<li>作用：存储测量后的宽/高值</li>
</ul>
</li>
</ol>
<p>View测量规格参考：<a href="https://www.jianshu.com/p/66eb92cca405" target="_blank" rel="noopener">View.MeasureSpec分析</a></p>
<h4 id="ViewGroup测量大概流程"><a href="#ViewGroup测量大概流程" class="headerlink" title="ViewGroup测量大概流程"></a>ViewGroup测量大概流程</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884370098973.png"  alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="View-measure流程"><a href="#View-measure流程" class="headerlink" title="View.measure流程"></a>View.measure流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; view measure入口， final类型</span><br><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; 是否需要再次计算等计算</span><br><span class="line">    ... </span><br><span class="line">    if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;   </span><br><span class="line">        &#x2F;&#x2F; 计算视图大小</span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;else &#123; </span><br><span class="line">        setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; 存储测量后的View宽 &#x2F; 高</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">          getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; View的宽度为mMinWidth和mBackground.getMinimumWidth()中的最大值,高度类似</span><br><span class="line">protected int getSuggestedMinimumWidth() &#123;</span><br><span class="line">    return (mBackground &#x3D;&#x3D; null) ? mMinWidth : max(mMinWidth,mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据View宽&#x2F;高的测量规格计算View的宽&#x2F;高值</span><br><span class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置默认大小</span><br><span class="line">    int result &#x3D; size;</span><br><span class="line">    &#x2F;&#x2F; 获取宽&#x2F;高测量规格的模式 &amp; 测量大小</span><br><span class="line">    int specMode &#x3D; MeasureSpec.getMode(measureSpec);</span><br><span class="line">    int specSize &#x3D; MeasureSpec.getSize(measureSpec);</span><br><span class="line">    </span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">    case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result &#x3D; size;</span><br><span class="line">        break;</span><br><span class="line">    &#x2F;&#x2F; 模式为AT_MOST,EXACTLY时，使用View测量后的宽&#x2F;高值 &#x3D; measureSpec中的Size</span><br><span class="line">    </span><br><span class="line">    case MeasureSpec.AT_MOST:  </span><br><span class="line">    case MeasureSpec.AT_MOST:</span><br><span class="line">    case MeasureSpec.EXACTLY:</span><br><span class="line">        result &#x3D; specSize;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 存储测量后的View宽 &#x2F; 高 </span><br><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    boolean optical &#x3D; isLayoutModeOptical(this);</span><br><span class="line">        if (optical !&#x3D; isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets &#x3D; getOpticalInsets();</span><br><span class="line">            int opticalWidth  &#x3D; insets.left + insets.right;</span><br><span class="line">            int opticalHeight &#x3D; insets.top  + insets.bottom;</span><br><span class="line">            </span><br><span class="line">            measuredWidth  +&#x3D; optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">            measuredHeight +&#x3D; optical ? opticalHeight : -opticalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    mMeasuredWidth &#x3D; measuredWidth;</span><br><span class="line">    mMeasuredHeight &#x3D; measuredHeight;</span><br><span class="line">    </span><br><span class="line">    mPrivateFlags |&#x3D; PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewGroup-onMeasure"><a href="#ViewGroup-onMeasure" class="headerlink" title="ViewGroup.onMeasure"></a>ViewGroup.onMeasure</h4><p>参考：<a href="https://www.jianshu.com/p/e893950d6cb3" target="_blank" rel="noopener">Android图形系统—View之LinearLayout.measure分析</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; ViewGroup 继承类，大体都要充写次方法，大体模式如下</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历子View，对子控件一一measure</span><br><span class="line">    for(int i&#x3D;0;i&lt;size;++i)&#123;</span><br><span class="line">        measureChild(child, widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 合并所有子控件大小，计算出父控件宽高测量规格</span><br><span class="line">    mergeChildSpec() ; &#x2F;&#x2F; 也有可能与第一步同时计算</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置父控件的宽&#x2F;高值</span><br><span class="line">    setMeasuredDimension(widthMeasure,  heightMeasure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图形系统-View测量规格解析</title>
    <url>/blog/2019/11/16/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F-View%E6%B5%8B%E9%87%8F%E8%A7%84%E6%A0%BC%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="图文概括"><a href="#图文概括" class="headerlink" title="图文概括"></a>图文概括</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884370526410.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884370627121.jpg"  alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="View-Measure-类分析"><a href="#View-Measure-类分析" class="headerlink" title="View.Measure 类分析"></a>View.Measure 类分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class MeasureSpec &#123;</span><br><span class="line">    &#x2F;&#x2F; 进位大小 &#x3D; 2的30次方</span><br><span class="line">    private static final int MODE_SHIFT &#x3D; 30;  </span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; 运算遮罩：0x3为16进制，二进制为11，向左进30位</span><br><span class="line">    &#x2F;&#x2F; &#x3D; 11 00 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">    private static final int MODE_MASK  &#x3D; 0x3 &lt;&lt; MODE_SHIFT;  </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; UNSPECIFIED的模式设置：0向左进位30 &#x3D; 00后跟30个0，即00 00000000000</span><br><span class="line">    public static final int UNSPECIFIED &#x3D; 0 &lt;&lt; MODE_SHIFT;  </span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; EXACTLY的模式设置：1向左进位30 &#x3D; 01后跟30个0 ，即01 00000000000</span><br><span class="line">    public static final int EXACTLY &#x3D; 1 &lt;&lt; MODE_SHIFT;  </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; AT_MOST的模式设置：2向左进位30 &#x3D; 10后跟30个0，即10 0000000000</span><br><span class="line">    public static final int AT_MOST &#x3D; 2 &lt;&lt; MODE_SHIFT;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 根据提供的size和mode得到测量规格，即measureSpec</span><br><span class="line">    public static int makeMeasureSpec(int size, int mode) &#123;  </span><br><span class="line">     &#x2F;&#x2F; 设计目的：使用一个32位的二进制数，其中：32和31位代表测量模式（mode）、后30位代表测量大小（size）</span><br><span class="line">         return size + mode;  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F; 通过measureSpec获得测量模式（mode）</span><br><span class="line">    public static int getMode(int measureSpec) &#123;  </span><br><span class="line">      &#x2F;&#x2F;位运算：保留measureSpec的高2位（即测量模式）、使用0替换后30位</span><br><span class="line">         return (measureSpec &amp; MODE_MASK);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 通过measureSpec获得测量大小size    </span><br><span class="line">    public static int getSize(int measureSpec) &#123;  </span><br><span class="line">      &#x2F;&#x2F; 位运算，即 将MODE_MASK取反，也就是变成了00 111111(00后跟30个1)，将32,31替换成0也就是去掉mode，保留后30位的size  </span><br><span class="line">         return (measureSpec &amp; ~MODE_MASK);  </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewGroup-getChildMeasureSpec-方法分析"><a href="#ViewGroup-getChildMeasureSpec-方法分析" class="headerlink" title="ViewGroup.getChildMeasureSpec 方法分析"></a>ViewGroup.getChildMeasureSpec 方法分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据父视图的MeasureSpec &amp; 布局参数LayoutParams，计算单个子View的MeasureSpec</span><br><span class="line">&#x2F;&#x2F; @param spec 父view的详细测量值(MeasureSpec) </span><br><span class="line">&#x2F;&#x2F; @param padding view当前尺寸的的内边距和外边距(padding,margin) </span><br><span class="line">&#x2F;&#x2F; @param childDimension 子视图的布局参数（宽&#x2F;高）</span><br><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">    &#x2F;&#x2F; 父view的测量模式  父view的大小</span><br><span class="line">    int specMode &#x3D; MeasureSpec.getMode(spec);</span><br><span class="line">    int specSize &#x3D; MeasureSpec.getSize(spec);</span><br><span class="line">    &#x2F;&#x2F; 通过父view计算出的子view &#x3D; 父大小-边距（父要求的大小，但子view不一定用这个值） </span><br><span class="line">    int size &#x3D; Math.max(0, specSize - padding);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 声明子view想要的实际大小和模式</span><br><span class="line">    int resultSize &#x3D; 0;</span><br><span class="line">    int resultMode &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当父view的模式为EXACITY时，父view强加给子view确切的值</span><br><span class="line">        &#x2F;&#x2F; 一般是父view设置为match_parent或者固定值的ViewGroup </span><br><span class="line">        case MeasureSpec.EXACTLY:  </span><br><span class="line">             &#x2F;&#x2F; 当子view的LayoutParams&gt;0，即有确切的值  </span><br><span class="line">            if (childDimension &gt;&#x3D; 0) &#123;</span><br><span class="line">                resultSize &#x3D; childDimension;</span><br><span class="line">                resultMode &#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">             &#x2F;&#x2F; 当子view的LayoutParams为MATCH_PARENT时(-1) </span><br><span class="line">             &#x2F;&#x2F; 子view大小为父view大小，模式为EXACTLY  </span><br><span class="line">                resultSize &#x3D; size;</span><br><span class="line">                resultMode &#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                &#x2F;&#x2F;子view决定自己的大小，但最大不能超过父view，模式为AT_MOST  </span><br><span class="line">                resultSize &#x3D; size;</span><br><span class="line">                resultMode &#x3D; MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 当父view的模式为AT_MOST时，父view强加给子view一个最大的值。（一般是父view设置为wrap_content）  </span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (childDimension &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Child wants a specific size... so be it</span><br><span class="line">            resultSize &#x3D; childDimension;</span><br><span class="line">            resultMode &#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            &#x2F;&#x2F; Child wants to be our size, but our size is not fixed.</span><br><span class="line">            &#x2F;&#x2F; Constrain child to not be bigger than us.</span><br><span class="line">            resultSize &#x3D; size;</span><br><span class="line">            resultMode &#x3D; MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; else if (childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            &#x2F;&#x2F; Child wants to determine its own size. It can&#39;t be</span><br><span class="line">            &#x2F;&#x2F; bigger than us.</span><br><span class="line">            resultSize &#x3D; size;</span><br><span class="line">            resultMode &#x3D; MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    </span><br><span class="line">         &#x2F;&#x2F; 当父view的模式为UNSPECIFIED时，父容器不对view有任何限制，要多大给多大</span><br><span class="line">        &#x2F;&#x2F; 多见于ListView、GridView  </span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            if (childDimension &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Child wants a specific size... let him have it</span><br><span class="line">            resultSize &#x3D; childDimension;</span><br><span class="line">            resultMode &#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            &#x2F;&#x2F; Child wants to be our size... find out how big it should</span><br><span class="line">            &#x2F;&#x2F; be</span><br><span class="line">            resultSize &#x3D; View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">            resultMode &#x3D; MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; else if (childDimension &#x3D;&#x3D; LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            &#x2F;&#x2F; Child wants to determine its own size.... find out how</span><br><span class="line">            &#x2F;&#x2F; big it should be</span><br><span class="line">            resultSize &#x3D; View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">            resultMode &#x3D; MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android—adb常用命令</title>
    <url>/blog/2019/11/06/Android%E2%80%94adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="什么是adb"><a href="#什么是adb" class="headerlink" title="什么是adb"></a>什么是adb</h2><p>ADB全称Android Debug Bridge, 是android sdk里的一个工具, 用这个工具可以直接操作管理android模拟器或者真实的andriod设备(手机)。</p>
<h2 id="adb命令的主要用途"><a href="#adb命令的主要用途" class="headerlink" title="adb命令的主要用途"></a>adb命令的主要用途</h2><ol>
<li>运行android设备的shell(命令行)</li>
<li>管理模拟器或android设备的映射端口</li>
<li>安装和卸载应用程序</li>
<li>计算机和android设备之间的上传和下载文件。</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="指定设备"><a href="#指定设备" class="headerlink" title="指定设备"></a>指定设备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  显示所有已连接上adb的设备</span><br><span class="line">adb devices       </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  使用adb devices中展示的第一个真机作为$command目标</span><br><span class="line">adb -d $command  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用adb devices中展示的第一个模拟器作为$command目标 </span><br><span class="line">adb -e $command  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用adb devices中展示的特定serialNumber的devices作为$command目标</span><br><span class="line">adb -s &lt;serialNumber&gt; $command</span><br></pre></td></tr></table></figure>
<h3 id="安装-amp-卸载"><a href="#安装-amp-卸载" class="headerlink" title="安装&amp;卸载"></a>安装&amp;卸载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb install</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 适合覆盖&#x2F;升级安装（前提是apk的签名一致，如果不一致，请卸载后再安装）</span><br><span class="line">adb install -r  </span><br><span class="line"></span><br><span class="line">adb uninstall $packageName</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保留数据信息，但是要求新安装的apk保持一致的签名</span><br><span class="line">adb uninstall -k $packageName</span><br></pre></td></tr></table></figure>
<h3 id="上传-amp-下载"><a href="#上传-amp-下载" class="headerlink" title="上传&amp;下载"></a>上传&amp;下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从电脑传文件到手机</span><br><span class="line">adb push &#x2F;users&#x2F;desktop &#x2F;sdcard&#x2F;data&#x2F;   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从手机传文件到电脑</span><br><span class="line">adb pull &#x2F;sdcard&#x2F;screenshot.png &#x2F;users&#x2F;desktop</span><br></pre></td></tr></table></figure>
<h3 id="shell相关"><a href="#shell相关" class="headerlink" title="shell相关"></a>shell相关</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F; 通过scheme打开页面</span><br><span class="line">adb shell am start -d $&#123;appScheme&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过package打开</span><br><span class="line">adb shell start $&#123;packageName&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过Activity打开</span><br><span class="line">adb shell am start -n $&#123;Activity&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; uninstall卸载   </span><br><span class="line">adb shell pm uninstall $&#123;packageName&#125;    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clear清除数据   </span><br><span class="line">adb shell pm clear $&#123;packageName&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取Activity信息</span><br><span class="line">adb shell dumpsys activity</span><br><span class="line">adb shell dumpsys activity top</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取cpu信息</span><br><span class="line">adb shell dumpsys cpuinfo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取设备电池信息</span><br><span class="line">adb shell dumpsys </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取电源管理信息</span><br><span class="line">adb shell dumpsys power</span><br></pre></td></tr></table></figure>

<h3 id="截屏与录屏"><a href="#截屏与录屏" class="headerlink" title="截屏与录屏"></a>截屏与录屏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;截屏</span><br><span class="line">adb shell screencap  &#x2F;sdcard&#x2F;screen.png   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 录屏  </span><br><span class="line">adb shell screenrecord -size 720*1280  &#x2F;sdcard&#x2F;record.mp4</span><br></pre></td></tr></table></figure>
<h3 id="屏幕参数"><a href="#屏幕参数" class="headerlink" title="屏幕参数"></a>屏幕参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 屏幕分辨率</span><br><span class="line">adb shell wm size    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 屏幕密度  </span><br><span class="line">adb shell wm density</span><br></pre></td></tr></table></figure>
<h3 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 系统版本</span><br><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure>

<h3 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a>logcat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;手机本地log导出</span><br><span class="line">adb logcat -d &gt;&gt; ~&#x2F;Desktop&#x2F;1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手机ANR log导出 </span><br><span class="line">adb pull &#x2F;data&#x2F;anr&#x2F;traces.txt </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出 Error&#x2F;Fatal 日志</span><br><span class="line">adb logcat *:ef</span><br></pre></td></tr></table></figure>




<hr>
]]></content>
      <categories>
        <category>开发效率</category>
        <category>Android</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用—性能监控指标总结</title>
    <url>/blog/2019/11/03/Android%E5%BA%94%E7%94%A8%E2%80%94%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><h4 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h4><ul>
<li>来源  <ul>
<li>Java层：通过设置异常处理的Handler Thread.setDefaultUncaughtExceptionHandler实现</li>
<li>Native层：<a href="https://juejin.im/entry/5962e439f265da6c2810c8aa" target="_blank" rel="noopener">参考</a></li>
</ul>
</li>
</ul>
<h4 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h4><ul>
<li>来源<ul>
<li>通过FileObserver监听/data/anr目录变化，当有traces.txt文件时代表有新ANR发生</li>
<li>通过Handler定期发送消息，并计算5秒内消失是否被处理，如果没处理代表主线程消息队列被阻塞。</li>
</ul>
</li>
</ul>
<h3 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h3><h4 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h4><ul>
<li>来源<ul>
<li>在Anroid N以下版本中通过Choreographer的FrameCallback的doFrame中计算1秒内绘制的次数</li>
<li>在Android N及以上版本中是通过向window中添加Window.OnFrameMetricsAvailableListener，在回调中计算获得 </li>
</ul>
</li>
<li>页面FPS</li>
<li>滚动FPS</li>
<li>自动义FPS</li>
</ul>
<h4 id="启动时长"><a href="#启动时长" class="headerlink" title="启动时长"></a>启动时长</h4><ul>
<li>app冷启动时长<ul>
<li>来源，使用Linux进程启动时间作为冷启动开始时间，从”/proc/$pid/stat”文件中解析得到</li>
</ul>
</li>
<li>页面启动时长</li>
<li>页面首屏时长</li>
<li>自定义测速时长</li>
</ul>
<h3 id="耗损"><a href="#耗损" class="headerlink" title="耗损"></a>耗损</h3><h4 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h4><ul>
<li>来源<ul>
<li>系统路径：查看 /proc/net/xt_qtaguid/stats</li>
<li>系统函数： 调用接口TrafficStats.getUidRxBytes()和TrafficStats.getUidTxBytes()</li>
<li>系统路径： 进入 /proc/uid_stat/[uid命名的目录]/tcp_snd 和 /proc/uid_stat/[uid命名的目录]/tcp_rcv </li>
<li>AOP：流量的统计是在网络层在编译阶段通过gradle插件插入字节码基于AOP实现流量统计，针对不同网络库主要包含HttpClient、okhttp2/okhttp3、HttpUrlConnection、自定义网络框架。通过计算Request和Response body的大小统计上行和下行流量</li>
</ul>
</li>
</ul>
<h4 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h4><ul>
<li>来源<ul>
<li>一种是利用系统提供的Api（BatteryStatsHelper等）来计算，</li>
<li>一种是Battery Historian工具。</li>
</ul>
</li>
</ul>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul>
<li>来源<ul>
<li>CPU总使用率，在proc/stat下有具体的CPU使用情况</li>
</ul>
</li>
</ul>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul>
<li>来源<ul>
<li>内存的统计是通过Debug.getPss()抽样的获取PSS内存计算平均值所得 </li>
</ul>
</li>
</ul>
<h3 id="业务指标"><a href="#业务指标" class="headerlink" title="业务指标"></a>业务指标</h3><h4 id="端到端"><a href="#端到端" class="headerlink" title="端到端"></a>端到端</h4><ul>
<li>网络成功率</li>
<li>业务成功率<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4></li>
<li>加载显示成功率</li>
<li>加载平均耗时</li>
<li>大小监控</li>
</ul>
<h3 id="软硬件指标"><a href="#软硬件指标" class="headerlink" title="软硬件指标"></a>软硬件指标</h3><p>设备型号<br>操作系统<br>屏幕分辨率<br>手机RAM<br>root状态<br>存储空间<br>网络类型</p>
<h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><ul>
<li>指标定义、数据收集、问题分析、问题解决方案等方面一一分析</li>
<li>数据平台建设指导</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统—进程创建流程</title>
    <url>/blog/2019/08/25/Android%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p>
<h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>每个App在启动前必须先创建一个进程，该进程是由Zygote fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件。大多数情况一个App就运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程。<br>进程是能在系统中独立运行并作为资源分配的基本单位，是CPU分配资源的最小单位，它包括独立的地址空间，资源以及一至多个线程。</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是进程中的一个实体，是CPU调度的最小单位，没有独立空间地址，多线程共享所属进程的空间地址，线程主要负责是CPU执行代码的过程<br>APP应用启动时，系统会为应用创建一个名为“主线程”的执行线程。</p>
<h3 id="进程创建流程图"><a href="#进程创建流程图" class="headerlink" title="进程创建流程图"></a>进程创建流程图</h3><ol>
<li>进程创建起点，Process.start，然后告知ZygoteProcess执行启动，它会构造socket通道最后将构造指令及参数发送给zygote进程</li>
<li>zygote进程，socket会循环监听请求，在接受请求后，会封装好构建进程参数通过Zygote.forkAndSpecialize及其native方法fork出一个子进程</li>
<li>子进程fork后，会进行一系列fork后处理事项及Runtime的init初始化工作，最后回调到子进程的zygote.runSelectLoop方法抛出异常走到ActivityThread.main方法，进入子进程世</li>
</ol>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884371848057.png"  alt=""></p>
<h3 id="进程创建代码分析"><a href="#进程创建代码分析" class="headerlink" title="进程创建代码分析"></a>进程创建代码分析</h3><h5 id="进程创建入口"><a href="#进程创建入口" class="headerlink" title="进程创建入口"></a>进程创建入口</h5><p>Process.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                             final String niceName,</span><br><span class="line">                             int uid, int gid, int[] gids,</span><br><span class="line">                             int debugFlags, int mountExternal,</span><br><span class="line">                             int targetSdkVersion,</span><br><span class="line">                             String seInfo,</span><br><span class="line">                             String abi,</span><br><span class="line">                             String instructionSet,</span><br><span class="line">                             String appDataDir,</span><br><span class="line">                             String invokeWith,</span><br><span class="line">                             String[] zygoteArgs) &#123;</span><br><span class="line">   return zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">               debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">               abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进程创建参数准备"><a href="#进程创建参数准备" class="headerlink" title="进程创建参数准备"></a>进程创建参数准备</h5><p>主要工作是生成argsForZygote数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数。</p>
<p>ZygoteProcess.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public final Process.ProcessStartResult start(final String processClass,</span><br><span class="line">                                             final String niceName,</span><br><span class="line">                                             int uid, int gid, int[] gids,</span><br><span class="line">                                             int debugFlags, int mountExternal,</span><br><span class="line">                                             int targetSdkVersion,</span><br><span class="line">                                             String seInfo,</span><br><span class="line">                                             String abi,</span><br><span class="line">                                             String instructionSet,</span><br><span class="line">                                             String appDataDir,</span><br><span class="line">                                             String invokeWith,</span><br><span class="line">                                             String[] zygoteArgs) &#123;</span><br><span class="line">    return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">         debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">         abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    synchronized(Process.class) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 生成argsForZygote数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数</span><br><span class="line">        argsForZygote.add(&quot;--runtime-args&quot;);</span><br><span class="line">        argsForZygote.add(&quot;--setuid&#x3D;&quot; + uid);</span><br><span class="line">        argsForZygote.add(&quot;--setgid&#x3D;&quot; + gid);</span><br><span class="line">        argsForZygote.add(&quot;--target-sdk-version&#x3D;&quot; + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        if (niceName !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--nice-name&#x3D;&quot; + niceName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (appDataDir !&#x3D; null) &#123;</span><br><span class="line">            argsForZygote.add(&quot;--app-data-dir&#x3D;&quot; + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        if (extraArgs !&#x3D; null) &#123;</span><br><span class="line">            for (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="连接Zygote服务，写入创建指令并获取返回结果"><a href="#连接Zygote服务，写入创建指令并获取返回结果" class="headerlink" title="连接Zygote服务，写入创建指令并获取返回结果"></a>连接Zygote服务，写入创建指令并获取返回结果</h5><p>ZygoteProcess.java<br>通过socket向Zygote进程发送消息，从而唤醒Zygote进程，来响应socket客户端的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;    </span><br><span class="line">    &#x2F;&#x2F; 向主zygote发起connect()操作</span><br><span class="line">    primaryZygoteState &#x3D; ZygoteState.connect(mSocket); </span><br><span class="line">    &#x2F;&#x2F;当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static Process.ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">       ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">       throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">         </span><br><span class="line">      final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">      final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line">       </span><br><span class="line">      writer.write(Integer.toString(args.size()));</span><br><span class="line">      writer.newLine();</span><br><span class="line">      &#x2F;&#x2F; 写入参数</span><br><span class="line">      for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">          String arg &#x3D; args.get(i);</span><br><span class="line">          writer.write(arg);</span><br><span class="line">          writer.newLine();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      writer.flush(); </span><br><span class="line">      </span><br><span class="line">      Process.ProcessStartResult result &#x3D; new Process.ProcessStartResult();</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F;等待socket服务端（即zygote）返回新创建的进程pid;</span><br><span class="line">      result.pid &#x3D; inputStream.readInt();</span><br><span class="line">      result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line">    </span><br><span class="line">      if (result.pid &lt; 0) &#123;</span><br><span class="line">          throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">      zygoteState.close();</span><br><span class="line">      throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Zygote接收客户端Socket请求"><a href="#Zygote接收客户端Socket请求" class="headerlink" title="Zygote接收客户端Socket请求"></a>Zygote接收客户端Socket请求</h5><p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务端等待请求，然后处理</span><br><span class="line">        zygoteServer.runSelectLoop(abiList); </span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        &#x2F;&#x2F; 新的进程会通过抛出异常后走到这里，通过反射调用main方法执行后续任务</span><br><span class="line">        caller.run(); </span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZygoteServer</p>
<ul>
<li>客户端通过openZygoteSocketIfNeeded()来跟zygote进程建立连接。zygote进程收到客户端连接请求后执行accept()；然后再创建ZygoteConnection对象,并添加到fds数组列表；</li>
<li>建立连接之后，可以跟客户端通信，进入runOnce()方法来接收客户端数据，并执行进程创建工作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void runSelectLoop(String abiList) throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    &#x2F;sServerSocket是socket通信中的服务端，即zygote进程 </span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line">        </span><br><span class="line">while (true) &#123;</span><br><span class="line">     StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">     for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">         pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">         pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">         pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">     &#125;</span><br><span class="line">     try &#123;</span><br><span class="line">         &#x2F;&#x2F;处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span><br><span class="line">         Os.poll(pollFds, -1);</span><br><span class="line">     &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">     &#125;</span><br><span class="line">     for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">         &#x2F;&#x2F;采用I&#x2F;O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；否则进入continue，跳出本次循环。</span><br><span class="line">         if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">             continue;</span><br><span class="line">         &#125;</span><br><span class="line">         if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求；则创建ZygoteConnection对象,并添加到fds。</span><br><span class="line">             ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);</span><br><span class="line">             peers.add(newPeer);</span><br><span class="line">             fds.add(newPeer.getFileDesciptor());</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;i&gt;0，则代表通过socket接收来自对端的数据，并执行 runOnce操作</span><br><span class="line">             boolean done &#x3D; peers.get(i).runOnce(this);</span><br><span class="line">             if (done) &#123;</span><br><span class="line">                 peers.remove(i);</span><br><span class="line">                 fds.remove(i);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ZygoteConnection acceptCommandPeer(String abiList) &#123;</span><br><span class="line">    &#x2F;&#x2F; 接收客户端发送过来的connect()操作，Zygote作为服务端执行accept()操作。 再后面客户端调用write()写数据，Zygote进程调用read()读数据。</span><br><span class="line">   return new ZygoteConnection(sServerSocket.accept(), abiList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="java层fork参数准备"><a href="#java层fork参数准备" class="headerlink" title="java层fork参数准备"></a>java层fork参数准备</h5><p>ZygoteConnection.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean runOnce(ZygoteServer zygoteServer) throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs &#x3D; null;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 读取socket客户端发送过来的参数列表</span><br><span class="line">    args &#x3D; readArgumentList();</span><br><span class="line">    descriptors &#x3D; mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    </span><br><span class="line">    int pid &#x3D; -1;</span><br><span class="line">    FileDescriptor childPipeFd &#x3D; null;</span><br><span class="line">    FileDescriptor serverPipeFd &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备一系列fork进程的参数</span><br><span class="line">      parsedArgs &#x3D; new Arguments(args);</span><br><span class="line">      int[][] rlimits &#x3D; null;</span><br><span class="line">      if (parsedArgs.rlimits !&#x3D; null) &#123;</span><br><span class="line">          rlimits &#x3D; parsedArgs.rlimits.toArray(intArray2d);</span><br><span class="line">      &#125;</span><br><span class="line">      int[] fdsToIgnore &#x3D; null;</span><br><span class="line">      if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">          FileDescriptor[] pipeFds &#x3D; Os.pipe2(O_CLOEXEC);</span><br><span class="line">          childPipeFd &#x3D; pipeFds[1];</span><br><span class="line">          serverPipeFd &#x3D; pipeFds[0];</span><br><span class="line">          Os.fcntlInt(childPipeFd, F_SETFD, 0);</span><br><span class="line">          fdsToIgnore &#x3D; new int[] &#123; childPipeFd.getInt$(), serverPipeFd.getInt$() &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      int [] fdsToClose &#x3D; &#123; -1, -1 &#125;;</span><br><span class="line">      FileDescriptor fd &#x3D; mSocket.getFileDescriptor();</span><br><span class="line">      if (fd !&#x3D; null) &#123;</span><br><span class="line">          fdsToClose[0] &#x3D; fd.getInt$();</span><br><span class="line">      &#125;</span><br><span class="line">      fd &#x3D; zygoteServer.getServerSocketFileDescriptor();</span><br><span class="line">      if (fd !&#x3D; null) &#123;</span><br><span class="line">          fdsToClose[1] &#x3D; fd.getInt$();</span><br><span class="line">      &#125;</span><br><span class="line">      fd &#x3D; null;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 执行fork操作</span><br><span class="line">      pid &#x3D; Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">              parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">              parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,</span><br><span class="line">              parsedArgs.appDataDir);</span><br><span class="line">              </span><br><span class="line">    &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           &#x2F;&#x2F; 子进程 </span><br><span class="line">           zygoteServer.closeServerSocket();</span><br><span class="line">           IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">           serverPipeFd &#x3D; null;</span><br><span class="line">           &#x2F;&#x2F; 进程初始化操作（最后抛出异常 回到runSelectLoop捕获异常方法）</span><br><span class="line">           handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; should never get here, the child is expected to either throw Zygote.MethodAndArgsCaller or exec().</span><br><span class="line">           return true;</span><br><span class="line">       &#125; else &#123; &#x2F;&#x2F; 父进程 （zygote进程）</span><br><span class="line">           &#x2F;&#x2F; in parent...pid of &lt; 0 means failure</span><br><span class="line">           IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">           childPipeFd &#x3D; null;</span><br><span class="line">           return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">       IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="nativeFork前准备"><a href="#nativeFork前准备" class="headerlink" title="nativeFork前准备"></a>nativeFork前准备</h5><p>Zygote.java<br>调用虚拟机执行preFork工作：停止Daemon子线程、等待所有子线程结束、完成gc堆的初始化工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</span><br><span class="line">     int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</span><br><span class="line">     int[] fdsToIgnore, String instructionSet, String appDataDir) &#123;</span><br><span class="line">   VM_HOOKS.preFork();</span><br><span class="line">   &#x2F;&#x2F; Resets nice priority for zygote process.</span><br><span class="line">   resetNicePriority();</span><br><span class="line">   int pid &#x3D; nativeForkAndSpecialize(</span><br><span class="line">             uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">             fdsToIgnore, instructionSet, appDataDir);</span><br><span class="line">   VM_HOOKS.postForkCommon();</span><br><span class="line">   return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用native的fork方法"><a href="#调用native的fork方法" class="headerlink" title="调用native的fork方法"></a>调用native的fork方法</h5><p>com_android_internal_os_Zygote.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkSystemServer(</span><br><span class="line">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span><br><span class="line">        jlong effectiveCapabilities) &#123;</span><br><span class="line">  &#x2F;&#x2F; fork子进程，</span><br><span class="line">  pid_t pid &#x3D; ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities,effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,NULL, NULL);</span><br><span class="line">  ...</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span><br><span class="line">                                     jint debug_flags, jobjectArray javaRlimits,</span><br><span class="line">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span><br><span class="line">                                     jint mount_external,</span><br><span class="line">                                     jstring java_se_info, jstring java_se_name,</span><br><span class="line">                                     bool is_system_server, jintArray fdsToClose,</span><br><span class="line">                                     jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  pid_t pid &#x3D; fork(); &#x2F;&#x2F;!!! fork子进程 (COW 方式)</span><br><span class="line">  </span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;进入子进程，初始化设置等</span><br><span class="line">    DetachDescriptors(env, fdsToClose); &#x2F;&#x2F;关闭并清除文件描述符</span><br><span class="line"></span><br><span class="line">    if (!is_system_server) &#123;</span><br><span class="line">        &#x2F;&#x2F;对于非system_server子进程，则创建进程组</span><br><span class="line">        int rc &#x3D; createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); &#x2F;&#x2F;设置设置group</span><br><span class="line">    SetRLimits(env, javaRlimits); &#x2F;&#x2F;设置资源limit</span><br><span class="line"></span><br><span class="line">    int rc &#x3D; setresgid(gid, gid, gid);</span><br><span class="line">    rc &#x3D; setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); &#x2F;&#x2F;设置调度策略</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;selinux上下文</span><br><span class="line">    rc &#x3D; selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    if (se_info_c_str &#x3D;&#x3D; NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str &#x3D; &quot;system_server&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (se_info_c_str !&#x3D; NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); &#x2F;&#x2F;设置线程名为system_server，方便调试</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为</span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line">    &#x2F;&#x2F;调用zygote.callPostForkChildHooks() </span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (pid &gt; 0) &#123; &#x2F;&#x2F;进入父进程，即zygote进程</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p>fork()采用copy on write技术，这是linux创建进程的标准方法，调用一次，返回两次，返回值有3种类型。父进程中，fork返回新创建的子进程的pid;子进程中，fork返回0；当出现错误时，fork返回负数。（当进程数超过上限或者系统内存不足时会出错）</p>
<p>fork()的主要工作是寻找空闲的进程号pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。 Zygote进程是所有Android进程的母体，包括system_server和各个App进程。zygote利用fork()方法生成新进程，对于新进程A复用Zygote进程本身的资源，再加上新进程A相关的资源，构成新的应用进程A。</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884372036920.png"  alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fork() &#123;</span><br><span class="line">  __bionic_atfork_run_prepare(); &#x2F;&#x2F;[见小节2.1.1]</span><br><span class="line"></span><br><span class="line">  pthread_internal_t* self &#x3D; __get_thread();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;fork期间，获取父进程pid，并使其缓存值无效</span><br><span class="line">  pid_t parent_pid &#x3D; self-&gt;invalidate_cached_pid();</span><br><span class="line">  &#x2F;&#x2F;系统调用【见小节2.2】</span><br><span class="line">  int result &#x3D; syscall(__NR_clone, FORK_FLAGS, NULL, NULL, NULL, &amp;(self-&gt;tid));</span><br><span class="line">  if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    self-&gt;set_cached_pid(gettid());</span><br><span class="line">    __bionic_atfork_run_child(); &#x2F;&#x2F;fork完成执行子进程回调方法</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    self-&gt;set_cached_pid(parent_pid);</span><br><span class="line">    __bionic_atfork_run_parent(); &#x2F;&#x2F;fork完成执行父进程回调方法</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行子进程fork完成后的hooks"><a href="#执行子进程fork完成后的hooks" class="headerlink" title="执行子进程fork完成后的hooks"></a>执行子进程fork完成后的hooks</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用ZygoteHooks.postForkChild()</span><br><span class="line">    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);</span><br><span class="line">&#125;</span><br><span class="line">public void postForkChild(int debugFlags, String instructionSet) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用native方法</span><br><span class="line">    nativePostForkChild(token, debugFlags, instructionSet);</span><br><span class="line">Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dalvik_system_ZygoteHooks.cc<br>设置新进程的主线程id，重置gc性能数据，设置信号处理函数等功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags, jstring instruction_set) &#123;</span><br><span class="line">    &#x2F;&#x2F;此处token是由nativePreFork创建的，记录着当前线程</span><br><span class="line">    Thread* thread &#x3D; reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">    &#x2F;&#x2F;设置新进程的主线程id</span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    ..</span><br><span class="line">    if (instruction_set !&#x3D; nullptr) &#123;</span><br><span class="line">      ScopedUtfChars isa_string(env, instruction_set);</span><br><span class="line">      InstructionSet isa &#x3D; GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">      Runtime::NativeBridgeAction action &#x3D; Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">      if (isa !&#x3D; kNone &amp;&amp; isa !&#x3D; kRuntimeISA) &#123;</span><br><span class="line">        action &#x3D; Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;Runtime 执行 fork事项</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime.cc<br>创建Java堆处理的线程池、设置信号处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, const char* isa) &#123;</span><br><span class="line">  is_zygote_ &#x3D; false;</span><br><span class="line">  if (is_native_bridge_loaded_) &#123;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">      case NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge(); &#x2F;&#x2F;卸载用于跨平台的桥连库</span><br><span class="line">        is_native_bridge_loaded_ &#x3D; false;</span><br><span class="line">        break;</span><br><span class="line">      case NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);&#x2F;&#x2F;初始化用于跨平台的桥连库</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建Java堆处理的线程池</span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  &#x2F;&#x2F;重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line">  if (jit_.get() &#x3D;&#x3D; nullptr &amp;&amp; jit_options_-&gt;UseJIT()) &#123;</span><br><span class="line">    &#x2F;&#x2F;当flag被设置，并且还没有创建JIT时，则创建JIT</span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;设置信号处理函数</span><br><span class="line">  StartSignalCatcher();</span><br><span class="line">  &#x2F;&#x2F;启动JDWP线程，当命令debuger的flags指定&quot;suspend&#x3D;y&quot;时，则暂停runtime</span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="VM-HOOKS的fork后续操作"><a href="#VM-HOOKS的fork后续操作" class="headerlink" title="VM_HOOKS的fork后续操作"></a>VM_HOOKS的fork后续操作</h5><p>ZygoteHooks.java<br>主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void postForkCommon() &#123;</span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void start() &#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="新进程创建后的初始化事项"><a href="#新进程创建后的初始化事项" class="headerlink" title="新进程创建后的初始化事项"></a>新进程创建后的初始化事项</h5><p>ZygoteConnection.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void handleChildProc(Arguments parsedArgs,</span><br><span class="line">       FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span><br><span class="line">       throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">   &#x2F;&#x2F; 关闭子进程的socket链接</span><br><span class="line">   closeSocket();</span><br><span class="line">   if (descriptors !&#x3D; null) &#123;</span><br><span class="line">   </span><br><span class="line">   if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">       WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">               parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">               VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">               pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">   &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">       &#x2F;&#x2F; 初始化</span><br><span class="line">       ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">               parsedArgs.remainingArgs, null &#x2F;* classLoader *&#x2F;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RuntimeInit.java</p>
<ul>
<li>commonInit，初始化时区、代理、异常捕获处理类等</li>
<li>nativeZygoteInit，启动binder相关初始化</li>
<li>applicationInit，app相关初始化，最后抛出异常回到runSelectLoop，该方法的参数m是指main()方法, argv是指ActivityThread. 根据前面的中可知，下一步进入caller.run()方法，也就是执行ActivityThread的main方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">       throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">   ......</span><br><span class="line">   commonInit();</span><br><span class="line">   nativeZygoteInit();</span><br><span class="line">   applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置默认的未捕捉异常处理方法</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置市区，中国时区为&quot;Asia&#x2F;Shanghai&quot;</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置log配置</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span><br><span class="line">    String userAgent &#x3D; getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置socket的tag，用于网络流量统计</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123;</span><br><span class="line">   </span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp</span><br><span class="line">virtual void onZygoteInit()&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置虚拟机的内存利用率参数值为0.75 , 设置目标sdk</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args &#x3D; new Arguments(argv); &#x2F;&#x2F;解析参数</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用startClass的static方法 main()；args.startClass为”com.android.server.SystemServer</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">   Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line">   Method m;</span><br><span class="line">   try &#123;</span><br><span class="line">       m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">   &#125; catch (Exception ex) &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int modifiers &#x3D; m.getModifiers();</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; ! 回到 ZygoteInit.main()方法中，直接进入catch语句（这样做好处是能清空栈帧，提高栈帧利用率，比较巧妙）</span><br><span class="line">   throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最后执行ActivityThread的main方法"><a href="#最后执行ActivityThread的main方法" class="headerlink" title="最后执行ActivityThread的main方法"></a>最后执行ActivityThread的main方法</h5><p>ActivityThread.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    &#x2F;&#x2F;创建主线程looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    &#x2F;&#x2F;attach到系统进程</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;主线程进入循环状态</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>启动流程</tag>
        <tag>Android进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统—Launcher启动流程</title>
    <url>/blog/2019/08/21/Android%E7%B3%BB%E7%BB%9F%E2%80%94Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>前期系列：<br><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote进程启动分析</a><br><a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">SystemServer启动分析</a><br><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">AMS启动分析</a></p>
<h3 id="Launcher启动流程图"><a href="#Launcher启动流程图" class="headerlink" title="Launcher启动流程图"></a>Launcher启动流程图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884365938266.jpg"  alt=""></p>
<h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><h5 id="AMS系统ready方法中开始启动HomeActivity"><a href="#AMS系统ready方法中开始启动HomeActivity" class="headerlink" title="AMS系统ready方法中开始启动HomeActivity"></a>AMS系统ready方法中开始启动HomeActivity</h5><p>ActivityManagerService.java</p>
<ul>
<li>获取和生成HomeActivity的Intent信息，并析构出ActivityInfo</li>
<li>调用ActivityStarter的startHomeActivityLocked方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Start up initial activity.</span><br><span class="line">        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean startHomeActivityLocked(int userId, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构建 Home Intent</span><br><span class="line">    Intent intent &#x3D; getHomeIntent();</span><br><span class="line">    &#x2F;&#x2F; 通过PM 构建 ActivityInfo</span><br><span class="line">    ActivityInfo aInfo &#x3D;</span><br><span class="line">      resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">     </span><br><span class="line">    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">    &#x2F;&#x2F; 创建ActivityInfo 对象  </span><br><span class="line">    aInfo &#x3D; new ActivityInfo(aInfo);</span><br><span class="line">    aInfo.applicationInfo &#x3D; getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">    ProcessRecord app &#x3D; getProcessRecordLocked(aInfo.processName,</span><br><span class="line">         aInfo.applicationInfo.uid, true);</span><br><span class="line">      </span><br><span class="line">    intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    &#x2F;&#x2F; 通过ActivityStart 启动 </span><br><span class="line">    mActivityStarter.startHomeActivityLocked(intent, aInfo, myReason);    </span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取系统的启动页面Activity Intent</span><br><span class="line">Intent getHomeIntent() &#123;</span><br><span class="line">   &#x2F;&#x2F; mTOPAction &#x3D; Intent.ACTION_MAIN;</span><br><span class="line">   Intent intent &#x3D; new Intent(mTopAction, mTopData !&#x3D; null ? Uri.parse(mTopData) : null);</span><br><span class="line">   intent.setComponent(mTopComponent);</span><br><span class="line">   &#x2F;&#x2F; 添加 &quot;android.intent.category.HOME&quot;; </span><br><span class="line">   intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">   return intent;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 通过PM将HomeIntent解析出ActivityInfo</span><br><span class="line">private ActivityInfo resolveActivityInfo(Intent intent, int flags, int userId) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ResolveInfo info&#x3D; AppGlobals.getPackageManager().resolveIntent(intent,</span><br><span class="line">    intent.resolveTypeIfNeeded(mContext.getContentResolver()),</span><br><span class="line">    flags, userId);</span><br><span class="line">    ai &#x3D; info.activityInfo;</span><br><span class="line">    return ai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Activity启动前检查及任务栈管理等"><a href="#Activity启动前检查及任务栈管理等" class="headerlink" title="Activity启动前检查及任务栈管理等"></a>Activity启动前检查及任务栈管理等</h5><p>ActivityStarter.java</p>
<ul>
<li>startHomeActivityLocked，将HomeStack移至顶部（第一次为空）</li>
<li>startActivityLocked，调用startActivity，并重新记录lastStartActivityResult</li>
<li>startActivity，参数校验、权限检查等，构建ActivityRecord等</li>
<li>startActivityUnchecked，涉及启动模式和位运算，以及调用ActivityStack的startActivityLocked来处理回退栈</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void startHomeActivityLocked(Intent intent, ActivityInfo aInfo, String reason) &#123;</span><br><span class="line">   &#x2F;&#x2F; 将HomeStack 移到top</span><br><span class="line">   mSupervisor.moveHomeStackTaskToTop(reason);</span><br><span class="line">   &#x2F;&#x2F; 执行 startActivityLocked</span><br><span class="line">   mLastHomeActivityStartResult &#x3D; startActivityLocked(null &#x2F;*caller*&#x2F;, intent,</span><br><span class="line">           null &#x2F;*ephemeralIntent*&#x2F;, null &#x2F;*resolvedType*&#x2F;, aInfo, null &#x2F;*rInfo*&#x2F;,</span><br><span class="line">           null &#x2F;*voiceSession*&#x2F;, null &#x2F;*voiceInteractor*&#x2F;, null &#x2F;*resultTo*&#x2F;,</span><br><span class="line">           null &#x2F;*resultWho*&#x2F;, 0 &#x2F;*requestCode*&#x2F;, 0 &#x2F;*callingPid*&#x2F;, 0 &#x2F;*callingUid*&#x2F;,</span><br><span class="line">           null &#x2F;*callingPackage*&#x2F;, 0 &#x2F;*realCallingPid*&#x2F;, 0 &#x2F;*realCallingUid*&#x2F;,</span><br><span class="line">           0 &#x2F;*startFlags*&#x2F;, null &#x2F;*options*&#x2F;, false &#x2F;*ignoreTargetSecurity*&#x2F;,</span><br><span class="line">           false &#x2F;*componentSpecified*&#x2F;, mLastHomeActivityStartRecord &#x2F;*outActivity*&#x2F;,</span><br><span class="line">           null &#x2F;*container*&#x2F;, null &#x2F;*inTask*&#x2F;, &quot;startHomeActivity: &quot; + reason);</span><br><span class="line">   if (mSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">       &#x2F;&#x2F; 调度</span><br><span class="line">       mSupervisor.scheduleResumeTopActivities();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int startActivityLocked(IApplicationThread caller,</span><br><span class="line">            Intent intent, String resolvedType, ActivityInfo aInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int callingPid, int callingUid, String callingPackage,</span><br><span class="line">            int realCallingPid, int realCallingUid, int startFlags, Bundle options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            ActivityContainer container, TaskRecord inTask) &#123;</span><br><span class="line">      </span><br><span class="line">   &#x2F;&#x2F; 参数校验、权限检查等工作，然后构建 ActivityRecord (存储Activity的重要信息)</span><br><span class="line">    ActivityRecord r &#x3D; new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">           callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">           resultRecord, resultWho, requestCode, componentSpecified, voiceSession !&#x3D; null,</span><br><span class="line">           mSupervisor, container, options, sourceRecord);</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 然后调用 startActivity</span><br><span class="line">   return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,</span><br><span class="line">                options, inTask, outActivity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int startActivity(...) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行 startActivityUnchecked</span><br><span class="line">    result &#x3D; startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">         startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">    IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,</span><br><span class="line">                                   boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">                                   ActivityRecord[] outActivity) &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化状态（该方法会校验Intent的Flag是否是特定的Flag，会涉及到各种启动模式和Android的位运算）</span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor);</span><br><span class="line">    &#x2F;&#x2F;判断是否需要启动新的task</span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    &#x2F;&#x2F;记录父Activity对应的TaskRecord信息</span><br><span class="line">    computeSourceStack();</span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line">    &#x2F;&#x2F;决定是否将新Activity插入到现有的Task中</span><br><span class="line">    ActivityRecord reusedActivity &#x3D; getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;任务栈历史栈配置（处理和WindowManagerService之间的交互、保证Activity对应的UI能在屏幕上显示出来）</span><br><span class="line">   mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">   </span><br><span class="line">    if (mDoResume) &#123; &#x2F;&#x2F; true </span><br><span class="line">        final ActivityRecord topTaskActivity &#x3D;</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        if (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity !&#x3D; null &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity !&#x3D; topTaskActivity)) &#123;</span><br><span class="line">            &#x2F;&#x2F;目标Task的focusable为false或者源Task栈顶Activity总是在其他Activity之上</span><br><span class="line">            &#x2F;&#x2F;不恢复目标Task，只需确保它可见</span><br><span class="line">            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">            &#x2F;&#x2F;通过WindowManagerService执行app启动动画</span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">            &#x2F;&#x2F;如果目标栈之前不是可聚焦状态，那么将目标栈变为可聚焦</span><br><span class="line">            if (mTargetStack.isFocusable( &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 最后走到ASS执行 resumeFocusedStackTopActivityLocked</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果不需要恢复，则将Activity加入到最近活动栈中</span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityStackSupervisor.java</p>
<ul>
<li>resumeFocusedStackTopActivityLocked,</li>
<li>resumeTopActivityInnerLocked,</li>
<li>resumeTopActivityInnerLocked, 暂停栈内所有Activity，继续调用</li>
<li>startSpecificActivityLocked, 查找ActivityRecord对应进程，存在则realStartActivityLocked，这里是第一次启动，不存在进程,调用AMS.startProcessLocked</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">  ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">    &#x2F;&#x2F;  执行 resumeTopActivityUncheckedLocked</span><br><span class="line">    return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ActivityStack.java</span><br><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    &#x2F;&#x2F;执行 resumeTopActivityInnerLocked</span><br><span class="line">    result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)&#123;</span><br><span class="line">    ...</span><br><span class="line">    final ActivityRecord next &#x3D; topRunningActivityLocked(true &#x2F;* focusableOnly *&#x2F;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;该方法会遍历所有任务栈，并调用ActivityStack#startPausingLocked()暂停处于栈内的所有Activity</span><br><span class="line">    boolean pausing &#x3D; mStackSupervisor.pauseBackStacks(userLeaving, next, false);</span><br><span class="line">    </span><br><span class="line">    if (next.app !&#x3D; null &amp;&amp; next.app.thread !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">        &#x2F;&#x2F;调用了startSpecificActivityLocked</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">                                 boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    &#x2F;&#x2F;这里根据processName和UID在系统中查找是否已经有相应的进程存在</span><br><span class="line">    &#x2F;&#x2F;如果之前app进程不存在，则app&#x3D;null</span><br><span class="line">    ProcessRecord app &#x3D; mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, true);</span><br><span class="line">    </span><br><span class="line">    if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if ((r.info.flags&amp; ActivityInfo.FLAG_MULTIPROCESS) &#x3D;&#x3D; 0</span><br><span class="line">                    || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                &#x2F;&#x2F;向PreocessRecord中增加对应的package信息</span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;若app进程存在，通知进程启动目标Activity</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;若进程不存在，则使用AMS开启一个新进程(进程不存在)</span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,&quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AMS开启进程启动"><a href="#AMS开启进程启动" class="headerlink" title="AMS开启进程启动"></a>AMS开启进程启动</h5><p>ActivityManagerService.java</p>
<ul>
<li><p>startProcessLocked, 进程的维护和清理等工作，然后调用重载方法</p>
</li>
<li><p>startProcessLocked, 该方法里主要干了三件事：</p>
<ol>
<li>设置了各种debug参数，若AndroidManifest.xml将android:debuggable设置为true，这些参数就会生效。</li>
<li>通过Process.start()开启一个新进程，实际上是通过Socket与Zygote通信，使用Zygote fork新进 程，同时将ActivityThread类加入到新进程,并调用ActivityThread.main()。</li>
<li>发送一条延时消息，若新创建的进程在消息接收前未与AMS交互，则进程启动失败</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName,</span><br><span class="line">       ApplicationInfo info, boolean knownToBeDead, int intentFlags,</span><br><span class="line">       String hostingType, ComponentName hostingName, boolean allowWhileBooting,</span><br><span class="line">       boolean isolated, boolean keepIfLarge) &#123;</span><br><span class="line">   return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">           hostingName, allowWhileBooting, isolated, 0 &#x2F;* isolatedUid *&#x2F;, keepIfLarge,</span><br><span class="line">           null &#x2F;* ABI override *&#x2F;, null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;,</span><br><span class="line">           null &#x2F;* crashHandler *&#x2F;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主要：创建或获取 ProcessRecord ，清理bad进程，然后启动进程</span><br><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">                                       boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    if (!isolated) &#123; &#x2F;&#x2F; 非孤立进程</span><br><span class="line">        &#x2F;&#x2F;根据进程名和UID查找相应的ProcessRecord，</span><br><span class="line">        &#x2F;&#x2F;当第一次启动app时这里返回值为null</span><br><span class="line">        app &#x3D; getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line"></span><br><span class="line">        if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果当前进程处于后台进程，检查当前进程是否为bad进程</span><br><span class="line">            if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;当用户明确要启动一个进程时，则清空它的crash次数</span><br><span class="line">            &#x2F;&#x2F;在看见crash对话框之前它才不会成为一个bad进程</span><br><span class="line">            mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">            if (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                if (app !&#x3D; null) &#123;</span><br><span class="line">                    app.bad &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果它是一个孤立的进程，则它无法使用现存的进程</span><br><span class="line">        app &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当已经存在ProcessRecord且其pid大于0(app早已经运行或者正在启动)</span><br><span class="line">    &#x2F;&#x2F;则不会清理该进程</span><br><span class="line">    if (app !&#x3D; null &amp;&amp; app.pid &gt; 0) &#123;</span><br><span class="line">        if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果它是新的包，则将其添加到列表中</span><br><span class="line">            app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">            return app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;当ProcessRecord被attach到之前的进程，就清理它</span><br><span class="line">        killProcessGroup(app.uid, app.pid);</span><br><span class="line">        handleAppDiedLocked(app, true, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostingNameStr &#x3D; hostingName !&#x3D; null</span><br><span class="line">            ? hostingName.flattenToShortString() : null;</span><br><span class="line">    if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据ApplicationInfo、processName、UID创建一个ProcessRecord对象</span><br><span class="line">        app &#x3D; newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">        if (app &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        app.crashHandler &#x3D; crashHandler;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;如果在进程中它是新的一个包，则添加它到列表里</span><br><span class="line">        app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果系统仍未准备好，则推迟启动它，将app加入hold列表</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;调用重载方法启动进程</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">    return (app.pid !&#x3D; 0) ? app : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果ProcessRecord的pid&gt;0且不为当前进程的pid</span><br><span class="line">    &#x2F;&#x2F;就从mPidsSelfLocked移除该pid</span><br><span class="line">    &#x2F;&#x2F;当进程不存在时，pid&#x3D;0</span><br><span class="line">    if (app.pid &gt; 0 &amp;&amp; app.pid !&#x3D; MY_PID) &#123;</span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            mPidsSelfLocked.remove(app.pid);</span><br><span class="line">            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">        &#125;</span><br><span class="line">        app.setPid(0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从hold列表移除该ProcessRecord</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line">    &#x2F;&#x2F;更新Cpu状态</span><br><span class="line">    updateCpuStats();</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final int userId &#x3D; UserHandle.getUserId(app.uid);</span><br><span class="line">            &#x2F;&#x2F;通过PMS检查待启动进程对应的package是否满足启动条件</span><br><span class="line">            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageNam     e, userId);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        if (!app.isolated) &#123;</span><br><span class="line">            int[] permGids &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                checkTime(startTime, &quot;startProcess: getting gids from package manager&quot;);</span><br><span class="line">                final IPackageManager pm &#x3D; AppGlobals.getPackageManager();</span><br><span class="line">                &#x2F;&#x2F;得到对应的GID</span><br><span class="line">                permGids &#x3D; pm.getPackageGids(app.info.packageName,</span><br><span class="line">                        MATCH_DEBUG_TRIAGED_MISSING, app.userId);</span><br><span class="line">                StorageManagerInternal storageManagerInternal &#x3D; LocalServices.getService(</span><br><span class="line">                        StorageManagerInternal.class);</span><br><span class="line">                &#x2F;&#x2F;获得进程对外部存储的访问模式</span><br><span class="line">                mountExternal &#x3D; storageManagerInternal.getExternalStorageMountMode(uid,</span><br><span class="line">                        app.info.packageName);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F;不同情况下设置debugFlags的值，具体的值请看Zygote类的static属性</span><br><span class="line">            ...</span><br><span class="line">            boolean isActivityProcess &#x3D; (entryPoint &#x3D;&#x3D; null);</span><br><span class="line">            &#x2F;&#x2F;当entryPoint为空的情况下，设置它的值</span><br><span class="line">            &#x2F;&#x2F;这里的entryPoint是第一个startProcessLocked()传进来的null值</span><br><span class="line">            &#x2F;&#x2F;这里是指定反射需要的className</span><br><span class="line">            if (entryPoint &#x3D;&#x3D; null) entryPoint &#x3D; &quot;android.app.ActivityThread&quot;;</span><br><span class="line"></span><br><span class="line">            ProcessStartResult startResult;</span><br><span class="line">            if (hostingType.equals(&quot;webview_service&quot;)) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; true</span><br><span class="line">                &#x2F;&#x2F;开启新进程的</span><br><span class="line">                startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith, entryPointArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 启动进程后更新ProcessRecord</span><br><span class="line">        app.setPid(startResult.pid);</span><br><span class="line">        app.usingWrapper &#x3D; startResult.usingWrapper;</span><br><span class="line">        app.removed &#x3D; false;</span><br><span class="line">        app.killed &#x3D; false;</span><br><span class="line">        app.killedByAm &#x3D; false;</span><br><span class="line"></span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            &#x2F;&#x2F;将启动结果的pid和PreocessRecord添加到mPidsSelfLocked</span><br><span class="line">            this.mPidsSelfLocked.put(startResult.pid, app);</span><br><span class="line">            if (isActivityProcess) &#123;</span><br><span class="line">                &#x2F;&#x2F;发送一个延时消息</span><br><span class="line">                &#x2F;&#x2F; PROC_START_TIMEOUT 值为 10</span><br><span class="line">                &#x2F;&#x2F;在消息未被处理前，若新创建的进程没有和AMS交互，则该进程启动失败</span><br><span class="line">                Message msg &#x3D; mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">                msg.obj &#x3D; app;</span><br><span class="line">                mHandler.sendMessageDelayed(msg, startResult.usingWrapper</span><br><span class="line">                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(RuntimeException e)&#123;</span><br><span class="line">            &#x2F;&#x2F;当创建进程出现异常的时候就会清理相关的记录forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,    false, true, false, false, UserHandle.getUserId(app.userId), &quot;start failure&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进程fork"><a href="#进程fork" class="headerlink" title="进程fork"></a>进程fork</h5><p>Process.start<br>参考：<a href="https://www.jianshu.com/p/c7fb582987ad" target="_blank" rel="noopener">Android系统—进程创建流程分析</a></p>
<h5 id="ActivityThread-main方法"><a href="#ActivityThread-main方法" class="headerlink" title="ActivityThread.main方法"></a>ActivityThread.main方法</h5><ul>
<li>Looper.prepareMainLooper</li>
<li>attach AMS</li>
<li>Looper.loop</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper(); &#x2F;&#x2F; 准备 main looper 和消息队列</span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread(); &#x2F;&#x2F; 构建AT</span><br><span class="line">    &#x2F;&#x2F;将应用进程绑定到ActivityManagerService</span><br><span class="line">    thread.attach(false);</span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.loop(); &#x2F;&#x2F; 开启循环，接收message并分发处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void attach(boolean system) &#123; </span><br><span class="line">   sCurrentActivityThread &#x3D; this;</span><br><span class="line">   mSystemThread &#x3D; system; &#x2F;&#x2F; false</span><br><span class="line">   if (!system) &#123; &#x2F;&#x2F; true</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 获取 AMS，调用AMS的 attachApplication</span><br><span class="line">       final IActivityManager mgr &#x3D; ActivityManager.getService();</span><br><span class="line">       try &#123;</span><br><span class="line">           mgr.attachApplication(mAppThread);</span><br><span class="line">       &#125; catch (RemoteException ex) &#123;</span><br><span class="line">           throw ex.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Watch for getting close to heap limit.</span><br><span class="line">       ...</span><br><span class="line">   &#125; else &#123; &#x2F;&#x2F; 系统进程处理逻辑</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AMS-绑定Application"><a href="#AMS-绑定Application" class="headerlink" title="AMS 绑定Application"></a>AMS 绑定Application</h5><p>ActivityManagerService.java</p>
<ul>
<li>attachApplication, 获取当前调用pid，调用重载方法</li>
<li>attachApplication<ul>
<li>重置ProcessRecord信息   </li>
<li>将进程的ApplicationThread绑定到AMS，初始化Application</li>
<li>最后执行到 ASS.attachApplicationLocked方法进行Activity的启动</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">       final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">       attachApplicationLocked(thread, callingPid);</span><br><span class="line">       Binder.restoreCallingIdentity(origId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                              int pid) &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    ... &#x2F;&#x2F; 根据pid 获取 对应 ProcessRecord</span><br><span class="line">    &#x2F;&#x2F; 新进程的名字</span><br><span class="line">    final String processName &#x3D; app.processName;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;在这个地方会注册该进程的死亡回调 ， Thread指的是ApplicationThread</span><br><span class="line">        AppDeathRecipient adr &#x3D; new AppDeathRecipient(</span><br><span class="line">                app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, 0);</span><br><span class="line">        app.deathRecipient &#x3D; adr;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        &#x2F;&#x2F;出现异常则重新开启一个进程</span><br><span class="line">        startProcessLocked(app, &quot;link fail&quot;, processName);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;重置 ProcessRecord</span><br><span class="line">    app.makeActive(thread, mProcessStats); &#x2F;&#x2F;给ProcessRecord的thread赋值</span><br><span class="line">    app.curAdj &#x3D; app.setAdj &#x3D; app.verifiedAdj &#x3D; ProcessList.INVALID_ADJ;</span><br><span class="line">    app.curSchedGroup &#x3D; app.setSchedGroup &#x3D; ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    app.forcingToImportant &#x3D; null;</span><br><span class="line">    updateProcessForegroundLocked(app, false, false);</span><br><span class="line">    app.hasShownUi &#x3D; false;</span><br><span class="line">    app.debugging &#x3D; false;</span><br><span class="line">    app.cached &#x3D; false;</span><br><span class="line">    app.killedByAm &#x3D; false;</span><br><span class="line">    app.killed &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">    &#x2F;&#x2F; 移除startProcessLocked()中发出的延时消息</span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line"></span><br><span class="line">    boolean normalMode &#x3D; mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    ... &#x2F;&#x2F; contentProvider相关处理</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 这里通过AIDL调用了ApplicationThread. bindApplication方法，</span><br><span class="line">    &#x2F;&#x2F; 这里是将新进程的ApplicationThread对象绑定到AMS的真正操作 ，两个方法只是参数不同</span><br><span class="line">    &#x2F;&#x2F; app.instr 为ProcessRecord.ActiveInstrumentation对象</span><br><span class="line">    if (app.instr !&#x3D; null) &#123;</span><br><span class="line">        thread.bindApplication(&#x2F;*参数省略*&#x2F;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        thread.bindApplication(&#x2F;*参数省略*&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;更新进程情况</span><br><span class="line">    updateLruProcessLocked(app, false, null);</span><br><span class="line">    &#x2F;&#x2F;将ProcessRecord从正在启动列表和hold列表中移除</span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检查最顶层可见的Activity是否等待运行在该进程中</span><br><span class="line">    if (normalMode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;调用ActivityStackSupervisor# attachApplicationLocked</span><br><span class="line">            if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">            badApp &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查找所有可运行在该进程中的服务</span><br><span class="line">    &#x2F;&#x2F;检查这个进程中是否有下一个广播接收者</span><br><span class="line">    &#x2F;&#x2F;检查这个进程中是否有下一个备份代理</span><br><span class="line">    &#x2F;&#x2F;上述操作如果出现异常就杀死进程</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ActivityThread-ApplicationThread处理Application绑定"><a href="#ActivityThread-ApplicationThread处理Application绑定" class="headerlink" title="ActivityThread.ApplicationThread处理Application绑定"></a>ActivityThread.ApplicationThread处理Application绑定</h5><p>ActivityThread.ApplicationThread</p>
<ul>
<li>bindApplication，构造AppBindData，发送bind消息</li>
<li>handleBindApplication <ul>
<li>进程、系统配置等初始化设置</li>
<li>构建Instrumentation、Application等app对象</li>
<li>调用Application.onCreate 生命周期方法  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void bindApplication(&#x2F;*省略参数*&#x2F;)&#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;&#x2F; 构造 AppBindData，并赋值</span><br><span class="line">	AppBindData data &#x3D; new AppBindData();</span><br><span class="line">	sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    &#x2F;&#x2F;注册UI线程到VMRuntime作为一个敏感线程</span><br><span class="line">    VMRuntime.registerSensitiveThread();</span><br><span class="line">    &#x2F;&#x2F;设置进程的启动时间</span><br><span class="line">    Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置进程名</span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());</span><br><span class="line">    &#x2F;&#x2F;当app版本&lt;&#x3D; 3.1 时，设置AsyncTask使用线程池实现</span><br><span class="line">    if (data.appInfo.targetSdkVersion &lt;&#x3D; android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重置时区（跟随系统时区）</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line">    LocaleList.setDefault(data.config.getLocales());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;更新系统配置</span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);</span><br><span class="line">        mCurDefaultDisplayDpi &#x3D; data.config.densityDpi;</span><br><span class="line">        applyCompatConfiguration(mCurDefaultDisplayDpi);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获得LoadedApk对象</span><br><span class="line">    data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line">    &#x2F;&#x2F;判断是否需要为进程设置新的分辨率密度</span><br><span class="line">    if ((data.appInfo.flags&amp; ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES)</span><br><span class="line">            &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        mDensityCompatMode &#x3D; true;</span><br><span class="line">        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">    updateDefaultDensity();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; StrictMode</span><br><span class="line">    &#x2F;&#x2F;表示只为系统应用(FLAG_SYSTEM, FLAG_UPDATED_SYSTEM_APP)开启了</span><br><span class="line">    &#x2F;&#x2F;StrictMode，其他应用还是需要自行开启</span><br><span class="line">    if ((data.appInfo.flags &amp;</span><br><span class="line">            (ApplicationInfo.FLAG_SYSTEM |</span><br><span class="line">                    ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) !&#x3D; 0) &#123;</span><br><span class="line">        StrictMode.conditionallyEnableDebugLogging();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;当api&gt;&#x3D;HONEYCOMB时,Android不允许在主线程中使用网络</span><br><span class="line">    if (data.appInfo.targetSdkVersion &gt;&#x3D; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        StrictMode.enableDeathOnNetwork();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Android 7.0以后，Android引入了FileProvider</span><br><span class="line">    if (data.appInfo.targetSdkVersion &gt;&#x3D; Build.VERSION_CODES.N) &#123;</span><br><span class="line">        StrictMode.enableDeathOnFileUriExposure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    final InstrumentationInfo ii;</span><br><span class="line">    &#x2F;&#x2F; Instrumentation信息会影响类加载器,所以应该在设置app context之前加载它</span><br><span class="line">    if (data.instrumentationName !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ii &#x3D; new ApplicationPackageManager(null, getPackageManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置InstrumentationInfo信息</span><br><span class="line">        ...</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        ii &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在这里创建了ContextImpl对象</span><br><span class="line">    final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;继续加载Instrumentation对象</span><br><span class="line">    if (ii !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl &#x3D; instrContext.getClassLoader();</span><br><span class="line">            &#x2F;&#x2F;创建Instrumentation对象</span><br><span class="line">            &#x2F;&#x2F; 之前提到，Instrumentation的作用就是监控系统和应用的交互，</span><br><span class="line">            &#x2F;&#x2F; 因此Activity的生命周期也会被Instrumentation所监控</span><br><span class="line">            mInstrumentation &#x3D;(Instrumentation)cl.loadClass(</span><br><span class="line">                    data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        final ComponentName component &#x3D; new ComponentName(ii.packageName, ii.name);</span><br><span class="line">        &#x2F;&#x2F;初始化Instrumentation参数</span><br><span class="line">        mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F; 构建 Applicaiton</span><br><span class="line">        Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">        &#x2F;&#x2F;设置ActivityThread.mInitialApplication</span><br><span class="line">        mInitialApplication &#x3D; app;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;这里会调用到Application的onCreate()方法</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch(Exception e)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行ASS的attachApplication"><a href="#执行ASS的attachApplication" class="headerlink" title="执行ASS的attachApplication"></a>执行ASS的attachApplication</h5><p>ActivityStackSupervisor.java</p>
<ul>
<li>attachApplicationLocked，找到对应ActivityRecord等</li>
<li>realStartActivityLocked，更新进程信息，获取发送启动Activity参数，最后调用ActivityThread中的ApplicationThread执行 scheduleLaunchActivity 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">   final String processName &#x3D; app.processName;</span><br><span class="line">   boolean didSomething &#x3D; false;</span><br><span class="line">   for (int displayNdx &#x3D; mActivityDisplays.size() - 1; displayNdx &gt;&#x3D; 0; --displayNdx) &#123;</span><br><span class="line">       ArrayList&lt;ActivityStack&gt; stacks &#x3D; mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">       for (int stackNdx &#x3D; stacks.size() - 1; stackNdx &gt;&#x3D; 0; --stackNdx) &#123;</span><br><span class="line">           final ActivityStack stack &#x3D; stacks.get(stackNdx);</span><br><span class="line">           if (!isFocusedStack(stack)) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; 找到 当前stack 下的top ActivityRecord</span><br><span class="line">           ActivityRecord hr &#x3D; stack.topRunningActivityLocked();</span><br><span class="line">           if (hr !&#x3D; null) &#123;</span><br><span class="line">               if (hr.app &#x3D;&#x3D; null &amp;&amp; app.uid &#x3D;&#x3D; hr.info.applicationInfo.uid</span><br><span class="line">                       &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       &#x2F;&#x2F; 调用 realStartActivityLocked </span><br><span class="line">                       if (realStartActivityLocked(hr, app, true, true)) &#123;</span><br><span class="line">                           didSomething &#x3D; true;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   ...</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if (!didSomething) &#123;</span><br><span class="line">       ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);</span><br><span class="line">   &#125;</span><br><span class="line">   return didSomething;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">       boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;获得已存在的Task和Stack</span><br><span class="line">    final TaskRecord task &#x3D; r.getTask();</span><br><span class="line">    final ActivityStack stack &#x3D; task.getStack();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;推迟resume，避免在一个循环中多次resume</span><br><span class="line">    beginDeferResume();</span><br><span class="line">    &#x2F;&#x2F;开始冻结屏幕</span><br><span class="line">    r.startFreezingScreenLocked(app, 0);</span><br><span class="line">    &#x2F;&#x2F;开始收集启动信息</span><br><span class="line">    r.startLaunchTickingLocked();</span><br><span class="line">    r.app &#x3D; app;</span><br><span class="line"></span><br><span class="line">    if (checkConfig) &#123;</span><br><span class="line">        final int displayId &#x3D; r.getDisplayId();</span><br><span class="line">        final Configuration config &#x3D;mWindowManager.updateOrientationFromAppTokens(</span><br><span class="line">                getDisplayOverrideConfiguration(displayId),r.mayFreezeScreenLocked(app) ? r.appToken : null, displayId);</span><br><span class="line">        &#x2F;&#x2F;当显示方向改变时，推迟resume，防止启动多余的Activity</span><br><span class="line">        mService.updateDisplayOverrideConfigurationLocked(config, r, true &#x2F;* deferResume *&#x2F;,displayId);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;更新进程使用情况</span><br><span class="line">    mService.updateLruProcessLocked(app, true, null);</span><br><span class="line">    &#x2F;&#x2F;更新进程OomAdj</span><br><span class="line">    mService.updateOomAdjLocked();</span><br><span class="line">    try &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;通过Binder调用ApplicationThread的scheduleLaunchActivity()</span><br><span class="line">        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r),r.info,mergedConfiguration.getGlobalConfiguration(),mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;... 处理进程臃肿的情况</span><br><span class="line">    &#125; catch(RemoteException e)&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;会进行两次操作，第一次重启进程失败后再抛出异常执行第二次操作</span><br><span class="line">        &#x2F;&#x2F;第二次失败后就放弃</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ActivityThread-执行Activity启动"><a href="#ActivityThread-执行Activity启动" class="headerlink" title="ActivityThread 执行Activity启动"></a>ActivityThread 执行Activity启动</h5><ul>
<li>ActivityThread.Application.scheduleLaunchActivity，构建ActivityClientRecord，发送H.LAUNCH_ACTIVITY消息</li>
<li>ActivityThread.handleLaunchActivity，执行Activity启动后的生命周期方法</li>
<li>performLaunchActivity，主要是调用Activity的onCreate(),onStart(),onRestoreInstance(),onPostCreate()生命周期</li>
<li>handleResumeActivity()，回调Activity的onResume()方法，并将DecorView添加到WindowManager中，这里的WindowManager是a.getWindowManager()得到的，其实现是WindowManagerImpl，这步操作在onResume()方法之后执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(...) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line">    ActivityClientRecord r &#x3D; new ActivityClientRecord();</span><br><span class="line">    ...</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前进程正活跃，避免GC</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    &#x2F;&#x2F;确保使用的是最近的配置</span><br><span class="line">    handleConfigurationChanged(null, null);</span><br><span class="line">    &#x2F;&#x2F;在创建Activity之前初始化WindowManagerService</span><br><span class="line">    if (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL()</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;执行performLaunchActivity(),并返回Activity对象</span><br><span class="line">    Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a !&#x3D; null) &#123;</span><br><span class="line">        r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState &#x3D; r.state;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;启动成功后，恢复Activity</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">        &#x2F;&#x2F; ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    ActivityInfo aInfo &#x3D; r.activityInfo;</span><br><span class="line">    if (r.packageInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;从PackageManagerService获取应用包信息</span><br><span class="line">        r.packageInfo &#x3D; getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component &#x3D; r.intent.getComponent();</span><br><span class="line">    if (component &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取组件信息</span><br><span class="line">        component &#x3D; r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果提前设置好了目标Activity，则重新设置组件信息</span><br><span class="line">    if (r.activityInfo.targetActivity !&#x3D; null) &#123;</span><br><span class="line">        component &#x3D; new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext &#x3D; createBaseContextForActivity(r);</span><br><span class="line">    Activity activity &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;利用ClassLoader去加载Activity</span><br><span class="line">        java.lang.ClassLoader cl &#x3D; appContext.getClassLoader();</span><br><span class="line">        &#x2F;&#x2F;利用Instrumentation创建Activity实例</span><br><span class="line">        activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state !&#x3D; null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        if (activity !&#x3D; null) &#123;</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config,r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;回调Activity的onCreate()方法</span><br><span class="line">        &#x2F;&#x2F;这里回调的重载函数由ActivityInfo的persistableMode参数决定</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        r.activity &#x3D; activity;</span><br><span class="line">        r.stopped &#x3D; true;</span><br><span class="line">        if (!r.activity.mFinished) &#123;</span><br><span class="line">            &#x2F;&#x2F;回调Activity的onStart()方法，同时会改变FragmentManager的状态信息</span><br><span class="line">            &#x2F;&#x2F; mInstrumentation.callActivityOnStart(this);</span><br><span class="line">            activity.performStart();</span><br><span class="line">            r.stopped &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;回调Activity的onRestoreInstanceState()方法</span><br><span class="line">        &#x2F;&#x2F;这里的回调方法同样由ActivityInfo的persistableMode参数决定</span><br><span class="line">        if (!r.activity.mFinished) &#123;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                if (r.state !&#x3D; null || r.persistentState !&#x3D; null) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                            r.persistentState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (r.state !&#x3D; null) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;回调Activity的OnPostCreate()方法</span><br><span class="line">        if (!r.activity.mFinished) &#123;</span><br><span class="line">            activity.mCalled &#x3D; false;</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                        r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!activity.mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                                &quot; did not call through to super.onPostCreate()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused &#x3D; true;</span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line">    &#125; catch(SuperNotCalledException e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">                                boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">    ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">    &#x2F;&#x2F;回调Activity的onResume()方法</span><br><span class="line">    r &#x3D; performResumeActivity(token, clearHide, reason);</span><br><span class="line">    if (r !&#x3D; null) &#123;</span><br><span class="line">        final Activity a &#x3D; r.activity;</span><br><span class="line">        final int forwardBit &#x3D; isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line">        &#x2F;&#x2F;显示window</span><br><span class="line">        if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">	          ...</span><br><span class="line">            ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">	          ...</span><br><span class="line">            &#x2F;&#x2F;将decorView添加到WindowManager中</span><br><span class="line">            wm.addView(decor, l);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;更新布局</span><br><span class="line">        wm.updateViewLayout(decor, l);</span><br><span class="line">        ...</span><br><span class="line">        if (reallyResume) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;通知AMS已经Resume了</span><br><span class="line">                ActivityManager.getService().activityResumed(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;如果在onResume之前抛出异常了,则通知AMS结束该Activity</span><br><span class="line">                ActivityManager.getService()</span><br><span class="line">                        .finishActivity(token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>启动流程</tag>
        <tag>Launcher</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统—ActivityManagerService启动流程</title>
    <url>/blog/2019/08/19/Android%E7%B3%BB%E7%BB%9F%E2%80%94ActivityManagerService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>上一集：<a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">SystemServer启动分析</a></p>
<h4 id="系统服务启动AMS"><a href="#系统服务启动AMS" class="headerlink" title="系统服务启动AMS"></a>系统服务启动AMS</h4><p>SystemServer.startBootstrapServices</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    &#x2F;&#x2F; 启动 AMS </span><br><span class="line">    mActivityManagerService &#x3D; mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    &#x2F;&#x2F; AMS设置 系统服务管理器</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    &#x2F;&#x2F; AMS设置 APP安装器</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    &#x2F;&#x2F; 启动电源管理器，AMS对其进行初始化</span><br><span class="line">    mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    &#x2F;&#x2F; 设置系统进程及相关</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AMS构建和启动"><a href="#AMS构建和启动" class="headerlink" title="AMS构建和启动"></a>AMS构建和启动</h4><p>ActivityManagerService构造函数</p>
<ul>
<li>初始化一些对象属性，包括 Context、ActivityThread、ServiceThread、MainHandler、ActivityManagerConstants 等对象</li>
<li>创建和管理四大组件相关的类对象，包括 BroadcastQueue、ActiveServices、ProviderMap、ActivityStackSupervisor、RecentTasks 和 ActivityStarter 等对象</li>
<li>创建一个 CPU 监控线程 mProcessCpuThread</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static final class Lifecycle extends SystemService&#123;</span><br><span class="line">    private final ActivityManagerService mService;</span><br><span class="line">    &#x2F;&#x2F; ServiceManager反射调用构造方法构造</span><br><span class="line">    public Lifecycle(Context context) &#123;</span><br><span class="line">      super(context);</span><br><span class="line">      mService &#x3D; new ActivityManagerService(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">      mService.start(); &#x2F;&#x2F; AMS 启动</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">    mContext &#x3D; systemContext; &#x2F;&#x2F; 赋值 SystemServer的context</span><br><span class="line">    mFactoryTest &#x3D; FactoryTest.getMode();</span><br><span class="line">    &#x2F;&#x2F; 赋值 SystemServer 的ActivityThread</span><br><span class="line">    mSystemThread &#x3D;  ActivityThread.currentActivityThread();</span><br><span class="line">    &#x2F;&#x2F; 创建带Handler的前台线程和MainHandler，AMS内部通信用</span><br><span class="line">    mHandlerThread &#x3D; new ServiceThread(TAG,</span><br><span class="line">          android.os.Process.THREAD_PRIORITY_FOREGROUND, false);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    mHandler &#x3D; new MainHandler(mHandlerThread.getLooper());</span><br><span class="line">    &#x2F;&#x2F; 创建UIHandler，AMS所需要的界面交互用</span><br><span class="line">    mUiHandler &#x3D; new UiHandler(); </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建前台广播接受队列 和 后台广播接受队列</span><br><span class="line">    mFgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">          &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false);</span><br><span class="line">    mBgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">          &quot;background&quot;, BROADCAST_BG_TIMEOUT, true);</span><br><span class="line">    mBroadcastQueues[0] &#x3D; mFgBroadcastQueue;</span><br><span class="line">    mBroadcastQueues[1] &#x3D; mBgBroadcastQueue;</span><br><span class="line">    &#x2F;&#x2F; 创建Service 和Provider 容器</span><br><span class="line">    mServices &#x3D; new ActiveServices(this);</span><br><span class="line">    mProviderMap &#x3D; new ProviderMap(this);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建 &#x2F;data&#x2F;system 目录</span><br><span class="line">    File dataDir &#x3D; Environment.getDataDirectory();</span><br><span class="line">    File systemDir &#x3D; new File(dataDir, &quot;system&quot;);</span><br><span class="line">    systemDir.mkdirs();</span><br><span class="line">    &#x2F;&#x2F; 创建 电量统计服务</span><br><span class="line">    mBatteryStatsService &#x3D; new BatteryStatsService(systemDir, mHandler);</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">    mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">    mOnBattery &#x3D; DEBUG_POWER ? true</span><br><span class="line">          : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().setCallback(this);</span><br><span class="line">    &#x2F;&#x2F; 创建 进程统计服务</span><br><span class="line">    mProcessStats &#x3D; new ProcessStatsService(this, new File(systemDir, &quot;procstats&quot;));</span><br><span class="line">    </span><br><span class="line">    mAppOpsService &#x3D; new AppOpsService(new File(systemDir, &quot;appops.xml&quot;), mHandler);</span><br><span class="line">    </span><br><span class="line">    mGrantFile &#x3D; new AtomicFile(new File(systemDir, &quot;urigrants.xml&quot;));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; User 0 is the first and only user that runs at boot.</span><br><span class="line">    mStartedUsers.put(UserHandle.USER_OWNER, new UserState(UserHandle.OWNER, true));</span><br><span class="line">    mUserLru.add(UserHandle.USER_OWNER);</span><br><span class="line">    updateStartedUserArrayLocked();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; CPU 追踪器初始化</span><br><span class="line">    mProcessCpuTracker.init();</span><br><span class="line">    &#x2F;&#x2F; 创建Activity相关对象</span><br><span class="line">    mRecentTasks &#x3D; new RecentTasks(this);</span><br><span class="line">    mStackSupervisor &#x3D; new ActivityStackSupervisor(this, mRecentTasks);</span><br><span class="line">    mTaskPersister &#x3D; new TaskPersister(systemDir, mStackSupervisor, mRecentTasks);</span><br><span class="line">    &#x2F;&#x2F; 创建‘CpuTracker’的现场</span><br><span class="line">    mProcessCpuThread &#x3D; new Thread(&quot;CpuTracker&quot;) &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">               synchronized(this) &#123;</span><br><span class="line">                   ... &#x2F;&#x2F; 更新cpu状态</span><br><span class="line">                   updateCpuStatsNow();</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void start() &#123;</span><br><span class="line">    &#x2F;&#x2F; 启动 CPU 监控线程，在启动 CPU 监控线程之前，首先将进程复位</span><br><span class="line">    &#x2F;&#x2F; 注册电池状态服务和权限管理服务</span><br><span class="line">    Process.removeAllProcessGroups(); &#x2F;&#x2F;移除所有的进程组</span><br><span class="line">    mProcessCpuThread.start(); &#x2F;&#x2F;启动CpuTracker线程</span><br><span class="line">    &#x2F;&#x2F;启动电池统计服务</span><br><span class="line">    mBatteryStatsService.publish(mContext);</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    &#x2F;&#x2F;创建LocalService，并添加到LocalServices</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SystemServer调用AMS注册各种服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setSystemProcess() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));</span><br><span class="line">        ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));</span><br><span class="line">        if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this));</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));</span><br><span class="line">        ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));</span><br><span class="line">        ApplicationInfo info &#x3D; mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                &quot;android&quot;, STOCK_PM_FLAGS);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建用于性能统计的Profiler对象</span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F;创建ProcessRecord对象</span><br><span class="line">            ProcessRecord app &#x3D; newProcessRecordLocked(info, info.processName, false, 0);</span><br><span class="line">            app.persistent &#x3D; true; &#x2F;&#x2F;设置为persistent进程</span><br><span class="line">            app.pid &#x3D; MY_PID;</span><br><span class="line">            app.maxAdj &#x3D; ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            updateLruProcessLocked(app, false, null);&#x2F;&#x2F;维护进程lru</span><br><span class="line">            updateOomAdjLocked(); &#x2F;&#x2F;更新adj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="系统服务Ready-AMS"><a href="#系统服务Ready-AMS" class="headerlink" title="系统服务Ready-AMS"></a>系统服务Ready-AMS</h4><p>SystemServer.startOtherServices</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;安装系统Provider</span><br><span class="line">  mActivityManagerService.installSystemProviders();</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;调用AMS systemReady , 传递了 一个Runnable对象</span><br><span class="line">  mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         ... &#x2F;&#x2F; AMS的systemReady方法会执行该Runnable   </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS.systemReady</p>
<ul>
<li>task清理和恢复、是否更新广播、进程清理等systemReady前任务执行</li>
<li>系统准备好后,回调runnable，启动webView、系统UI、一系列服务ready和systemRunning</li>
<li>启动persistent进程，启动HomeActivity，发送系统广播等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    &#x2F;&#x2F; before goingCallback执行</span><br><span class="line">    &#x2F;&#x2F; goingCallback执行</span><br><span class="line">    &#x2F;&#x2F; after goingCallback执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    &#x2F;&#x2F; before goingCallback执行</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 同步执行 待 systemReady ok</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        if (mSystemReady) &#123;</span><br><span class="line">            if (goingCallback !&#x3D; null) &#123;</span><br><span class="line">                goingCallback.run();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        mLocalDeviceIdleController</span><br><span class="line">                &#x3D; LocalServices.getService(DeviceIdleController.LocalService.class);</span><br><span class="line">           </span><br><span class="line">        updateCurrentProfileIdsLocked();</span><br><span class="line">        &#x2F;&#x2F; 清理最近task，把需要恢复的task添加上</span><br><span class="line">        mRecentTasks.clear();</span><br><span class="line">        mRecentTasks.addAll(mTaskPersister.restoreTasksLocked());</span><br><span class="line">        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">        mTaskPersister.startPersisting();</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F; 检查是否需要更新</span><br><span class="line">        if (!mDidUpdate) &#123;</span><br><span class="line">            if (mWaitingUpdate) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            final ArrayList&lt;ComponentName&gt; doneReceivers &#x3D; new ArrayList&lt;ComponentName&gt;();</span><br><span class="line">            mWaitingUpdate &#x3D; deliverPreBootCompleted(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                        mDidUpdate &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    showBootMessage(mContext.getText(</span><br><span class="line">                            R.string.android_upgrading_complete),</span><br><span class="line">                            false);</span><br><span class="line">                    writeLastDonePreBootReceivers(doneReceivers);</span><br><span class="line">                    systemReady(goingCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, doneReceivers, UserHandle.USER_OWNER);</span><br><span class="line">           </span><br><span class="line">            if (mWaitingUpdate) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mDidUpdate &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        mAppOpsService.systemReady();</span><br><span class="line">        mSystemReady &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 将非persistent进程，添加到procsToKill</span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procsToKill &#x3D; null;</span><br><span class="line">    synchronized(mPidsSelfLocked) &#123;</span><br><span class="line">       for (int i&#x3D;mPidsSelfLocked.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">           ProcessRecord proc &#x3D; mPidsSelfLocked.valueAt(i);</span><br><span class="line">           if (!isAllowedWhileBooting(proc.info))&#123;</span><br><span class="line">               if (procsToKill &#x3D;&#x3D; null) &#123;</span><br><span class="line">                   procsToKill &#x3D; new ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">               &#125;</span><br><span class="line">               procsToKill.add(proc);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#x2F;&#x2F; 杀掉进程</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">       if (procsToKill !&#x3D; null) &#123;</span><br><span class="line">           for (int i&#x3D;procsToKill.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">               ProcessRecord proc &#x3D; procsToKill.get(i);</span><br><span class="line">               removeProcessLocked(proc, true, false, &quot;system update done&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 进程 ready    </span><br><span class="line">       mProcessesReady &#x3D; true;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; system 现在进入ready 状态</span><br><span class="line">   Slog.i(TAG, &quot;System now ready&quot;);</span><br><span class="line">   EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,</span><br><span class="line">       SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   retrieveSettings();</span><br><span class="line">   loadResourcesOnSystemReady();</span><br><span class="line"></span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       readGrantedUriPermissionsLocked(); &#x2F;&#x2F; 权限检查</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; goingCallback 执行</span><br><span class="line">    if (goingCallback !&#x3D; null) goingCallback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ...</span><br><span class="line">  mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      &#x2F;&#x2F; phase550</span><br><span class="line">      mSystemServiceManager.startBootPhase(</span><br><span class="line">              SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line"></span><br><span class="line">      mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">      &#x2F;&#x2F;启动WebView</span><br><span class="line">      WebViewFactory.prepareWebViewInSystemServer();</span><br><span class="line">      &#x2F;&#x2F;启动系统UI</span><br><span class="line">      startSystemUi(context);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 执行一系列服务的systemReady方法</span><br><span class="line">      networkScoreF.systemReady();</span><br><span class="line">      networkManagementF.systemReady();</span><br><span class="line">      networkStatsF.systemReady();</span><br><span class="line">      networkPolicyF.systemReady();</span><br><span class="line">      connectivityF.systemReady();</span><br><span class="line">      audioServiceF.systemReady();</span><br><span class="line">      Watchdog.getInstance().start(); &#x2F;&#x2F;Watchdog开始工作</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;phase600</span><br><span class="line">      mSystemServiceManager.startBootPhase(</span><br><span class="line">              SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;执行一系列服务的systemRunning方法</span><br><span class="line">      wallpaper.systemRunning();</span><br><span class="line">      inputMethodManager.systemRunning(statusBarF);</span><br><span class="line">      location.systemRunning();</span><br><span class="line">      countryDetector.systemRunning();</span><br><span class="line">      networkTimeUpdater.systemRunning();</span><br><span class="line">      commonTimeMgmtService.systemRunning();</span><br><span class="line">      textServiceManagerService.systemRunning();</span><br><span class="line">      assetAtlasService.systemRunning();</span><br><span class="line">      inputManager.systemRunning();</span><br><span class="line">      telephonyRegistry.systemRunning();</span><br><span class="line">      mediaRouter.systemRunning();</span><br><span class="line">      mmsService.systemRunning();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    ... &#x2F;&#x2F; before goingCallback执行</span><br><span class="line">    ... &#x2F;&#x2F; goingCallback执行</span><br><span class="line">    &#x2F;&#x2F; after goingCallback执行</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">    if (mFactoryTest !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        &#x2F;&#x2F;通过pms获取所有的persistent进程</span><br><span class="line">        List apps &#x3D; AppGlobals.getPackageManager().</span><br><span class="line">            getPersistentApplications(STOCK_PM_FLAGS);</span><br><span class="line">        if (apps !&#x3D; null) &#123;</span><br><span class="line">            int N &#x3D; apps.size();</span><br><span class="line">            int i;</span><br><span class="line">            for (i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                ApplicationInfo info &#x3D; (ApplicationInfo)apps.get(i);</span><br><span class="line">                if (info !&#x3D; null &amp;&amp; !info.packageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;启动persistent进程</span><br><span class="line">                    addAppLocked(info, false, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBooting &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F; 启动桌面Activity </span><br><span class="line">    startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    long ident &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;system发送广播USER_STARTED</span><br><span class="line">        Intent intent &#x3D; new Intent(Intent.ACTION_USER_STARTED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(...);  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;system发送广播USER_STARTING</span><br><span class="line">        intent &#x3D; new Intent(Intent.ACTION_USER_STARTING);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);</span><br><span class="line">        broadcastIntentLocked(...);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 恢复栈顶Activity</span><br><span class="line">    mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">    sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下一集：<a href="https://www.jianshu.com/p/6df6ddac15d5" target="_blank" rel="noopener">Launcher启动分析</a></p>
<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>启动流程</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统SystemServer启动流程分析</title>
    <url>/blog/2019/08/18/Android%E7%B3%BB%E7%BB%9FSystemServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<hr>
<p>cover: <a href="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884373277864.png" target="_blank" rel="noopener">http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884373277864.png</a><br>tags: </p>
<ul>
<li>源码</li>
<li>启动流程</li>
<li>SystemServer<br>categories:</li>
<li>[Android, 系统]</li>
</ul>
<hr>
<h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><p><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote启动流程分析</a></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884373277864.png"  alt=""></p>
<h3 id="源码追踪"><a href="#源码追踪" class="headerlink" title="源码追踪"></a>源码追踪</h3><h4 id="SystemServer启动"><a href="#SystemServer启动" class="headerlink" title="SystemServer启动"></a>SystemServer启动</h4><p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ......    </span><br><span class="line">            &#x2F;&#x2F; 调用启动 SystemServer方法</span><br><span class="line">            if (startSystemServer) &#123; </span><br><span class="line">                startSystemServer(abiList, socketName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">        ......  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">private static boolean startSystemServer(String abiList, String socketName)</span><br><span class="line">      throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">      </span><br><span class="line">    ... 参数准备</span><br><span class="line">    int pid;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 解析参数，生成目标格式</span><br><span class="line">      parsedArgs &#x3D; new ZygoteConnection.Arguments(args);</span><br><span class="line">      ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">      ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; fork SystemServer 进程 </span><br><span class="line">      pid &#x3D; Zygote.forkSystemServer(</span><br><span class="line">              parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">              parsedArgs.gids,</span><br><span class="line">              parsedArgs.debugFlags,</span><br><span class="line">              null,</span><br><span class="line">              parsedArgs.permittedCapabilities,</span><br><span class="line">              parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">      throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 子进程 SystemServer</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;    </span><br><span class="line">      &#x2F;&#x2F; 执行启动流程的剩余工作</span><br><span class="line">      handleSystemServerProcess(parsedArgs); </span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SystemServer进程fork"><a href="#SystemServer进程fork" class="headerlink" title="SystemServer进程fork"></a>SystemServer进程fork</h4><p>Zygote.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,</span><br><span class="line">        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用native方法fork system_server进程</span><br><span class="line">    int pid &#x3D; nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    ...</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>com_android_internal_os_Zygote.cpp</p>
<p>主要：fork创建新进程SystemServer，采用copy on write方式（为了高效先全部复制，等需要的时候在修改）另外， fork方法会有两次返回，分别返回子进程和父进程的pid</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkSystemServer(</span><br><span class="line">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span><br><span class="line">        jlong effectiveCapabilities) &#123;</span><br><span class="line">  &#x2F;&#x2F; fork子进程，</span><br><span class="line">  pid_t pid &#x3D; ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities,effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,NULL, NULL);</span><br><span class="line">  ...</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span><br><span class="line">                                     jint debug_flags, jobjectArray javaRlimits,</span><br><span class="line">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span><br><span class="line">                                     jint mount_external,</span><br><span class="line">                                     jstring java_se_info, jstring java_se_name,</span><br><span class="line">                                     bool is_system_server, jintArray fdsToClose,</span><br><span class="line">                                     jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  pid_t pid &#x3D; fork(); &#x2F;&#x2F;!!! fork子进程 (COW 方式)</span><br><span class="line">  </span><br><span class="line">  if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;进入子进程，初始化设置等</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (pid &gt; 0) &#123; &#x2F;&#x2F;进入父进程，即zygote进程</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开始执行SystemServer进程fork后的ZygoteInit操作"><a href="#开始执行SystemServer进程fork后的ZygoteInit操作" class="headerlink" title="开始执行SystemServer进程fork后的ZygoteInit操作"></a>开始执行SystemServer进程fork后的ZygoteInit操作</h4><p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void handleSystemServerProcess(</span><br><span class="line">        ZygoteConnection.Arguments parsedArgs)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    &#x2F;&#x2F; 关闭父进程zygote复制而来的Socket</span><br><span class="line">    closeServerSocket(); </span><br><span class="line"></span><br><span class="line">    if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName); &#x2F;&#x2F;设置当前进程名为&quot;system_server&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String systemServerClasspath &#x3D; Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">    if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; 执行dex优化操作</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; invokeWith &#x3D; null</span><br><span class="line">        ClassLoader cl &#x3D; null;</span><br><span class="line">        if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">            创建类加载器，并赋予当前线程</span><br><span class="line">            cl &#x3D; new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; RuntimeInit 执行 zygoteInit初始化工作</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RuntimeInit.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">       throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">   ......</span><br><span class="line">   commonInit();</span><br><span class="line">   nativeZygoteInit();</span><br><span class="line">   applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置默认的未捕捉异常处理方法</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置市区，中国时区为&quot;Asia&#x2F;Shanghai&quot;</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重置log配置</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span><br><span class="line">    String userAgent &#x3D; getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置socket的tag，用于网络流量统计</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123;</span><br><span class="line">   </span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  &#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp</span><br><span class="line">virtual void onZygoteInit()&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); &#x2F;&#x2F;启动新binder线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置虚拟机的内存利用率参数值为0.75 , 设置目标sdk</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args &#x3D; new Arguments(argv); &#x2F;&#x2F;解析参数</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用startClass的static方法 main()；args.startClass为”com.android.server.SystemServer</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; Class.forName(className, true, classLoader);</span><br><span class="line">        Method m;</span><br><span class="line">        try &#123;</span><br><span class="line">            m &#x3D; cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int modifiers &#x3D; m.getModifiers();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ! 回到 ZygoteInit.main()方法中，直接进入catch语句（这样做好处是能清空栈帧，提高栈帧利用率，比较巧妙）</span><br><span class="line">        throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ZygoteInit.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        startSystemServer(abiList, socketName);&#x2F;&#x2F;启动system_server</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;根据传递过来的参数，可知此处通过反射机制调用的是SystemServer.main()方法</span><br><span class="line">                mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">                ... </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="SystemServer进程开始执行SystemServer-main方法"><a href="#SystemServer进程开始执行SystemServer-main方法" class="headerlink" title="SystemServer进程开始执行SystemServer.main方法"></a>SystemServer进程开始执行SystemServer.main方法</h4><p>SystemServer.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   new SystemServer().run(); &#x2F;&#x2F;创建SystemServer对象，再调用对象的run()方法</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void run() &#123;       </span><br><span class="line">   &#x2F;&#x2F; 设置系统时间、设置默认语言、虚拟机库文件、虚拟机内存 等</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 当前线程作为mainLooper</span><br><span class="line">   Looper.prepareMainLooper(); </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 初始化系统上下文</span><br><span class="line">   createSystemContext();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建系统服务管理 用于创建和启动system service</span><br><span class="line">   mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">   LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 启动各种系统服务</span><br><span class="line">   try &#123;</span><br><span class="line">       startBootstrapServices(); &#x2F;&#x2F; 启动引导服务</span><br><span class="line">       startCoreServices();    &#x2F;&#x2F; 启动核心服务</span><br><span class="line">       startOtherServices();   &#x2F;&#x2F; 启动其它服务</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 开启loop循环</span><br><span class="line">   Looper.loop();</span><br><span class="line">   throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void createSystemContext() &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建主线程任务的管理和调度类 ActivityThread</span><br><span class="line">   ActivityThread activityThread &#x3D; ActivityThread.systemMain();</span><br><span class="line">   &#x2F;&#x2F; 会依次创建对象有ActivityThread，Instrumentation, ContextImpl，LoadedApk，Application</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依次启动引导服务、核心服务、其它服务"><a href="#依次启动引导服务、核心服务、其它服务" class="headerlink" title="依次启动引导服务、核心服务、其它服务"></a>依次启动引导服务、核心服务、其它服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    &#x2F;&#x2F;阻塞等待 Installer 建立socket通道</span><br><span class="line">    Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 ActivityManagerService</span><br><span class="line">    mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 PowerManagerService</span><br><span class="line">    mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 LightsService</span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 DisplayManagerService</span><br><span class="line">    mDisplayManagerService &#x3D; mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Phase100: 服务启动阶段100 [100、480、500、550、600、1000]</span><br><span class="line">      mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 PackageManagerService</span><br><span class="line">    mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务 UserManagerService，新建目录&#x2F;data&#x2F;user&#x2F;</span><br><span class="line">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置AMS</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动传感器服务</span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">    &#x2F;&#x2F;启动服务BatteryService，用于统计电池电量，需要LightService.</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务UsageStatsService，用于统计应用使用情况</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务WebViewUpdateService</span><br><span class="line">    mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startOtherServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mContentResolver &#x3D; context.getContentResolver(); &#x2F;&#x2F; resolver</span><br><span class="line">    mActivityManagerService.installSystemProviders(); &#x2F;&#x2F;provider</span><br><span class="line">    ActivityManagerNative.getDefault().showBootMessage(...); &#x2F;&#x2F;显示启动界面</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;phase480 和phase500  [100、480、500、550、600、1000]</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 准备好 window, power, package, display服务</span><br><span class="line">    wm.systemReady();</span><br><span class="line">    mPowerManagerService.systemReady(...);</span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    mDisplayManagerService.systemReady(...);</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; AMS ready 完成服务启动其它阶段 及Home启动等</span><br><span class="line">    mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F;phase550</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         &#x2F;&#x2F;phase600</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP缓存策略分析</title>
    <url>/blog/2019/08/01/HTTP%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h3><p>HTTP缓存通常指浏览器缓存，基于HTTP中header字段实现<br>HTTP缓存分为强缓存和协商缓存，见下图</p>
<p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428152733.png"  alt=""></p>
<h4 id="Cache-Control主要字段说明"><a href="#Cache-Control主要字段说明" class="headerlink" title="Cache-Control主要字段说明"></a>Cache-Control主要字段说明</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884373558675.png"  alt=""></p>
<h4 id="缓存校验字段"><a href="#缓存校验字段" class="headerlink" title="缓存校验字段"></a>缓存校验字段</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884373664867.png"  alt=""></p>
<h4 id="缓存字段对比"><a href="#缓存字段对比" class="headerlink" title="缓存字段对比"></a>缓存字段对比</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884373733907.png"  alt=""></p>
<h3 id="HTTP缓存流程"><a href="#HTTP缓存流程" class="headerlink" title="HTTP缓存流程"></a>HTTP缓存流程</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884373801845.png"  alt=""></p>
<h3 id="为什么使用HTTP缓存"><a href="#为什么使用HTTP缓存" class="headerlink" title="为什么使用HTTP缓存"></a>为什么使用HTTP缓存</h3><p>终端缓存策略，可以缩短端到端的请求资源的距离，减少延迟，而且缓存重用，也能减少宽带流量，降低网络负荷。<br>最终用户体验和性能得到优化，避免无用资源请求浪费</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Zygote启动流程分析</title>
    <url>/blog/2019/05/16/Zygote%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="Zygote简介"><a href="#Zygote简介" class="headerlink" title="Zygote简介"></a>Zygote简介</h4><p>Zygote中文翻译为“受精卵”，正如其名，它主要用于孵化子进程。<br>Zygote是一个C/S模型，Zygote进程作为服务端，其他进程作为客户端向它发出“孵化”请求，而Zygote接收到这个请求后就“孵化”出一个新的进程。<br>此篇文章着重介绍 Zygote进程的创建和启动流程</p>
<h4 id="Zygote进程启动流程图"><a href="#Zygote进程启动流程图" class="headerlink" title="Zygote进程启动流程图"></a>Zygote进程启动流程图</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884374803682.jpg"  alt=""></p>
<h4 id="init进程main方法"><a href="#init进程main方法" class="headerlink" title="init进程main方法"></a>init进程main方法</h4><h5 id="system-core-init-init-c"><a href="#system-core-init-init-c" class="headerlink" title="/system/core/init/init.c"></a>/system/core/init/init.c</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     int main(int argc, char **argv)&#123;      </span><br><span class="line">        ... &#x2F;&#x2F; 初始化 文件、属性服务等</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 解析 init.rc </span><br><span class="line">1077    init_parse_config_file(&quot;&#x2F;init.rc&quot;);</span><br><span class="line">1078    &#x2F;&#x2F; 执行 rc解析后的data （见 rc 语法）</span><br><span class="line">1079    action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);</span><br><span class="line">1081    queue_builtin_action(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);</span><br><span class="line">1082    queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">1083    queue_builtin_action(keychord_init_action, &quot;keychord_init&quot;);</span><br><span class="line">1084    queue_builtin_action(console_init_action, &quot;console_init&quot;);</span><br><span class="line">1087    action_for_each_trigger(&quot;init&quot;, action_add_queue_tail);</span><br><span class="line">1092    queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">1093    queue_builtin_action(property_service_init_action, &quot;property_service_init&quot;);</span><br><span class="line">1094    queue_builtin_action(signal_init_action, &quot;signal_init&quot;);</span><br><span class="line">1097    if (is_charger) &#123;</span><br><span class="line">1098        action_for_each_trigger(&quot;charger&quot;, action_add_queue_tail);</span><br><span class="line">1099    &#125; else &#123;</span><br><span class="line">1100        action_for_each_trigger(&quot;late-init&quot;, action_add_queue_tail);</span><br><span class="line">1101    &#125;</span><br><span class="line">1104    queue_builtin_action(queue_property_triggers_action, &quot;queue_property_triggers&quot;);</span><br><span class="line">1108    queue_builtin_action(bootchart_init_action, &quot;bootchart_init&quot;);</span><br><span class="line"></span><br><span class="line">1110    &#x2F;&#x2F; 无限循环，执行action、检查是否需要重启、处理系统属性变化、回收僵尸进程等</span><br><span class="line">1111    for(;;) &#123;</span><br><span class="line">            ......</span><br><span class="line">1173    &#125;</span><br><span class="line">1174</span><br><span class="line">1175    return 0;</span><br><span class="line">1176&#125;</span><br><span class="line">1177</span><br></pre></td></tr></table></figure>

<h4 id="rc配置文件"><a href="#rc配置文件" class="headerlink" title="rc配置文件"></a>rc配置文件</h4><h5 id="system-core-rootdir-init-rc"><a href="#system-core-rootdir-init-rc" class="headerlink" title="/system/core/rootdir/init.rc"></a>/system/core/rootdir/init.rc</h5><p>init.rc是一个配置文件，内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：<br>Action、Commands、Services、Options和Import</p>
<h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><p>init.c的main方法中通过触发器trigger执行，执行顺序依次为<br>early-init、init、late-init、boot/charger、property等</p>
<h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>init.c先解析rc文件将service添加到service链表中，然后有 Action配置在on XXX时机下触发启动服务<br>init生成的子进程，定义在rc文件，其中每一个service在启动时会通过fork方式生成子进程</p>
<h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><p>执行命令，例如：start <service_name>： 启动指定的服务</p>
<h5 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h5><p>是Service的可选项，例如 socket：创建名为/dev/soket/<name>的socket</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">422  on nonencrypted  &#x2F;&#x2F; 执行启动 main服务</span><br><span class="line">423    class_start main</span><br><span class="line">424    class_start late_start</span><br><span class="line">...  </span><br><span class="line">     &#x2F;&#x2F; service 例子</span><br><span class="line">519  service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">520    class core</span><br><span class="line">521    user system</span><br><span class="line">522    group system</span><br><span class="line">523    critical</span><br><span class="line">524    onrestart restart healthd</span><br><span class="line">525    onrestart restart zygote</span><br><span class="line">526    onrestart restart media</span><br><span class="line">527    onrestart restart surfaceflinger</span><br><span class="line">528    onrestart restart drm</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="system-core-rootdir-init-zygote64-rc"><a href="#system-core-rootdir-init-zygote64-rc" class="headerlink" title="/system/core/rootdir/init.zygote64.rc"></a>/system/core/rootdir/init.zygote64.rc</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">2    class main</span><br><span class="line">3    socket zygote stream 660 root system</span><br><span class="line">4    onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</span><br><span class="line">5    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">6    onrestart restart media</span><br><span class="line">7    onrestart restart netd</span><br></pre></td></tr></table></figure>

<h4 id="rc配置文件解析"><a href="#rc配置文件解析" class="headerlink" title="rc配置文件解析"></a>rc配置文件解析</h4><p>/system/core/init/init_parser.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      &#x2F;&#x2F; 解析 rc文件</span><br><span class="line">404   int init_parse_config_file(const char *fn)&#123;</span><br><span class="line">409    &#x2F;&#x2F; 解析 rc文件数据</span><br><span class="line">410    parse_config(fn, data);</span><br><span class="line">412    ......</span><br><span class="line">413 &#125;</span><br><span class="line"></span><br><span class="line">347  static void parse_config(const char *fn, char *s)&#123;</span><br><span class="line">       ... &#x2F;&#x2F; 初始化变量等</span><br><span class="line">365    for (;;) &#123;</span><br><span class="line">366        switch (next_token(&amp;state)) &#123;</span><br><span class="line">367        ...</span><br><span class="line">370        case T_NEWLINE:</span><br><span class="line">371            state.line++;</span><br><span class="line">372            if (nargs) &#123;</span><br><span class="line">373                int kw &#x3D; lookup_keyword(args[0]);</span><br><span class="line">374                if (kw_is(kw, SECTION)) &#123;</span><br><span class="line">375                    state.parse_line(&amp;state, 0, 0); &#x2F;&#x2F; 解析一份配置的每一项</span><br><span class="line">376                    parse_new_section(&amp;state, kw, nargs, args); &#x2F;&#x2F; 解析一份配置</span><br><span class="line">377                &#125; else &#123;</span><br><span class="line">378                    state.parse_line(&amp;state, nargs, args);</span><br><span class="line">379                &#125;</span><br><span class="line">380                nargs &#x3D; 0;</span><br><span class="line">381            &#125;</span><br><span class="line">382            break;</span><br><span class="line">384         ...</span><br><span class="line">388        &#125;</span><br><span class="line">389    &#125;</span><br><span class="line">390     .....</span><br><span class="line">401    &#125;</span><br><span class="line">402&#125;</span><br><span class="line"></span><br><span class="line">      static void parse_new_section(struct parse_state *state, int kw,</span><br><span class="line">321                       int nargs, char **args)&#123;</span><br><span class="line">323    </span><br><span class="line">326    case K_service: &#x2F;&#x2F; 解析服务</span><br><span class="line">327        state-&gt;context &#x3D; parse_service(state, nargs, args);</span><br><span class="line">328        if (state-&gt;context) &#123;</span><br><span class="line">329            state-&gt;parse_line &#x3D; parse_line_service;</span><br><span class="line">330            return;</span><br><span class="line">331        &#125;</span><br><span class="line">332        break;</span><br><span class="line">333    case K_on: &#x2F;&#x2F; 解析 Action</span><br><span class="line">334        state-&gt;context &#x3D; parse_action(state, nargs, args);</span><br><span class="line">335        if (state-&gt;context) &#123;</span><br><span class="line">336            state-&gt;parse_line &#x3D; parse_line_action;</span><br><span class="line">337            return;</span><br><span class="line">338        &#125;</span><br><span class="line">339        break;</span><br><span class="line">340    ......</span><br><span class="line">345&#125;</span><br><span class="line">346</span><br><span class="line"></span><br><span class="line">616  static void *parse_service(struct parse_state *state, int nargs, char **args)&#123;</span><br><span class="line">       &#x2F;&#x2F; 创建service ， 并添加到 Service链表中</span><br><span class="line">640    svc-&gt;name &#x3D; args[1];</span><br><span class="line">641    svc-&gt;classname &#x3D; &quot;default&quot;;</span><br><span class="line">642    memcpy(svc-&gt;args, args + 2, sizeof(char*) * nargs);</span><br><span class="line">643    svc-&gt;args[nargs] &#x3D; 0;</span><br><span class="line">644    svc-&gt;nargs &#x3D; nargs;</span><br><span class="line">645    svc-&gt;onrestart.name &#x3D; &quot;onrestart&quot;;</span><br><span class="line">646    list_init(&amp;svc-&gt;onrestart.commands);</span><br><span class="line">647    list_add_tail(&amp;service_list, &amp;svc-&gt;slist);</span><br><span class="line">648    return svc;</span><br><span class="line">649 &#125;</span><br><span class="line">650</span><br></pre></td></tr></table></figure>

<h4 id="Zygote服务启动和进程创建"><a href="#Zygote服务启动和进程创建" class="headerlink" title="Zygote服务启动和进程创建"></a>Zygote服务启动和进程创建</h4><p>服务进程启动，7.0之前面向过程实现，之后面向对象实现<br>/system/core/init/builtins.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     int do_class_start(int nargs, char **args)&#123;</span><br><span class="line">221    service_for_each_class(args[1], service_start_if_not_disabled);</span><br><span class="line">222    return 0;</span><br><span class="line">223&#125;</span><br><span class="line"></span><br><span class="line">194 static void service_start_if_not_disabled(struct service *svc)&#123;</span><br><span class="line">196    if (!(svc-&gt;flags &amp; SVC_DISABLED)) &#123;</span><br><span class="line">197        service_start(svc, NULL); &#x2F;&#x2F; 启动service</span><br><span class="line">198    &#125; else &#123;</span><br><span class="line">199        svc-&gt;flags |&#x3D; SVC_DISABLED_START;</span><br><span class="line">200    &#125;</span><br><span class="line">201 &#125;</span><br></pre></td></tr></table></figure>
<p>/system/core/init/init.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    void service_start(struct service *svc, const char *dynamic_args) &#123;</span><br><span class="line">       .....</span><br><span class="line">251    pid &#x3D; fork();  &#x2F;&#x2F; fork 进程</span><br><span class="line">252</span><br><span class="line">253    if (pid &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; init 子进程</span><br><span class="line">254       if (!dynamic_args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过execve(svc-&gt;args[0], (char**)svc-&gt;args, (char**) ENV)，进入App_main.cpp的main()函数</span><br><span class="line">335            if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123;</span><br><span class="line">336                ERROR(&quot;cannot execve(&#39;%s&#39;): %s\n&quot;, svc-&gt;args[0], strerror(errno));</span><br><span class="line">337            &#125;</span><br><span class="line">338       &#125;</span><br><span class="line">356        _exit(127);</span><br><span class="line">357    &#125;</span><br><span class="line">358     ...</span><br><span class="line">359 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Zygote进程main方法"><a href="#Zygote进程main方法" class="headerlink" title="Zygote进程main方法"></a>Zygote进程main方法</h4><p>/frameworks/base/cmds/app_process/app_main.cpp<br>主要事情：创建一个AppRuntime，调用它的start函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">132 int main(int argc, const char* const argv[])&#123;</span><br><span class="line">       .....</span><br><span class="line">       &#x2F;&#x2F; 传递的参数 args 为 “-Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server”</span><br><span class="line">197    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); &#x2F;&#x2F; 初始一个 runtime</span><br><span class="line">       </span><br><span class="line">162    while (i &lt; argc) &#123;</span><br><span class="line">163        const char* arg &#x3D; argv[i++];</span><br><span class="line">164        if (!parentDir) &#123;</span><br><span class="line">165            parentDir &#x3D; arg;</span><br><span class="line">166        &#125; else if (strcmp(arg, &quot;--zygote&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">167            zygote &#x3D; true;   &#x2F;&#x2F; 标识启动zygote</span><br><span class="line">168            niceName &#x3D; &quot;zygote&quot;;  </span><br><span class="line">169        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">170            startSystemServer &#x3D; true;</span><br><span class="line">171        &#125; else if (strcmp(arg, &quot;--application&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">172            application &#x3D; true;</span><br><span class="line">173        &#125; else if (strncmp(arg, &quot;--nice-name&#x3D;&quot;, 12) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">174            niceName &#x3D; arg + 12;</span><br><span class="line">175        &#125; else &#123;</span><br><span class="line">176            className &#x3D; arg;</span><br><span class="line">177            break;</span><br><span class="line">178        &#125;</span><br><span class="line">179    &#125;</span><br><span class="line">180</span><br><span class="line">        ......</span><br><span class="line">187</span><br><span class="line">188    if (zygote) &#123; &#x2F;&#x2F; 调用AppRuntime启动ZygoteInit</span><br><span class="line">189        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,</span><br><span class="line">190                startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</span><br><span class="line">191    &#125; else if (className) &#123;</span><br><span class="line">196        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;,</span><br><span class="line">197                application ? &quot;application&quot; : &quot;tool&quot;);</span><br><span class="line">198    &#125; else &#123;</span><br><span class="line">202        return 10;</span><br><span class="line">203    &#125;</span><br><span class="line">204&#125;</span><br><span class="line">205</span><br></pre></td></tr></table></figure>

<h4 id="AndroidRuntime初始化及启动Zygote初始化"><a href="#AndroidRuntime初始化及启动Zygote初始化" class="headerlink" title="AndroidRuntime初始化及启动Zygote初始化"></a>AndroidRuntime初始化及启动Zygote初始化</h4><p>AndroidRuntime.cpp<br>主要事情：启动虚拟机、注册JNI方法，调用ZygoteInit的main函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     void AndroidRuntime::start(const char* className, const char* options) &#123;</span><br><span class="line">        ......</span><br><span class="line">836</span><br><span class="line">837    &#x2F;* start the virtual machine 启动虚拟机 *&#x2F;</span><br><span class="line">838    JNIEnv* env; </span><br><span class="line">839    if (startVm(&amp;mJavaVM, &amp;env) !&#x3D; 0) &#123;</span><br><span class="line">840        return;</span><br><span class="line">841    &#125;</span><br><span class="line">842    onVmCreated(env);</span><br><span class="line">843</span><br><span class="line">844    &#x2F;*</span><br><span class="line">845     * Register android functions. JNI方法注册</span><br><span class="line">846     *&#x2F;</span><br><span class="line">847    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">848        ALOGE(&quot;Unable to register all android natives\n&quot;);</span><br><span class="line">849        return;</span><br><span class="line">850    &#125;</span><br><span class="line">        ......</span><br><span class="line">871</span><br><span class="line">        &#x2F;&#x2F; 将 &quot;com.android.internal.os.ZygoteInit&quot;转换为&quot;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit&quot;</span><br><span class="line">876    char* slashClassName &#x3D; toSlashClassName(className);</span><br><span class="line">877    jclass startClass &#x3D; env-&gt;FindClass(slashClassName);</span><br><span class="line">878    if (startClass &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">879       ......</span><br><span class="line">881    &#125; else &#123;</span><br><span class="line">882        jmethodID startMeth &#x3D; env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</span><br><span class="line">883            &quot;([Ljava&#x2F;lang&#x2F;String;)V&quot;);</span><br><span class="line">884        if (startMeth &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">885            ......</span><br><span class="line">887        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用ZygoteInit.main()方法</span><br><span class="line">888            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">889</span><br><span class="line">895    &#125;</span><br><span class="line">896   ......</span><br><span class="line">903&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZygoteInit的main方法"><a href="#ZygoteInit的main方法" class="headerlink" title="ZygoteInit的main方法"></a>ZygoteInit的main方法</h4><p>ZygoteInit.java<br>主要事情：创建Socket用来和AMS通讯、启动SystemServer、调用runSelectLoop进入循环等待唤醒并执行相应工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            RuntimeInit.enableDdms(); &#x2F;&#x2F; 开启DDMS功能</span><br><span class="line">            ......</span><br><span class="line">            &#x2F;&#x2F; 注册 ZygoteSocket 进程间通信</span><br><span class="line">            registerZygoteSocket(socketName);</span><br><span class="line">            &#x2F;&#x2F; 预加载 类和资源（fork 进程共享）</span><br><span class="line">            preload();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Do an initial gc to clean up after startup</span><br><span class="line">            gcAndFinalize();</span><br><span class="line">            &#x2F;&#x2F; 启动 SystemServer 此处会fork出服务进程</span><br><span class="line">            if (startSystemServer) &#123;</span><br><span class="line">                startSystemServer(abiList, socketName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 开启无限循环模式 处理进程消息</span><br><span class="line">            runSelectLoop(abiList);</span><br><span class="line">            &#x2F;&#x2F; 关闭 socket</span><br><span class="line">            closeServerSocket();</span><br><span class="line">        &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">            caller.run(); &#x2F;&#x2F; 子进程 System_Server抛异常后调用</span><br><span class="line">        &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</span><br><span class="line">            closeServerSocket();</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>启动流程</tag>
        <tag>Zygote</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统启动流程</title>
    <url>/blog/2019/04/09/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Android启动流程"><a href="#Android启动流程" class="headerlink" title="Android启动流程"></a>Android启动流程</h3><ol>
<li><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote进程启动分析</a></li>
<li><a href="https://www.jianshu.com/p/0556e0940115" target="_blank" rel="noopener">SystemServer启动分析</a></li>
<li><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">AMS启动分析</a></li>
<li><a href="https://www.jianshu.com/p/6df6ddac15d5" target="_blank" rel="noopener">Launcher启动流程分析</a></li>
</ol>
<p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428153232.png"  alt=""></p>
<h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>启动电源以及系统启动</p>
<ul>
<li>电源按下时引导芯片会从预定义地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行</li>
<li>BootLoader，引导执行程序。主要作用就是把操作系统拉起来运行</li>
</ul>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>内核启动，初始化各种软硬件环境，加载驱动程序，挂载根文件系统，并执行init程序，由此开启Android的世界</p>
<ul>
<li>swapper进程：又叫idle进程，系统初始化Kernel由无到有开创的第一个进程，用于初始化进程管理、内存管理，加载Binder Drive、Disply、Camera Driver等相关工作</li>
<li>kthreadd进程：Linux系统内核进程，所有内核进程鼻祖，会创建其它内核守护进程</li>
</ul>
<h3 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h3><h5 id="init进程主要流程"><a href="#init进程主要流程" class="headerlink" title="init进程主要流程"></a>init进程主要流程</h5><ul>
<li>创建和挂载启动所需的文件目录</li>
<li>初始化属性服务</li>
<li>处理子进程的终止(<strong>signal方式</strong>)<ul>
<li>Zygote进程异常终止的重启动</li>
<li>回收僵尸进程 </li>
</ul>
</li>
<li>fork出 logd 、 healthd 、 installd 、 adbd 等用户守护进程</li>
<li>启动属性服务<ul>
<li>启动servicemanager（binder服务大管家）、bootanim（开机动画）、mediaserver等重要服务</li>
<li>本地服务是指运行在C++层的系统守护进程</li>
</ul>
</li>
<li>解析init.rc配置文件并启动Zygote进程 <ul>
<li>解析 init.zygote.rc </li>
<li>启动 main 类型服务 </li>
<li>启动 zygote 服务 </li>
<li>创建 Zygote 进程 </li>
<li>创建 Zygote Socket </li>
</ul>
</li>
<li>进入无限循环，执行action、检查是否需要重启、处理系统属性变化、回收僵尸进程等</li>
</ul>
<h3 id="C-Framework层"><a href="#C-Framework层" class="headerlink" title="C++ Framework层"></a>C++ Framework层</h3><p>主要运行本地服务，即MediaServer进程，由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger、CameraService等服务</p>
<h3 id="Java-Framework层"><a href="#Java-Framework层" class="headerlink" title="Java Framework层"></a>Java Framework层</h3><h5 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h5><p><a href="https://www.jianshu.com/p/65cf9a2a0725" target="_blank" rel="noopener">Zygote启动流程分析</a></p>
<ul>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；<br>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，这样当程序被fork处理后，应用的进程内已经包含了这些系统资源，大大节省了应用的启动时间。</li>
<li>调用startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>最后调用runSelectLoop()，进入监听和接收消息的循环，当接收到请求创建新进程请求时立即唤醒并执行相应工作。（采用高效的I/O多路复用机制，保证没有客户端连接请求或数据处理时休眠，否则相应客户端的请求）</li>
</ul>
<h5 id="System-Server"><a href="#System-Server" class="headerlink" title="System Server"></a>System Server</h5><p><a href="https://www.jianshu.com/p/4d02ac462733" target="_blank" rel="noopener">System Server启动流程分析</a></p>
<ul>
<li>SystemServer的启动<ul>
<li>初始化设置</li>
<li>调用createSystemContext()来创建系统上下文</li>
<li>创建SystemServiceManager</li>
<li>启动各种服务（引导服务、核心服务、其它服务）</li>
<li>进入Looper.loop循环    </li>
</ul>
</li>
<li>初始化系统上下文<ul>
<li>创建ActivityThread对象</li>
<li>创建SystemContext对象（ContextImpl） </li>
</ul>
</li>
<li>创建SystemServiceManager</li>
<li>启动各种服务<ul>
<li>startBootstrapServices()</li>
<li>startCoreServices()</li>
<li>startOtherServices()</li>
</ul>
</li>
</ul>
<h5 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h5><p>是Android中核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作<br><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener"><a href="https://www.jianshu.com/p/725c4e7e2230" target="_blank" rel="noopener">Android系统—ActivityManagerService启动流程</a>
</a></p>
<ul>
<li>创建AMS实例对象，创建Andoid Runtime，ActivityThread和Context对象；</li>
<li>启动AMS服务，创建ActivityManagerService.Lifecycle对象</li>
<li>setSystemProcess：注册AMS、meminfo、cpuinfo等服务到ServiceManager</li>
<li>启动SystemUIService，再调用一系列服务的systemReady()方法</li>
<li>AMS.startHomeActivityLocked，启动HomeAcitivity</li>
</ul>
<h3 id="App层"><a href="#App层" class="headerlink" title="App层"></a>App层</h3><p>Zygote进程孵化出的第一个应用进程是Launcher进程（桌面），它还会孵化出Browser进程（浏览器）、Phone进程（电话）等。我们每个创建的应用都是一个单独的进程。</p>
<ul>
<li>当我们点击应用图标启动应用时或者在应用内启动一个带有process标签的Activity时，都会触发创建新进程的请求，这种请求会先通过Binder</li>
<li>发送给system_server进程，也即是发送给ActivityManagerService进行处理。<br>system_server进程会调用Process.start()方法，会先收集uid、gid等参数，然后通过Socket方式发送给Zygote进程，请求创建新进程。</li>
<li>Zygote进程接收到创建新进程的请求后，调用ZygoteInit.main()方法进行runSelectLoop()循环体内，当有客户端连接时执行ZygoteConnection.runOnce()方法，最后fork生成新的应用进程。</li>
<li>新创建的进程会调用handleChildProc()方法，最后调用我们非常熟悉的ActivityThread.main()方法。</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884375001962.jpg"  alt=""></p>
<hr>
<p>推荐阅读：<a href="https://www.jianshu.com/p/238eb0a17760" target="_blank" rel="noopener">图形系统总结</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>启动流程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程—线程池</title>
    <url>/blog/2019/03/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的，合理使用线程有3个好处。</p>
<ol>
<li>降低资源消耗。通过重用已创建的线程来降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。通过已创建线程立即执行任务，减少了线程的创建时间</li>
<li>提高线程的可管理性。通过合理地使用线程池，从而实现统一分配、调优和监控等</li>
</ol>
<h3 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884375643340.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884375704682.jpg"  alt=""></p>
<p><strong>ThreadPoolExecutor执行任务流程</strong></p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建线程来执行任务</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果BlockingQueue已满，则创建新的线程来处理任务</li>
<li>如果当前运行线程总数大于maximumPoolSize，任务将被拒绝执行。并调用RejectedExecutionHandler.rejectedExecution方法</li>
</ol>
<h3 id="线程池包结构"><a href="#线程池包结构" class="headerlink" title="线程池包结构"></a>线程池包结构</h3><p>线程池简要组成部分可以分三块，任务、任务执行者及工具类相关</p>
<ul>
<li>任务: Callable、Runnable、FutureTask</li>
<li>任务执行者：ThreadPoolExecutor、ScheduledThreadPoolExecutor</li>
<li>工具类：Executors</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884375892205.jpg"  alt=""></p>
<h3 id="ThreadPoolExecutor解析"><a href="#ThreadPoolExecutor解析" class="headerlink" title="ThreadPoolExecutor解析"></a>ThreadPoolExecutor解析</h3><p>Java线程池最核心的类即ThreadPoolExecutor，它是线程池的实现类。</p>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884375970217.jpg"  alt=""></p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul>
<li><p>WorkQueue: 任务阻塞队列，缓存将要执行的Runnable任务</p>
<ul>
<li>ArrayBlockingQueue：基于数组有界阻塞队列</li>
<li>LinkedBlockingQueue：基于链表阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列（读写须等待一并进行）</li>
<li>PriorityBlockingQueue：支持优先级的无界队列</li>
</ul>
</li>
<li><p>RejectedExecutionHandler：任务拒绝策略，默认AbortPolicy</p>
<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public ThreadPoolExecutor(</span><br><span class="line">     int corePoolSize,                   &#x2F;&#x2F; 核心线程数</span><br><span class="line">     int maximumPoolSize,                &#x2F;&#x2F; 最大线程数</span><br><span class="line">     long keepAliveTime,                 &#x2F;&#x2F; 非核心线程闲置回收时间</span><br><span class="line">     TimeUnit unit,                      &#x2F;&#x2F; 时间单位</span><br><span class="line">     BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 装载任务的阻塞队列                                              ThreadFactory threadFactory,             &#x2F;&#x2F; 线程创建工厂                        </span><br><span class="line">     RejectedExecutionHandler handler    &#x2F;&#x2F; 任务拒绝状态时处理策略</span><br><span class="line">     ) &#123; </span><br><span class="line">        &#x2F;&#x2F; ......                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 运行中</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 拒绝新任务</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 拒绝新任务且不处理剩余任务</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 所有线程停止，准备执行终止方法 </span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS; &#x2F;&#x2F; 已执行终止方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程状态 ctl值取低29位</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line"> &#x2F;&#x2F; 线程状态 ctl值取高3位</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">       int c &#x3D; ctl.get();</span><br><span class="line">       &#x2F;&#x2F; 首先，运行线程数是否小雨核心线程</span><br><span class="line">       if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           if (addWorker(command, true)) &#x2F;&#x2F; 创建核心线程</span><br><span class="line">               return;</span><br><span class="line">           c &#x3D; ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 其次，往队列中插入任务</span><br><span class="line">       if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           int recheck &#x3D; ctl.get();</span><br><span class="line">           if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">               addWorker(null, false);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 否则，创建非核心线程执行任务</span><br><span class="line">       else if (!addWorker(command, false))</span><br><span class="line">           reject(command); &#x2F;&#x2F; 如果上面都失败，则拒绝执行任务，调用handler</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="addWork"><a href="#addWork" class="headerlink" title="addWork()"></a>addWork()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 使用CAS机制轮训线程池的状态，如果处于SHTUTDOWN及以上状态则拒绝执行任务</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        boolean workerStarted &#x3D; false;</span><br><span class="line">        boolean workerAdded &#x3D; false;</span><br><span class="line">        Worker w &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            w &#x3D; new Worker(firstTask); &#x2F;&#x2F; 构建Worker（worker会创建thread）</span><br><span class="line">            final Thread t &#x3D; w.thread;</span><br><span class="line">            if (t !&#x3D; null) &#123;</span><br><span class="line">                final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    </span><br><span class="line">                    int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    if (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                        if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable</span><br><span class="line">                            throw new IllegalThreadStateException();</span><br><span class="line">                        workers.add(w); &#x2F;&#x2F; 新建woker线程加入集合保存</span><br><span class="line">                        int s &#x3D; workers.size();</span><br><span class="line">                        if (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize &#x3D; s;</span><br><span class="line">                        workerAdded &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                if (workerAdded) &#123;</span><br><span class="line">                    t.start(); &#x2F;&#x2F; 执行任务</span><br><span class="line">                    workerStarted &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Work类"><a href="#Work类" class="headerlink" title="Work类"></a>Work类</h5><p>TreadPoolExecutor内部类，Worker构造方法指定第一个要执行的任务，并通过线程工厂创建线程。<br>Worker为Runnable，可以执行run，即调用到外部类的runWorker方法<br>继承AbstractQueuedSynchronizer，执行每个任务前通过lock方法加锁，执行完后通过unlock释放锁，以防止运行中任务中断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;</span><br><span class="line">        final Thread thread;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        </span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask &#x3D; firstTask; </span><br><span class="line">            this.thread &#x3D; getThreadFactory().newThread(this); &#x2F;&#x2F; 构造的时候创建线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="runWork（）"><a href="#runWork（）" class="headerlink" title="runWork（）"></a>runWork（）</h5><p>每一个Worker在getTask()成功之后都要获取Worker的锁之后运行，也就是说运行中的Worker不会中断。因为核心线程一般在空闲的时候会一直阻塞在获取Task上，也只有中断才可能导致其退出。这些阻塞着的Worker就是空闲的线程（当然，非核心线程阻塞之后也是空闲线程）。如果设置了keepAliveTime&gt;0，那非核心线程会在空闲状态下等待keepAliveTime之后销毁，直到最终的线程数量等于corePoolSize</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">        Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">        Runnable task &#x3D; w.firstTask;</span><br><span class="line">        w.firstTask &#x3D; null;</span><br><span class="line">        w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">        boolean completedAbruptly &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        task.run(); &#x2F;&#x2F; 任务执行</span><br><span class="line">                    &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Error x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw x;</span><br><span class="line">                    &#125; catch (Throwable x) &#123;</span><br><span class="line">                        thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    task &#x3D; null;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly &#x3D; false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作</span><br><span class="line">            &#x2F;&#x2F;比如在corePoolSize跟maximumPoolSize之间的woker会进行回收</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="getTask（）"><a href="#getTask（）" class="headerlink" title="getTask（）"></a>getTask（）</h5><p>通过一个循环不断轮询任务队列有没有任务到来，首先判断线程池是否处于正常运行状态，根据超时配置有两种方法取出任务：<br>BlockingQueue.poll 阻塞指定的时间尝试获取任务，如果超过指定的时间还未获取到任务就返回null。<br>BlockingQueue.take 这种方法会在取到任务前一直阻塞。<br>keepAliveTime代表了线程池中的线程（即woker线程）的存活时间，如果到期则回收woker线程<br>FixedThreadPool使用的是take方法，所以会线程会一直阻塞等待任务。CachedThreadPool使用的是poll方法，也就是说CachedThreadPool中的线程如果在60秒内未获取到队列中的任务就会被终止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c &#x3D; ctl.get();</span><br><span class="line">            int rs &#x3D; runStateOf(c);</span><br><span class="line">            ......</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Are workers subject to culling?</span><br><span class="line">            boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            &#x2F;&#x2F; 超时配置时间，通过不同方法取任务</span><br><span class="line">            try &#123;</span><br><span class="line">                Runnable r &#x3D; timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line"></span><br><span class="line">                if (r !&#x3D; null)</span><br><span class="line">                    return r;</span><br><span class="line">                timedOut &#x3D; true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">                timedOut &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Executors构建线程方法"><a href="#Executors构建线程方法" class="headerlink" title="Executors构建线程方法"></a>Executors构建线程方法</h3><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>定长线程池：<br>可控制线程最大并发数（同时执行的线程数）<br>超出的线程会在队列中等待</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>可缓存线程池：<br>线程数无限制<br>有空闲线程则复用空闲线程，若无空闲线程则新建线程<br>一定程序减少频繁创建/销毁线程，减少系统开销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>单线程化的线程池：</p>
<p>有且仅有一个工作线程执行任务<br>所有任务按照指定顺序执行，即遵循队列的入队出队规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>支持定时以指定周期循环执行任务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解ThreadLocal</title>
    <url>/blog/2019/03/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/</url>
    <content><![CDATA[<h3 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h3><blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p>
</blockquote>
<p>释义：<br>ThreadLocal提供线程本地实例。它与普通变量区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。<br>ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<h3 id="ThreadLocal解决什么问题？"><a href="#ThreadLocal解决什么问题？" class="headerlink" title="ThreadLocal解决什么问题？"></a>ThreadLocal解决什么问题？</h3><p>并发编程中常见需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。<br>常规思路：使用一个线程共享的Map&lt;Thread,T&gt;,通过map来获取对应线程变量的值。带来的问题是需要同步，效率比较低。<br>而ThreadLocal从另一个角度解决多线程并发的问题。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。<br>（空间换时间）</p>
<h3 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h3><h5 id="整体结构图"><a href="#整体结构图" class="headerlink" title="整体结构图"></a>整体结构图</h5><ul>
<li>Thread持有成员变量threadLocals（ThreadLocalMap）</li>
<li>ThreadLocalMap是一个映射表，内部实现一个数组，每一个元素位Entry</li>
<li>Entry为一个键值对，key为Thread，Value为任何对象</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884376281320.jpg"  alt=""></p>
<h5 id="ThreadLocal解析"><a href="#ThreadLocal解析" class="headerlink" title="ThreadLocal解析"></a>ThreadLocal解析</h5><p>set和get方法通过线程对应ThreadLocalMap来管理实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">     Thread t &#x3D; Thread.currentThread(); &#x2F;&#x2F; 获取当前线程</span><br><span class="line">     ThreadLocalMap map &#x3D; getMap(t); &#x2F;&#x2F; 获取线程对应映射表</span><br><span class="line">     if (map !&#x3D; null) &#x2F;&#x2F; 设置KV</span><br><span class="line">         map.set(this, value);</span><br><span class="line">     else</span><br><span class="line">         createMap(t, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">      Thread t &#x3D; Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">      if (map !&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 获取映射表中当前ThreadLocal对应的Value</span><br><span class="line">          ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">          if (e !&#x3D; null) &#123;</span><br><span class="line">              @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">              T result &#x3D; (T)e.value;</span><br><span class="line">              return result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果Map还未初始化或者Map中没有找到Key，则设置一个初始值</span><br><span class="line">      return setInitialValue();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ThreadLocalMap解析"><a href="#ThreadLocalMap解析" class="headerlink" title="ThreadLocalMap解析"></a>ThreadLocalMap解析</h5><p><strong>成员变量和内部类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了处理非常大(指的是值)和长时间的用途，哈希表的Key使用了弱引用(WeakReferences)。</span><br><span class="line">&#x2F;&#x2F; 引用的队列(弱引用)不再被使用的时候，对应的过期的条目就能通过主动删除移出哈希表。</span><br><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Value为WeakReference持有</span><br><span class="line">       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               super(k);</span><br><span class="line">               value &#x3D; v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 初始化容量，必须是2的幂次方</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private static final int INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 哈希表，长度为2的幂次方</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private Entry[] table;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * The number of entries in the table.（Entry数目）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * 记录下一次扩容阀值</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private int threshold; &#x2F;&#x2F; Default to 0</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * Set the resize threshold to maintain at worst a 2&#x2F;3 load factor.（设置下一次阀值，len的三分之二）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private void setThreshold(int len) &#123;</span><br><span class="line">           threshold &#x3D; len * 2 &#x2F; 3;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * Increment i modulo len.（以len为模增加i）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private static int nextIndex(int i, int len) &#123;</span><br><span class="line">           return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * Decrement i modulo len.（以len为模减少i）</span><br><span class="line">        *&#x2F;</span><br><span class="line">       private static int prevIndex(int i, int len) &#123;</span><br><span class="line">           return ((i - 1 &gt;&#x3D; 0) ? i - 1 : len - 1);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造ThreadLocal时候使用，对应ThreadLocal的实例方法void createMap(Thread t, T firstValue)</span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 哈希表默认容量为16</span><br><span class="line">    table &#x3D; new Entry[INITIAL_CAPACITY];</span><br><span class="line">    &#x2F;&#x2F; 计算第一个元素的哈希码 （黄金分割数 &amp;（容量-1））</span><br><span class="line">    int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] &#x3D; new Entry(firstKey, firstValue);</span><br><span class="line">    size &#x3D; 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造InheritableThreadLocal时候使用，基于父线程的ThreadLocalMap里面的内容进行提取放入新的ThreadLocalMap的哈希表中</span><br><span class="line">&#x2F;&#x2F; 对应ThreadLocal的静态方法static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap)</span><br><span class="line">private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    Entry[] parentTable &#x3D; parentMap.table;</span><br><span class="line">    int len &#x3D; parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table &#x3D; new Entry[len];</span><br><span class="line">    &#x2F;&#x2F; 基于父ThreadLocalMap的哈希表进行拷贝</span><br><span class="line">    for (Entry e : parentTable) &#123;</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key &#x3D; (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            if (key !&#x3D; null) &#123;</span><br><span class="line">                Object value &#x3D; key.childValue(e.value);</span><br><span class="line">                Entry c &#x3D; new Entry(key, value);</span><br><span class="line">                int h &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                while (table[h] !&#x3D; null)</span><br><span class="line">                    h &#x3D; nextIndex(h, len);</span><br><span class="line">                table[h] &#x3D; c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>set部分</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; We don&#39;t use a fast path as with get() because it is at</span><br><span class="line">           &#x2F;&#x2F; least as common to use set() to create new entries as</span><br><span class="line">           &#x2F;&#x2F; it is to replace existing ones, in which case, a fast</span><br><span class="line">           &#x2F;&#x2F; path would fail more often than not.</span><br><span class="line">           </span><br><span class="line">           Entry[] tab &#x3D; table;</span><br><span class="line">           int len &#x3D; tab.length;</span><br><span class="line">           int i &#x3D; key.threadLocalHashCode &amp; (len-1); &#x2F;&#x2F;取index值</span><br><span class="line">           &#x2F;&#x2F; nextIndex方法实现全遍历</span><br><span class="line">           for (Entry e &#x3D; tab[i];</span><br><span class="line">                e !&#x3D; null;</span><br><span class="line">                e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123; </span><br><span class="line">                </span><br><span class="line">               ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">               if (k &#x3D;&#x3D; key) &#123; &#x2F;&#x2F; 匹配则直接替换value</span><br><span class="line">                   e.value &#x3D; value;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               &#x2F;&#x2F; key为null，则替换key并赋值value</span><br><span class="line">               if (k &#x3D;&#x3D; null) &#123; </span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">           int sz &#x3D; ++size;</span><br><span class="line">           &#x2F;&#x2F; 追求效率的平衡，仅清理i到sz指引的回收value</span><br><span class="line">           if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">               rehash(); &#x2F;&#x2F; 重新hash</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">         private void rehash() &#123;</span><br><span class="line">           &#x2F;&#x2F; 清理一遍哈希表</span><br><span class="line">           expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 哈希表元素数目大雨 3&#x2F;4阀值，则扩容</span><br><span class="line">           if (size &gt;&#x3D; threshold - threshold &#x2F; 4)</span><br><span class="line">               resize();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   private void resize() &#123;</span><br><span class="line">           Entry[] oldTab &#x3D; table;</span><br><span class="line">           int oldLen &#x3D; oldTab.length;</span><br><span class="line">           int newLen &#x3D; oldLen * 2;</span><br><span class="line">           Entry[] newTab &#x3D; new Entry[newLen];</span><br><span class="line">           int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">           for (int j &#x3D; 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">               Entry e &#x3D; oldTab[j];</span><br><span class="line">               if (e !&#x3D; null) &#123;</span><br><span class="line">                   ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">                   if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       e.value &#x3D; null; &#x2F;&#x2F; Help the GC</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       int h &#x3D; k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                       while (newTab[h] !&#x3D; null)</span><br><span class="line">                           h &#x3D; nextIndex(h, newLen);</span><br><span class="line">                       newTab[h] &#x3D; e;</span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           setThreshold(newLen);</span><br><span class="line">           size &#x3D; count;</span><br><span class="line">           table &#x3D; newTab;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><strong>get部分</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">           int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">           Entry e &#x3D; table[i];</span><br><span class="line">           if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)</span><br><span class="line">               return e;</span><br><span class="line">           else  &#x2F;&#x2F; 注意这里，如果e为null或者Key对不上，会调用getEntryAfterMiss</span><br><span class="line">               return getEntryAfterMiss(key, i, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">           Entry[] tab &#x3D; table;</span><br><span class="line">           int len &#x3D; tab.length;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 这里会通过nextIndex尝试遍历整个哈希表，如果找到匹配的Key则返回Entry</span><br><span class="line">           &#x2F;&#x2F; 如果哈希表中存在Key &#x3D;&#x3D; null的情况，调用expungeStaleEntry进行清理</span><br><span class="line">           while (e !&#x3D; null) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">               if (k &#x3D;&#x3D; key)</span><br><span class="line">                   return e;</span><br><span class="line">               if (k &#x3D;&#x3D; null)</span><br><span class="line">                   expungeStaleEntry(i);</span><br><span class="line">               else</span><br><span class="line">                   i &#x3D; nextIndex(i, len);</span><br><span class="line">               e &#x3D; tab[i];</span><br><span class="line">           &#125;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ul>
<li>什么情况下ThreadLocal的使用会导致内存泄漏？<ul>
<li>通过源码分析可以知道，ThreadLocalMap存放的Value是弱引用，会自动GC。但是对应的强引用则只在调用get、set或者remove才可能被回收</li>
<li>例如：大量地(静态)初始化ThreadLocal实例，初始化之后不再调用get()、set()、remove()方法。</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><ul>
<li>JavaWeb中Session的实现</li>
<li>Android应用中的Looper创建管理</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://throwable.coding.me/2019/02/17/java-currency-threadlocal/#%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">ThreadLocal源码分析-黄金分割数的使用</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android线程消息机制</title>
    <url>/blog/2019/03/16/Android%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android应用程序有主线程和子线程之分，其中主线程由AMS请求Zygote进程创建；而子线程则由主线程或者其它子线程创建。我们知道Android规定只能在主线程中执行与界面相关工作（严格意义是界面创建元素对应的线程），一旦我们在主线程执行的任务过重，就可能导致UI绘制无法及时完成，产生掉帧现象，或者更严重直接ANR。所以为了避霾类似问题，我们需要多线程技术方案，把那些复杂或者非重要的任务移到其它线程执行，来提升体验。<br>我们知道对于不定期的后台任务，一般有两种处理方式。第一种方式是每当条件满足的时，就创建一个子线程来执行一个不定期的后台任务，当这个不定期的任务执行完成之后，这个新创建子线程就随之推出。第二种方式是创建一个具有消息循环的子线程，每当条件满足时，就将一个不定期后台任务封装成一个消息发送到子线程的消息队列中去执行，而当条件不满足时，这个子线程就会因问它的消息队列为空而进入睡眠等待状态。虽然第一种方式创建的子线程不需要消息循环机制，但是频繁的创建和销毁子线程是有代价的，因此更倾向于第二种方式来执行那些不定期的后台任务。Android应用程序主线程和子线程都是具有消息循环机制的。<br>下面我们将从Android消息机制原理、Android线程消息循环模型和Android线程和线程池进行全面理解。</p>
<h3 id="Android消息机制"><a href="#Android消息机制" class="headerlink" title="Android消息机制"></a>Android消息机制</h3><p>Android的消息机制主要指Handler的运行机制及它附带的MessageQueue和Looper的工作过程。</p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p><strong>主要用途</strong></p>
<ol>
<li>在未来某个时间点处理 Messages 或者执行 Runnables</li>
<li>将任务切换到另一个线程执行</li>
</ol>
<p><strong>源码分析</strong><br>大致流程：构造Handler -&gt; 发送Runnable -&gt; 组合Message -&gt; Message入队 -&gt; Looper轮训Message执行任务 -&gt; 取Message对应Handler执行消息回调处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 字段</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Set this flag to true to detect anonymous, local or member classes</span><br><span class="line"> * that extend this Handler class and that are not static. These kind</span><br><span class="line"> * of classes can potentially create leaks.</span><br><span class="line"> * 非static的匿名内部类、局部变量或成员变量都将可能造成内存泄漏</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final boolean FIND_POTENTIAL_LEAKS &#x3D; false;</span><br><span class="line">final Looper mLooper; &#x2F;&#x2F; 持有对应Looper，获取对应queue</span><br><span class="line">final MessageQueue mQueue; &#x2F;&#x2F; 持有对应的消息队列，进行消息入队操作</span><br><span class="line">final Callback mCallback; &#x2F;&#x2F; hook，非null 优先回调处理消息</span><br><span class="line">final boolean mAsynchronous; &#x2F;&#x2F; 是否异步消息标识</span><br><span class="line">IMessenger mMessenger; &#x2F;&#x2F; 作用进程间通信</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数 Handler持有对应线程的Looper，同时持有对应Looper的MessageQueue</span><br><span class="line">public Handler() &#123;  ...  &#125;</span><br><span class="line">public Handler(Callback) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper,Callback) &#123;  ...  &#125;</span><br><span class="line">public Handler(boolean) &#123;  ...  &#125;</span><br><span class="line">public Handler(Callback,boolean) &#123;  ...  &#125;</span><br><span class="line">public Handler(Looper,Callback,boolean) &#123;  ...  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post方法，针对不同执行时间的Runnable的方法，最终Runnable转为Message，调用发消息方法插入队列</span><br><span class="line">public final boolean post(Runnable r)&#123; ... &#125;</span><br><span class="line">public final boolean postAtFrontOfQueuepo(Runnable r)&#123; ... &#125;</span><br><span class="line">public final boolean postAtTime(Runnable r,long uptimeMillis)&#123; ... &#125;</span><br><span class="line">public final boolean postAtTime(Runnable r,Object token,long uptimeMillis)&#123; ... &#125;</span><br><span class="line">public final boolean postDelayed(Runnable r,long delayMillis)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将runnable转为Message</span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;...&#125;</span><br><span class="line">private static Message getPostMessage(Runnable r, Object token) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  sendMessage方法，内部实现就是将Message入MessageQueue</span><br><span class="line">public final boolean sendMessage(Message msg)&#123; ... &#125;</span><br><span class="line">public final boolean sendEmptyMessage(int what)&#123; ... &#125;</span><br><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis)&#123; ... &#125;</span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; ... &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Message插入MessageQueue，</span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this; &#x2F;&#x2F; 指定Msg处理对象为当前Handler</span><br><span class="line">    if (mAsynchronous) &#123; &#x2F;&#x2F; 是否异步消息，即跳过屏障执行。</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis); &#x2F;&#x2F; 执行等待时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Looper轮训到执行任务消息时，便调用Message的target即此Handler的这个发送消息方法进行处理</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback !&#x3D; null) &#123; &#x2F;&#x2F; 优先尝试msg的callback回调</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback !&#x3D; null) &#123; &#x2F;&#x2F; Handler构造callBack</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg); &#x2F;&#x2F; 子类实现处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>数据结构主要包含一个int标识，一个long执行时间标识，一个Object数据传输对象，一个Bundle类型data存储对象，记录对应的Hanlder对象。<br>另外维护了一个默认50大小的单链表，用于Message创建，后续系统会回收Message</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个可以发送给 Handler 的消息，包含描述和任意数据对象。消息对象有两个额外的 int 字段和一个 object 字段，这可以满足大部分场景的需求了。</span><br><span class="line">&#x2F;&#x2F; 推荐通过Message.obtain()构建Message而不是直接new，里面维护了默认50大小的链表Message的sPool </span><br><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line">    public int what; &#x2F;&#x2F; 消息标识</span><br><span class="line">    public Object obj; &#x2F;&#x2F; 消息数据存储，用于非bundle传输</span><br><span class="line">    &#x2F;&#x2F; Flag标识（是否使用、是否异步消息）</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAG_IN_USE &#x3D; 1 &lt;&lt; 0;</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAG_ASYNCHRONOUS &#x3D; 1 &lt;&lt; 1;</span><br><span class="line">    &#x2F;*package*&#x2F; static final int FLAGS_TO_CLEAR_ON_COPY_FROM &#x3D; FLAG_IN_USE;</span><br><span class="line">    &#x2F;*package*&#x2F; int flags;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*package*&#x2F; long when; &#x2F;&#x2F; 执行时间</span><br><span class="line">    &#x2F;*package*&#x2F; Bundle data; &#x2F;&#x2F; 非obj传输情况</span><br><span class="line">    &#x2F;*package*&#x2F; Handler target; &#x2F;&#x2F; 发送的Handler</span><br><span class="line">    &#x2F;*package*&#x2F; Runnable callback; &#x2F;</span><br><span class="line">    &#x2F;&#x2F; sometimes we store linked lists of these things</span><br><span class="line">    &#x2F;*package*&#x2F; Message next; &#x2F;&#x2F; Message单链表指向 </span><br><span class="line"></span><br><span class="line">    private static final Object sPoolSync &#x3D; new Object();</span><br><span class="line">    private static Message sPool; &#x2F;&#x2F; Message 链表池</span><br><span class="line">    private static int sPoolSize &#x3D; 0;</span><br><span class="line">    private static final int MAX_POOL_SIZE &#x3D; 50;</span><br><span class="line">    private static boolean gCheckRecycle &#x3D; true; &#x2F;&#x2F; 回收标识</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 各种Message构建方法 </span><br><span class="line">    public static Message obtain(Handler h, int what, int arg1, int arg2) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>通过ThreadLocal实现各线程持有自己的Looper<br>loop方法进行消息轮训，获取消息，调用目标Handler分发任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 扮演消息循环角色，从MessageQueue取消息，有就执行，无则阻塞等待</span><br><span class="line">public final class Looper &#123;</span><br><span class="line">    &#x2F;&#x2F; 重要字段</span><br><span class="line">    &#x2F;&#x2F; ThreadLocal缓存，实现各线程持有各自Looper对象。参考https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;8a7fe7d592f8</span><br><span class="line">    static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    private static Looper sMainLooper;  &#x2F;&#x2F; 持有主线程Looper，便于其它线程交互</span><br><span class="line"></span><br><span class="line">    final MessageQueue mQueue; &#x2F;&#x2F; Looper对应的MessageQueue</span><br><span class="line">    final Thread mThread; &#x2F;&#x2F; Looper对应当前线程</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数私有，必须通过prepare方法来构建</span><br><span class="line">    private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class="line">        mThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 构建Looper，通过ThreadLocal维护Looper（各线程对应一个Looper）</span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        &#x2F;&#x2F; 主线程消息轮训不允许退出，一直循环处理</span><br><span class="line">        &#x2F;&#x2F; 子线程消息轮训可以退出</span><br><span class="line">        if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 主线程构建Looper方法（ActivityThread调用）</span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper &#x3D; myLooper(); &#x2F;&#x2F; 此处缓存主线程Looper，便于后续与主线程的交互</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最重要的 loop 方法，消息轮训实现 （部分关键代码）</span><br><span class="line">    public static void loop() &#123;</span><br><span class="line">        final Looper me &#x3D; myLooper(); &#x2F;&#x2F; 获取当前线程对应的loop</span><br><span class="line">        final MessageQueue queue &#x3D; me.mQueue;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 循环去消息 （MessageQueue取过程可能阻塞）</span><br><span class="line">            Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block （参考MessageQueue next方法）</span><br><span class="line">            if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            msg.target.dispatchMessage(msg);&#x2F;&#x2F; 派发消息到对应Handler</span><br><span class="line">             </span><br><span class="line">            msg.recycleUnchecked(); &#x2F;&#x2F; 释放message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>重点关注 next取message 和 enqueueMessage插入message方法</p>
<blockquote>
<p>主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，详情见Android消息机制1-Handler(Java层)，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 基于Native JNI实现，重点看next和enqueueMessage方法</span><br><span class="line">public final class MessageQueue &#123;</span><br><span class="line"></span><br><span class="line">    private long mPtr; &#x2F;&#x2F; 保存Native层的MessageQueue的对象</span><br><span class="line"></span><br><span class="line">    Message mMessages; &#x2F;&#x2F; 即将执行的message（链表头部）</span><br><span class="line">    private final ArrayList&lt;IdleHandler&gt; mIdleHandlers &#x3D; new ArrayList&lt;IdleHandler&gt;(); &#x2F;&#x2F; 空闲handler列表（用于添加空闲任务）</span><br><span class="line">    private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">    private IdleHandler[] mPendingIdleHandlers; &#x2F;&#x2F; IdleHandler数组</span><br><span class="line">    private boolean mQuitting; &#x2F;&#x2F; 是否终止</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span><br><span class="line">    private boolean mBlocked; &#x2F;&#x2F; 表明next方法是否block 当调用JNI pollOnce方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The next barrier token.</span><br><span class="line">    &#x2F;&#x2F; Barriers are indicated by messages with a null target whose arg1 field carries the token.</span><br><span class="line">    private int mNextBarrierToken;</span><br><span class="line">    &#x2F;&#x2F; JNI 方法</span><br><span class="line">    private native static long nativeInit();</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed &#x3D; quitAllowed;</span><br><span class="line">        mPtr &#x3D; nativeInit(); &#x2F;&#x2F; 进行native层初始化</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点方法 ，获取下一个待处理任务 （部分重点代码）</span><br><span class="line">    Message next() &#123;</span><br><span class="line">        int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; 用于IdleHandler任务处理</span><br><span class="line">        int nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        for (;;) &#123; &#x2F;&#x2F; 无限循环</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis); &#x2F;&#x2F;Native Looper的epoll</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">             </span><br><span class="line">                final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg &#x3D; null;</span><br><span class="line">                Message msg &#x3D; mMessages;</span><br><span class="line">                if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 处理无target的异步消息 （暂时忽略）</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg &#x3D; msg;</span><br><span class="line">                        msg &#x3D; msg.next;</span><br><span class="line">                    &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (msg !&#x3D; null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 标记下一次轮训时间</span><br><span class="line">                        nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        </span><br><span class="line">                        mBlocked &#x3D; false;</span><br><span class="line">                        if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                            prevMsg.next &#x3D; msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages &#x3D; msg.next; &#x2F;&#x2F; 记录下一个头部message</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next &#x3D; null;</span><br><span class="line">                        </span><br><span class="line">                        msg.markInUse(); &#x2F;&#x2F; 标记message状态</span><br><span class="line">                        return msg; &#x2F;&#x2F; 返回message</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                if (mQuitting) &#123; &#x2F;&#x2F; 终止</span><br><span class="line">                    dispose();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 后面是 IdleHandler相关处理逻辑（暂时忽略）</span><br><span class="line">                ......</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 重点方法 ，Message入队 （部分重点代码）</span><br><span class="line">    boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            msg.markInUse(); &#x2F;&#x2F; </span><br><span class="line">            msg.when &#x3D; when;</span><br><span class="line">            Message p &#x3D; mMessages;</span><br><span class="line">            boolean needWake;</span><br><span class="line">            if (p &#x3D;&#x3D; null || when &#x3D;&#x3D; 0 || when &lt; p.when) &#123;</span><br><span class="line">                &#x2F;&#x2F; 立即执行任务，标记为head message。</span><br><span class="line">                msg.next &#x3D; p;</span><br><span class="line">                mMessages &#x3D; msg;</span><br><span class="line">                needWake &#x3D; mBlocked; &#x2F;&#x2F; 唤醒，如果处于blocked状态</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 考虑是否异步任务</span><br><span class="line">                needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                &#x2F;&#x2F; 根据执行时间先后，插入message链表队列</span><br><span class="line">                for (;;) &#123; </span><br><span class="line">                    prev &#x3D; p;</span><br><span class="line">                    p &#x3D; p.next;</span><br><span class="line">                    if (p &#x3D;&#x3D; null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next &#x3D; p; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next</span><br><span class="line">                prev.next &#x3D; msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 唤醒. 参考JNI方法</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JNI方法（参考）<a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Native层</a></p>
<p>MessageQueue通过mPtr变量保存NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Looper.cpp</span><br><span class="line"></span><br><span class="line">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        result &#x3D; pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Looper::pollInner(int timeoutMillis) &#123;</span><br><span class="line">	...</span><br><span class="line">    &#x2F;&#x2F; Poll.</span><br><span class="line">    int result &#x3D; POLL_WAKE;</span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We are about to idle.</span><br><span class="line">    mIdling &#x3D; true;</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">	&#x2F;&#x2F;阻塞等待可以读取管道的通知</span><br><span class="line">    int eventCount &#x3D; epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No longer idling.</span><br><span class="line">    mIdling &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Acquire lock.</span><br><span class="line">    mLock.lock();</span><br><span class="line">	...</span><br><span class="line">    for (int i &#x3D; 0; i &lt; eventCount; i++) &#123;</span><br><span class="line">        int fd &#x3D; eventItems[i].data.fd;</span><br><span class="line">        uint32_t epollEvents &#x3D; eventItems[i].events;</span><br><span class="line">        if (fd &#x3D;&#x3D; mWakeReadPipeFd) &#123;</span><br><span class="line">            if (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();&#x2F;&#x2F; 关键代码方法</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Looper::awoken() &#123; &#x2F;&#x2F; 唤醒方法 （enqueueMessage方法调用）</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ awoken&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    char buffer[16];</span><br><span class="line">    ssize_t nRead;</span><br><span class="line">    do &#123;</span><br><span class="line">        nRead &#x3D; read(mWakeReadPipeFd, buffer, sizeof(buffer));&#x2F;&#x2F;可以看到读取了管道中的内容</span><br><span class="line">    &#125; while ((nRead &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EINTR) || nRead &#x3D;&#x3D; sizeof(buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Looper::wake() &#123; &#x2F;&#x2F; 最终调用到 native wake方法</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ wake&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ssize_t nWrite;</span><br><span class="line">    do &#123;</span><br><span class="line">        nWrite &#x3D; write(mWakeWritePipeFd, &quot;W&quot;, 1);&#x2F;&#x2F;进行了写操作</span><br><span class="line">    &#125; while (nWrite &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EINTR);</span><br><span class="line"></span><br><span class="line">    if (nWrite !&#x3D; 1) &#123;</span><br><span class="line">        if (errno !&#x3D; EAGAIN) &#123;</span><br><span class="line">            ALOGW(&quot;Could not write wake signal, errno&#x3D;%d&quot;, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Android线程消息循环模型"><a href="#Android线程消息循环模型" class="headerlink" title="Android线程消息循环模型"></a>Android线程消息循环模型</h3><h4 id="主线程消息循环模型"><a href="#主线程消息循环模型" class="headerlink" title="主线程消息循环模型"></a>主线程消息循环模型</h4><p>ActivityThread通过ApplicationThread和AMS进行进程间通讯，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，</p>
<p>system_server进程：<br>系统进程，包含了大量的系统服务。如图中ApplicationThreadProxy、ActivityManagerService，这两个服务都运行在system_server进程的不同线程中。另外ATP、AMS都是基于IBinder接口，属于binder线程，都是由binder底层驱动创建和销毁</p>
<p>App进程：<br>即应用程序，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作；另外每个App进程至少都有两个Binder线程，ApplicationThread和ActivityManagerProxy。</p>
<p>Binder<br>用于不同进程之间通信</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884377557402.jpg"  alt=""></p>
<h4 id="主线程与子线程交互的消息循环模型"><a href="#主线程与子线程交互的消息循环模型" class="headerlink" title="主线程与子线程交互的消息循环模型"></a>主线程与子线程交互的消息循环模型</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884377701439.jpg"  alt=""></p>
<h3 id="Android线程和线程池相关概念"><a href="#Android线程和线程池相关概念" class="headerlink" title="Android线程和线程池相关概念"></a>Android线程和线程池相关概念</h3><p>参考：<a href="https://www.jianshu.com/p/d9e46d5a4af9" target="_blank" rel="noopener">Java线程池理解</a></p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h5 id="Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？"><a href="#Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？" class="headerlink" title="Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？"></a>Looper死循环为什么不会导致应用卡死，会消耗大量资源吗？</h5><p>见MessageQueue的next方法，涉及到Linux pipe/epoll机制，因为在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next ()中的nativePollOnce方法里，这是主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事物发生。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 </p>
<h5 id="主线程的消息循环机制是什么（死循环如何处理其它事务）？"><a href="#主线程的消息循环机制是什么（死循环如何处理其它事务）？" class="headerlink" title="主线程的消息循环机制是什么（死循环如何处理其它事务）？"></a>主线程的消息循环机制是什么（死循环如何处理其它事务）？</h5><p>参考前面的主线程消息模型图例</p>
<h5 id="ActivityThread-的动力是什么？（ActivityThread执行Looper的线程是什么）"><a href="#ActivityThread-的动力是什么？（ActivityThread执行Looper的线程是什么）" class="headerlink" title="ActivityThread 的动力是什么？（ActivityThread执行Looper的线程是什么）"></a>ActivityThread 的动力是什么？（ActivityThread执行Looper的线程是什么）</h5><p>ActivityThread通过main方法执行，也就是咱们的Runtime线程。该线程默认是不可quit的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  程序入口，runtime线程执行</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">       Looper.prepareMainLooper(); &#x2F;&#x2F; 将该线程对应Looper标记为MainLooper</span><br><span class="line"></span><br><span class="line">       ActivityThread thread &#x3D; new ActivityThread(); </span><br><span class="line">       thread.attach(false, startSeq);  &#x2F;&#x2F; 初始化ActivityThread</span><br><span class="line">       if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">           sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Looper.loop(); &#x2F;&#x2F; 循环</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="Handler-是如何能够线程切换，发送Message的？（线程间通讯）"><a href="#Handler-是如何能够线程切换，发送Message的？（线程间通讯）" class="headerlink" title="Handler 是如何能够线程切换，发送Message的？（线程间通讯）"></a>Handler 是如何能够线程切换，发送Message的？（线程间通讯）</h5><p>主线程到其它线程，只需要创建线程执行任务就可以。其它线程切回主线程，只需要拿到或者创建主线程Handler既可以发送消息切换回去</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>Reference子类源码解析</title>
    <url>/blog/2019/03/10/Reference%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="SoftReference和WeakReference"><a href="#SoftReference和WeakReference" class="headerlink" title="SoftReference和WeakReference"></a>SoftReference和WeakReference</h3><p>我们知道这两个类基本功能相似，区别在于当引用对象为空的时候，WeakRefreence对象会在GC回收的时候被回收，而SoftReference则需要更苛刻的条件</p>
<h4 id="SoftReference实现原理"><a href="#SoftReference实现原理" class="headerlink" title="SoftReference实现原理"></a>SoftReference实现原理</h4><p>总结：GC回收时计算 SoftReference存活时间与剩余内存换算得出的时间进行大小比较（内存剩余空间*设定系数仅过换算规则计算得出），如果大于测认为需要回收，反之亦然</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;memory&#x2F;referenceProcessor.cpp</span><br><span class="line">if (rt &#x3D;&#x3D; REF_SOFT) &#123;</span><br><span class="line">    &#x2F;&#x2F; 是否需要清除软引用</span><br><span class="line">    if (!_current_soft_ref_policy-&gt;should_clear_reference(obj, _soft_ref_timestamp_clock)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; should_clear_reference 实现如下</span><br><span class="line">bool LRUMaxHeapPolicy::should_clear_reference(oop p,</span><br><span class="line">                                             jlong timestamp_clock) &#123;</span><br><span class="line">  jlong interval &#x3D; timestamp_clock - java_lang_ref_SoftReference::timestamp(p);</span><br><span class="line">  assert(interval &gt;&#x3D; 0, &quot;Sanity check&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The interval will be zero if the ref was accessed since the last scavenge&#x2F;gc.</span><br><span class="line">  if(interval &lt;&#x3D; _max_interval) &#123; &#x2F;&#x2F; 与_max_interval比较</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Capture state (of-the-VM) information needed to evaluate the policy</span><br><span class="line">void LRUMaxHeapPolicy::setup() &#123;</span><br><span class="line">  size_t max_heap &#x3D; MaxHeapSize;</span><br><span class="line">  max_heap -&#x3D; Universe::get_heap_used_at_last_gc();</span><br><span class="line">  max_heap &#x2F;&#x3D; M;</span><br><span class="line"></span><br><span class="line">  _max_interval &#x3D; max_heap * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">  &#x2F;&#x2F; _max_interval 计算</span><br><span class="line">  assert(_max_interval &gt;&#x3D; 0,&quot;Sanity check&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SoftReference对象记录两个时间，目的就是为了GC判断是否需要清除</span><br><span class="line">public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 由JVM负责更新的，记录了上一次GC发生的时间。</span><br><span class="line">    static private long clock;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每次调用 get 方法都会更新，记录了当前Reference最后一次被访问的时间。</span><br><span class="line">    private long timestamp;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent) &#123;</span><br><span class="line">        super(referent);</span><br><span class="line">        this.timestamp &#x3D; clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">        this.timestamp &#x3D; clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 和super.get的逻辑最大的不同，就在于每次调用get都会把上次发生GC的时间，也就是</span><br><span class="line">    &#x2F;&#x2F; clock 更新到 timestamp 中去。</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        T o &#x3D; super.get();</span><br><span class="line">        if (o !&#x3D; null &amp;&amp; this.timestamp !&#x3D; clock)</span><br><span class="line">            this.timestamp &#x3D; clock;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PhantomReference和Cleaner"><a href="#PhantomReference和Cleaner" class="headerlink" title="PhantomReference和Cleaner"></a>PhantomReference和Cleaner</h3><ul>
<li>不能访问到referent</li>
<li>Cleaner继承PhantomReference，它们本质流程都是Reference流程，有GC标记，ReferenceHandler处理</li>
<li>Cleaner的clean方法由ReferenceHandler调用，最终到thunk线程进行自定义资源回收处理，以及自己的释放</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; get方法永远是null，所以无法获得referent</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Cleaner extends PhantomReference&lt;Object&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F; Reference需要Queue，但Cleaner自己管理ref，所以虚构个无用Queue</span><br><span class="line">    private static final ReferenceQueue&lt;Object&gt; dummyQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 所有的cleaner都会被加到一个双向链表中去，确保回收前这些Cleaner都是存活的。</span><br><span class="line">    static private Cleaner first &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private Cleaner</span><br><span class="line">        next &#x3D; null,</span><br><span class="line">        prev &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构造的时候把自己加到双向链表中去</span><br><span class="line">    private static synchronized Cleaner add(Cleaner cl) &#123;</span><br><span class="line">        if (first !&#x3D; null) &#123;</span><br><span class="line">            cl.next &#x3D; first;</span><br><span class="line">            first.prev &#x3D; cl;</span><br><span class="line">        &#125;</span><br><span class="line">        first &#x3D; cl;</span><br><span class="line">        return cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; clean方法会调用remove把当前的cleaner从链表中删除。</span><br><span class="line">    private static synchronized boolean remove(Cleaner cl) &#123;</span><br><span class="line">        &#x2F;&#x2F; If already removed, do nothing</span><br><span class="line">        if (cl.next &#x3D;&#x3D; cl)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update list</span><br><span class="line">        if (first &#x3D;&#x3D; cl) &#123;</span><br><span class="line">            if (cl.next !&#x3D; null)</span><br><span class="line">                first &#x3D; cl.next;</span><br><span class="line">            else</span><br><span class="line">                first &#x3D; cl.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cl.next !&#x3D; null)</span><br><span class="line">            cl.next.prev &#x3D; cl.prev;</span><br><span class="line">        if (cl.prev !&#x3D; null)</span><br><span class="line">            cl.prev.next &#x3D; cl.next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Indicate removal by pointing the cleaner to itself</span><br><span class="line">        cl.next &#x3D; cl;</span><br><span class="line">        cl.prev &#x3D; cl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用户自定义的一个Runnable对象，</span><br><span class="line">    private final Runnable thunk;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 私有有构造函数，保证了用户无法单独地使用new来创建Cleaner。</span><br><span class="line">    private Cleaner(Object referent, Runnable thunk) &#123;</span><br><span class="line">        super(referent, dummyQueue);</span><br><span class="line">        this.thunk &#x3D; thunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 所有的Cleaner都必须通过create方法进行创建。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Cleaner create(Object ob, Runnable thunk) &#123;</span><br><span class="line">        if (thunk &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        return add(new Cleaner(ob, thunk));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Reference Handler线程调用，来清理资源。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void clean() &#123;</span><br><span class="line">        if (!remove(this))</span><br><span class="line">            return;</span><br><span class="line">        try &#123;</span><br><span class="line">            thunk.run();</span><br><span class="line">        &#125; catch (final Throwable x) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        if (System.err !&#x3D; null)</span><br><span class="line">                            new Error(&quot;Cleaner terminated abnormally&quot;, x)</span><br><span class="line">                                .printStackTrace();</span><br><span class="line">                        System.exit(1);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FinalReference和Finalizer"><a href="#FinalReference和Finalizer" class="headerlink" title="FinalReference和Finalizer"></a>FinalReference和Finalizer</h3><ul>
<li>它本质流程依然与Reference类似</li>
<li>Finalizer的构造是通过标志由JVM构造（JVM构造的时候会判断finalize方法是否非空，最终会调用到register进行构造）</li>
<li>Finalizer加入的queue会被Finalizer线程进行处理</li>
<li>finalize方法只会调用一次，通过hasBeenFinalized这个tag保证</li>
<li>⚠️ finalize可以通过获取referent复活对象，其中存在很多安全隐患</li>
<li>⚠️ FinalizerThread为守护线程，优先级很低，很有可能抢占不到资源而导致资源无法回收</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Reference和ReferenceQueue相关源码解析</title>
    <url>/blog/2019/03/05/Reference%E5%92%8CReferenceQueue%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="为什么需要引用？"><a href="#为什么需要引用？" class="headerlink" title="为什么需要引用？"></a>为什么需要引用？</h3><p>我们知道在最早的JVM实现里，是使用“跟踪回收”算法从GC ROOTS出发，按照BFS或者DFS遍历所有可达对象，针对不不可达对象进行回收。但随着Java演进，暴露出一些不能覆盖的场景，例如：某些场景下使用方希望在回收具体对象的同时还能辅助回收这个对象绑定的一些资源（如socket、堆外内存等）、某些场景下希望使用堆内缓存尽可能缓存更多更久的数据但不OOM。基于此，JDK在1.2引入了Refreence及其子类来支持一些新特性和功能</p>
<h3 id="Reference介绍"><a href="#Reference介绍" class="headerlink" title="Reference介绍"></a>Reference介绍</h3><h5 id="Reference类图"><a href="#Reference类图" class="headerlink" title="Reference类图"></a>Reference类图</h5><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884378246371.jpg"  alt=""></p>
<ul>
<li><strong>FinalReference</strong>，一种保底策略，因为GC只能管理自动内存资源而无法管理其它资源（如堆外内存、file handle、socket等），这些需要使用方手动对资源进行管理</li>
<li><strong>SoftReference</strong>，软引用，只有在堆内存不足时，垃圾回收器会回收对应引用。所以比较适合用来实现不是特别重要的缓存</li>
<li><strong>WeakReference</strong>，弱引用，每次垃圾回收都会回收其引用，一般在需要控制内存但又又想要尽量用到内存的场景下使用</li>
<li><strong>PhantomReference</strong>，虚引用，对引用无影响，只用于获取对象被回收的通知。和软引用以及弱引用不同的是幻影引用指向的对象没有其他强引用、软引用指向时不会自动被GC清理。</li>
</ul>
<p>⚠️ 因为默认的引用就是强引用，所以没有强引用的Reference实现类。<br>详情：<a href="https://www.jianshu.com/p/7ff38dfbb5a8" target="_blank" rel="noopener">Reference子类源码解析</a></p>
<h4 id="Reference生命周期"><a href="#Reference生命周期" class="headerlink" title="Reference生命周期"></a>Reference生命周期</h4><p>Referent被GC回收，则会根据是持有ReferenceQueue，而加入到对应到ReferenceQueue中，这样可以通过RQ来监听reference是否回收状态</p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884378341961.jpg"  alt=""></p>
<h4 id="Reference运行结构"><a href="#Reference运行结构" class="headerlink" title="Reference运行结构"></a>Reference运行结构</h4><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884378410825.jpg"  alt=""></p>
<h4 id="Reference源码"><a href="#Reference源码" class="headerlink" title="Reference源码"></a>Reference源码</h4><h6 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h6><ul>
<li>referent：  引用指向的对象</li>
<li>queue： ReferenceQueue，Reference构造的时候传入，其内部封装了单向链表的添加，删除和遍历等操作。用于Reference状态监听及管理</li>
<li>discovered：单向链表，由JVM维护</li>
<li>next：指向ReferenceQueue中下一个元素，ReferenceQueue链表指针</li>
<li>pending：discovered链表表头，在referent被回收后的reference<br>将有JVM标记，等待入队处理</li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ul>
<li>static代码块：构造ReferenceHandler线程，循环执行tryHandlePending方法</li>
<li>tryHandlePending：循环处理pending链表头，维护discovered链表，如果pending不为空，则进行插入ReferenceQueue进行后续操作。（这里如果是cleaner，则先进行clean操作）</li>
</ul>
<h6 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h6><ul>
<li>ReferenceHandler，线程实现类，run方法中循环调用Refreence的静态方法tryHandlePending</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于控制垃圾回收器操作与Pending状态的Reference入队操作不冲突执行的全局锁</span><br><span class="line">&#x2F;&#x2F; 垃圾回收器开始一轮垃圾回收前要获取此锁</span><br><span class="line">&#x2F;&#x2F; 所以所有占用这个锁的代码必须尽快完成，不能生成新对象，也不能调用用户代码</span><br><span class="line">static private class Lock &#123; &#125;;</span><br><span class="line">private static Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        super(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个线程一直执行</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Reference&lt;Object&gt; r;</span><br><span class="line">            &#x2F;&#x2F; 获取锁，避免与垃圾回收器同时操作</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断pending-Reference链表是否有数据</span><br><span class="line">                if (pending !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果有Pending Reference，从列表中取出</span><br><span class="line">                    r &#x3D; pending;</span><br><span class="line">                    pending &#x3D; r.discovered;</span><br><span class="line">                    r.discovered &#x3D; null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 如果没有Pending Reference，调用wait等待</span><br><span class="line">                    &#x2F;&#x2F; </span><br><span class="line">                    &#x2F;&#x2F; wait等待锁，是可能抛出OOME的，</span><br><span class="line">                    &#x2F;&#x2F; 因为可能发生InterruptedException异常，然后就需要实例化这个异常对象，</span><br><span class="line">                    &#x2F;&#x2F; 如果此时内存不足，就可能抛出OOME，所以这里需要捕获OutOfMemoryError，</span><br><span class="line">                    &#x2F;&#x2F; 避免因为OOME而导致ReferenceHandler进程静默退出</span><br><span class="line">                    try &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; catch (OutOfMemoryError x) &#123; &#125;</span><br><span class="line">                    &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Reference是Cleaner，调用其clean方法</span><br><span class="line">            &#x2F;&#x2F; 这与Cleaner机制有关系，不在此文的讨论访问</span><br><span class="line">            if (r instanceof Cleaner) &#123;</span><br><span class="line">                ((Cleaner)r).clean();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 把Reference添加到关联的ReferenceQueue中</span><br><span class="line">            &#x2F;&#x2F; 如果Reference构造时没有关联ReferenceQueue，会关联ReferenceQueue.NULL，这里就不会进行入队操作了</span><br><span class="line">            ReferenceQueue&lt;Object&gt; q &#x3D; r.queue;</span><br><span class="line">            if (q !&#x3D; ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReferenceQueue源码"><a href="#ReferenceQueue源码" class="headerlink" title="ReferenceQueue源码"></a>ReferenceQueue源码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReferenceQueue&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 单向链表</span><br><span class="line">    private volatile Reference&lt;? extends T&gt; head &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; </span><br><span class="line">    &#x2F;* Called only by Reference class *&#x2F;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">		&#x2F;&#x2F; 判断Reference是否需要入队</span><br><span class="line">        ReferenceQueue&lt;?&gt; queue &#x3D; r.queue;</span><br><span class="line">        if ((queue &#x3D;&#x3D; NULL) || (queue &#x3D;&#x3D; ENQUEUED)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        assert queue &#x3D;&#x3D; this;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Reference入队后，其queue变量设置为ENQUEUED</span><br><span class="line">        r.queue &#x3D; ENQUEUED;</span><br><span class="line">        &#x2F;&#x2F; Reference的next变量指向ReferenceQueue中下一个元素</span><br><span class="line">        r.next &#x3D; (head &#x3D;&#x3D; null) ? r : head;</span><br><span class="line">        head &#x3D; r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        if (r instanceof FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Reference&lt;? extends T&gt; poll() &#123;</span><br><span class="line">        &#x2F;&#x2F; 出队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Reference类解决的三个问题"><a href="#Reference类解决的三个问题" class="headerlink" title="Reference类解决的三个问题"></a>Reference类解决的三个问题</h3><ul>
<li>实现特定的引用类型，支持不同功能</li>
<li>使用者可以在对象被回收后得到通知</li>
<li>使用者可以自定义回收，进行非GC回收的资源释放</li>
</ul>
<p>参考<br><a href="https://coldwalker.com/2019/02//gc_intro/" target="_blank" rel="noopener">https://coldwalker.com/2019/02//gc_intro/</a><br><a href="https://github.com/zxiaofan/JDK/blob/master/JDK1.8/src/java/lang/ref/ReferenceQueue.java" target="_blank" rel="noopener">https://github.com/zxiaofan/JDK/blob/master/JDK1.8/src/java/lang/ref/ReferenceQueue.java</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存相关总结</title>
    <url>/blog/2018/02/11/JVM%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="JVM大体结构图"><a href="#JVM大体结构图" class="headerlink" title="JVM大体结构图"></a>JVM大体结构图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884378926639.jpg"  alt=""></p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><ul>
<li>线程隔离数据区<ul>
<li>程序计算器<ul>
<li>当前线程执行字节码的行号指示器</li>
<li>如分支、循环、跳转、异常处理、线程恢复等</li>
</ul>
</li>
<li>虚拟机栈<ul>
<li>栈帧存储区域，栈帧包含局部变量、操作数栈、动态链接、方法出口等</li>
<li>异常情况，StackOverflowError、OutOfMemoryError</li>
</ul>
</li>
<li>本地方法栈 <ul>
<li>JNI服务使用的栈，作用于本地方法（C/C++） </li>
</ul>
</li>
</ul>
</li>
<li>线程共享数据区<ul>
<li>Java堆<ul>
<li>存储对象实例</li>
<li>异常情况， OutOfMemoryError、内存泄漏</li>
</ul>
</li>
<li>方法区 <ul>
<li>存储加载的类信息、常量、静态变量、JIT编译后的代码等数据</li>
<li>异常情况，OutOfMemoryError</li>
<li>运行时常量池，字面量、符号引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象创建与回收过程"><a href="#对象创建与回收过程" class="headerlink" title="对象创建与回收过程"></a>对象创建与回收过程</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884379135740.jpg"  alt=""></p>
<h3 id="JVM垃圾收集算法"><a href="#JVM垃圾收集算法" class="headerlink" title="JVM垃圾收集算法"></a>JVM垃圾收集算法</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul>
<li>内存分成大小相等的两块，每次使用其中一块，回收的时候，把存活的对象复制到另一块，然后把这块内存整个清理掉</li>
<li>优点，回收效率提高、不存在碎片化</li>
<li>缺点，内存利用率低</li>
<li>解决，采用非对称法，eden:survivor = 8:1<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428153805.png"  alt=""></li>
</ul>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><ul>
<li>标记阶段，确定所有要回收的对象，做标记</li>
<li>清除阶段，将标记阶段确定的回收对象进行清除</li>
<li>优点，简单，最基础算法 </li>
<li>缺点，效率低，碎片化 </li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884379225616.jpg"  alt=""></p>
<h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><ul>
<li>把存活对象移动到内存的一端，然后直接回收边界以外的内存</li>
<li>场景,适合老年代存活对象较多的情况，减少内存复制量</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884379370450.jpg"  alt=""></p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884379522001.jpg"  alt=""></p>
<h4 id="Serial-SerialOld"><a href="#Serial-SerialOld" class="headerlink" title="Serial/SerialOld"></a>Serial/SerialOld</h4><ul>
<li>过程<ol>
<li>收集GC_ROOTS</li>
<li>对象可达性分析</li>
<li>标记垃圾对象</li>
<li>清理垃圾对象 </li>
</ol>
</li>
<li>优点，简单高效    </li>
<li>缺点，STW，服务停顿时间长 </li>
<li>场景，几百兆以内客户端程序 </li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884379609341.jpg"  alt=""></p>
<h4 id="Parnew-Parallel-Scavenge-Parallel-Old"><a href="#Parnew-Parallel-Scavenge-Parallel-Old" class="headerlink" title="Parnew/Parallel Scavenge/Parallel Old"></a>Parnew/Parallel Scavenge/Parallel Old</h4><h5 id="Serial算法多线程版"><a href="#Serial算法多线程版" class="headerlink" title="Serial算法多线程版"></a>Serial算法多线程版</h5><ul>
<li>优点，多线程，回收速度快 </li>
<li>缺点，依然会暂停服务</li>
<li>场景，对响应时间要求不高的Server端</li>
</ul>
<p>ParNew与Parallel Scanvenge区别</p>
<ul>
<li>Parnew关注回收速度，多线程减少单词GC时间</li>
<li>Parallel Scanvenge关注吞吐量，减少GC时间占比</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884379722524.jpg"  alt=""></p>
<h4 id="CMS-Concurrent-Mark-Sweep-算法"><a href="#CMS-Concurrent-Mark-Sweep-算法" class="headerlink" title="CMS(Concurrent Mark Sweep)算法"></a>CMS(Concurrent Mark Sweep)算法</h4><ul>
<li>优点，并发，暂停时间短</li>
<li>缺点，耗CPU、GC时间长，GC提前，浮动垃圾，碎片化</li>
<li>场景，对响应时间敏感的Server服务，大部分线上服务应该是CMS</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884380075349.jpg"  alt=""></p>
<h4 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h4><ul>
<li>新一代垃圾回收算法</li>
<li>场景，大内存、高响应的服务端应用</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884380225514.jpg"  alt=""></p>
<h3 id="JVM工具集"><a href="#JVM工具集" class="headerlink" title="JVM工具集"></a>JVM工具集</h3><h4 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h4><ul>
<li>查看当前用户java进程，类似于ps</li>
<li>-q 只输出LVMID(与PID一致)，省略主类的名称 </li>
<li>-m 输出启动时传递给主类main函数的参数</li>
<li>-l 输出主类的全名，如果是jar包，输出jar路径</li>
<li>-v 输出启动时的jvm参数</li>
</ul>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><ul>
<li>用于监视虚拟机各种运行状态信息，例如类装载、内存、垃圾收集、 jit编译等运行参数</li>
<li>-class 监视类装载、卸载数量、总空间以及装载所耗费时间等</li>
<li>-gc 监视java堆状况，包括eden区，survivor区，老年代，永久代的容量、已用 空间和 GC时间等信息</li>
<li>-gcnew 监视新生代GC状况</li>
<li>-gcold 监视老年代GC状况</li>
<li>-compiler 输出JIT编译器编译过的方法、耗时等信息</li>
</ul>
<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul>
<li>java内存映像工具，用于生成堆转储快照，即dump文件，结合JHAT、MAT或者VisualVM等软件 来分析java内存的详细使用情况，便于排查java内存问题</li>
<li>-dump 生成堆转储快照</li>
<li>-finalizerinfo 显示在等待执行finalize方法的对象</li>
<li>-heap 显示java堆详细信息，如使用的回收器、参数配置、分代状况等</li>
<li>-histo 显示堆中对象统计信息，包括类、实例数量、合计容量等</li>
<li>-permstat 以classloader为统计口径显示永久代内存状态</li>
<li>-F 强制生成堆转出快照</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://plumbr.io/handbook/what-is-garbage-collection" target="_blank" rel="noopener">https://plumbr.io/handbook/what-is-garbage-collection</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>java对象生命周期</title>
    <url>/blog/2018/02/10/java%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="Java对象生命周期图"><a href="#Java对象生命周期图" class="headerlink" title="Java对象生命周期图"></a>Java对象生命周期图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884380468535.jpg"  alt=""></p>
<h3 id="创建阶段（Created）"><a href="#创建阶段（Created）" class="headerlink" title="创建阶段（Created）"></a>创建阶段（Created）</h3><ul>
<li>分配存储空间</li>
<li>开始构造对象</li>
<li>父类到子类依次初始化类变量</li>
<li>父类成员初始化，父类构造函数初始化</li>
<li>子类成员初始化，子类构造函数初始化</li>
</ul>
<h3 id="应用阶段（In-Use）"><a href="#应用阶段（In-Use）" class="headerlink" title="应用阶段（In Use）"></a>应用阶段（In Use）</h3><p>对象被一个或多个强引用持有，并且在作用域内</p>
<h3 id="不可见阶段（Invisible）"><a href="#不可见阶段（Invisible）" class="headerlink" title="不可见阶段（Invisible）"></a>不可见阶段（Invisible）</h3><p>其它区域已经不可以再引用它，本地变量超出了可见范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        Object a &#x3D; new Object();</span><br><span class="line">    &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    a.clone(); &#x2F;&#x2F; 该区域a不可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不可达阶段（Unreachable）"><a href="#不可达阶段（Unreachable）" class="headerlink" title="不可达阶段（Unreachable）"></a>不可达阶段（Unreachable）</h3><p>不再被任何强引用所持有</p>
<h3 id="收集阶段（Collected）"><a href="#收集阶段（Collected）" class="headerlink" title="收集阶段（Collected）"></a>收集阶段（Collected）</h3><p>对象不可达，并且垃圾回收器已经对该对象的内存空间重新分配做好准备时</p>
<h3 id="终结阶段（Finalized）"><a href="#终结阶段（Finalized）" class="headerlink" title="终结阶段（Finalized）"></a>终结阶段（Finalized）</h3><p>对象执行完finalize方法后，等待垃圾回收器对对象空间进行回收</p>
<h3 id="对象重新分配阶段（Deallocated）"><a href="#对象重新分配阶段（Deallocated）" class="headerlink" title="对象重新分配阶段（Deallocated）"></a>对象重新分配阶段（Deallocated）</h3><p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，此时称为对象空间重新分配阶段</p>
<h3 id="子父类代码执行顺序图"><a href="#子父类代码执行顺序图" class="headerlink" title="子父类代码执行顺序图"></a>子父类代码执行顺序图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884380726555.jpg"  alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类生命周期</title>
    <url>/blog/2018/02/10/Java%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="Java类生命周期图"><a href="#Java类生命周期图" class="headerlink" title="Java类生命周期图"></a>Java类生命周期图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884380896710.jpg"  alt=""></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li>验证是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>
<li>包括文件格式验证、元数据验证、字节码验证、符号引用验证</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li>类变量分配内存，并设为jvm默认的初始值</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>将常量池内的符号引用替换为直接引用的过程</li>
<li>主要针对类或接口、字段、类方法、接口方法四类符号引用进行解析</li>
<li>符号引用<ul>
<li>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中</li>
</ul>
</li>
<li>直接引用<ul>
<li>可以是直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化阶段是执行类构造器clinit方法的过程</li>
<li>clinit方法<ul>
<li>由编译器自动收集所有类变量（静态非final） 赋值操作和静态代码块语句合并产生</li>
<li>收集顺序由出现顺序决定，定义在前面的不能访问定义在后面的类变量</li>
<li>虚拟机保证父类clinit方法先于子类clinit方法执行</li>
<li>类或接口不一定都有clinit方法</li>
<li>虚拟机保证clinit方法在多线程环境下被正确的加锁和同步</li>
</ul>
</li>
<li>时机<ul>
<li>new、操作该类类变量、调用类方法</li>
<li>对类反射</li>
<li>子类初始化的时候，父类还没有初始化，则会先进行父类初始化</li>
<li>main函数对应的类</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>参考对象生命周期</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>jvm回收条件</p>
<ul>
<li>该类所有的实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>Class对象没有任何地方被引用，且无法在任何地方通过反射访问该类的方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器</title>
    <url>/blog/2018/02/10/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h3 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>“通过一个类的全限定名来获取描述此类的二进制字节流。” ——实现这个动作的代码模块称为类加载器。</p>
<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><ul>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为 JVM 方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li>如果想维持双亲委派机制，则覆写findClass方法</li>
<li>如果想打破双亲委派机制，则覆写loadClass方法</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884381298637.jpg"  alt=""></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h5><ul>
<li><p>Java类库的隔离：不同应用程序使用不同的类加载器，可以实现Java类库的隔离。</p>
</li>
<li><p>Java类库的共享：通过Common类加载器和Shared类加载器可以实现Java类库的共享。</p>
</li>
<li><p>安全：服务器和应用程序有各自的类加载器加载Class文件。服务器的类库与应用程序的类库可以互相独立。</p>
</li>
<li><p>支持HotSwap（热替换）：JSP文件有独立的类加载器，服务器能通过替换JSP文件的类加载器来实现JSP的HotSwap功能。</p>
</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884381427798.jpg"  alt=""></p>
<h3 id="Android类加载图"><a href="#Android类加载图" class="headerlink" title="Android类加载图"></a>Android类加载图</h3><h4 id="加载阶段-1"><a href="#加载阶段-1" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>通过一个dex文件或者apk文件的路径完成类的加载</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>BootClassLoader，主要用于加载系统的类，包括java和Android系统的类库</li>
<li>PathClassLoader，主要用于加载应用内中的类，路径是固定的，只能加载/data/app中的apk，无法指定dex路径</li>
<li>DexClassLoader，可任意加载.apk、zip或jar等，实现动态加载</li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884381510914.jpg"  alt=""></p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>类加载器相关应用，插件化、热补等</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中HashMap分析</title>
    <url>/blog/2018/02/08/Java8%E4%B8%ADHashMap%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Put方法流程图"><a href="#Put方法流程图" class="headerlink" title="Put方法流程图"></a>Put方法流程图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884382228558.png"  alt=""></p>
<h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>高16bit不变，低16bit和高16bit做了一个异或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><ul>
<li>map中存储的KV数目</li>
<li>值为2的n次幂<ul>
<li>哈希表是通过除法散列法，取模会用到除法运算，效率很低，而HashMap通过 h&amp;（length－1）替代取模</li>
<li>length 为2的整数次幂，是为了使不同hash值发生碰撞概率小即更均匀散列</li>
<li>length 的值为100..0，length－1为011..1，相当于对取模，而且保证了hash可以奇偶都有</li>
</ul>
</li>
</ul>
<h4 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h4><ul>
<li>阀值，=容量*loadFactor（负载因子，默认0.75）</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><ul>
<li>hash与旧链表大小做 &amp; 运算，=0不变，=1移动到原位置+旧链表大小的位置 </li>
</ul>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884382320409.png"  alt=""></p>
<h3 id="线程是否安全"><a href="#线程是否安全" class="headerlink" title="线程是否安全"></a>线程是否安全</h3><ul>
<li>JDK1.7，扩容前后链表导致，转移过程中修改了原来链表中节点引用关系，可能导致死循环</li>
<li>JDK1.8，不会引起死循环，但put／get不一定同步</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义UUID-移动设备唯一标识</title>
    <url>/blog/2018/02/08/%E8%87%AA%E5%AE%9A%E4%B9%89UUID-%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>希望自主生成用于所有移动业务上标识设备唯一性的标识符</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>业务支撑、日活和新增设备等数据统计、风控等</p>
<h3 id="uuid系统图"><a href="#uuid系统图" class="headerlink" title="uuid系统图"></a>uuid系统图</h3><p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884381961254.jpg"  alt=""></p>
<h3 id="UUID生成"><a href="#UUID生成" class="headerlink" title="UUID生成"></a>UUID生成</h3><h4 id="移动端相关参数"><a href="#移动端相关参数" class="headerlink" title="移动端相关参数"></a>移动端相关参数</h4><h5 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h5><pre><code>IMEI

* International Mobile Equipment Identity，移动设备国际识别码，是手机的唯一识别号码。等价于DeviceId
* 仅支持具有通话功能的设备，例如平板没有
* 需要权限，并且在少数手机拿到的是不合法值
* 一定的重复率（约5%）

MAC Address

* 支持带有Wifi和蓝牙硬件的设备
* 需要权限

Sim Serial Number

* Sim卡序列号
* 对于CDMA设备，返回一个空值</code></pre><h5 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h5><pre><code>IDFA: 广告标志符,重置系统、还原广告会重新生成）
OpenUDID: 由OpenUDID的SDK包生成，该应用重置则会重新生成
keychain: 系统级存储，用于生成的标识存储
MACAddress和UDID:老版本兼容按需使用</code></pre><h4 id="uuid生成算法"><a href="#uuid生成算法" class="headerlink" title="uuid生成算法"></a>uuid生成算法</h4><p>相关参数：客户端类型、版本号、设备信息长度、设备信息内容（见上）、时间戳、设备信息类型、随机数<br>原则：生成uuid唯一，设备信息可反查，设备信息关联uuid，设备信息可校验等<br>算法：32位明文存储相关信息，AES64对称加密</p>
<h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><table>
<thead>
<tr>
<th>uuid</th>
<th>imei</th>
<th>mac</th>
<th>simid</th>
<th>idfa</th>
<th>keychainid</th>
<th>openudid</th>
<th>idfa</th>
<th align="left">udid</th>
<th align="left">Xxx</th>
</tr>
</thead>
</table>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>uuid没法保存<br>uuid合法性（去重、是否作弊）<br>兼容已有uuid<br>防止刷接口<br>防止伪造uuid</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用</category>
      </categories>
      <tags>
        <tag>ID</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/blog/2018/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884381673571.jpg"  alt=""></p>
<p><img src="/blog/" class="lazyload" data-src="http://q9j7c7ivg.bkt.clouddn.com/2020-05-03-15884381735864.jpg"  alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title> Mac下Charles使用教程</title>
    <url>/blog/2018/02/08/%20Mac%E4%B8%8BCharles%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>Charles是常用的截取网络封包的工具，Mac、Windows和linux下均可用</p>
<h5 id="能做什么？"><a href="#能做什么？" class="headerlink" title="能做什么？"></a>能做什么？</h5><ul>
<li>支持截取Http和Https（支持SSL代理）网络封包，</li>
<li>支持流量控制，可以模拟慢网、弱网等case</li>
<li>支持AJAX调试，可以自动格式化json或xml</li>
<li>支持重发网络请求，进行后端压测</li>
<li>支持网络请求和响应内容的mock修改</li>
</ul>
<h5 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h5><p>fiddler、tcpdump</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154824.png"  alt=""></p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h5 id="Charles安装"><a href="#Charles安装" class="headerlink" title="Charles安装"></a>Charles安装</h5><h5 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h5><h6 id="设置charles为设置成系统代理"><a href="#设置charles为设置成系统代理" class="headerlink" title="设置charles为设置成系统代理"></a>设置charles为设置成系统代理</h6><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154838.png"  alt=""></p>
<h6 id="开启Charles的代理功能"><a href="#开启Charles的代理功能" class="headerlink" title="开启Charles的代理功能"></a>开启Charles的代理功能</h6><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154849.png"  alt=""></p>
<h6 id="手机连Charles"><a href="#手机连Charles" class="headerlink" title="手机连Charles"></a>手机连Charles<br></h6><ul>
<li>Mac上查IP Address</li>
<li>手机Wifi连对应服务器+端口（8888）</li>
<li>第一次连接好后，Charles会弹出对应询问框（<strong>连上才会有</strong>），点击allow开始使用</li>
</ul>
<h5 id="Https截取配置"><a href="#Https截取配置" class="headerlink" title="Https截取配置"></a>Https截取配置</h5><p>给Mac安装证书，并信任证书<br>给手机安装证书（需要安装伪CA证书）<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154855.png"  alt=""></p>
<p>Charles设置SSL代理<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428155248.png"  alt=""></p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><h5 id="模拟弱网"><a href="#模拟弱网" class="headerlink" title="模拟弱网"></a>模拟弱网</h5><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154909.png"  alt=""></p>
<h5 id="修改请求或响应内容"><a href="#修改请求或响应内容" class="headerlink" title="修改请求或响应内容"></a>修改请求或响应内容</h5><ul>
<li>Breakpoint<br>&emsp;临时性网络内容修改<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154921.png"  alt=""></li>
</ul>
<ul>
<li>Rewrite<br>&emsp;适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。主要可以对某些匹配请求的header、host、url、path、query param、response status、body进行rewrite</li>
<li>Repeat<br>&emsp;用作接口压力测试</li>
<li>Map<br>&emsp;MapRemote重定向，适用于不同服务器切换测试<br>&emsp;MapLocal重定向到本地数据，适用于本地修改及时查看数据响应</li>
<li>DNS Spoofing Setting<br>&emsp;适用于需要将<strong>域名</strong>打到<strong>ip地址</strong>的服务器上</li>
</ul>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154930.png"  alt=""></p>
<h3 id="常见坑"><a href="#常见坑" class="headerlink" title="常见坑"></a>常见坑</h3><h5 id="Charles与翻墙软件冲突"><a href="#Charles与翻墙软件冲突" class="headerlink" title="Charles与翻墙软件冲突"></a>Charles与翻墙软件冲突</h5><h5 id="Charles设置MapLocal在Android中出现乱码"><a href="#Charles设置MapLocal在Android中出现乱码" class="headerlink" title="Charles设置MapLocal在Android中出现乱码"></a>Charles设置MapLocal在Android中出现乱码</h5><p>原因：MapLocal的Response的Headers中Content-Type值为text/plain,没有指定编码，Android的网络解析框架如果不支持的话则会出现乱码<br>解决：Tools-&gt;Rewrite-&gt;Rewrite Rule<br><img src="/blog/" class="lazyload" data-src="https://raw.githubusercontent.com/afree8909/pictures/master/blog20200428154942.png"  alt=""></p>
<h5 id="Charles连接不上"><a href="#Charles连接不上" class="headerlink" title="Charles连接不上"></a>Charles连接不上</h5><p>其它配置正确情况下，请先用网线试下，是否可以连接成功，如果可以的话，基本确认是Mac的wifi网络对手机不可见，如果属于公司网络，联系公司内网进行设置，保证手机和Mac的网段一致</p>
]]></content>
      <categories>
        <category>开发效率</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/blog/2018/02/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个类只有一个实例，该实例必须自行创建，并且向整个系统提供这个实例</p>
<h3 id="实现考虑因素"><a href="#实现考虑因素" class="headerlink" title="实现考虑因素"></a>实现考虑因素</h3><ul>
<li>唯一性<ul>
<li>是否防克隆</li>
<li>是否防反射</li>
<li>是否防序列化 </li>
</ul>
</li>
<li>性能<ul>
<li>是否需要懒加载 </li>
<li>是否防指令重排（双重锁方式问题） </li>
</ul>
</li>
</ul>
<h3 id="三种实现方式"><a href="#三种实现方式" class="headerlink" title="三种实现方式"></a>三种实现方式</h3><table>
<thead>
<tr>
<th>实现</th>
<th>懒加载</th>
<th>线程安全</th>
<th>防克隆</th>
<th>防反射</th>
<th>防序列化</th>
</tr>
</thead>
<tbody><tr>
<td>双重锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>枚举</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="双重锁方式（添加了防御功能）"><a href="#双重锁方式（添加了防御功能）" class="headerlink" title="双重锁方式（添加了防御功能）"></a>双重锁方式（添加了防御功能）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton implements Serializable, Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Singleton sSingleton; &#x2F;&#x2F; volatile防止指令重排</span><br><span class="line">    private static boolean sFlag &#x3D; true;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        if(sFlag)&#123; &#x2F;&#x2F; 防反射</span><br><span class="line">            sFlag &#x3D; false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw new RuntimeException(&quot;对象已经存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if (sSingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (sSingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    sSingleton &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return getSingleton(); &#x2F;&#x2F; 防序列化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return getSingleton(); &#x2F;&#x2F; 防克隆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Instance &#123;</span><br><span class="line">    private Instance() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Holder &#123;</span><br><span class="line">        &#x2F;&#x2F; 类加载机制保证懒加载，static&amp;final确保线程安全</span><br><span class="line">        private static final Instance INSTANCE &#x3D; new Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Instance getInstance() &#123;</span><br><span class="line">        return Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类方式"><a href="#枚举类方式" class="headerlink" title="枚举类方式"></a>枚举类方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Single &#123;</span><br><span class="line">    SINGLE;</span><br><span class="line">    public void whateverMethod()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本等价于(除enum的防反射、序列化、克隆等属性)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class Single&#123;</span><br><span class="line">    public static final Single SINGLE &#x3D; new Single();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           Singleton singleton &#x3D; Singleton.getSingleton();</span><br><span class="line">           testCloneSingleton(singleton);</span><br><span class="line">           testReflectSingleton(singleton);</span><br><span class="line">           testSerializableSingleton(singleton);</span><br><span class="line"></span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void testCloneSingleton(Singleton singleton) throws CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">       boolean equals &#x3D; singleton.equals(Singleton.getSingleton().clone());</span><br><span class="line"></span><br><span class="line">       System.out.print(equals);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void testReflectSingleton(Singleton singleton) throws Exception &#123;</span><br><span class="line">       Constructor constructor &#x3D; Singleton.class.getDeclaredConstructor();</span><br><span class="line">       constructor.setAccessible(true);</span><br><span class="line">       constructor.newInstance();</span><br><span class="line"></span><br><span class="line">       boolean equals &#x3D; singleton.equals(constructor.newInstance(););</span><br><span class="line"></span><br><span class="line">       System.out.print(equals);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static void testSerializableSingleton(Singleton singleton) throws Exception &#123;</span><br><span class="line">       String tempFile &#x3D; &quot;tempFile&quot;;</span><br><span class="line">       ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(tempFile));</span><br><span class="line">       oos.writeObject(getSingleton());</span><br><span class="line">       ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(new File(tempFile)));</span><br><span class="line"></span><br><span class="line">       boolean equals &#x3D; singleton.equals(objectInputStream.readObject());</span><br><span class="line"></span><br><span class="line">       System.out.print(equals);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
</search>
